// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// An Adaptive MT Dataset.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AdaptiveMtDataset {
    /// Required. The resource name of the dataset, in form of
    /// `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset_id}`
    pub name: std::string::String,

    /// The name of the dataset to show in the interface. The name can be
    /// up to 32 characters long and can consist only of ASCII Latin letters A-Z
    /// and a-z, underscores (_), and ASCII digits 0-9.
    pub display_name: std::string::String,

    /// The BCP-47 language code of the source language.
    pub source_language_code: std::string::String,

    /// The BCP-47 language code of the target language.
    pub target_language_code: std::string::String,

    /// The number of examples in the dataset.
    pub example_count: i32,

    /// Output only. Timestamp when this dataset was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this dataset was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdaptiveMtDataset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AdaptiveMtDataset::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AdaptiveMtDataset::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [source_language_code][crate::model::AdaptiveMtDataset::source_language_code].
    pub fn set_source_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_language_code = v.into();
        self
    }

    /// Sets the value of [target_language_code][crate::model::AdaptiveMtDataset::target_language_code].
    pub fn set_target_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_language_code = v.into();
        self
    }

    /// Sets the value of [example_count][crate::model::AdaptiveMtDataset::example_count].
    pub fn set_example_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.example_count = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AdaptiveMtDataset::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::AdaptiveMtDataset::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::AdaptiveMtDataset::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::AdaptiveMtDataset::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AdaptiveMtDataset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.AdaptiveMtDataset"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdaptiveMtDataset {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __source_language_code,
            __target_language_code,
            __example_count,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdaptiveMtDataset")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "sourceLanguageCode" => Ok(__FieldTag::__source_language_code),
                            "source_language_code" => Ok(__FieldTag::__source_language_code),
                            "targetLanguageCode" => Ok(__FieldTag::__target_language_code),
                            "target_language_code" => Ok(__FieldTag::__target_language_code),
                            "exampleCount" => Ok(__FieldTag::__example_count),
                            "example_count" => Ok(__FieldTag::__example_count),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdaptiveMtDataset;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdaptiveMtDataset")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_language_code => {
                            if !fields.insert(__FieldTag::__source_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_language_code",
                                ));
                            }
                            result.source_language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_language_code => {
                            if !fields.insert(__FieldTag::__target_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_language_code",
                                ));
                            }
                            result.target_language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__example_count => {
                            if !fields.insert(__FieldTag::__example_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for example_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.example_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdaptiveMtDataset {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.source_language_code.is_empty() {
            state.serialize_entry("sourceLanguageCode", &self.source_language_code)?;
        }
        if !self.target_language_code.is_empty() {
            state.serialize_entry("targetLanguageCode", &self.target_language_code)?;
        }
        if !wkt::internal::is_default(&self.example_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("exampleCount", &__With(&self.example_count))?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

///  Request message for creating an AdaptiveMtDataset.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAdaptiveMtDatasetRequest {
    /// Required. Name of the parent project. In form of
    /// `projects/{project-number-or-id}/locations/{location-id}`
    pub parent: std::string::String,

    /// Required. The AdaptiveMtDataset to be created.
    pub adaptive_mt_dataset: std::option::Option<crate::model::AdaptiveMtDataset>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAdaptiveMtDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAdaptiveMtDatasetRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [adaptive_mt_dataset][crate::model::CreateAdaptiveMtDatasetRequest::adaptive_mt_dataset].
    pub fn set_adaptive_mt_dataset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AdaptiveMtDataset>,
    {
        self.adaptive_mt_dataset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [adaptive_mt_dataset][crate::model::CreateAdaptiveMtDatasetRequest::adaptive_mt_dataset].
    pub fn set_or_clear_adaptive_mt_dataset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AdaptiveMtDataset>,
    {
        self.adaptive_mt_dataset = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateAdaptiveMtDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.CreateAdaptiveMtDatasetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAdaptiveMtDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __adaptive_mt_dataset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAdaptiveMtDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "adaptiveMtDataset" => Ok(__FieldTag::__adaptive_mt_dataset),
                            "adaptive_mt_dataset" => Ok(__FieldTag::__adaptive_mt_dataset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAdaptiveMtDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAdaptiveMtDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__adaptive_mt_dataset => {
                            if !fields.insert(__FieldTag::__adaptive_mt_dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for adaptive_mt_dataset",
                                ));
                            }
                            result.adaptive_mt_dataset = map
                                .next_value::<std::option::Option<crate::model::AdaptiveMtDataset>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAdaptiveMtDatasetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.adaptive_mt_dataset.is_some() {
            state.serialize_entry("adaptiveMtDataset", &self.adaptive_mt_dataset)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for deleting an AdaptiveMtDataset.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAdaptiveMtDatasetRequest {
    /// Required. Name of the dataset. In the form of
    /// `projects/{project-number-or-id}/locations/{location-id}/adaptiveMtDatasets/{adaptive-mt-dataset-id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAdaptiveMtDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAdaptiveMtDatasetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAdaptiveMtDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DeleteAdaptiveMtDatasetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAdaptiveMtDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAdaptiveMtDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAdaptiveMtDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAdaptiveMtDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAdaptiveMtDatasetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for getting an Adaptive MT dataset.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAdaptiveMtDatasetRequest {
    /// Required. Name of the dataset. In the form of
    /// `projects/{project-number-or-id}/locations/{location-id}/adaptiveMtDatasets/{adaptive-mt-dataset-id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAdaptiveMtDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAdaptiveMtDatasetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAdaptiveMtDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GetAdaptiveMtDatasetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAdaptiveMtDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAdaptiveMtDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAdaptiveMtDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAdaptiveMtDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAdaptiveMtDatasetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for listing all Adaptive MT datasets that the requestor has
/// access to.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAdaptiveMtDatasetsRequest {
    /// Required. The resource name of the project from which to list the Adaptive
    /// MT datasets. `projects/{project-number-or-id}/locations/{location-id}`
    pub parent: std::string::String,

    /// Optional. Requested page size. The server may return fewer results than
    /// requested. If unspecified, the server picks an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    /// Typically, this is the value of
    /// ListAdaptiveMtDatasetsResponse.next_page_token returned from the
    /// previous call to `ListAdaptiveMtDatasets` method. The first page is
    /// returned if `page_token`is empty or missing.
    pub page_token: std::string::String,

    /// Optional. An expression for filtering the results of the request.
    /// Filter is not supported yet.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAdaptiveMtDatasetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAdaptiveMtDatasetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAdaptiveMtDatasetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAdaptiveMtDatasetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAdaptiveMtDatasetsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListAdaptiveMtDatasetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListAdaptiveMtDatasetsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAdaptiveMtDatasetsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAdaptiveMtDatasetsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAdaptiveMtDatasetsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAdaptiveMtDatasetsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAdaptiveMtDatasetsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A list of AdaptiveMtDatasets.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAdaptiveMtDatasetsResponse {
    /// Output only. A list of Adaptive MT datasets.
    pub adaptive_mt_datasets: std::vec::Vec<crate::model::AdaptiveMtDataset>,

    /// Optional. A token to retrieve a page of results. Pass this value in the
    /// [ListAdaptiveMtDatasetsRequest.page_token] field in the subsequent call to
    /// `ListAdaptiveMtDatasets` method to retrieve the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAdaptiveMtDatasetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [adaptive_mt_datasets][crate::model::ListAdaptiveMtDatasetsResponse::adaptive_mt_datasets].
    pub fn set_adaptive_mt_datasets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AdaptiveMtDataset>,
    {
        use std::iter::Iterator;
        self.adaptive_mt_datasets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAdaptiveMtDatasetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAdaptiveMtDatasetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListAdaptiveMtDatasetsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAdaptiveMtDatasetsResponse {
    type PageItem = crate::model::AdaptiveMtDataset;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.adaptive_mt_datasets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAdaptiveMtDatasetsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __adaptive_mt_datasets,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAdaptiveMtDatasetsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "adaptiveMtDatasets" => Ok(__FieldTag::__adaptive_mt_datasets),
                            "adaptive_mt_datasets" => Ok(__FieldTag::__adaptive_mt_datasets),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAdaptiveMtDatasetsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAdaptiveMtDatasetsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__adaptive_mt_datasets => {
                            if !fields.insert(__FieldTag::__adaptive_mt_datasets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for adaptive_mt_datasets",
                                ));
                            }
                            result.adaptive_mt_datasets =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AdaptiveMtDataset>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAdaptiveMtDatasetsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.adaptive_mt_datasets.is_empty() {
            state.serialize_entry("adaptiveMtDatasets", &self.adaptive_mt_datasets)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for sending an AdaptiveMt translation query.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AdaptiveMtTranslateRequest {
    /// Required. Location to make a regional call.
    ///
    /// Format: `projects/{project-number-or-id}/locations/{location-id}`.
    pub parent: std::string::String,

    /// Required. The resource name for the dataset to use for adaptive MT.
    /// `projects/{project}/locations/{location-id}/adaptiveMtDatasets/{dataset}`
    pub dataset: std::string::String,

    /// Required. The content of the input in string format.
    pub content: std::vec::Vec<std::string::String>,

    /// Configuration for caller provided reference sentences.
    pub reference_sentence_config:
        std::option::Option<crate::model::adaptive_mt_translate_request::ReferenceSentenceConfig>,

    /// Optional. Glossary to be applied. The glossary must be
    /// within the same region (have the same location-id) as the model, otherwise
    /// an INVALID_ARGUMENT (400) error is returned.
    pub glossary_config:
        std::option::Option<crate::model::adaptive_mt_translate_request::GlossaryConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdaptiveMtTranslateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::AdaptiveMtTranslateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [dataset][crate::model::AdaptiveMtTranslateRequest::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [content][crate::model::AdaptiveMtTranslateRequest::content].
    pub fn set_content<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.content = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [reference_sentence_config][crate::model::AdaptiveMtTranslateRequest::reference_sentence_config].
    pub fn set_reference_sentence_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::adaptive_mt_translate_request::ReferenceSentenceConfig>,
    {
        self.reference_sentence_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reference_sentence_config][crate::model::AdaptiveMtTranslateRequest::reference_sentence_config].
    pub fn set_or_clear_reference_sentence_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::adaptive_mt_translate_request::ReferenceSentenceConfig>,
    {
        self.reference_sentence_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [glossary_config][crate::model::AdaptiveMtTranslateRequest::glossary_config].
    pub fn set_glossary_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::adaptive_mt_translate_request::GlossaryConfig>,
    {
        self.glossary_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [glossary_config][crate::model::AdaptiveMtTranslateRequest::glossary_config].
    pub fn set_or_clear_glossary_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::adaptive_mt_translate_request::GlossaryConfig>,
    {
        self.glossary_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AdaptiveMtTranslateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.AdaptiveMtTranslateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdaptiveMtTranslateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __dataset,
            __content,
            __reference_sentence_config,
            __glossary_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdaptiveMtTranslateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "dataset" => Ok(__FieldTag::__dataset),
                            "content" => Ok(__FieldTag::__content),
                            "referenceSentenceConfig" => {
                                Ok(__FieldTag::__reference_sentence_config)
                            }
                            "reference_sentence_config" => {
                                Ok(__FieldTag::__reference_sentence_config)
                            }
                            "glossaryConfig" => Ok(__FieldTag::__glossary_config),
                            "glossary_config" => Ok(__FieldTag::__glossary_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdaptiveMtTranslateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdaptiveMtTranslateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset",
                                ));
                            }
                            result.dataset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            result.content = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__reference_sentence_config => {
                            if !fields.insert(__FieldTag::__reference_sentence_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reference_sentence_config",
                                ));
                            }
                            result.reference_sentence_config = map.next_value::<std::option::Option<crate::model::adaptive_mt_translate_request::ReferenceSentenceConfig>>()?
                                ;
                        }
                        __FieldTag::__glossary_config => {
                            if !fields.insert(__FieldTag::__glossary_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for glossary_config",
                                ));
                            }
                            result.glossary_config = map.next_value::<std::option::Option<
                                crate::model::adaptive_mt_translate_request::GlossaryConfig,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdaptiveMtTranslateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.dataset.is_empty() {
            state.serialize_entry("dataset", &self.dataset)?;
        }
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if self.reference_sentence_config.is_some() {
            state.serialize_entry("referenceSentenceConfig", &self.reference_sentence_config)?;
        }
        if self.glossary_config.is_some() {
            state.serialize_entry("glossaryConfig", &self.glossary_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AdaptiveMtTranslateRequest].
pub mod adaptive_mt_translate_request {
    #[allow(unused_imports)]
    use super::*;

    /// A pair of sentences used as reference in source and target languages.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ReferenceSentencePair {
        /// Source sentence in the sentence pair.
        pub source_sentence: std::string::String,

        /// Target sentence in the sentence pair.
        pub target_sentence: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ReferenceSentencePair {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_sentence][crate::model::adaptive_mt_translate_request::ReferenceSentencePair::source_sentence].
        pub fn set_source_sentence<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_sentence = v.into();
            self
        }

        /// Sets the value of [target_sentence][crate::model::adaptive_mt_translate_request::ReferenceSentencePair::target_sentence].
        pub fn set_target_sentence<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.target_sentence = v.into();
            self
        }
    }

    impl wkt::message::Message for ReferenceSentencePair {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.translation.v3.AdaptiveMtTranslateRequest.ReferenceSentencePair"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ReferenceSentencePair {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __source_sentence,
                __target_sentence,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ReferenceSentencePair")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sourceSentence" => Ok(__FieldTag::__source_sentence),
                                "source_sentence" => Ok(__FieldTag::__source_sentence),
                                "targetSentence" => Ok(__FieldTag::__target_sentence),
                                "target_sentence" => Ok(__FieldTag::__target_sentence),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ReferenceSentencePair;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ReferenceSentencePair")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__source_sentence => {
                                if !fields.insert(__FieldTag::__source_sentence) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for source_sentence",
                                    ));
                                }
                                result.source_sentence = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__target_sentence => {
                                if !fields.insert(__FieldTag::__target_sentence) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for target_sentence",
                                    ));
                                }
                                result.target_sentence = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ReferenceSentencePair {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.source_sentence.is_empty() {
                state.serialize_entry("sourceSentence", &self.source_sentence)?;
            }
            if !self.target_sentence.is_empty() {
                state.serialize_entry("targetSentence", &self.target_sentence)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A list of reference sentence pairs.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ReferenceSentencePairList {
        /// Reference sentence pairs.
        pub reference_sentence_pairs:
            std::vec::Vec<crate::model::adaptive_mt_translate_request::ReferenceSentencePair>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ReferenceSentencePairList {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [reference_sentence_pairs][crate::model::adaptive_mt_translate_request::ReferenceSentencePairList::reference_sentence_pairs].
        pub fn set_reference_sentence_pairs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::adaptive_mt_translate_request::ReferenceSentencePair,
                >,
        {
            use std::iter::Iterator;
            self.reference_sentence_pairs = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ReferenceSentencePairList {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.translation.v3.AdaptiveMtTranslateRequest.ReferenceSentencePairList"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ReferenceSentencePairList {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __reference_sentence_pairs,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ReferenceSentencePairList")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "referenceSentencePairs" => {
                                    Ok(__FieldTag::__reference_sentence_pairs)
                                }
                                "reference_sentence_pairs" => {
                                    Ok(__FieldTag::__reference_sentence_pairs)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ReferenceSentencePairList;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ReferenceSentencePairList")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__reference_sentence_pairs => {
                                if !fields.insert(__FieldTag::__reference_sentence_pairs) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for reference_sentence_pairs",
                                    ));
                                }
                                result.reference_sentence_pairs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::adaptive_mt_translate_request::ReferenceSentencePair>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ReferenceSentencePairList {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.reference_sentence_pairs.is_empty() {
                state.serialize_entry("referenceSentencePairs", &self.reference_sentence_pairs)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Message of caller-provided reference configuration.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ReferenceSentenceConfig {
        /// Reference sentences pair lists. Each list will be used as the references
        /// to translate the sentence under "content" field at the corresponding
        /// index. Length of the list is required to be equal to the length of
        /// "content" field.
        pub reference_sentence_pair_lists:
            std::vec::Vec<crate::model::adaptive_mt_translate_request::ReferenceSentencePairList>,

        /// Source language code.
        pub source_language_code: std::string::String,

        /// Target language code.
        pub target_language_code: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ReferenceSentenceConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [reference_sentence_pair_lists][crate::model::adaptive_mt_translate_request::ReferenceSentenceConfig::reference_sentence_pair_lists].
        pub fn set_reference_sentence_pair_lists<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::adaptive_mt_translate_request::ReferenceSentencePairList,
                >,
        {
            use std::iter::Iterator;
            self.reference_sentence_pair_lists = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [source_language_code][crate::model::adaptive_mt_translate_request::ReferenceSentenceConfig::source_language_code].
        pub fn set_source_language_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_language_code = v.into();
            self
        }

        /// Sets the value of [target_language_code][crate::model::adaptive_mt_translate_request::ReferenceSentenceConfig::target_language_code].
        pub fn set_target_language_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.target_language_code = v.into();
            self
        }
    }

    impl wkt::message::Message for ReferenceSentenceConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.translation.v3.AdaptiveMtTranslateRequest.ReferenceSentenceConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ReferenceSentenceConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __reference_sentence_pair_lists,
                __source_language_code,
                __target_language_code,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ReferenceSentenceConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "referenceSentencePairLists" => {
                                    Ok(__FieldTag::__reference_sentence_pair_lists)
                                }
                                "reference_sentence_pair_lists" => {
                                    Ok(__FieldTag::__reference_sentence_pair_lists)
                                }
                                "sourceLanguageCode" => Ok(__FieldTag::__source_language_code),
                                "source_language_code" => Ok(__FieldTag::__source_language_code),
                                "targetLanguageCode" => Ok(__FieldTag::__target_language_code),
                                "target_language_code" => Ok(__FieldTag::__target_language_code),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ReferenceSentenceConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ReferenceSentenceConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__reference_sentence_pair_lists => {
                                if !fields.insert(__FieldTag::__reference_sentence_pair_lists) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for reference_sentence_pair_lists",
                                    ));
                                }
                                result.reference_sentence_pair_lists = map.next_value::<std::option::Option<std::vec::Vec<crate::model::adaptive_mt_translate_request::ReferenceSentencePairList>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__source_language_code => {
                                if !fields.insert(__FieldTag::__source_language_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for source_language_code",
                                    ));
                                }
                                result.source_language_code = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__target_language_code => {
                                if !fields.insert(__FieldTag::__target_language_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for target_language_code",
                                    ));
                                }
                                result.target_language_code = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ReferenceSentenceConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.reference_sentence_pair_lists.is_empty() {
                state.serialize_entry(
                    "referenceSentencePairLists",
                    &self.reference_sentence_pair_lists,
                )?;
            }
            if !self.source_language_code.is_empty() {
                state.serialize_entry("sourceLanguageCode", &self.source_language_code)?;
            }
            if !self.target_language_code.is_empty() {
                state.serialize_entry("targetLanguageCode", &self.target_language_code)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Configures which glossary is used for a specific target language and
    /// defines
    /// options for applying that glossary.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GlossaryConfig {
        /// Required. The `glossary` to be applied for this translation.
        ///
        /// The format depends on the glossary:
        ///
        /// - User-provided custom glossary:
        ///   `projects/{project-number-or-id}/locations/{location-id}/glossaries/{glossary-id}`
        pub glossary: std::string::String,

        /// Optional. Indicates match is case insensitive. The default value is
        /// `false` if missing.
        pub ignore_case: bool,

        /// Optional. If set to true, the glossary will be used for contextual
        /// translation.
        pub contextual_translation_enabled: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GlossaryConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [glossary][crate::model::adaptive_mt_translate_request::GlossaryConfig::glossary].
        pub fn set_glossary<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.glossary = v.into();
            self
        }

        /// Sets the value of [ignore_case][crate::model::adaptive_mt_translate_request::GlossaryConfig::ignore_case].
        pub fn set_ignore_case<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.ignore_case = v.into();
            self
        }

        /// Sets the value of [contextual_translation_enabled][crate::model::adaptive_mt_translate_request::GlossaryConfig::contextual_translation_enabled].
        pub fn set_contextual_translation_enabled<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.contextual_translation_enabled = v.into();
            self
        }
    }

    impl wkt::message::Message for GlossaryConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.translation.v3.AdaptiveMtTranslateRequest.GlossaryConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GlossaryConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __glossary,
                __ignore_case,
                __contextual_translation_enabled,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GlossaryConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "glossary" => Ok(__FieldTag::__glossary),
                                "ignoreCase" => Ok(__FieldTag::__ignore_case),
                                "ignore_case" => Ok(__FieldTag::__ignore_case),
                                "contextualTranslationEnabled" => {
                                    Ok(__FieldTag::__contextual_translation_enabled)
                                }
                                "contextual_translation_enabled" => {
                                    Ok(__FieldTag::__contextual_translation_enabled)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GlossaryConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GlossaryConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__glossary => {
                                if !fields.insert(__FieldTag::__glossary) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for glossary",
                                    ));
                                }
                                result.glossary = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__ignore_case => {
                                if !fields.insert(__FieldTag::__ignore_case) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ignore_case",
                                    ));
                                }
                                result.ignore_case = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__contextual_translation_enabled => {
                                if !fields.insert(__FieldTag::__contextual_translation_enabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for contextual_translation_enabled",
                                    ));
                                }
                                result.contextual_translation_enabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GlossaryConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.glossary.is_empty() {
                state.serialize_entry("glossary", &self.glossary)?;
            }
            if !wkt::internal::is_default(&self.ignore_case) {
                state.serialize_entry("ignoreCase", &self.ignore_case)?;
            }
            if !wkt::internal::is_default(&self.contextual_translation_enabled) {
                state.serialize_entry(
                    "contextualTranslationEnabled",
                    &self.contextual_translation_enabled,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// An AdaptiveMt translation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AdaptiveMtTranslation {
    /// Output only. The translated text.
    pub translated_text: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdaptiveMtTranslation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [translated_text][crate::model::AdaptiveMtTranslation::translated_text].
    pub fn set_translated_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.translated_text = v.into();
        self
    }
}

impl wkt::message::Message for AdaptiveMtTranslation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.AdaptiveMtTranslation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdaptiveMtTranslation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __translated_text,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdaptiveMtTranslation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "translatedText" => Ok(__FieldTag::__translated_text),
                            "translated_text" => Ok(__FieldTag::__translated_text),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdaptiveMtTranslation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdaptiveMtTranslation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__translated_text => {
                            if !fields.insert(__FieldTag::__translated_text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for translated_text",
                                ));
                            }
                            result.translated_text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdaptiveMtTranslation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.translated_text.is_empty() {
            state.serialize_entry("translatedText", &self.translated_text)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An AdaptiveMtTranslate response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AdaptiveMtTranslateResponse {
    /// Output only. The translation.
    pub translations: std::vec::Vec<crate::model::AdaptiveMtTranslation>,

    /// Output only. The translation's language code.
    pub language_code: std::string::String,

    /// Text translation response if a glossary is provided in the request. This
    /// could be the same as 'translation' above if no terms apply.
    pub glossary_translations: std::vec::Vec<crate::model::AdaptiveMtTranslation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdaptiveMtTranslateResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [translations][crate::model::AdaptiveMtTranslateResponse::translations].
    pub fn set_translations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AdaptiveMtTranslation>,
    {
        use std::iter::Iterator;
        self.translations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [language_code][crate::model::AdaptiveMtTranslateResponse::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [glossary_translations][crate::model::AdaptiveMtTranslateResponse::glossary_translations].
    pub fn set_glossary_translations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AdaptiveMtTranslation>,
    {
        use std::iter::Iterator;
        self.glossary_translations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AdaptiveMtTranslateResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.AdaptiveMtTranslateResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdaptiveMtTranslateResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __translations,
            __language_code,
            __glossary_translations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdaptiveMtTranslateResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "translations" => Ok(__FieldTag::__translations),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "glossaryTranslations" => Ok(__FieldTag::__glossary_translations),
                            "glossary_translations" => Ok(__FieldTag::__glossary_translations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdaptiveMtTranslateResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdaptiveMtTranslateResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__translations => {
                            if !fields.insert(__FieldTag::__translations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for translations",
                                ));
                            }
                            result.translations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AdaptiveMtTranslation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__glossary_translations => {
                            if !fields.insert(__FieldTag::__glossary_translations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for glossary_translations",
                                ));
                            }
                            result.glossary_translations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AdaptiveMtTranslation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdaptiveMtTranslateResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.translations.is_empty() {
            state.serialize_entry("translations", &self.translations)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self.glossary_translations.is_empty() {
            state.serialize_entry("glossaryTranslations", &self.glossary_translations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An AdaptiveMtFile.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AdaptiveMtFile {
    /// Required. The resource name of the file, in form of
    /// `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset}/adaptiveMtFiles/{file}`
    pub name: std::string::String,

    /// The file's display name.
    pub display_name: std::string::String,

    /// The number of entries that the file contains.
    pub entry_count: i32,

    /// Output only. Timestamp when this file was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this file was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdaptiveMtFile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AdaptiveMtFile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AdaptiveMtFile::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [entry_count][crate::model::AdaptiveMtFile::entry_count].
    pub fn set_entry_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.entry_count = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AdaptiveMtFile::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::AdaptiveMtFile::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::AdaptiveMtFile::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::AdaptiveMtFile::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AdaptiveMtFile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.AdaptiveMtFile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdaptiveMtFile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __entry_count,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdaptiveMtFile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "entryCount" => Ok(__FieldTag::__entry_count),
                            "entry_count" => Ok(__FieldTag::__entry_count),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdaptiveMtFile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdaptiveMtFile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entry_count => {
                            if !fields.insert(__FieldTag::__entry_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.entry_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdaptiveMtFile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.entry_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("entryCount", &__With(&self.entry_count))?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for getting an AdaptiveMtFile.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAdaptiveMtFileRequest {
    /// Required. The resource name of the file, in form of
    /// `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset}/adaptiveMtFiles/{file}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAdaptiveMtFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAdaptiveMtFileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAdaptiveMtFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GetAdaptiveMtFileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAdaptiveMtFileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAdaptiveMtFileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAdaptiveMtFileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAdaptiveMtFileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAdaptiveMtFileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for deleting an AdaptiveMt file.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAdaptiveMtFileRequest {
    /// Required. The resource name of the file to delete, in form of
    /// `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset}/adaptiveMtFiles/{file}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAdaptiveMtFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAdaptiveMtFileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAdaptiveMtFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DeleteAdaptiveMtFileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAdaptiveMtFileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAdaptiveMtFileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAdaptiveMtFileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAdaptiveMtFileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAdaptiveMtFileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for importing an AdaptiveMt file along with its sentences.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportAdaptiveMtFileRequest {
    /// Required. The resource name of the file, in form of
    /// `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset}`
    pub parent: std::string::String,

    /// The source for the document.
    pub source: std::option::Option<crate::model::import_adaptive_mt_file_request::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportAdaptiveMtFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportAdaptiveMtFileRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source][crate::model::ImportAdaptiveMtFileRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<
                std::option::Option<crate::model::import_adaptive_mt_file_request::Source>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportAdaptiveMtFileRequest::source]
    /// if it holds a `FileInputSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn file_input_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FileInputSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_adaptive_mt_file_request::Source::FileInputSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportAdaptiveMtFileRequest::source]
    /// to hold a `FileInputSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_file_input_source<
        T: std::convert::Into<std::boxed::Box<crate::model::FileInputSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_adaptive_mt_file_request::Source::FileInputSource(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::ImportAdaptiveMtFileRequest::source]
    /// if it holds a `GcsInputSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_input_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsInputSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_adaptive_mt_file_request::Source::GcsInputSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportAdaptiveMtFileRequest::source]
    /// to hold a `GcsInputSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_input_source<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsInputSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_adaptive_mt_file_request::Source::GcsInputSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportAdaptiveMtFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ImportAdaptiveMtFileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportAdaptiveMtFileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __file_input_source,
            __gcs_input_source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportAdaptiveMtFileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "fileInputSource" => Ok(__FieldTag::__file_input_source),
                            "file_input_source" => Ok(__FieldTag::__file_input_source),
                            "gcsInputSource" => Ok(__FieldTag::__gcs_input_source),
                            "gcs_input_source" => Ok(__FieldTag::__gcs_input_source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportAdaptiveMtFileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportAdaptiveMtFileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_input_source => {
                            if !fields.insert(__FieldTag::__file_input_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_input_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.translation.v3.ImportAdaptiveMtFileRequest.file_input_source, latest field was fileInputSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::import_adaptive_mt_file_request::Source::FileInputSource(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::FileInputSource>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__gcs_input_source => {
                            if !fields.insert(__FieldTag::__gcs_input_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_input_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.translation.v3.ImportAdaptiveMtFileRequest.gcs_input_source, latest field was gcsInputSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::import_adaptive_mt_file_request::Source::GcsInputSource(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::GcsInputSource>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportAdaptiveMtFileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.file_input_source() {
            state.serialize_entry("fileInputSource", value)?;
        }
        if let Some(value) = self.gcs_input_source() {
            state.serialize_entry("gcsInputSource", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ImportAdaptiveMtFileRequest].
pub mod import_adaptive_mt_file_request {
    #[allow(unused_imports)]
    use super::*;

    /// The source for the document.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Inline file source.
        FileInputSource(std::boxed::Box<crate::model::FileInputSource>),
        /// Google Cloud Storage file source.
        GcsInputSource(std::boxed::Box<crate::model::GcsInputSource>),
    }
}

/// The response for importing an AdaptiveMtFile
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportAdaptiveMtFileResponse {
    /// Output only. The Adaptive MT file that was imported.
    pub adaptive_mt_file: std::option::Option<crate::model::AdaptiveMtFile>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportAdaptiveMtFileResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [adaptive_mt_file][crate::model::ImportAdaptiveMtFileResponse::adaptive_mt_file].
    pub fn set_adaptive_mt_file<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AdaptiveMtFile>,
    {
        self.adaptive_mt_file = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [adaptive_mt_file][crate::model::ImportAdaptiveMtFileResponse::adaptive_mt_file].
    pub fn set_or_clear_adaptive_mt_file<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AdaptiveMtFile>,
    {
        self.adaptive_mt_file = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ImportAdaptiveMtFileResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ImportAdaptiveMtFileResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportAdaptiveMtFileResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __adaptive_mt_file,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportAdaptiveMtFileResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "adaptiveMtFile" => Ok(__FieldTag::__adaptive_mt_file),
                            "adaptive_mt_file" => Ok(__FieldTag::__adaptive_mt_file),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportAdaptiveMtFileResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportAdaptiveMtFileResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__adaptive_mt_file => {
                            if !fields.insert(__FieldTag::__adaptive_mt_file) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for adaptive_mt_file",
                                ));
                            }
                            result.adaptive_mt_file = map
                                .next_value::<std::option::Option<crate::model::AdaptiveMtFile>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportAdaptiveMtFileResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.adaptive_mt_file.is_some() {
            state.serialize_entry("adaptiveMtFile", &self.adaptive_mt_file)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request to list all AdaptiveMt files under a given dataset.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAdaptiveMtFilesRequest {
    /// Required. The resource name of the project from which to list the Adaptive
    /// MT files.
    /// `projects/{project}/locations/{location}/adaptiveMtDatasets/{dataset}`
    pub parent: std::string::String,

    /// Optional.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    /// Typically, this is the value of
    /// ListAdaptiveMtFilesResponse.next_page_token returned from the
    /// previous call to `ListAdaptiveMtFiles` method. The first page is
    /// returned if `page_token`is empty or missing.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAdaptiveMtFilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAdaptiveMtFilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAdaptiveMtFilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAdaptiveMtFilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAdaptiveMtFilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListAdaptiveMtFilesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAdaptiveMtFilesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAdaptiveMtFilesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAdaptiveMtFilesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAdaptiveMtFilesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAdaptiveMtFilesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response for listing all AdaptiveMt files under a given dataset.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAdaptiveMtFilesResponse {
    /// Output only. The Adaptive MT files.
    pub adaptive_mt_files: std::vec::Vec<crate::model::AdaptiveMtFile>,

    /// Optional. A token to retrieve a page of results. Pass this value in the
    /// ListAdaptiveMtFilesRequest.page_token field in the subsequent call to
    /// `ListAdaptiveMtFiles` method to retrieve the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAdaptiveMtFilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [adaptive_mt_files][crate::model::ListAdaptiveMtFilesResponse::adaptive_mt_files].
    pub fn set_adaptive_mt_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AdaptiveMtFile>,
    {
        use std::iter::Iterator;
        self.adaptive_mt_files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAdaptiveMtFilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAdaptiveMtFilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListAdaptiveMtFilesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAdaptiveMtFilesResponse {
    type PageItem = crate::model::AdaptiveMtFile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.adaptive_mt_files
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAdaptiveMtFilesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __adaptive_mt_files,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAdaptiveMtFilesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "adaptiveMtFiles" => Ok(__FieldTag::__adaptive_mt_files),
                            "adaptive_mt_files" => Ok(__FieldTag::__adaptive_mt_files),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAdaptiveMtFilesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAdaptiveMtFilesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__adaptive_mt_files => {
                            if !fields.insert(__FieldTag::__adaptive_mt_files) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for adaptive_mt_files",
                                ));
                            }
                            result.adaptive_mt_files =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AdaptiveMtFile>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAdaptiveMtFilesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.adaptive_mt_files.is_empty() {
            state.serialize_entry("adaptiveMtFiles", &self.adaptive_mt_files)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An AdaptiveMt sentence entry.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AdaptiveMtSentence {
    /// Required. The resource name of the file, in form of
    /// `projects/{project-number-or-id}/locations/{location_id}/adaptiveMtDatasets/{dataset}/adaptiveMtFiles/{file}/adaptiveMtSentences/{sentence}`
    pub name: std::string::String,

    /// Required. The source sentence.
    pub source_sentence: std::string::String,

    /// Required. The target sentence.
    pub target_sentence: std::string::String,

    /// Output only. Timestamp when this sentence was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this sentence was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdaptiveMtSentence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AdaptiveMtSentence::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source_sentence][crate::model::AdaptiveMtSentence::source_sentence].
    pub fn set_source_sentence<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_sentence = v.into();
        self
    }

    /// Sets the value of [target_sentence][crate::model::AdaptiveMtSentence::target_sentence].
    pub fn set_target_sentence<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_sentence = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::AdaptiveMtSentence::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::AdaptiveMtSentence::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::AdaptiveMtSentence::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::AdaptiveMtSentence::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AdaptiveMtSentence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.AdaptiveMtSentence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdaptiveMtSentence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __source_sentence,
            __target_sentence,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdaptiveMtSentence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "sourceSentence" => Ok(__FieldTag::__source_sentence),
                            "source_sentence" => Ok(__FieldTag::__source_sentence),
                            "targetSentence" => Ok(__FieldTag::__target_sentence),
                            "target_sentence" => Ok(__FieldTag::__target_sentence),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdaptiveMtSentence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdaptiveMtSentence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_sentence => {
                            if !fields.insert(__FieldTag::__source_sentence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_sentence",
                                ));
                            }
                            result.source_sentence = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_sentence => {
                            if !fields.insert(__FieldTag::__target_sentence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_sentence",
                                ));
                            }
                            result.target_sentence = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdaptiveMtSentence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.source_sentence.is_empty() {
            state.serialize_entry("sourceSentence", &self.source_sentence)?;
        }
        if !self.target_sentence.is_empty() {
            state.serialize_entry("targetSentence", &self.target_sentence)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for listing Adaptive MT sentences from a Dataset/File.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAdaptiveMtSentencesRequest {
    /// Required. The resource name of the project from which to list the Adaptive
    /// MT files. The following format lists all sentences under a file.
    /// `projects/{project}/locations/{location}/adaptiveMtDatasets/{dataset}/adaptiveMtFiles/{file}`
    /// The following format lists all sentences within a dataset.
    /// `projects/{project}/locations/{location}/adaptiveMtDatasets/{dataset}`
    pub parent: std::string::String,

    pub page_size: i32,

    /// A token identifying a page of results the server should return.
    /// Typically, this is the value of
    /// ListAdaptiveMtSentencesRequest.next_page_token returned from the
    /// previous call to `ListTranslationMemories` method. The first page is
    /// returned if `page_token` is empty or missing.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAdaptiveMtSentencesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAdaptiveMtSentencesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAdaptiveMtSentencesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAdaptiveMtSentencesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAdaptiveMtSentencesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListAdaptiveMtSentencesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAdaptiveMtSentencesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAdaptiveMtSentencesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAdaptiveMtSentencesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAdaptiveMtSentencesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAdaptiveMtSentencesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List AdaptiveMt sentences response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAdaptiveMtSentencesResponse {
    /// Output only. The list of AdaptiveMtSentences.
    pub adaptive_mt_sentences: std::vec::Vec<crate::model::AdaptiveMtSentence>,

    /// Optional.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAdaptiveMtSentencesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [adaptive_mt_sentences][crate::model::ListAdaptiveMtSentencesResponse::adaptive_mt_sentences].
    pub fn set_adaptive_mt_sentences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AdaptiveMtSentence>,
    {
        use std::iter::Iterator;
        self.adaptive_mt_sentences = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAdaptiveMtSentencesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAdaptiveMtSentencesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListAdaptiveMtSentencesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAdaptiveMtSentencesResponse {
    type PageItem = crate::model::AdaptiveMtSentence;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.adaptive_mt_sentences
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAdaptiveMtSentencesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __adaptive_mt_sentences,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAdaptiveMtSentencesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "adaptiveMtSentences" => Ok(__FieldTag::__adaptive_mt_sentences),
                            "adaptive_mt_sentences" => Ok(__FieldTag::__adaptive_mt_sentences),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAdaptiveMtSentencesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAdaptiveMtSentencesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__adaptive_mt_sentences => {
                            if !fields.insert(__FieldTag::__adaptive_mt_sentences) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for adaptive_mt_sentences",
                                ));
                            }
                            result.adaptive_mt_sentences = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AdaptiveMtSentence>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAdaptiveMtSentencesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.adaptive_mt_sentences.is_empty() {
            state.serialize_entry("adaptiveMtSentences", &self.adaptive_mt_sentences)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ImportData.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportDataRequest {
    /// Required. Name of the dataset. In form of
    /// `projects/{project-number-or-id}/locations/{location-id}/datasets/{dataset-id}`
    pub dataset: std::string::String,

    /// Required. The config for the input content.
    pub input_config: std::option::Option<crate::model::DatasetInputConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset][crate::model::ImportDataRequest::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [input_config][crate::model::ImportDataRequest::input_config].
    pub fn set_input_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatasetInputConfig>,
    {
        self.input_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [input_config][crate::model::ImportDataRequest::input_config].
    pub fn set_or_clear_input_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatasetInputConfig>,
    {
        self.input_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ImportDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ImportDataRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportDataRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataset,
            __input_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportDataRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataset" => Ok(__FieldTag::__dataset),
                            "inputConfig" => Ok(__FieldTag::__input_config),
                            "input_config" => Ok(__FieldTag::__input_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportDataRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportDataRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset",
                                ));
                            }
                            result.dataset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__input_config => {
                            if !fields.insert(__FieldTag::__input_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_config",
                                ));
                            }
                            result.input_config = map.next_value::<std::option::Option<crate::model::DatasetInputConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportDataRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dataset.is_empty() {
            state.serialize_entry("dataset", &self.dataset)?;
        }
        if self.input_config.is_some() {
            state.serialize_entry("inputConfig", &self.input_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Input configuration for datasets.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DatasetInputConfig {
    /// Files containing the sentence pairs to be imported to the dataset.
    pub input_files: std::vec::Vec<crate::model::dataset_input_config::InputFile>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatasetInputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input_files][crate::model::DatasetInputConfig::input_files].
    pub fn set_input_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::dataset_input_config::InputFile>,
    {
        use std::iter::Iterator;
        self.input_files = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DatasetInputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DatasetInputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatasetInputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __input_files,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatasetInputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inputFiles" => Ok(__FieldTag::__input_files),
                            "input_files" => Ok(__FieldTag::__input_files),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatasetInputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatasetInputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__input_files => {
                            if !fields.insert(__FieldTag::__input_files) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_files",
                                ));
                            }
                            result.input_files = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::dataset_input_config::InputFile>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatasetInputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.input_files.is_empty() {
            state.serialize_entry("inputFiles", &self.input_files)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DatasetInputConfig].
pub mod dataset_input_config {
    #[allow(unused_imports)]
    use super::*;

    /// An input file.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InputFile {
        /// Optional. Usage of the file contents. Options are TRAIN|VALIDATION|TEST,
        /// or UNASSIGNED (by default) for auto split.
        pub usage: std::string::String,

        /// Source of the file containing sentence pairs.
        /// Supported formats are tab-separated values (.tsv) and Translation Memory
        /// eXchange (.tmx) .
        pub source: std::option::Option<crate::model::dataset_input_config::input_file::Source>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InputFile {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [usage][crate::model::dataset_input_config::InputFile::usage].
        pub fn set_usage<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.usage = v.into();
            self
        }

        /// Sets the value of [source][crate::model::dataset_input_config::InputFile::source].
        ///
        /// Note that all the setters affecting `source` are mutually
        /// exclusive.
        pub fn set_source<
            T: std::convert::Into<
                    std::option::Option<crate::model::dataset_input_config::input_file::Source>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = v.into();
            self
        }

        /// The value of [source][crate::model::dataset_input_config::InputFile::source]
        /// if it holds a `GcsSource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn gcs_source(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::GcsInputSource>> {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::dataset_input_config::input_file::Source::GcsSource(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::dataset_input_config::InputFile::source]
        /// to hold a `GcsSource`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_gcs_source<
            T: std::convert::Into<std::boxed::Box<crate::model::GcsInputSource>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = std::option::Option::Some(
                crate::model::dataset_input_config::input_file::Source::GcsSource(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for InputFile {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.translation.v3.DatasetInputConfig.InputFile"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for InputFile {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __usage,
                __gcs_source,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for InputFile")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "usage" => Ok(__FieldTag::__usage),
                                "gcsSource" => Ok(__FieldTag::__gcs_source),
                                "gcs_source" => Ok(__FieldTag::__gcs_source),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = InputFile;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct InputFile")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__usage => {
                                if !fields.insert(__FieldTag::__usage) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for usage",
                                    ));
                                }
                                result.usage = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__gcs_source => {
                                if !fields.insert(__FieldTag::__gcs_source) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for gcs_source",
                                    ));
                                }
                                if result.source.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `source`, a oneof with full ID .google.cloud.translation.v3.DatasetInputConfig.InputFile.gcs_source, latest field was gcsSource",
                                    ));
                                }
                                result.source = std::option::Option::Some(
                                    crate::model::dataset_input_config::input_file::Source::GcsSource(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::GcsInputSource>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for InputFile {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.usage.is_empty() {
                state.serialize_entry("usage", &self.usage)?;
            }
            if let Some(value) = self.gcs_source() {
                state.serialize_entry("gcsSource", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [InputFile].
    pub mod input_file {
        #[allow(unused_imports)]
        use super::*;

        /// Source of the file containing sentence pairs.
        /// Supported formats are tab-separated values (.tsv) and Translation Memory
        /// eXchange (.tmx) .
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Source {
            /// Google Cloud Storage file source.
            GcsSource(std::boxed::Box<crate::model::GcsInputSource>),
        }
    }
}

/// Metadata of import data operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportDataMetadata {
    /// The current state of the operation.
    pub state: crate::model::OperationState,

    /// The creation time of the operation.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The last update time of the operation.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Only populated when operation doesn't succeed.
    pub error: std::option::Option<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportDataMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::ImportDataMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ImportDataMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ImportDataMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ImportDataMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ImportDataMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::ImportDataMetadata::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::ImportDataMetadata::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ImportDataMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ImportDataMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportDataMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __create_time,
            __update_time,
            __error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportDataMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "error" => Ok(__FieldTag::__error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportDataMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportDataMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::OperationState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportDataMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ExportData.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportDataRequest {
    /// Required. Name of the dataset. In form of
    /// `projects/{project-number-or-id}/locations/{location-id}/datasets/{dataset-id}`
    pub dataset: std::string::String,

    /// Required. The config for the output content.
    pub output_config: std::option::Option<crate::model::DatasetOutputConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset][crate::model::ExportDataRequest::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [output_config][crate::model::ExportDataRequest::output_config].
    pub fn set_output_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatasetOutputConfig>,
    {
        self.output_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_config][crate::model::ExportDataRequest::output_config].
    pub fn set_or_clear_output_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatasetOutputConfig>,
    {
        self.output_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ExportDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ExportDataRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportDataRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataset,
            __output_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportDataRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataset" => Ok(__FieldTag::__dataset),
                            "outputConfig" => Ok(__FieldTag::__output_config),
                            "output_config" => Ok(__FieldTag::__output_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportDataRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportDataRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset",
                                ));
                            }
                            result.dataset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__output_config => {
                            if !fields.insert(__FieldTag::__output_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_config",
                                ));
                            }
                            result.output_config = map.next_value::<std::option::Option<crate::model::DatasetOutputConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportDataRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dataset.is_empty() {
            state.serialize_entry("dataset", &self.dataset)?;
        }
        if self.output_config.is_some() {
            state.serialize_entry("outputConfig", &self.output_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Output configuration for datasets.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DatasetOutputConfig {
    /// Required. Specify the output.
    pub destination: std::option::Option<crate::model::dataset_output_config::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatasetOutputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination][crate::model::DatasetOutputConfig::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::dataset_output_config::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::DatasetOutputConfig::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsOutputDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::dataset_output_config::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::DatasetOutputConfig::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsOutputDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::dataset_output_config::Destination::GcsDestination(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DatasetOutputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DatasetOutputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatasetOutputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_destination,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatasetOutputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsDestination" => Ok(__FieldTag::__gcs_destination),
                            "gcs_destination" => Ok(__FieldTag::__gcs_destination),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatasetOutputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatasetOutputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_destination => {
                            if !fields.insert(__FieldTag::__gcs_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_destination",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.translation.v3.DatasetOutputConfig.gcs_destination, latest field was gcsDestination",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::dataset_output_config::Destination::GcsDestination(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsOutputDestination>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatasetOutputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_destination() {
            state.serialize_entry("gcsDestination", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DatasetOutputConfig].
pub mod dataset_output_config {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Specify the output.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Google Cloud Storage destination to write the output.
        GcsDestination(std::boxed::Box<crate::model::GcsOutputDestination>),
    }
}

/// Metadata of export data operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportDataMetadata {
    /// The current state of the operation.
    pub state: crate::model::OperationState,

    /// The creation time of the operation.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The last update time of the operation.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Only populated when operation doesn't succeed.
    pub error: std::option::Option<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportDataMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::ExportDataMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ExportDataMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ExportDataMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ExportDataMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ExportDataMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::ExportDataMetadata::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::ExportDataMetadata::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ExportDataMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ExportDataMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportDataMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __create_time,
            __update_time,
            __error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportDataMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "error" => Ok(__FieldTag::__error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportDataMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportDataMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::OperationState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportDataMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for DeleteDataset.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDatasetRequest {
    /// Required. The name of the dataset to delete.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDatasetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DeleteDatasetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDatasetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata of delete dataset operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDatasetMetadata {
    /// The current state of the operation.
    pub state: crate::model::OperationState,

    /// The creation time of the operation.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The last update time of the operation.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Only populated when operation doesn't succeed.
    pub error: std::option::Option<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDatasetMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::DeleteDatasetMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DeleteDatasetMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DeleteDatasetMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DeleteDatasetMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DeleteDatasetMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::DeleteDatasetMetadata::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::DeleteDatasetMetadata::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeleteDatasetMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DeleteDatasetMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDatasetMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __create_time,
            __update_time,
            __error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDatasetMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "error" => Ok(__FieldTag::__error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDatasetMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDatasetMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::OperationState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDatasetMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetDataset.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDatasetRequest {
    /// Required. The resource name of the dataset to retrieve.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDatasetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GetDatasetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDatasetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListDatasets.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDatasetsRequest {
    /// Required. Name of the parent project. In form of
    /// `projects/{project-number-or-id}/locations/{location-id}`
    pub parent: std::string::String,

    /// Optional. Requested page size. The server can return fewer results than
    /// requested.
    pub page_size: i32,

    /// Optional. A token identifying a page of results for the server to return.
    /// Typically obtained from next_page_token field in the response of a
    /// ListDatasets call.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDatasetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDatasetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDatasetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDatasetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDatasetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListDatasetsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDatasetsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDatasetsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDatasetsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDatasetsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDatasetsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListDatasets.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDatasetsResponse {
    /// The datasets read.
    pub datasets: std::vec::Vec<crate::model::Dataset>,

    /// A token to retrieve next page of results.
    /// Pass this token to the page_token field in the ListDatasetsRequest to
    /// obtain the corresponding page.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDatasetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [datasets][crate::model::ListDatasetsResponse::datasets].
    pub fn set_datasets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Dataset>,
    {
        use std::iter::Iterator;
        self.datasets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDatasetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListDatasetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListDatasetsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDatasetsResponse {
    type PageItem = crate::model::Dataset;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.datasets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDatasetsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __datasets,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDatasetsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "datasets" => Ok(__FieldTag::__datasets),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDatasetsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDatasetsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__datasets => {
                            if !fields.insert(__FieldTag::__datasets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datasets",
                                ));
                            }
                            result.datasets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Dataset>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDatasetsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.datasets.is_empty() {
            state.serialize_entry("datasets", &self.datasets)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for CreateDataset.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDatasetRequest {
    /// Required. The project name.
    pub parent: std::string::String,

    /// Required. The Dataset to create.
    pub dataset: std::option::Option<crate::model::Dataset>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDatasetRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [dataset][crate::model::CreateDatasetRequest::dataset].
    pub fn set_dataset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Dataset>,
    {
        self.dataset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dataset][crate::model::CreateDatasetRequest::dataset].
    pub fn set_or_clear_dataset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Dataset>,
    {
        self.dataset = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.CreateDatasetRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __dataset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "dataset" => Ok(__FieldTag::__dataset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset",
                                ));
                            }
                            result.dataset =
                                map.next_value::<std::option::Option<crate::model::Dataset>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDatasetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.dataset.is_some() {
            state.serialize_entry("dataset", &self.dataset)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata of create dataset operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDatasetMetadata {
    /// The current state of the operation.
    pub state: crate::model::OperationState,

    /// The creation time of the operation.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The last update time of the operation.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Only populated when operation doesn't succeed.
    pub error: std::option::Option<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDatasetMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::CreateDatasetMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CreateDatasetMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CreateDatasetMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::CreateDatasetMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::CreateDatasetMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::CreateDatasetMetadata::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::CreateDatasetMetadata::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateDatasetMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.CreateDatasetMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDatasetMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __create_time,
            __update_time,
            __error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDatasetMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "error" => Ok(__FieldTag::__error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDatasetMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDatasetMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::OperationState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDatasetMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListExamples.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListExamplesRequest {
    /// Required. Name of the parent dataset. In form of
    /// `projects/{project-number-or-id}/locations/{location-id}/datasets/{dataset-id}`
    pub parent: std::string::String,

    /// Optional. An expression for filtering the examples that will be returned.
    /// Example filter:
    ///
    /// * `usage=TRAIN`
    pub filter: std::string::String,

    /// Optional. Requested page size. The server can return fewer results than
    /// requested.
    pub page_size: i32,

    /// Optional. A token identifying a page of results for the server to return.
    /// Typically obtained from next_page_token field in the response of a
    /// ListExamples call.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListExamplesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListExamplesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListExamplesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListExamplesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListExamplesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListExamplesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListExamplesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListExamplesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListExamplesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListExamplesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListExamplesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListExamplesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListExamples.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListExamplesResponse {
    /// The sentence pairs.
    pub examples: std::vec::Vec<crate::model::Example>,

    /// A token to retrieve next page of results.
    /// Pass this token to the page_token field in the ListExamplesRequest to
    /// obtain the corresponding page.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListExamplesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [examples][crate::model::ListExamplesResponse::examples].
    pub fn set_examples<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Example>,
    {
        use std::iter::Iterator;
        self.examples = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListExamplesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListExamplesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListExamplesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListExamplesResponse {
    type PageItem = crate::model::Example;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.examples
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListExamplesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __examples,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListExamplesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "examples" => Ok(__FieldTag::__examples),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListExamplesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListExamplesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__examples => {
                            if !fields.insert(__FieldTag::__examples) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for examples",
                                ));
                            }
                            result.examples = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Example>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListExamplesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.examples.is_empty() {
            state.serialize_entry("examples", &self.examples)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A sentence pair.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Example {
    /// Output only. The resource name of the example, in form of
    /// `projects/{project-number-or-id}/locations/{location_id}/datasets/{dataset_id}/examples/{example_id}`
    pub name: std::string::String,

    /// Sentence in source language.
    pub source_text: std::string::String,

    /// Sentence in target language.
    pub target_text: std::string::String,

    /// Output only. Usage of the sentence pair. Options are TRAIN|VALIDATION|TEST.
    pub usage: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Example {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Example::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source_text][crate::model::Example::source_text].
    pub fn set_source_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_text = v.into();
        self
    }

    /// Sets the value of [target_text][crate::model::Example::target_text].
    pub fn set_target_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_text = v.into();
        self
    }

    /// Sets the value of [usage][crate::model::Example::usage].
    pub fn set_usage<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.usage = v.into();
        self
    }
}

impl wkt::message::Message for Example {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.Example"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Example {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __source_text,
            __target_text,
            __usage,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Example")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "sourceText" => Ok(__FieldTag::__source_text),
                            "source_text" => Ok(__FieldTag::__source_text),
                            "targetText" => Ok(__FieldTag::__target_text),
                            "target_text" => Ok(__FieldTag::__target_text),
                            "usage" => Ok(__FieldTag::__usage),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Example;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Example")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_text => {
                            if !fields.insert(__FieldTag::__source_text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_text",
                                ));
                            }
                            result.source_text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_text => {
                            if !fields.insert(__FieldTag::__target_text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_text",
                                ));
                            }
                            result.target_text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__usage => {
                            if !fields.insert(__FieldTag::__usage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for usage",
                                ));
                            }
                            result.usage = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Example {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.source_text.is_empty() {
            state.serialize_entry("sourceText", &self.source_text)?;
        }
        if !self.target_text.is_empty() {
            state.serialize_entry("targetText", &self.target_text)?;
        }
        if !self.usage.is_empty() {
            state.serialize_entry("usage", &self.usage)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for BatchTransferResources.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchTransferResourcesResponse {
    /// Responses of the transfer for individual resources.
    pub responses:
        std::vec::Vec<crate::model::batch_transfer_resources_response::TransferResourceResponse>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchTransferResourcesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [responses][crate::model::BatchTransferResourcesResponse::responses].
    pub fn set_responses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
                crate::model::batch_transfer_resources_response::TransferResourceResponse,
            >,
    {
        use std::iter::Iterator;
        self.responses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchTransferResourcesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.BatchTransferResourcesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchTransferResourcesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __responses,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchTransferResourcesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "responses" => Ok(__FieldTag::__responses),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchTransferResourcesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchTransferResourcesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__responses => {
                            if !fields.insert(__FieldTag::__responses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for responses",
                                ));
                            }
                            result.responses = map.next_value::<std::option::Option<std::vec::Vec<crate::model::batch_transfer_resources_response::TransferResourceResponse>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchTransferResourcesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.responses.is_empty() {
            state.serialize_entry("responses", &self.responses)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BatchTransferResourcesResponse].
pub mod batch_transfer_resources_response {
    #[allow(unused_imports)]
    use super::*;

    /// Transfer response for a single resource.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TransferResourceResponse {
        /// Full name of the resource to transfer as specified in the request.
        pub source: std::string::String,

        /// Full name of the new resource successfully transferred from the source
        /// hosted by Translation API. Target will be empty if the transfer failed.
        pub target: std::string::String,

        /// The error result in case of failure.
        pub error: std::option::Option<rpc::model::Status>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TransferResourceResponse {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source][crate::model::batch_transfer_resources_response::TransferResourceResponse::source].
        pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source = v.into();
            self
        }

        /// Sets the value of [target][crate::model::batch_transfer_resources_response::TransferResourceResponse::target].
        pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.target = v.into();
            self
        }

        /// Sets the value of [error][crate::model::batch_transfer_resources_response::TransferResourceResponse::error].
        pub fn set_error<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.error = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [error][crate::model::batch_transfer_resources_response::TransferResourceResponse::error].
        pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.error = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for TransferResourceResponse {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.translation.v3.BatchTransferResourcesResponse.TransferResourceResponse"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TransferResourceResponse {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __source,
                __target,
                __error,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TransferResourceResponse")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "source" => Ok(__FieldTag::__source),
                                "target" => Ok(__FieldTag::__target),
                                "error" => Ok(__FieldTag::__error),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TransferResourceResponse;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TransferResourceResponse")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__source => {
                                if !fields.insert(__FieldTag::__source) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for source",
                                    ));
                                }
                                result.source = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__target => {
                                if !fields.insert(__FieldTag::__target) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for target",
                                    ));
                                }
                                result.target = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__error => {
                                if !fields.insert(__FieldTag::__error) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for error",
                                    ));
                                }
                                result.error =
                                    map.next_value::<std::option::Option<rpc::model::Status>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TransferResourceResponse {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.source.is_empty() {
                state.serialize_entry("source", &self.source)?;
            }
            if !self.target.is_empty() {
                state.serialize_entry("target", &self.target)?;
            }
            if self.error.is_some() {
                state.serialize_entry("error", &self.error)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// A dataset that hosts the examples (sentence pairs) used for translation
/// models.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Dataset {
    /// The resource name of the dataset, in form of
    /// `projects/{project-number-or-id}/locations/{location_id}/datasets/{dataset_id}`
    pub name: std::string::String,

    /// The name of the dataset to show in the interface. The name can be
    /// up to 32 characters long and can consist only of ASCII Latin letters A-Z
    /// and a-z, underscores (_), and ASCII digits 0-9.
    pub display_name: std::string::String,

    /// The BCP-47 language code of the source language.
    pub source_language_code: std::string::String,

    /// The BCP-47 language code of the target language.
    pub target_language_code: std::string::String,

    /// Output only. The number of examples in the dataset.
    pub example_count: i32,

    /// Output only. Number of training examples (sentence pairs).
    pub train_example_count: i32,

    /// Output only. Number of validation examples (sentence pairs).
    pub validate_example_count: i32,

    /// Output only. Number of test examples (sentence pairs).
    pub test_example_count: i32,

    /// Output only. Timestamp when this dataset was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this dataset was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Dataset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Dataset::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Dataset::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [source_language_code][crate::model::Dataset::source_language_code].
    pub fn set_source_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_language_code = v.into();
        self
    }

    /// Sets the value of [target_language_code][crate::model::Dataset::target_language_code].
    pub fn set_target_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_language_code = v.into();
        self
    }

    /// Sets the value of [example_count][crate::model::Dataset::example_count].
    pub fn set_example_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.example_count = v.into();
        self
    }

    /// Sets the value of [train_example_count][crate::model::Dataset::train_example_count].
    pub fn set_train_example_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.train_example_count = v.into();
        self
    }

    /// Sets the value of [validate_example_count][crate::model::Dataset::validate_example_count].
    pub fn set_validate_example_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.validate_example_count = v.into();
        self
    }

    /// Sets the value of [test_example_count][crate::model::Dataset::test_example_count].
    pub fn set_test_example_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.test_example_count = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Dataset::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Dataset::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Dataset::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Dataset::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Dataset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.Dataset"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Dataset {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __source_language_code,
            __target_language_code,
            __example_count,
            __train_example_count,
            __validate_example_count,
            __test_example_count,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Dataset")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "sourceLanguageCode" => Ok(__FieldTag::__source_language_code),
                            "source_language_code" => Ok(__FieldTag::__source_language_code),
                            "targetLanguageCode" => Ok(__FieldTag::__target_language_code),
                            "target_language_code" => Ok(__FieldTag::__target_language_code),
                            "exampleCount" => Ok(__FieldTag::__example_count),
                            "example_count" => Ok(__FieldTag::__example_count),
                            "trainExampleCount" => Ok(__FieldTag::__train_example_count),
                            "train_example_count" => Ok(__FieldTag::__train_example_count),
                            "validateExampleCount" => Ok(__FieldTag::__validate_example_count),
                            "validate_example_count" => Ok(__FieldTag::__validate_example_count),
                            "testExampleCount" => Ok(__FieldTag::__test_example_count),
                            "test_example_count" => Ok(__FieldTag::__test_example_count),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Dataset;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Dataset")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_language_code => {
                            if !fields.insert(__FieldTag::__source_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_language_code",
                                ));
                            }
                            result.source_language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_language_code => {
                            if !fields.insert(__FieldTag::__target_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_language_code",
                                ));
                            }
                            result.target_language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__example_count => {
                            if !fields.insert(__FieldTag::__example_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for example_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.example_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__train_example_count => {
                            if !fields.insert(__FieldTag::__train_example_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for train_example_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.train_example_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__validate_example_count => {
                            if !fields.insert(__FieldTag::__validate_example_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_example_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.validate_example_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__test_example_count => {
                            if !fields.insert(__FieldTag::__test_example_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test_example_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.test_example_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Dataset {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.source_language_code.is_empty() {
            state.serialize_entry("sourceLanguageCode", &self.source_language_code)?;
        }
        if !self.target_language_code.is_empty() {
            state.serialize_entry("targetLanguageCode", &self.target_language_code)?;
        }
        if !wkt::internal::is_default(&self.example_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("exampleCount", &__With(&self.example_count))?;
        }
        if !wkt::internal::is_default(&self.train_example_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("trainExampleCount", &__With(&self.train_example_count))?;
        }
        if !wkt::internal::is_default(&self.validate_example_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "validateExampleCount",
                &__With(&self.validate_example_count),
            )?;
        }
        if !wkt::internal::is_default(&self.test_example_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("testExampleCount", &__With(&self.test_example_count))?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for CreateModel.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateModelRequest {
    /// Required. The project name, in form of
    /// `projects/{project}/locations/{location}`
    pub parent: std::string::String,

    /// Required. The Model to create.
    pub model: std::option::Option<crate::model::Model>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateModelRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [model][crate::model::CreateModelRequest::model].
    pub fn set_model<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Model>,
    {
        self.model = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [model][crate::model::CreateModelRequest::model].
    pub fn set_or_clear_model<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Model>,
    {
        self.model = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.CreateModelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __model,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "model" => Ok(__FieldTag::__model),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model =
                                map.next_value::<std::option::Option<crate::model::Model>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.model.is_some() {
            state.serialize_entry("model", &self.model)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata of create model operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateModelMetadata {
    /// The current state of the operation.
    pub state: crate::model::OperationState,

    /// The creation time of the operation.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The last update time of the operation.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Only populated when operation doesn't succeed.
    pub error: std::option::Option<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateModelMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::CreateModelMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CreateModelMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CreateModelMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::CreateModelMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::CreateModelMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::CreateModelMetadata::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::CreateModelMetadata::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateModelMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.CreateModelMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateModelMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __create_time,
            __update_time,
            __error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateModelMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "error" => Ok(__FieldTag::__error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateModelMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateModelMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::OperationState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateModelMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListModels.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListModelsRequest {
    /// Required. Name of the parent project. In form of
    /// `projects/{project-number-or-id}/locations/{location-id}`
    pub parent: std::string::String,

    /// Optional. An expression for filtering the models that will be returned.
    /// Supported filter:
    /// `dataset_id=${dataset_id}`
    pub filter: std::string::String,

    /// Optional. Requested page size. The server can return fewer results than
    /// requested.
    pub page_size: i32,

    /// Optional. A token identifying a page of results for the server to return.
    /// Typically obtained from next_page_token field in the response of a
    /// ListModels call.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListModelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListModelsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListModelsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListModelsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListModelsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListModelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListModelsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListModelsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListModelsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListModelsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListModelsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListModelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListModels.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListModelsResponse {
    /// The models read.
    pub models: std::vec::Vec<crate::model::Model>,

    /// A token to retrieve next page of results.
    /// Pass this token to the page_token field in the ListModelsRequest to
    /// obtain the corresponding page.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListModelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [models][crate::model::ListModelsResponse::models].
    pub fn set_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Model>,
    {
        use std::iter::Iterator;
        self.models = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListModelsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListModelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListModelsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListModelsResponse {
    type PageItem = crate::model::Model;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.models
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListModelsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __models,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListModelsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "models" => Ok(__FieldTag::__models),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListModelsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListModelsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__models => {
                            if !fields.insert(__FieldTag::__models) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for models",
                                ));
                            }
                            result.models = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Model>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListModelsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.models.is_empty() {
            state.serialize_entry("models", &self.models)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetModel.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetModelRequest {
    /// Required. The resource name of the model to retrieve.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GetModelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for DeleteModel.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteModelRequest {
    /// Required. The name of the model to delete.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DeleteModelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata of delete model operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteModelMetadata {
    /// The current state of the operation.
    pub state: crate::model::OperationState,

    /// The creation time of the operation.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The last update time of the operation.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Only populated when operation doesn't succeed.
    pub error: std::option::Option<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteModelMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::DeleteModelMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::OperationState>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DeleteModelMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DeleteModelMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DeleteModelMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DeleteModelMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::DeleteModelMetadata::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::DeleteModelMetadata::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeleteModelMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DeleteModelMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteModelMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __create_time,
            __update_time,
            __error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteModelMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "error" => Ok(__FieldTag::__error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteModelMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteModelMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::OperationState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteModelMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A trained translation model.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Model {
    /// The resource name of the model, in form of
    /// `projects/{project-number-or-id}/locations/{location_id}/models/{model_id}`
    pub name: std::string::String,

    /// The name of the model to show in the interface. The name can be
    /// up to 32 characters long and can consist only of ASCII Latin letters A-Z
    /// and a-z, underscores (_), and ASCII digits 0-9.
    pub display_name: std::string::String,

    /// The dataset from which the model is trained, in form of
    /// `projects/{project-number-or-id}/locations/{location_id}/datasets/{dataset_id}`
    pub dataset: std::string::String,

    /// Output only. The BCP-47 language code of the source language.
    pub source_language_code: std::string::String,

    /// Output only. The BCP-47 language code of the target language.
    pub target_language_code: std::string::String,

    /// Output only. Number of examples (sentence pairs) used to train the model.
    pub train_example_count: i32,

    /// Output only. Number of examples (sentence pairs) used to validate the
    /// model.
    pub validate_example_count: i32,

    /// Output only. Number of examples (sentence pairs) used to test the model.
    pub test_example_count: i32,

    /// Output only. Timestamp when the model resource was created, which is also
    /// when the training started.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when this model was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Model {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Model::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Model::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [dataset][crate::model::Model::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [source_language_code][crate::model::Model::source_language_code].
    pub fn set_source_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_language_code = v.into();
        self
    }

    /// Sets the value of [target_language_code][crate::model::Model::target_language_code].
    pub fn set_target_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_language_code = v.into();
        self
    }

    /// Sets the value of [train_example_count][crate::model::Model::train_example_count].
    pub fn set_train_example_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.train_example_count = v.into();
        self
    }

    /// Sets the value of [validate_example_count][crate::model::Model::validate_example_count].
    pub fn set_validate_example_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.validate_example_count = v.into();
        self
    }

    /// Sets the value of [test_example_count][crate::model::Model::test_example_count].
    pub fn set_test_example_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.test_example_count = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Model::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Model::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Model::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Model::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Model {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.Model"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Model {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __dataset,
            __source_language_code,
            __target_language_code,
            __train_example_count,
            __validate_example_count,
            __test_example_count,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Model")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "dataset" => Ok(__FieldTag::__dataset),
                            "sourceLanguageCode" => Ok(__FieldTag::__source_language_code),
                            "source_language_code" => Ok(__FieldTag::__source_language_code),
                            "targetLanguageCode" => Ok(__FieldTag::__target_language_code),
                            "target_language_code" => Ok(__FieldTag::__target_language_code),
                            "trainExampleCount" => Ok(__FieldTag::__train_example_count),
                            "train_example_count" => Ok(__FieldTag::__train_example_count),
                            "validateExampleCount" => Ok(__FieldTag::__validate_example_count),
                            "validate_example_count" => Ok(__FieldTag::__validate_example_count),
                            "testExampleCount" => Ok(__FieldTag::__test_example_count),
                            "test_example_count" => Ok(__FieldTag::__test_example_count),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Model;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Model")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset",
                                ));
                            }
                            result.dataset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_language_code => {
                            if !fields.insert(__FieldTag::__source_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_language_code",
                                ));
                            }
                            result.source_language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_language_code => {
                            if !fields.insert(__FieldTag::__target_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_language_code",
                                ));
                            }
                            result.target_language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__train_example_count => {
                            if !fields.insert(__FieldTag::__train_example_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for train_example_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.train_example_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__validate_example_count => {
                            if !fields.insert(__FieldTag::__validate_example_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_example_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.validate_example_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__test_example_count => {
                            if !fields.insert(__FieldTag::__test_example_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test_example_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.test_example_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Model {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.dataset.is_empty() {
            state.serialize_entry("dataset", &self.dataset)?;
        }
        if !self.source_language_code.is_empty() {
            state.serialize_entry("sourceLanguageCode", &self.source_language_code)?;
        }
        if !self.target_language_code.is_empty() {
            state.serialize_entry("targetLanguageCode", &self.target_language_code)?;
        }
        if !wkt::internal::is_default(&self.train_example_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("trainExampleCount", &__With(&self.train_example_count))?;
        }
        if !wkt::internal::is_default(&self.validate_example_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "validateExampleCount",
                &__With(&self.validate_example_count),
            )?;
        }
        if !wkt::internal::is_default(&self.test_example_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("testExampleCount", &__With(&self.test_example_count))?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The Google Cloud Storage location for the input content.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsInputSource {
    /// Required. Source data URI. For example, `gs://my_bucket/my_object`.
    pub input_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsInputSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input_uri][crate::model::GcsInputSource::input_uri].
    pub fn set_input_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.input_uri = v.into();
        self
    }
}

impl wkt::message::Message for GcsInputSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GcsInputSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsInputSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __input_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsInputSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inputUri" => Ok(__FieldTag::__input_uri),
                            "input_uri" => Ok(__FieldTag::__input_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsInputSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsInputSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__input_uri => {
                            if !fields.insert(__FieldTag::__input_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_uri",
                                ));
                            }
                            result.input_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsInputSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.input_uri.is_empty() {
            state.serialize_entry("inputUri", &self.input_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An inlined file.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FileInputSource {
    /// Required. The file's mime type.
    pub mime_type: std::string::String,

    /// Required. The file's byte contents.
    pub content: ::bytes::Bytes,

    /// Required. The file's display name.
    pub display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileInputSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mime_type][crate::model::FileInputSource::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [content][crate::model::FileInputSource::content].
    pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::FileInputSource::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for FileInputSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.FileInputSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FileInputSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mime_type,
            __content,
            __display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FileInputSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            "content" => Ok(__FieldTag::__content),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FileInputSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FileInputSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mime_type",
                                ));
                            }
                            result.mime_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.content = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FileInputSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if !self.content.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("content", &__With(&self.content))?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The Google Cloud Storage location for the output content.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsOutputDestination {
    /// Required. Google Cloud Storage URI to output directory. For example,
    /// `gs://bucket/directory`. The requesting user must have write permission to
    /// the bucket. The directory will be created if it doesn't exist.
    pub output_uri_prefix: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsOutputDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_uri_prefix][crate::model::GcsOutputDestination::output_uri_prefix].
    pub fn set_output_uri_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_uri_prefix = v.into();
        self
    }
}

impl wkt::message::Message for GcsOutputDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GcsOutputDestination"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsOutputDestination {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __output_uri_prefix,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsOutputDestination")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "outputUriPrefix" => Ok(__FieldTag::__output_uri_prefix),
                            "output_uri_prefix" => Ok(__FieldTag::__output_uri_prefix),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsOutputDestination;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsOutputDestination")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__output_uri_prefix => {
                            if !fields.insert(__FieldTag::__output_uri_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_uri_prefix",
                                ));
                            }
                            result.output_uri_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsOutputDestination {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.output_uri_prefix.is_empty() {
            state.serialize_entry("outputUriPrefix", &self.output_uri_prefix)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a single entry in a glossary.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GlossaryEntry {
    /// Identifier. The resource name of the entry.
    /// Format:
    /// `projects/*/locations/*/glossaries/*/glossaryEntries/*`
    pub name: std::string::String,

    /// Describes the glossary entry.
    pub description: std::string::String,

    /// The different data for the glossary types (Unidirectional, Equivalent term
    /// sets).
    pub data: std::option::Option<crate::model::glossary_entry::Data>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GlossaryEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GlossaryEntry::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::GlossaryEntry::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [data][crate::model::GlossaryEntry::data].
    ///
    /// Note that all the setters affecting `data` are mutually
    /// exclusive.
    pub fn set_data<
        T: std::convert::Into<std::option::Option<crate::model::glossary_entry::Data>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data = v.into();
        self
    }

    /// The value of [data][crate::model::GlossaryEntry::data]
    /// if it holds a `TermsPair`, `None` if the field is not set or
    /// holds a different branch.
    pub fn terms_pair(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::glossary_entry::GlossaryTermsPair>>
    {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::glossary_entry::Data::TermsPair(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::GlossaryEntry::data]
    /// to hold a `TermsPair`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_terms_pair<
        T: std::convert::Into<std::boxed::Box<crate::model::glossary_entry::GlossaryTermsPair>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data =
            std::option::Option::Some(crate::model::glossary_entry::Data::TermsPair(v.into()));
        self
    }

    /// The value of [data][crate::model::GlossaryEntry::data]
    /// if it holds a `TermsSet`, `None` if the field is not set or
    /// holds a different branch.
    pub fn terms_set(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::glossary_entry::GlossaryTermsSet>> {
        #[allow(unreachable_patterns)]
        self.data.as_ref().and_then(|v| match v {
            crate::model::glossary_entry::Data::TermsSet(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data][crate::model::GlossaryEntry::data]
    /// to hold a `TermsSet`.
    ///
    /// Note that all the setters affecting `data` are
    /// mutually exclusive.
    pub fn set_terms_set<
        T: std::convert::Into<std::boxed::Box<crate::model::glossary_entry::GlossaryTermsSet>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data =
            std::option::Option::Some(crate::model::glossary_entry::Data::TermsSet(v.into()));
        self
    }
}

impl wkt::message::Message for GlossaryEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GlossaryEntry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GlossaryEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __terms_pair,
            __terms_set,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GlossaryEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "termsPair" => Ok(__FieldTag::__terms_pair),
                            "terms_pair" => Ok(__FieldTag::__terms_pair),
                            "termsSet" => Ok(__FieldTag::__terms_set),
                            "terms_set" => Ok(__FieldTag::__terms_set),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GlossaryEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GlossaryEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__terms_pair => {
                            if !fields.insert(__FieldTag::__terms_pair) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for terms_pair",
                                ));
                            }
                            if result.data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data`, a oneof with full ID .google.cloud.translation.v3.GlossaryEntry.terms_pair, latest field was termsPair",
                                ));
                            }
                            result.data = std::option::Option::Some(
                                crate::model::glossary_entry::Data::TermsPair(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::glossary_entry::GlossaryTermsPair,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__terms_set => {
                            if !fields.insert(__FieldTag::__terms_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for terms_set",
                                ));
                            }
                            if result.data.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data`, a oneof with full ID .google.cloud.translation.v3.GlossaryEntry.terms_set, latest field was termsSet",
                                ));
                            }
                            result.data = std::option::Option::Some(
                                crate::model::glossary_entry::Data::TermsSet(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::glossary_entry::GlossaryTermsSet,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GlossaryEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.terms_pair() {
            state.serialize_entry("termsPair", value)?;
        }
        if let Some(value) = self.terms_set() {
            state.serialize_entry("termsSet", value)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GlossaryEntry].
pub mod glossary_entry {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a single entry for an unidirectional glossary.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GlossaryTermsPair {
        /// The source term is the term that will get match in the text,
        pub source_term: std::option::Option<crate::model::GlossaryTerm>,

        /// The term that will replace the match source term.
        pub target_term: std::option::Option<crate::model::GlossaryTerm>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GlossaryTermsPair {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_term][crate::model::glossary_entry::GlossaryTermsPair::source_term].
        pub fn set_source_term<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::GlossaryTerm>,
        {
            self.source_term = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [source_term][crate::model::glossary_entry::GlossaryTermsPair::source_term].
        pub fn set_or_clear_source_term<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::GlossaryTerm>,
        {
            self.source_term = v.map(|x| x.into());
            self
        }

        /// Sets the value of [target_term][crate::model::glossary_entry::GlossaryTermsPair::target_term].
        pub fn set_target_term<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::GlossaryTerm>,
        {
            self.target_term = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [target_term][crate::model::glossary_entry::GlossaryTermsPair::target_term].
        pub fn set_or_clear_target_term<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::GlossaryTerm>,
        {
            self.target_term = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for GlossaryTermsPair {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.translation.v3.GlossaryEntry.GlossaryTermsPair"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GlossaryTermsPair {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __source_term,
                __target_term,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GlossaryTermsPair")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sourceTerm" => Ok(__FieldTag::__source_term),
                                "source_term" => Ok(__FieldTag::__source_term),
                                "targetTerm" => Ok(__FieldTag::__target_term),
                                "target_term" => Ok(__FieldTag::__target_term),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GlossaryTermsPair;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GlossaryTermsPair")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__source_term => {
                                if !fields.insert(__FieldTag::__source_term) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for source_term",
                                    ));
                                }
                                result.source_term = map
                                    .next_value::<std::option::Option<crate::model::GlossaryTerm>>(
                                    )?;
                            }
                            __FieldTag::__target_term => {
                                if !fields.insert(__FieldTag::__target_term) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for target_term",
                                    ));
                                }
                                result.target_term = map
                                    .next_value::<std::option::Option<crate::model::GlossaryTerm>>(
                                    )?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GlossaryTermsPair {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.source_term.is_some() {
                state.serialize_entry("sourceTerm", &self.source_term)?;
            }
            if self.target_term.is_some() {
                state.serialize_entry("targetTerm", &self.target_term)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Represents a single entry for an equivalent term set glossary. This is used
    /// for equivalent term sets where each term can be replaced by the other terms
    /// in the set.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GlossaryTermsSet {
        /// Each term in the set represents a term that can be replaced by the other
        /// terms.
        pub terms: std::vec::Vec<crate::model::GlossaryTerm>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GlossaryTermsSet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [terms][crate::model::glossary_entry::GlossaryTermsSet::terms].
        pub fn set_terms<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::GlossaryTerm>,
        {
            use std::iter::Iterator;
            self.terms = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for GlossaryTermsSet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.translation.v3.GlossaryEntry.GlossaryTermsSet"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GlossaryTermsSet {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __terms,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GlossaryTermsSet")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "terms" => Ok(__FieldTag::__terms),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GlossaryTermsSet;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GlossaryTermsSet")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__terms => {
                                if !fields.insert(__FieldTag::__terms) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for terms",
                                    ));
                                }
                                result.terms =
                                    map.next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::GlossaryTerm>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GlossaryTermsSet {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.terms.is_empty() {
                state.serialize_entry("terms", &self.terms)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The different data for the glossary types (Unidirectional, Equivalent term
    /// sets).
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Data {
        /// Used for an unidirectional glossary.
        TermsPair(std::boxed::Box<crate::model::glossary_entry::GlossaryTermsPair>),
        /// Used for an equivalent term sets glossary.
        TermsSet(std::boxed::Box<crate::model::glossary_entry::GlossaryTermsSet>),
    }
}

/// Represents a single glossary term
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GlossaryTerm {
    /// The language for this glossary term.
    pub language_code: std::string::String,

    /// The text for the glossary term.
    pub text: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GlossaryTerm {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [language_code][crate::model::GlossaryTerm::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [text][crate::model::GlossaryTerm::text].
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.text = v.into();
        self
    }
}

impl wkt::message::Message for GlossaryTerm {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GlossaryTerm"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GlossaryTerm {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __language_code,
            __text,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GlossaryTerm")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "text" => Ok(__FieldTag::__text),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GlossaryTerm;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GlossaryTerm")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            result.text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GlossaryTerm {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configures transliteration feature on top of translation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TransliterationConfig {
    /// If true, source text in romanized form can be translated to the target
    /// language.
    pub enable_transliteration: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TransliterationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_transliteration][crate::model::TransliterationConfig::enable_transliteration].
    pub fn set_enable_transliteration<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_transliteration = v.into();
        self
    }
}

impl wkt::message::Message for TransliterationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.TransliterationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransliterationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_transliteration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransliterationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableTransliteration" => Ok(__FieldTag::__enable_transliteration),
                            "enable_transliteration" => Ok(__FieldTag::__enable_transliteration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransliterationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransliterationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_transliteration => {
                            if !fields.insert(__FieldTag::__enable_transliteration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_transliteration",
                                ));
                            }
                            result.enable_transliteration = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TransliterationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_transliteration) {
            state.serialize_entry("enableTransliteration", &self.enable_transliteration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for synchronous translation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TranslateTextRequest {
    /// Required. The content of the input in string format.
    /// We recommend the total content be less than 30,000 codepoints. The max
    /// length of this field is 1024. Use BatchTranslateText for larger text.
    pub contents: std::vec::Vec<std::string::String>,

    /// Optional. The format of the source text, for example, "text/html",
    /// "text/plain". If left blank, the MIME type defaults to "text/html".
    pub mime_type: std::string::String,

    /// Optional. The ISO-639 language code of the input text if
    /// known, for example, "en-US" or "sr-Latn". Supported language codes are
    /// listed in [Language
    /// Support](https://cloud.google.com/translate/docs/languages). If the source
    /// language isn't specified, the API attempts to identify the source language
    /// automatically and returns the source language within the response.
    pub source_language_code: std::string::String,

    /// Required. The ISO-639 language code to use for translation of the input
    /// text, set to one of the language codes listed in [Language
    /// Support](https://cloud.google.com/translate/docs/languages).
    pub target_language_code: std::string::String,

    /// Required. Project or location to make a call. Must refer to a caller's
    /// project.
    ///
    /// Format: `projects/{project-number-or-id}` or
    /// `projects/{project-number-or-id}/locations/{location-id}`.
    ///
    /// For global calls, use `projects/{project-number-or-id}/locations/global` or
    /// `projects/{project-number-or-id}`.
    ///
    /// Non-global location is required for requests using AutoML models or
    /// custom glossaries.
    ///
    /// Models and glossaries must be within the same region (have same
    /// location-id), otherwise an INVALID_ARGUMENT (400) error is returned.
    pub parent: std::string::String,

    /// Optional. The `model` type requested for this translation.
    ///
    /// The format depends on model type:
    ///
    /// - AutoML Translation models:
    ///   `projects/{project-number-or-id}/locations/{location-id}/models/{model-id}`
    ///
    /// - General (built-in) models:
    ///   `projects/{project-number-or-id}/locations/{location-id}/models/general/nmt`,
    ///
    /// - Translation LLM models:
    ///   `projects/{project-number-or-id}/locations/{location-id}/models/general/translation-llm`,
    ///
    ///
    /// For global (non-regionalized) requests, use `location-id` `global`.
    /// For example,
    /// `projects/{project-number-or-id}/locations/global/models/general/nmt`.
    ///
    /// If not provided, the default Google model (NMT) will be used
    pub model: std::string::String,

    /// Optional. Glossary to be applied. The glossary must be
    /// within the same region (have the same location-id) as the model, otherwise
    /// an INVALID_ARGUMENT (400) error is returned.
    pub glossary_config: std::option::Option<crate::model::TranslateTextGlossaryConfig>,

    /// Optional. Transliteration to be applied.
    pub transliteration_config: std::option::Option<crate::model::TransliterationConfig>,

    /// Optional. The labels with user-defined metadata for the request.
    ///
    /// Label keys and values can be no longer than 63 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label values are optional. Label keys must start with a letter.
    ///
    /// See <https://cloud.google.com/translate/docs/advanced/labels> for more
    /// information.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TranslateTextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [contents][crate::model::TranslateTextRequest::contents].
    pub fn set_contents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.contents = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [mime_type][crate::model::TranslateTextRequest::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [source_language_code][crate::model::TranslateTextRequest::source_language_code].
    pub fn set_source_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_language_code = v.into();
        self
    }

    /// Sets the value of [target_language_code][crate::model::TranslateTextRequest::target_language_code].
    pub fn set_target_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_language_code = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::TranslateTextRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [model][crate::model::TranslateTextRequest::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [glossary_config][crate::model::TranslateTextRequest::glossary_config].
    pub fn set_glossary_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TranslateTextGlossaryConfig>,
    {
        self.glossary_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [glossary_config][crate::model::TranslateTextRequest::glossary_config].
    pub fn set_or_clear_glossary_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TranslateTextGlossaryConfig>,
    {
        self.glossary_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transliteration_config][crate::model::TranslateTextRequest::transliteration_config].
    pub fn set_transliteration_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransliterationConfig>,
    {
        self.transliteration_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transliteration_config][crate::model::TranslateTextRequest::transliteration_config].
    pub fn set_or_clear_transliteration_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransliterationConfig>,
    {
        self.transliteration_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::TranslateTextRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for TranslateTextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.TranslateTextRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TranslateTextRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __contents,
            __mime_type,
            __source_language_code,
            __target_language_code,
            __parent,
            __model,
            __glossary_config,
            __transliteration_config,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TranslateTextRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "contents" => Ok(__FieldTag::__contents),
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            "sourceLanguageCode" => Ok(__FieldTag::__source_language_code),
                            "source_language_code" => Ok(__FieldTag::__source_language_code),
                            "targetLanguageCode" => Ok(__FieldTag::__target_language_code),
                            "target_language_code" => Ok(__FieldTag::__target_language_code),
                            "parent" => Ok(__FieldTag::__parent),
                            "model" => Ok(__FieldTag::__model),
                            "glossaryConfig" => Ok(__FieldTag::__glossary_config),
                            "glossary_config" => Ok(__FieldTag::__glossary_config),
                            "transliterationConfig" => Ok(__FieldTag::__transliteration_config),
                            "transliteration_config" => Ok(__FieldTag::__transliteration_config),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TranslateTextRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TranslateTextRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__contents => {
                            if !fields.insert(__FieldTag::__contents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contents",
                                ));
                            }
                            result.contents = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mime_type",
                                ));
                            }
                            result.mime_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_language_code => {
                            if !fields.insert(__FieldTag::__source_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_language_code",
                                ));
                            }
                            result.source_language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_language_code => {
                            if !fields.insert(__FieldTag::__target_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_language_code",
                                ));
                            }
                            result.target_language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__glossary_config => {
                            if !fields.insert(__FieldTag::__glossary_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for glossary_config",
                                ));
                            }
                            result.glossary_config = map.next_value::<std::option::Option<crate::model::TranslateTextGlossaryConfig>>()?
                                ;
                        }
                        __FieldTag::__transliteration_config => {
                            if !fields.insert(__FieldTag::__transliteration_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transliteration_config",
                                ));
                            }
                            result.transliteration_config = map.next_value::<std::option::Option<crate::model::TransliterationConfig>>()?
                                ;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TranslateTextRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.contents.is_empty() {
            state.serialize_entry("contents", &self.contents)?;
        }
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if !self.source_language_code.is_empty() {
            state.serialize_entry("sourceLanguageCode", &self.source_language_code)?;
        }
        if !self.target_language_code.is_empty() {
            state.serialize_entry("targetLanguageCode", &self.target_language_code)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if self.glossary_config.is_some() {
            state.serialize_entry("glossaryConfig", &self.glossary_config)?;
        }
        if self.transliteration_config.is_some() {
            state.serialize_entry("transliterationConfig", &self.transliteration_config)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TranslateTextResponse {
    /// Text translation responses with no glossary applied.
    /// This field has the same length as
    /// [`contents`][google.cloud.translation.v3.TranslateTextRequest.contents].
    ///
    /// [google.cloud.translation.v3.TranslateTextRequest.contents]: crate::model::TranslateTextRequest::contents
    pub translations: std::vec::Vec<crate::model::Translation>,

    /// Text translation responses if a glossary is provided in the request.
    /// This can be the same as
    /// [`translations`][google.cloud.translation.v3.TranslateTextResponse.translations]
    /// if no terms apply. This field has the same length as
    /// [`contents`][google.cloud.translation.v3.TranslateTextRequest.contents].
    ///
    /// [google.cloud.translation.v3.TranslateTextRequest.contents]: crate::model::TranslateTextRequest::contents
    /// [google.cloud.translation.v3.TranslateTextResponse.translations]: crate::model::TranslateTextResponse::translations
    pub glossary_translations: std::vec::Vec<crate::model::Translation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TranslateTextResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [translations][crate::model::TranslateTextResponse::translations].
    pub fn set_translations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Translation>,
    {
        use std::iter::Iterator;
        self.translations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [glossary_translations][crate::model::TranslateTextResponse::glossary_translations].
    pub fn set_glossary_translations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Translation>,
    {
        use std::iter::Iterator;
        self.glossary_translations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TranslateTextResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.TranslateTextResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TranslateTextResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __translations,
            __glossary_translations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TranslateTextResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "translations" => Ok(__FieldTag::__translations),
                            "glossaryTranslations" => Ok(__FieldTag::__glossary_translations),
                            "glossary_translations" => Ok(__FieldTag::__glossary_translations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TranslateTextResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TranslateTextResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__translations => {
                            if !fields.insert(__FieldTag::__translations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for translations",
                                ));
                            }
                            result.translations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Translation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__glossary_translations => {
                            if !fields.insert(__FieldTag::__glossary_translations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for glossary_translations",
                                ));
                            }
                            result.glossary_translations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Translation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TranslateTextResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.translations.is_empty() {
            state.serialize_entry("translations", &self.translations)?;
        }
        if !self.glossary_translations.is_empty() {
            state.serialize_entry("glossaryTranslations", &self.glossary_translations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A single translation response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Translation {
    /// Text translated into the target language.
    /// If an error occurs during translation, this field might be excluded from
    /// the response.
    pub translated_text: std::string::String,

    /// Only present when `model` is present in the request.
    /// `model` here is normalized to have project number.
    ///
    /// For example:
    /// If the `model` requested in TranslationTextRequest is
    /// `projects/{project-id}/locations/{location-id}/models/general/nmt` then
    /// `model` here would be normalized to
    /// `projects/{project-number}/locations/{location-id}/models/general/nmt`.
    pub model: std::string::String,

    /// The ISO-639 language code of source text in the initial request, detected
    /// automatically, if no source language was passed within the initial
    /// request. If the source language was passed, auto-detection of the language
    /// does not occur and this field is empty.
    pub detected_language_code: std::string::String,

    /// The `glossary_config` used for this translation.
    pub glossary_config: std::option::Option<crate::model::TranslateTextGlossaryConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Translation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [translated_text][crate::model::Translation::translated_text].
    pub fn set_translated_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.translated_text = v.into();
        self
    }

    /// Sets the value of [model][crate::model::Translation::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [detected_language_code][crate::model::Translation::detected_language_code].
    pub fn set_detected_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.detected_language_code = v.into();
        self
    }

    /// Sets the value of [glossary_config][crate::model::Translation::glossary_config].
    pub fn set_glossary_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TranslateTextGlossaryConfig>,
    {
        self.glossary_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [glossary_config][crate::model::Translation::glossary_config].
    pub fn set_or_clear_glossary_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TranslateTextGlossaryConfig>,
    {
        self.glossary_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Translation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.Translation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Translation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __translated_text,
            __model,
            __detected_language_code,
            __glossary_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Translation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "translatedText" => Ok(__FieldTag::__translated_text),
                            "translated_text" => Ok(__FieldTag::__translated_text),
                            "model" => Ok(__FieldTag::__model),
                            "detectedLanguageCode" => Ok(__FieldTag::__detected_language_code),
                            "detected_language_code" => Ok(__FieldTag::__detected_language_code),
                            "glossaryConfig" => Ok(__FieldTag::__glossary_config),
                            "glossary_config" => Ok(__FieldTag::__glossary_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Translation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Translation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__translated_text => {
                            if !fields.insert(__FieldTag::__translated_text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for translated_text",
                                ));
                            }
                            result.translated_text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__detected_language_code => {
                            if !fields.insert(__FieldTag::__detected_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detected_language_code",
                                ));
                            }
                            result.detected_language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__glossary_config => {
                            if !fields.insert(__FieldTag::__glossary_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for glossary_config",
                                ));
                            }
                            result.glossary_config = map.next_value::<std::option::Option<crate::model::TranslateTextGlossaryConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Translation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.translated_text.is_empty() {
            state.serialize_entry("translatedText", &self.translated_text)?;
        }
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if !self.detected_language_code.is_empty() {
            state.serialize_entry("detectedLanguageCode", &self.detected_language_code)?;
        }
        if self.glossary_config.is_some() {
            state.serialize_entry("glossaryConfig", &self.glossary_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for synchronous romanization.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RomanizeTextRequest {
    /// Required. Project or location to make a call. Must refer to a caller's
    /// project.
    ///
    /// Format: `projects/{project-number-or-id}/locations/{location-id}` or
    /// `projects/{project-number-or-id}`.
    ///
    /// For global calls, use `projects/{project-number-or-id}/locations/global` or
    /// `projects/{project-number-or-id}`.
    pub parent: std::string::String,

    /// Required. The content of the input in string format.
    pub contents: std::vec::Vec<std::string::String>,

    /// Optional. The ISO-639 language code of the input text if
    /// known, for example, "hi" or "zh". Supported language codes are
    /// listed in [Language
    /// Support](https://cloud.google.com/translate/docs/languages#roman). If the
    /// source language isn't specified, the API attempts to identify the source
    /// language automatically and returns the source language for each content in
    /// the response.
    pub source_language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RomanizeTextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::RomanizeTextRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [contents][crate::model::RomanizeTextRequest::contents].
    pub fn set_contents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.contents = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [source_language_code][crate::model::RomanizeTextRequest::source_language_code].
    pub fn set_source_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_language_code = v.into();
        self
    }
}

impl wkt::message::Message for RomanizeTextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.RomanizeTextRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RomanizeTextRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __contents,
            __source_language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RomanizeTextRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "contents" => Ok(__FieldTag::__contents),
                            "sourceLanguageCode" => Ok(__FieldTag::__source_language_code),
                            "source_language_code" => Ok(__FieldTag::__source_language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RomanizeTextRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RomanizeTextRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__contents => {
                            if !fields.insert(__FieldTag::__contents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contents",
                                ));
                            }
                            result.contents = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__source_language_code => {
                            if !fields.insert(__FieldTag::__source_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_language_code",
                                ));
                            }
                            result.source_language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RomanizeTextRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.contents.is_empty() {
            state.serialize_entry("contents", &self.contents)?;
        }
        if !self.source_language_code.is_empty() {
            state.serialize_entry("sourceLanguageCode", &self.source_language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A single romanization response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Romanization {
    /// Romanized text.
    /// If an error occurs during romanization, this field might be excluded from
    /// the response.
    pub romanized_text: std::string::String,

    /// The ISO-639 language code of source text in the initial request, detected
    /// automatically, if no source language was passed within the initial
    /// request. If the source language was passed, auto-detection of the language
    /// does not occur and this field is empty.
    pub detected_language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Romanization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [romanized_text][crate::model::Romanization::romanized_text].
    pub fn set_romanized_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.romanized_text = v.into();
        self
    }

    /// Sets the value of [detected_language_code][crate::model::Romanization::detected_language_code].
    pub fn set_detected_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.detected_language_code = v.into();
        self
    }
}

impl wkt::message::Message for Romanization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.Romanization"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Romanization {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __romanized_text,
            __detected_language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Romanization")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "romanizedText" => Ok(__FieldTag::__romanized_text),
                            "romanized_text" => Ok(__FieldTag::__romanized_text),
                            "detectedLanguageCode" => Ok(__FieldTag::__detected_language_code),
                            "detected_language_code" => Ok(__FieldTag::__detected_language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Romanization;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Romanization")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__romanized_text => {
                            if !fields.insert(__FieldTag::__romanized_text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for romanized_text",
                                ));
                            }
                            result.romanized_text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__detected_language_code => {
                            if !fields.insert(__FieldTag::__detected_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detected_language_code",
                                ));
                            }
                            result.detected_language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Romanization {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.romanized_text.is_empty() {
            state.serialize_entry("romanizedText", &self.romanized_text)?;
        }
        if !self.detected_language_code.is_empty() {
            state.serialize_entry("detectedLanguageCode", &self.detected_language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for synchronous romanization.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RomanizeTextResponse {
    /// Text romanization responses.
    /// This field has the same length as
    /// [`contents`][google.cloud.translation.v3.RomanizeTextRequest.contents].
    ///
    /// [google.cloud.translation.v3.RomanizeTextRequest.contents]: crate::model::RomanizeTextRequest::contents
    pub romanizations: std::vec::Vec<crate::model::Romanization>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RomanizeTextResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [romanizations][crate::model::RomanizeTextResponse::romanizations].
    pub fn set_romanizations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Romanization>,
    {
        use std::iter::Iterator;
        self.romanizations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RomanizeTextResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.RomanizeTextResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RomanizeTextResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __romanizations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RomanizeTextResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "romanizations" => Ok(__FieldTag::__romanizations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RomanizeTextResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RomanizeTextResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__romanizations => {
                            if !fields.insert(__FieldTag::__romanizations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for romanizations",
                                ));
                            }
                            result.romanizations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Romanization>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RomanizeTextResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.romanizations.is_empty() {
            state.serialize_entry("romanizations", &self.romanizations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for language detection.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DetectLanguageRequest {
    /// Required. Project or location to make a call. Must refer to a caller's
    /// project.
    ///
    /// Format: `projects/{project-number-or-id}/locations/{location-id}` or
    /// `projects/{project-number-or-id}`.
    ///
    /// For global calls, use `projects/{project-number-or-id}/locations/global` or
    /// `projects/{project-number-or-id}`.
    ///
    /// Only models within the same region (has same location-id) can be used.
    /// Otherwise an INVALID_ARGUMENT (400) error is returned.
    pub parent: std::string::String,

    /// Optional. The language detection model to be used.
    ///
    /// Format:
    /// `projects/{project-number-or-id}/locations/{location-id}/models/language-detection/{model-id}`
    ///
    /// Only one language detection model is currently supported:
    /// `projects/{project-number-or-id}/locations/{location-id}/models/language-detection/default`.
    ///
    /// If not specified, the default model is used.
    pub model: std::string::String,

    /// Optional. The format of the source text, for example, "text/html",
    /// "text/plain". If left blank, the MIME type defaults to "text/html".
    pub mime_type: std::string::String,

    /// Optional. The labels with user-defined metadata for the request.
    ///
    /// Label keys and values can be no longer than 63 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label values are optional. Label keys must start with a letter.
    ///
    /// See <https://cloud.google.com/translate/docs/advanced/labels> for more
    /// information.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. The source of the document from which to detect the language.
    pub source: std::option::Option<crate::model::detect_language_request::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DetectLanguageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::DetectLanguageRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [model][crate::model::DetectLanguageRequest::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [mime_type][crate::model::DetectLanguageRequest::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::DetectLanguageRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [source][crate::model::DetectLanguageRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::detect_language_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::DetectLanguageRequest::source]
    /// if it holds a `Content`, `None` if the field is not set or
    /// holds a different branch.
    pub fn content(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::detect_language_request::Source::Content(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::DetectLanguageRequest::source]
    /// to hold a `Content`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::detect_language_request::Source::Content(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DetectLanguageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DetectLanguageRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DetectLanguageRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __model,
            __content,
            __mime_type,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DetectLanguageRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "model" => Ok(__FieldTag::__model),
                            "content" => Ok(__FieldTag::__content),
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DetectLanguageRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DetectLanguageRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.translation.v3.DetectLanguageRequest.content, latest field was content",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::detect_language_request::Source::Content(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mime_type",
                                ));
                            }
                            result.mime_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DetectLanguageRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if let Some(value) = self.content() {
            state.serialize_entry("content", value)?;
        }
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DetectLanguageRequest].
pub mod detect_language_request {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The source of the document from which to detect the language.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// The content of the input stored as a string.
        Content(std::string::String),
    }
}

/// The response message for language detection.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DetectedLanguage {
    /// The ISO-639 language code of the source content in the request, detected
    /// automatically.
    pub language_code: std::string::String,

    /// The confidence of the detection result for this language.
    pub confidence: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DetectedLanguage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [language_code][crate::model::DetectedLanguage::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::DetectedLanguage::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

impl wkt::message::Message for DetectedLanguage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DetectedLanguage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DetectedLanguage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __language_code,
            __confidence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DetectedLanguage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "confidence" => Ok(__FieldTag::__confidence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DetectedLanguage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DetectedLanguage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DetectedLanguage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for language detection.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DetectLanguageResponse {
    /// The most probable language detected by the Translation API. For each
    /// request, the Translation API will always return only one result.
    pub languages: std::vec::Vec<crate::model::DetectedLanguage>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DetectLanguageResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [languages][crate::model::DetectLanguageResponse::languages].
    pub fn set_languages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DetectedLanguage>,
    {
        use std::iter::Iterator;
        self.languages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DetectLanguageResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DetectLanguageResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DetectLanguageResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __languages,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DetectLanguageResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "languages" => Ok(__FieldTag::__languages),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DetectLanguageResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DetectLanguageResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__languages => {
                            if !fields.insert(__FieldTag::__languages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for languages",
                                ));
                            }
                            result.languages =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DetectedLanguage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DetectLanguageResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.languages.is_empty() {
            state.serialize_entry("languages", &self.languages)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for discovering supported languages.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSupportedLanguagesRequest {
    /// Required. Project or location to make a call. Must refer to a caller's
    /// project.
    ///
    /// Format: `projects/{project-number-or-id}` or
    /// `projects/{project-number-or-id}/locations/{location-id}`.
    ///
    /// For global calls, use `projects/{project-number-or-id}/locations/global` or
    /// `projects/{project-number-or-id}`.
    ///
    /// Non-global location is required for AutoML models.
    ///
    /// Only models within the same region (have same location-id) can be used,
    /// otherwise an INVALID_ARGUMENT (400) error is returned.
    pub parent: std::string::String,

    /// Optional. The language to use to return localized, human readable names
    /// of supported languages. If missing, then display names are not returned
    /// in a response.
    pub display_language_code: std::string::String,

    /// Optional. Get supported languages of this model.
    ///
    /// The format depends on model type:
    ///
    /// - AutoML Translation models:
    ///   `projects/{project-number-or-id}/locations/{location-id}/models/{model-id}`
    ///
    /// - General (built-in) models:
    ///   `projects/{project-number-or-id}/locations/{location-id}/models/general/nmt`,
    ///
    ///
    /// Returns languages supported by the specified model.
    /// If missing, we get supported languages of Google general NMT model.
    pub model: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSupportedLanguagesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::GetSupportedLanguagesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [display_language_code][crate::model::GetSupportedLanguagesRequest::display_language_code].
    pub fn set_display_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.display_language_code = v.into();
        self
    }

    /// Sets the value of [model][crate::model::GetSupportedLanguagesRequest::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }
}

impl wkt::message::Message for GetSupportedLanguagesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GetSupportedLanguagesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSupportedLanguagesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __display_language_code,
            __model,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSupportedLanguagesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "displayLanguageCode" => Ok(__FieldTag::__display_language_code),
                            "display_language_code" => Ok(__FieldTag::__display_language_code),
                            "model" => Ok(__FieldTag::__model),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSupportedLanguagesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSupportedLanguagesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_language_code => {
                            if !fields.insert(__FieldTag::__display_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_language_code",
                                ));
                            }
                            result.display_language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSupportedLanguagesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.display_language_code.is_empty() {
            state.serialize_entry("displayLanguageCode", &self.display_language_code)?;
        }
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for discovering supported languages.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SupportedLanguages {
    /// A list of supported language responses. This list contains an entry
    /// for each language the Translation API supports.
    pub languages: std::vec::Vec<crate::model::SupportedLanguage>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SupportedLanguages {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [languages][crate::model::SupportedLanguages::languages].
    pub fn set_languages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SupportedLanguage>,
    {
        use std::iter::Iterator;
        self.languages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SupportedLanguages {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.SupportedLanguages"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SupportedLanguages {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __languages,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SupportedLanguages")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "languages" => Ok(__FieldTag::__languages),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SupportedLanguages;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SupportedLanguages")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__languages => {
                            if !fields.insert(__FieldTag::__languages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for languages",
                                ));
                            }
                            result.languages =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SupportedLanguage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SupportedLanguages {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.languages.is_empty() {
            state.serialize_entry("languages", &self.languages)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A single supported language response corresponds to information related
/// to one supported language.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SupportedLanguage {
    /// Supported language code, generally consisting of its ISO 639-1
    /// identifier, for example, 'en', 'ja'. In certain cases, ISO-639 codes
    /// including language and region identifiers are returned (for example,
    /// 'zh-TW' and 'zh-CN').
    pub language_code: std::string::String,

    /// Human-readable name of the language localized in the display language
    /// specified in the request.
    pub display_name: std::string::String,

    /// Can be used as a source language.
    pub support_source: bool,

    /// Can be used as a target language.
    pub support_target: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SupportedLanguage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [language_code][crate::model::SupportedLanguage::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::SupportedLanguage::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [support_source][crate::model::SupportedLanguage::support_source].
    pub fn set_support_source<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.support_source = v.into();
        self
    }

    /// Sets the value of [support_target][crate::model::SupportedLanguage::support_target].
    pub fn set_support_target<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.support_target = v.into();
        self
    }
}

impl wkt::message::Message for SupportedLanguage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.SupportedLanguage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SupportedLanguage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __language_code,
            __display_name,
            __support_source,
            __support_target,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SupportedLanguage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "supportSource" => Ok(__FieldTag::__support_source),
                            "support_source" => Ok(__FieldTag::__support_source),
                            "supportTarget" => Ok(__FieldTag::__support_target),
                            "support_target" => Ok(__FieldTag::__support_target),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SupportedLanguage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SupportedLanguage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__support_source => {
                            if !fields.insert(__FieldTag::__support_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for support_source",
                                ));
                            }
                            result.support_source = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__support_target => {
                            if !fields.insert(__FieldTag::__support_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for support_target",
                                ));
                            }
                            result.support_target = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SupportedLanguage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.support_source) {
            state.serialize_entry("supportSource", &self.support_source)?;
        }
        if !wkt::internal::is_default(&self.support_target) {
            state.serialize_entry("supportTarget", &self.support_target)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The Google Cloud Storage location for the input content.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsSource {
    /// Required. Source data URI. For example, `gs://my_bucket/my_object`.
    pub input_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input_uri][crate::model::GcsSource::input_uri].
    pub fn set_input_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.input_uri = v.into();
        self
    }
}

impl wkt::message::Message for GcsSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GcsSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __input_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inputUri" => Ok(__FieldTag::__input_uri),
                            "input_uri" => Ok(__FieldTag::__input_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__input_uri => {
                            if !fields.insert(__FieldTag::__input_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_uri",
                                ));
                            }
                            result.input_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.input_uri.is_empty() {
            state.serialize_entry("inputUri", &self.input_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Input configuration for BatchTranslateText request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InputConfig {
    /// Optional. Can be "text/plain" or "text/html".
    /// For `.tsv`, "text/html" is used if mime_type is missing.
    /// For `.html`, this field must be "text/html" or empty.
    /// For `.txt`, this field must be "text/plain" or empty.
    pub mime_type: std::string::String,

    /// Required. Specify the input.
    pub source: std::option::Option<crate::model::input_config::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mime_type][crate::model::InputConfig::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [source][crate::model::InputConfig::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::input_config::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::InputConfig::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::input_config::Source::GcsSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::InputConfig::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::input_config::Source::GcsSource(v.into()));
        self
    }
}

impl wkt::message::Message for InputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.InputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mime_type,
            __gcs_source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            "gcsSource" => Ok(__FieldTag::__gcs_source),
                            "gcs_source" => Ok(__FieldTag::__gcs_source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mime_type",
                                ));
                            }
                            result.mime_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcs_source => {
                            if !fields.insert(__FieldTag::__gcs_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.translation.v3.InputConfig.gcs_source, latest field was gcsSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::input_config::Source::GcsSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if let Some(value) = self.gcs_source() {
            state.serialize_entry("gcsSource", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [InputConfig].
pub mod input_config {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Specify the input.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Required. Google Cloud Storage location for the source input.
        /// This can be a single file (for example,
        /// `gs://translation-test/input.tsv`) or a wildcard (for example,
        /// `gs://translation-test/*`). If a file extension is `.tsv`, it can
        /// contain either one or two columns. The first column (optional) is the id
        /// of the text request. If the first column is missing, we use the row
        /// number (0-based) from the input file as the ID in the output file. The
        /// second column is the actual text to be
        /// translated. We recommend each row be <= 10K Unicode codepoints,
        /// otherwise an error might be returned.
        /// Note that the input tsv must be RFC 4180 compliant.
        ///
        /// You could use <https://github.com/Clever/csvlint> to check potential
        /// formatting errors in your tsv file.
        /// csvlint --delimiter='\t' your_input_file.tsv
        ///
        /// The other supported file extensions are `.txt` or `.html`, which is
        /// treated as a single large chunk of text.
        GcsSource(std::boxed::Box<crate::model::GcsSource>),
    }
}

/// The Google Cloud Storage location for the output content.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsDestination {
    /// Required. The bucket used in 'output_uri_prefix' must exist and there must
    /// be no files under 'output_uri_prefix'. 'output_uri_prefix' must end with
    /// "/" and start with "gs://". One 'output_uri_prefix' can only be used by one
    /// batch translation job at a time. Otherwise an INVALID_ARGUMENT (400) error
    /// is returned.
    pub output_uri_prefix: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_uri_prefix][crate::model::GcsDestination::output_uri_prefix].
    pub fn set_output_uri_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_uri_prefix = v.into();
        self
    }
}

impl wkt::message::Message for GcsDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GcsDestination"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsDestination {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __output_uri_prefix,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsDestination")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "outputUriPrefix" => Ok(__FieldTag::__output_uri_prefix),
                            "output_uri_prefix" => Ok(__FieldTag::__output_uri_prefix),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsDestination;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsDestination")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__output_uri_prefix => {
                            if !fields.insert(__FieldTag::__output_uri_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_uri_prefix",
                                ));
                            }
                            result.output_uri_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsDestination {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.output_uri_prefix.is_empty() {
            state.serialize_entry("outputUriPrefix", &self.output_uri_prefix)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Output configuration for BatchTranslateText request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OutputConfig {
    /// Required. The destination of output.
    pub destination: std::option::Option<crate::model::output_config::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OutputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination][crate::model::OutputConfig::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::output_config::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::OutputConfig::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::output_config::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::OutputConfig::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::output_config::Destination::GcsDestination(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OutputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.OutputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OutputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_destination,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OutputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsDestination" => Ok(__FieldTag::__gcs_destination),
                            "gcs_destination" => Ok(__FieldTag::__gcs_destination),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OutputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OutputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_destination => {
                            if !fields.insert(__FieldTag::__gcs_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_destination",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.translation.v3.OutputConfig.gcs_destination, latest field was gcsDestination",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::output_config::Destination::GcsDestination(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsDestination>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OutputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_destination() {
            state.serialize_entry("gcsDestination", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [OutputConfig].
pub mod output_config {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The destination of output.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Google Cloud Storage destination for output content.
        /// For every single input file (for example, gs://a/b/c.[extension]), we
        /// generate at most 2 * n output files. (n is the # of target_language_codes
        /// in the BatchTranslateTextRequest).
        ///
        /// Output files (tsv) generated are compliant with RFC 4180 except that
        /// record delimiters are '\n' instead of '\r\n'. We don't provide any way to
        /// change record delimiters.
        ///
        /// While the input files are being processed, we write/update an index file
        /// 'index.csv'  under 'output_uri_prefix' (for example,
        /// gs://translation-test/index.csv) The index file is generated/updated as
        /// new files are being translated. The format is:
        ///
        /// input_file,target_language_code,translations_file,errors_file,
        /// glossary_translations_file,glossary_errors_file
        ///
        /// input_file is one file we matched using gcs_source.input_uri.
        /// target_language_code is provided in the request.
        /// translations_file contains the translations. (details provided below)
        /// errors_file contains the errors during processing of the file. (details
        /// below). Both translations_file and errors_file could be empty
        /// strings if we have no content to output.
        /// glossary_translations_file and glossary_errors_file are always empty
        /// strings if the input_file is tsv. They could also be empty if we have no
        /// content to output.
        ///
        /// Once a row is present in index.csv, the input/output matching never
        /// changes. Callers should also expect all the content in input_file are
        /// processed and ready to be consumed (that is, no partial output file is
        /// written).
        ///
        /// Since index.csv will be keeping updated during the process, please make
        /// sure there is no custom retention policy applied on the output bucket
        /// that may avoid file updating.
        /// (<https://cloud.google.com/storage/docs/bucket-lock#retention-policy>)
        ///
        /// The format of translations_file (for target language code 'trg') is:
        /// `gs://translation_test/a_b_c_'trg'_translations.[extension]`
        ///
        /// If the input file extension is tsv, the output has the following
        /// columns:
        /// Column 1: ID of the request provided in the input, if it's not
        /// provided in the input, then the input row number is used (0-based).
        /// Column 2: source sentence.
        /// Column 3: translation without applying a glossary. Empty string if there
        /// is an error.
        /// Column 4 (only present if a glossary is provided in the request):
        /// translation after applying the glossary. Empty string if there is an
        /// error applying the glossary. Could be same string as column 3 if there is
        /// no glossary applied.
        ///
        /// If input file extension is a txt or html, the translation is directly
        /// written to the output file. If glossary is requested, a separate
        /// glossary_translations_file has format of
        /// `gs://translation_test/a_b_c_'trg'_glossary_translations.[extension]`
        ///
        /// The format of errors file (for target language code 'trg') is:
        /// `gs://translation_test/a_b_c_'trg'_errors.[extension]`
        ///
        /// If the input file extension is tsv, errors_file contains the following:
        /// Column 1: ID of the request provided in the input, if it's not
        /// provided in the input, then the input row number is used (0-based).
        /// Column 2: source sentence.
        /// Column 3: Error detail for the translation. Could be empty.
        /// Column 4 (only present if a glossary is provided in the request):
        /// Error when applying the glossary.
        ///
        /// If the input file extension is txt or html, glossary_error_file will be
        /// generated that contains error details. glossary_error_file has format of
        /// `gs://translation_test/a_b_c_'trg'_glossary_errors.[extension]`
        GcsDestination(std::boxed::Box<crate::model::GcsDestination>),
    }
}

/// A document translation request input config.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DocumentInputConfig {
    /// Specifies the input document's mime_type.
    ///
    /// If not specified it will be determined using the file extension for
    /// gcs_source provided files. For a file provided through bytes content the
    /// mime_type must be provided.
    /// Currently supported mime types are:
    ///
    /// - application/pdf
    /// - application/vnd.openxmlformats-officedocument.wordprocessingml.document
    /// - application/vnd.openxmlformats-officedocument.presentationml.presentation
    /// - application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
    pub mime_type: std::string::String,

    /// Specifies the source for the document's content.
    /// The input file size should be <= 20MB for
    ///
    /// - application/vnd.openxmlformats-officedocument.wordprocessingml.document
    /// - application/vnd.openxmlformats-officedocument.presentationml.presentation
    /// - application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
    ///   The input file size should be <= 20MB and the maximum page limit is 20 for
    /// - application/pdf
    pub source: std::option::Option<crate::model::document_input_config::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DocumentInputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mime_type][crate::model::DocumentInputConfig::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [source][crate::model::DocumentInputConfig::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::document_input_config::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::DocumentInputConfig::source]
    /// if it holds a `Content`, `None` if the field is not set or
    /// holds a different branch.
    pub fn content(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::document_input_config::Source::Content(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::DocumentInputConfig::source]
    /// to hold a `Content`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::document_input_config::Source::Content(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::DocumentInputConfig::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::document_input_config::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::DocumentInputConfig::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::document_input_config::Source::GcsSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DocumentInputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DocumentInputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DocumentInputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __content,
            __gcs_source,
            __mime_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DocumentInputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "content" => Ok(__FieldTag::__content),
                            "gcsSource" => Ok(__FieldTag::__gcs_source),
                            "gcs_source" => Ok(__FieldTag::__gcs_source),
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DocumentInputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DocumentInputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.translation.v3.DocumentInputConfig.content, latest field was content",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::document_input_config::Source::Content(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__gcs_source => {
                            if !fields.insert(__FieldTag::__gcs_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.translation.v3.DocumentInputConfig.gcs_source, latest field was gcsSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::document_input_config::Source::GcsSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mime_type",
                                ));
                            }
                            result.mime_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DocumentInputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("content", &__With(value))?;
        }
        if let Some(value) = self.gcs_source() {
            state.serialize_entry("gcsSource", value)?;
        }
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DocumentInputConfig].
pub mod document_input_config {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the source for the document's content.
    /// The input file size should be <= 20MB for
    ///
    /// - application/vnd.openxmlformats-officedocument.wordprocessingml.document
    /// - application/vnd.openxmlformats-officedocument.presentationml.presentation
    /// - application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
    ///   The input file size should be <= 20MB and the maximum page limit is 20 for
    /// - application/pdf
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Document's content represented as a stream of bytes.
        Content(::bytes::Bytes),
        /// Google Cloud Storage location. This must be a single file.
        /// For example: gs://example_bucket/example_file.pdf
        GcsSource(std::boxed::Box<crate::model::GcsSource>),
    }
}

/// A document translation request output config.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DocumentOutputConfig {
    /// Optional. Specifies the translated document's mime_type.
    /// If not specified, the translated file's mime type will be the same as the
    /// input file's mime type.
    /// Currently only support the output mime type to be the same as input mime
    /// type.
    ///
    /// - application/pdf
    /// - application/vnd.openxmlformats-officedocument.wordprocessingml.document
    /// - application/vnd.openxmlformats-officedocument.presentationml.presentation
    /// - application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
    pub mime_type: std::string::String,

    /// A URI destination for the translated document.
    /// It is optional to provide a destination. If provided the results from
    /// TranslateDocument will be stored in the destination.
    /// Whether a destination is provided or not, the translated documents will be
    /// returned within TranslateDocumentResponse.document_translation and
    /// TranslateDocumentResponse.glossary_document_translation.
    pub destination: std::option::Option<crate::model::document_output_config::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DocumentOutputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mime_type][crate::model::DocumentOutputConfig::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::DocumentOutputConfig::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::document_output_config::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::DocumentOutputConfig::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::document_output_config::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::DocumentOutputConfig::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::document_output_config::Destination::GcsDestination(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DocumentOutputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DocumentOutputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DocumentOutputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_destination,
            __mime_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DocumentOutputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsDestination" => Ok(__FieldTag::__gcs_destination),
                            "gcs_destination" => Ok(__FieldTag::__gcs_destination),
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DocumentOutputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DocumentOutputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_destination => {
                            if !fields.insert(__FieldTag::__gcs_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_destination",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.translation.v3.DocumentOutputConfig.gcs_destination, latest field was gcsDestination",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::document_output_config::Destination::GcsDestination(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsDestination>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mime_type",
                                ));
                            }
                            result.mime_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DocumentOutputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_destination() {
            state.serialize_entry("gcsDestination", value)?;
        }
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DocumentOutputConfig].
pub mod document_output_config {
    #[allow(unused_imports)]
    use super::*;

    /// A URI destination for the translated document.
    /// It is optional to provide a destination. If provided the results from
    /// TranslateDocument will be stored in the destination.
    /// Whether a destination is provided or not, the translated documents will be
    /// returned within TranslateDocumentResponse.document_translation and
    /// TranslateDocumentResponse.glossary_document_translation.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Optional. Google Cloud Storage destination for the translation output,
        /// e.g., `gs://my_bucket/my_directory/`.
        ///
        /// The destination directory provided does not have to be empty, but the
        /// bucket must exist. If a file with the same name as the output file
        /// already exists in the destination an error will be returned.
        ///
        /// For a DocumentInputConfig.contents provided document, the output file
        /// will have the name "output_[trg]_translations.[ext]", where
        ///
        /// - [trg] corresponds to the translated file's language code,
        /// - [ext] corresponds to the translated file's extension according to its
        ///   mime type.
        ///
        /// For a DocumentInputConfig.gcs_uri provided document, the output file will
        /// have a name according to its URI. For example: an input file with URI:
        /// `gs://a/b/c.[extension]` stored in a gcs_destination bucket with name
        /// "my_bucket" will have an output URI:
        /// `gs://my_bucket/a_b_c_[trg]_translations.[ext]`, where
        ///
        /// - [trg] corresponds to the translated file's language code,
        /// - [ext] corresponds to the translated file's extension according to its
        ///   mime type.
        ///
        /// If the document was directly provided through the request, then the
        /// output document will have the format:
        /// `gs://my_bucket/translated_document_[trg]_translations.[ext]`, where
        ///
        /// - [trg] corresponds to the translated file's language code,
        /// - [ext] corresponds to the translated file's extension according to its
        ///   mime type.
        ///
        /// If a glossary was provided, then the output URI for the glossary
        /// translation will be equal to the default output URI but have
        /// `glossary_translations` instead of `translations`. For the previous
        /// example, its glossary URI would be:
        /// `gs://my_bucket/a_b_c_[trg]_glossary_translations.[ext]`.
        ///
        /// Thus the max number of output files will be 2 (Translated document,
        /// Glossary translated document).
        ///
        /// Callers should expect no partial outputs. If there is any error during
        /// document translation, no output will be stored in the Cloud Storage
        /// bucket.
        GcsDestination(std::boxed::Box<crate::model::GcsDestination>),
    }
}

/// A document translation request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TranslateDocumentRequest {
    /// Required. Location to make a regional call.
    ///
    /// Format: `projects/{project-number-or-id}/locations/{location-id}`.
    ///
    /// For global calls, use `projects/{project-number-or-id}/locations/global` or
    /// `projects/{project-number-or-id}`.
    ///
    /// Non-global location is required for requests using AutoML models or custom
    /// glossaries.
    ///
    /// Models and glossaries must be within the same region (have the same
    /// location-id), otherwise an INVALID_ARGUMENT (400) error is returned.
    pub parent: std::string::String,

    /// Optional. The ISO-639 language code of the input document if known, for
    /// example, "en-US" or "sr-Latn". Supported language codes are listed in
    /// [Language Support] (<https://cloud.google.com/translate/docs/languages>). If
    /// the source language isn't specified, the API attempts to identify the
    /// source language automatically and returns the source language within the
    /// response. Source language must be specified if the request contains a
    /// glossary or a custom model.
    pub source_language_code: std::string::String,

    /// Required. The ISO-639 language code to use for translation of the input
    /// document, set to one of the language codes listed in [Language Support]
    /// (<https://cloud.google.com/translate/docs/languages>).
    pub target_language_code: std::string::String,

    /// Required. Input configurations.
    pub document_input_config: std::option::Option<crate::model::DocumentInputConfig>,

    /// Optional. Output configurations.
    /// Defines if the output file should be stored within Cloud Storage as well
    /// as the desired output format. If not provided the translated file will
    /// only be returned through a byte-stream and its output mime type will be
    /// the same as the input file's mime type.
    pub document_output_config: std::option::Option<crate::model::DocumentOutputConfig>,

    /// Optional. The `model` type requested for this translation.
    ///
    /// The format depends on model type:
    ///
    /// - AutoML Translation models:
    ///   `projects/{project-number-or-id}/locations/{location-id}/models/{model-id}`
    ///
    /// - General (built-in) models:
    ///   `projects/{project-number-or-id}/locations/{location-id}/models/general/nmt`,
    ///
    ///
    /// If not provided, the default Google model (NMT) will be used for
    /// translation.
    pub model: std::string::String,

    /// Optional. Glossary to be applied. The glossary must be within the same
    /// region (have the same location-id) as the model, otherwise an
    /// INVALID_ARGUMENT (400) error is returned.
    pub glossary_config: std::option::Option<crate::model::TranslateTextGlossaryConfig>,

    /// Optional. The labels with user-defined metadata for the request.
    ///
    /// Label keys and values can be no longer than 63 characters (Unicode
    /// codepoints), can only contain lowercase letters, numeric characters,
    /// underscores and dashes. International characters are allowed. Label values
    /// are optional. Label keys must start with a letter.
    ///
    /// See <https://cloud.google.com/translate/docs/advanced/labels> for more
    /// information.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. This flag is to support user customized attribution.
    /// If not provided, the default is `Machine Translated by Google`.
    /// Customized attribution should follow rules in
    /// <https://cloud.google.com/translate/attribution#attribution_and_logos>
    pub customized_attribution: std::string::String,

    /// Optional. is_translate_native_pdf_only field for external customers.
    /// If true, the page limit of online native pdf translation is 300 and only
    /// native pdf pages will be translated.
    pub is_translate_native_pdf_only: bool,

    /// Optional. If true, use the text removal server to remove the shadow text on
    /// background image for native pdf translation.
    /// Shadow removal feature can only be enabled when
    /// is_translate_native_pdf_only: false && pdf_native_only: false
    pub enable_shadow_removal_native_pdf: bool,

    /// Optional. If true, enable auto rotation correction in DVS.
    pub enable_rotation_correction: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TranslateDocumentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::TranslateDocumentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source_language_code][crate::model::TranslateDocumentRequest::source_language_code].
    pub fn set_source_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_language_code = v.into();
        self
    }

    /// Sets the value of [target_language_code][crate::model::TranslateDocumentRequest::target_language_code].
    pub fn set_target_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_language_code = v.into();
        self
    }

    /// Sets the value of [document_input_config][crate::model::TranslateDocumentRequest::document_input_config].
    pub fn set_document_input_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DocumentInputConfig>,
    {
        self.document_input_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document_input_config][crate::model::TranslateDocumentRequest::document_input_config].
    pub fn set_or_clear_document_input_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DocumentInputConfig>,
    {
        self.document_input_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [document_output_config][crate::model::TranslateDocumentRequest::document_output_config].
    pub fn set_document_output_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DocumentOutputConfig>,
    {
        self.document_output_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document_output_config][crate::model::TranslateDocumentRequest::document_output_config].
    pub fn set_or_clear_document_output_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DocumentOutputConfig>,
    {
        self.document_output_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [model][crate::model::TranslateDocumentRequest::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [glossary_config][crate::model::TranslateDocumentRequest::glossary_config].
    pub fn set_glossary_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TranslateTextGlossaryConfig>,
    {
        self.glossary_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [glossary_config][crate::model::TranslateDocumentRequest::glossary_config].
    pub fn set_or_clear_glossary_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TranslateTextGlossaryConfig>,
    {
        self.glossary_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::TranslateDocumentRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [customized_attribution][crate::model::TranslateDocumentRequest::customized_attribution].
    pub fn set_customized_attribution<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.customized_attribution = v.into();
        self
    }

    /// Sets the value of [is_translate_native_pdf_only][crate::model::TranslateDocumentRequest::is_translate_native_pdf_only].
    pub fn set_is_translate_native_pdf_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_translate_native_pdf_only = v.into();
        self
    }

    /// Sets the value of [enable_shadow_removal_native_pdf][crate::model::TranslateDocumentRequest::enable_shadow_removal_native_pdf].
    pub fn set_enable_shadow_removal_native_pdf<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_shadow_removal_native_pdf = v.into();
        self
    }

    /// Sets the value of [enable_rotation_correction][crate::model::TranslateDocumentRequest::enable_rotation_correction].
    pub fn set_enable_rotation_correction<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_rotation_correction = v.into();
        self
    }
}

impl wkt::message::Message for TranslateDocumentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.TranslateDocumentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TranslateDocumentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __source_language_code,
            __target_language_code,
            __document_input_config,
            __document_output_config,
            __model,
            __glossary_config,
            __labels,
            __customized_attribution,
            __is_translate_native_pdf_only,
            __enable_shadow_removal_native_pdf,
            __enable_rotation_correction,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TranslateDocumentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "sourceLanguageCode" => Ok(__FieldTag::__source_language_code),
                            "source_language_code" => Ok(__FieldTag::__source_language_code),
                            "targetLanguageCode" => Ok(__FieldTag::__target_language_code),
                            "target_language_code" => Ok(__FieldTag::__target_language_code),
                            "documentInputConfig" => Ok(__FieldTag::__document_input_config),
                            "document_input_config" => Ok(__FieldTag::__document_input_config),
                            "documentOutputConfig" => Ok(__FieldTag::__document_output_config),
                            "document_output_config" => Ok(__FieldTag::__document_output_config),
                            "model" => Ok(__FieldTag::__model),
                            "glossaryConfig" => Ok(__FieldTag::__glossary_config),
                            "glossary_config" => Ok(__FieldTag::__glossary_config),
                            "labels" => Ok(__FieldTag::__labels),
                            "customizedAttribution" => Ok(__FieldTag::__customized_attribution),
                            "customized_attribution" => Ok(__FieldTag::__customized_attribution),
                            "isTranslateNativePdfOnly" => {
                                Ok(__FieldTag::__is_translate_native_pdf_only)
                            }
                            "is_translate_native_pdf_only" => {
                                Ok(__FieldTag::__is_translate_native_pdf_only)
                            }
                            "enableShadowRemovalNativePdf" => {
                                Ok(__FieldTag::__enable_shadow_removal_native_pdf)
                            }
                            "enable_shadow_removal_native_pdf" => {
                                Ok(__FieldTag::__enable_shadow_removal_native_pdf)
                            }
                            "enableRotationCorrection" => {
                                Ok(__FieldTag::__enable_rotation_correction)
                            }
                            "enable_rotation_correction" => {
                                Ok(__FieldTag::__enable_rotation_correction)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TranslateDocumentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TranslateDocumentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_language_code => {
                            if !fields.insert(__FieldTag::__source_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_language_code",
                                ));
                            }
                            result.source_language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_language_code => {
                            if !fields.insert(__FieldTag::__target_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_language_code",
                                ));
                            }
                            result.target_language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__document_input_config => {
                            if !fields.insert(__FieldTag::__document_input_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document_input_config",
                                ));
                            }
                            result.document_input_config = map.next_value::<std::option::Option<crate::model::DocumentInputConfig>>()?
                                ;
                        }
                        __FieldTag::__document_output_config => {
                            if !fields.insert(__FieldTag::__document_output_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document_output_config",
                                ));
                            }
                            result.document_output_config = map.next_value::<std::option::Option<crate::model::DocumentOutputConfig>>()?
                                ;
                        }
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__glossary_config => {
                            if !fields.insert(__FieldTag::__glossary_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for glossary_config",
                                ));
                            }
                            result.glossary_config = map.next_value::<std::option::Option<crate::model::TranslateTextGlossaryConfig>>()?
                                ;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__customized_attribution => {
                            if !fields.insert(__FieldTag::__customized_attribution) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for customized_attribution",
                                ));
                            }
                            result.customized_attribution = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_translate_native_pdf_only => {
                            if !fields.insert(__FieldTag::__is_translate_native_pdf_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_translate_native_pdf_only",
                                ));
                            }
                            result.is_translate_native_pdf_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_shadow_removal_native_pdf => {
                            if !fields.insert(__FieldTag::__enable_shadow_removal_native_pdf) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_shadow_removal_native_pdf",
                                ));
                            }
                            result.enable_shadow_removal_native_pdf = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_rotation_correction => {
                            if !fields.insert(__FieldTag::__enable_rotation_correction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_rotation_correction",
                                ));
                            }
                            result.enable_rotation_correction = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TranslateDocumentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.source_language_code.is_empty() {
            state.serialize_entry("sourceLanguageCode", &self.source_language_code)?;
        }
        if !self.target_language_code.is_empty() {
            state.serialize_entry("targetLanguageCode", &self.target_language_code)?;
        }
        if self.document_input_config.is_some() {
            state.serialize_entry("documentInputConfig", &self.document_input_config)?;
        }
        if self.document_output_config.is_some() {
            state.serialize_entry("documentOutputConfig", &self.document_output_config)?;
        }
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if self.glossary_config.is_some() {
            state.serialize_entry("glossaryConfig", &self.glossary_config)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.customized_attribution.is_empty() {
            state.serialize_entry("customizedAttribution", &self.customized_attribution)?;
        }
        if !wkt::internal::is_default(&self.is_translate_native_pdf_only) {
            state.serialize_entry(
                "isTranslateNativePdfOnly",
                &self.is_translate_native_pdf_only,
            )?;
        }
        if !wkt::internal::is_default(&self.enable_shadow_removal_native_pdf) {
            state.serialize_entry(
                "enableShadowRemovalNativePdf",
                &self.enable_shadow_removal_native_pdf,
            )?;
        }
        if !wkt::internal::is_default(&self.enable_rotation_correction) {
            state.serialize_entry("enableRotationCorrection", &self.enable_rotation_correction)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A translated document message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DocumentTranslation {
    /// The array of translated documents. It is expected to be size 1 for now. We
    /// may produce multiple translated documents in the future for other type of
    /// file formats.
    pub byte_stream_outputs: std::vec::Vec<::bytes::Bytes>,

    /// The translated document's mime type.
    pub mime_type: std::string::String,

    /// The detected language for the input document.
    /// If the user did not provide the source language for the input document,
    /// this field will have the language code automatically detected. If the
    /// source language was passed, auto-detection of the language does not occur
    /// and this field is empty.
    pub detected_language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DocumentTranslation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [byte_stream_outputs][crate::model::DocumentTranslation::byte_stream_outputs].
    pub fn set_byte_stream_outputs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<::bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.byte_stream_outputs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [mime_type][crate::model::DocumentTranslation::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [detected_language_code][crate::model::DocumentTranslation::detected_language_code].
    pub fn set_detected_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.detected_language_code = v.into();
        self
    }
}

impl wkt::message::Message for DocumentTranslation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DocumentTranslation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DocumentTranslation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __byte_stream_outputs,
            __mime_type,
            __detected_language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DocumentTranslation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "byteStreamOutputs" => Ok(__FieldTag::__byte_stream_outputs),
                            "byte_stream_outputs" => Ok(__FieldTag::__byte_stream_outputs),
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            "detectedLanguageCode" => Ok(__FieldTag::__detected_language_code),
                            "detected_language_code" => Ok(__FieldTag::__detected_language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DocumentTranslation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DocumentTranslation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__byte_stream_outputs => {
                            if !fields.insert(__FieldTag::__byte_stream_outputs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for byte_stream_outputs",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<::bytes::Bytes>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::vec::Vec<serde_with::base64::Base64>,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.byte_stream_outputs =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mime_type",
                                ));
                            }
                            result.mime_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__detected_language_code => {
                            if !fields.insert(__FieldTag::__detected_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detected_language_code",
                                ));
                            }
                            result.detected_language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DocumentTranslation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.byte_stream_outputs.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<serde_with::base64::Base64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("byteStreamOutputs", &__With(&self.byte_stream_outputs))?;
        }
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if !self.detected_language_code.is_empty() {
            state.serialize_entry("detectedLanguageCode", &self.detected_language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A translated document response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TranslateDocumentResponse {
    /// Translated document.
    pub document_translation: std::option::Option<crate::model::DocumentTranslation>,

    /// The document's translation output if a glossary is provided in the request.
    /// This can be the same as [TranslateDocumentResponse.document_translation]
    /// if no glossary terms apply.
    pub glossary_document_translation: std::option::Option<crate::model::DocumentTranslation>,

    /// Only present when 'model' is present in the request.
    /// 'model' is normalized to have a project number.
    ///
    /// For example:
    /// If the 'model' field in TranslateDocumentRequest is:
    /// `projects/{project-id}/locations/{location-id}/models/general/nmt` then
    /// `model` here would be normalized to
    /// `projects/{project-number}/locations/{location-id}/models/general/nmt`.
    pub model: std::string::String,

    /// The `glossary_config` used for this translation.
    pub glossary_config: std::option::Option<crate::model::TranslateTextGlossaryConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TranslateDocumentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document_translation][crate::model::TranslateDocumentResponse::document_translation].
    pub fn set_document_translation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DocumentTranslation>,
    {
        self.document_translation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document_translation][crate::model::TranslateDocumentResponse::document_translation].
    pub fn set_or_clear_document_translation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DocumentTranslation>,
    {
        self.document_translation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [glossary_document_translation][crate::model::TranslateDocumentResponse::glossary_document_translation].
    pub fn set_glossary_document_translation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DocumentTranslation>,
    {
        self.glossary_document_translation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [glossary_document_translation][crate::model::TranslateDocumentResponse::glossary_document_translation].
    pub fn set_or_clear_glossary_document_translation<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::DocumentTranslation>,
    {
        self.glossary_document_translation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [model][crate::model::TranslateDocumentResponse::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [glossary_config][crate::model::TranslateDocumentResponse::glossary_config].
    pub fn set_glossary_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TranslateTextGlossaryConfig>,
    {
        self.glossary_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [glossary_config][crate::model::TranslateDocumentResponse::glossary_config].
    pub fn set_or_clear_glossary_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TranslateTextGlossaryConfig>,
    {
        self.glossary_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TranslateDocumentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.TranslateDocumentResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TranslateDocumentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __document_translation,
            __glossary_document_translation,
            __model,
            __glossary_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TranslateDocumentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "documentTranslation" => Ok(__FieldTag::__document_translation),
                            "document_translation" => Ok(__FieldTag::__document_translation),
                            "glossaryDocumentTranslation" => {
                                Ok(__FieldTag::__glossary_document_translation)
                            }
                            "glossary_document_translation" => {
                                Ok(__FieldTag::__glossary_document_translation)
                            }
                            "model" => Ok(__FieldTag::__model),
                            "glossaryConfig" => Ok(__FieldTag::__glossary_config),
                            "glossary_config" => Ok(__FieldTag::__glossary_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TranslateDocumentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TranslateDocumentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__document_translation => {
                            if !fields.insert(__FieldTag::__document_translation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document_translation",
                                ));
                            }
                            result.document_translation = map.next_value::<std::option::Option<crate::model::DocumentTranslation>>()?
                                ;
                        }
                        __FieldTag::__glossary_document_translation => {
                            if !fields.insert(__FieldTag::__glossary_document_translation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for glossary_document_translation",
                                ));
                            }
                            result.glossary_document_translation = map.next_value::<std::option::Option<crate::model::DocumentTranslation>>()?
                                ;
                        }
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__glossary_config => {
                            if !fields.insert(__FieldTag::__glossary_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for glossary_config",
                                ));
                            }
                            result.glossary_config = map.next_value::<std::option::Option<crate::model::TranslateTextGlossaryConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TranslateDocumentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.document_translation.is_some() {
            state.serialize_entry("documentTranslation", &self.document_translation)?;
        }
        if self.glossary_document_translation.is_some() {
            state.serialize_entry(
                "glossaryDocumentTranslation",
                &self.glossary_document_translation,
            )?;
        }
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if self.glossary_config.is_some() {
            state.serialize_entry("glossaryConfig", &self.glossary_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The batch translation request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchTranslateTextRequest {
    /// Required. Location to make a call. Must refer to a caller's project.
    ///
    /// Format: `projects/{project-number-or-id}/locations/{location-id}`.
    ///
    /// The `global` location is not supported for batch translation.
    ///
    /// Only AutoML Translation models or glossaries within the same region (have
    /// the same location-id) can be used, otherwise an INVALID_ARGUMENT (400)
    /// error is returned.
    pub parent: std::string::String,

    /// Required. Source language code. Supported language codes are listed in
    /// [Language
    /// Support](https://cloud.google.com/translate/docs/languages).
    pub source_language_code: std::string::String,

    /// Required. Specify up to 10 language codes here. Supported language codes
    /// are listed in [Language
    /// Support](https://cloud.google.com/translate/docs/languages).
    pub target_language_codes: std::vec::Vec<std::string::String>,

    /// Optional. The models to use for translation. Map's key is target language
    /// code. Map's value is model name. Value can be a built-in general model,
    /// or an AutoML Translation model.
    ///
    /// The value format depends on model type:
    ///
    /// - AutoML Translation models:
    ///   `projects/{project-number-or-id}/locations/{location-id}/models/{model-id}`
    ///
    /// - General (built-in) models:
    ///   `projects/{project-number-or-id}/locations/{location-id}/models/general/nmt`,
    ///
    ///
    /// If the map is empty or a specific model is
    /// not requested for a language pair, then default google model (nmt) is used.
    pub models: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Input configurations.
    /// The total number of files matched should be <= 100.
    /// The total content size should be <= 100M Unicode codepoints.
    /// The files must use UTF-8 encoding.
    pub input_configs: std::vec::Vec<crate::model::InputConfig>,

    /// Required. Output configuration.
    /// If 2 input configs match to the same file (that is, same input path),
    /// we don't generate output for duplicate inputs.
    pub output_config: std::option::Option<crate::model::OutputConfig>,

    /// Optional. Glossaries to be applied for translation.
    /// It's keyed by target language code.
    pub glossaries:
        std::collections::HashMap<std::string::String, crate::model::TranslateTextGlossaryConfig>,

    /// Optional. The labels with user-defined metadata for the request.
    ///
    /// Label keys and values can be no longer than 63 characters
    /// (Unicode codepoints), can only contain lowercase letters, numeric
    /// characters, underscores and dashes. International characters are allowed.
    /// Label values are optional. Label keys must start with a letter.
    ///
    /// See <https://cloud.google.com/translate/docs/advanced/labels> for more
    /// information.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchTranslateTextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchTranslateTextRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source_language_code][crate::model::BatchTranslateTextRequest::source_language_code].
    pub fn set_source_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_language_code = v.into();
        self
    }

    /// Sets the value of [target_language_codes][crate::model::BatchTranslateTextRequest::target_language_codes].
    pub fn set_target_language_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_language_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [models][crate::model::BatchTranslateTextRequest::models].
    pub fn set_models<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.models = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [input_configs][crate::model::BatchTranslateTextRequest::input_configs].
    pub fn set_input_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InputConfig>,
    {
        use std::iter::Iterator;
        self.input_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [output_config][crate::model::BatchTranslateTextRequest::output_config].
    pub fn set_output_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputConfig>,
    {
        self.output_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_config][crate::model::BatchTranslateTextRequest::output_config].
    pub fn set_or_clear_output_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputConfig>,
    {
        self.output_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [glossaries][crate::model::BatchTranslateTextRequest::glossaries].
    pub fn set_glossaries<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::TranslateTextGlossaryConfig>,
    {
        use std::iter::Iterator;
        self.glossaries = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::BatchTranslateTextRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for BatchTranslateTextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.BatchTranslateTextRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchTranslateTextRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __source_language_code,
            __target_language_codes,
            __models,
            __input_configs,
            __output_config,
            __glossaries,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchTranslateTextRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "sourceLanguageCode" => Ok(__FieldTag::__source_language_code),
                            "source_language_code" => Ok(__FieldTag::__source_language_code),
                            "targetLanguageCodes" => Ok(__FieldTag::__target_language_codes),
                            "target_language_codes" => Ok(__FieldTag::__target_language_codes),
                            "models" => Ok(__FieldTag::__models),
                            "inputConfigs" => Ok(__FieldTag::__input_configs),
                            "input_configs" => Ok(__FieldTag::__input_configs),
                            "outputConfig" => Ok(__FieldTag::__output_config),
                            "output_config" => Ok(__FieldTag::__output_config),
                            "glossaries" => Ok(__FieldTag::__glossaries),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchTranslateTextRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchTranslateTextRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_language_code => {
                            if !fields.insert(__FieldTag::__source_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_language_code",
                                ));
                            }
                            result.source_language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_language_codes => {
                            if !fields.insert(__FieldTag::__target_language_codes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_language_codes",
                                ));
                            }
                            result.target_language_codes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__models => {
                            if !fields.insert(__FieldTag::__models) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for models",
                                ));
                            }
                            result.models = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__input_configs => {
                            if !fields.insert(__FieldTag::__input_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_configs",
                                ));
                            }
                            result.input_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::InputConfig>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__output_config => {
                            if !fields.insert(__FieldTag::__output_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_config",
                                ));
                            }
                            result.output_config = map
                                .next_value::<std::option::Option<crate::model::OutputConfig>>()?;
                        }
                        __FieldTag::__glossaries => {
                            if !fields.insert(__FieldTag::__glossaries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for glossaries",
                                ));
                            }
                            result.glossaries = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::TranslateTextGlossaryConfig,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchTranslateTextRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.source_language_code.is_empty() {
            state.serialize_entry("sourceLanguageCode", &self.source_language_code)?;
        }
        if !self.target_language_codes.is_empty() {
            state.serialize_entry("targetLanguageCodes", &self.target_language_codes)?;
        }
        if !self.models.is_empty() {
            state.serialize_entry("models", &self.models)?;
        }
        if !self.input_configs.is_empty() {
            state.serialize_entry("inputConfigs", &self.input_configs)?;
        }
        if self.output_config.is_some() {
            state.serialize_entry("outputConfig", &self.output_config)?;
        }
        if !self.glossaries.is_empty() {
            state.serialize_entry("glossaries", &self.glossaries)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// State metadata for the batch translation operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchTranslateMetadata {
    /// The state of the operation.
    pub state: crate::model::batch_translate_metadata::State,

    /// Number of successfully translated characters so far (Unicode codepoints).
    pub translated_characters: i64,

    /// Number of characters that have failed to process so far (Unicode
    /// codepoints).
    pub failed_characters: i64,

    /// Total number of characters (Unicode codepoints).
    /// This is the total number of codepoints from input files times the number of
    /// target languages and appears here shortly after the call is submitted.
    pub total_characters: i64,

    /// Time when the operation was submitted.
    pub submit_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchTranslateMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::BatchTranslateMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::batch_translate_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [translated_characters][crate::model::BatchTranslateMetadata::translated_characters].
    pub fn set_translated_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.translated_characters = v.into();
        self
    }

    /// Sets the value of [failed_characters][crate::model::BatchTranslateMetadata::failed_characters].
    pub fn set_failed_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failed_characters = v.into();
        self
    }

    /// Sets the value of [total_characters][crate::model::BatchTranslateMetadata::total_characters].
    pub fn set_total_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_characters = v.into();
        self
    }

    /// Sets the value of [submit_time][crate::model::BatchTranslateMetadata::submit_time].
    pub fn set_submit_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.submit_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [submit_time][crate::model::BatchTranslateMetadata::submit_time].
    pub fn set_or_clear_submit_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.submit_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BatchTranslateMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.BatchTranslateMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchTranslateMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __translated_characters,
            __failed_characters,
            __total_characters,
            __submit_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchTranslateMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "translatedCharacters" => Ok(__FieldTag::__translated_characters),
                            "translated_characters" => Ok(__FieldTag::__translated_characters),
                            "failedCharacters" => Ok(__FieldTag::__failed_characters),
                            "failed_characters" => Ok(__FieldTag::__failed_characters),
                            "totalCharacters" => Ok(__FieldTag::__total_characters),
                            "total_characters" => Ok(__FieldTag::__total_characters),
                            "submitTime" => Ok(__FieldTag::__submit_time),
                            "submit_time" => Ok(__FieldTag::__submit_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchTranslateMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchTranslateMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state =
                                map.next_value::<std::option::Option<
                                    crate::model::batch_translate_metadata::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__translated_characters => {
                            if !fields.insert(__FieldTag::__translated_characters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for translated_characters",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.translated_characters =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__failed_characters => {
                            if !fields.insert(__FieldTag::__failed_characters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failed_characters",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.failed_characters =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_characters => {
                            if !fields.insert(__FieldTag::__total_characters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_characters",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_characters =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__submit_time => {
                            if !fields.insert(__FieldTag::__submit_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for submit_time",
                                ));
                            }
                            result.submit_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchTranslateMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.translated_characters) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("translatedCharacters", &__With(&self.translated_characters))?;
        }
        if !wkt::internal::is_default(&self.failed_characters) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failedCharacters", &__With(&self.failed_characters))?;
        }
        if !wkt::internal::is_default(&self.total_characters) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalCharacters", &__With(&self.total_characters))?;
        }
        if self.submit_time.is_some() {
            state.serialize_entry("submitTime", &self.submit_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BatchTranslateMetadata].
pub mod batch_translate_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// State of the job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Invalid.
        Unspecified,
        /// Request is being processed.
        Running,
        /// The batch is processed, and at least one item was successfully
        /// processed.
        Succeeded,
        /// The batch is done and no item was successfully processed.
        Failed,
        /// Request is in the process of being canceled after caller invoked
        /// longrunning.Operations.CancelOperation on the request id.
        Cancelling,
        /// The batch is done after the user has called the
        /// longrunning.Operations.CancelOperation. Any records processed before the
        /// cancel command are output as specified in the request.
        Cancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Cancelling => std::option::Option::Some(4),
                Self::Cancelled => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Succeeded,
                3 => Self::Failed,
                4 => Self::Cancelling,
                5 => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "CANCELLING" => Self::Cancelling,
                "CANCELLED" => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Cancelling => serializer.serialize_i32(4),
                Self::Cancelled => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.translation.v3.BatchTranslateMetadata.State",
            ))
        }
    }
}

/// Stored in the
/// [google.longrunning.Operation.response][google.longrunning.Operation.response]
/// field returned by BatchTranslateText if at least one sentence is translated
/// successfully.
///
/// [google.longrunning.Operation.response]: longrunning::model::Operation::result
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchTranslateResponse {
    /// Total number of characters (Unicode codepoints).
    pub total_characters: i64,

    /// Number of successfully translated characters (Unicode codepoints).
    pub translated_characters: i64,

    /// Number of characters that have failed to process (Unicode codepoints).
    pub failed_characters: i64,

    /// Time when the operation was submitted.
    pub submit_time: std::option::Option<wkt::Timestamp>,

    /// The time when the operation is finished and
    /// [google.longrunning.Operation.done][google.longrunning.Operation.done] is
    /// set to true.
    ///
    /// [google.longrunning.Operation.done]: longrunning::model::Operation::done
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchTranslateResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_characters][crate::model::BatchTranslateResponse::total_characters].
    pub fn set_total_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_characters = v.into();
        self
    }

    /// Sets the value of [translated_characters][crate::model::BatchTranslateResponse::translated_characters].
    pub fn set_translated_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.translated_characters = v.into();
        self
    }

    /// Sets the value of [failed_characters][crate::model::BatchTranslateResponse::failed_characters].
    pub fn set_failed_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failed_characters = v.into();
        self
    }

    /// Sets the value of [submit_time][crate::model::BatchTranslateResponse::submit_time].
    pub fn set_submit_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.submit_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [submit_time][crate::model::BatchTranslateResponse::submit_time].
    pub fn set_or_clear_submit_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.submit_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::BatchTranslateResponse::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::BatchTranslateResponse::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BatchTranslateResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.BatchTranslateResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchTranslateResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __total_characters,
            __translated_characters,
            __failed_characters,
            __submit_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchTranslateResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "totalCharacters" => Ok(__FieldTag::__total_characters),
                            "total_characters" => Ok(__FieldTag::__total_characters),
                            "translatedCharacters" => Ok(__FieldTag::__translated_characters),
                            "translated_characters" => Ok(__FieldTag::__translated_characters),
                            "failedCharacters" => Ok(__FieldTag::__failed_characters),
                            "failed_characters" => Ok(__FieldTag::__failed_characters),
                            "submitTime" => Ok(__FieldTag::__submit_time),
                            "submit_time" => Ok(__FieldTag::__submit_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchTranslateResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchTranslateResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__total_characters => {
                            if !fields.insert(__FieldTag::__total_characters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_characters",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_characters =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__translated_characters => {
                            if !fields.insert(__FieldTag::__translated_characters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for translated_characters",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.translated_characters =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__failed_characters => {
                            if !fields.insert(__FieldTag::__failed_characters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failed_characters",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.failed_characters =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__submit_time => {
                            if !fields.insert(__FieldTag::__submit_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for submit_time",
                                ));
                            }
                            result.submit_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchTranslateResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.total_characters) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalCharacters", &__With(&self.total_characters))?;
        }
        if !wkt::internal::is_default(&self.translated_characters) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("translatedCharacters", &__With(&self.translated_characters))?;
        }
        if !wkt::internal::is_default(&self.failed_characters) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failedCharacters", &__With(&self.failed_characters))?;
        }
        if self.submit_time.is_some() {
            state.serialize_entry("submitTime", &self.submit_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Input configuration for glossaries.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GlossaryInputConfig {
    /// Required. Specify the input.
    pub source: std::option::Option<crate::model::glossary_input_config::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GlossaryInputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::GlossaryInputConfig::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::glossary_input_config::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::GlossaryInputConfig::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::glossary_input_config::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::GlossaryInputConfig::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::glossary_input_config::Source::GcsSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for GlossaryInputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GlossaryInputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GlossaryInputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GlossaryInputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsSource" => Ok(__FieldTag::__gcs_source),
                            "gcs_source" => Ok(__FieldTag::__gcs_source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GlossaryInputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GlossaryInputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_source => {
                            if !fields.insert(__FieldTag::__gcs_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.translation.v3.GlossaryInputConfig.gcs_source, latest field was gcsSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::glossary_input_config::Source::GcsSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GlossaryInputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_source() {
            state.serialize_entry("gcsSource", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GlossaryInputConfig].
pub mod glossary_input_config {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Specify the input.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Required. Google Cloud Storage location of glossary data.
        /// File format is determined based on the filename extension. API returns
        /// [google.rpc.Code.INVALID_ARGUMENT] for unsupported URI-s and file
        /// formats. Wildcards are not allowed. This must be a single file in one of
        /// the following formats:
        ///
        /// For unidirectional glossaries:
        ///
        /// - TSV/CSV (`.tsv`/`.csv`): Two column file, tab- or comma-separated.
        ///   The first column is source text. The second column is target text.
        ///   No headers in this file. The first row contains data and not column
        ///   names.
        ///
        /// - TMX (`.tmx`): TMX file with parallel data defining source/target term
        ///   pairs.
        ///
        ///
        /// For equivalent term sets glossaries:
        ///
        /// - CSV (`.csv`): Multi-column CSV file defining equivalent glossary terms
        ///   in multiple languages. See documentation for more information -
        ///   [glossaries](https://cloud.google.com/translate/docs/advanced/glossary).
        GcsSource(std::boxed::Box<crate::model::GcsSource>),
    }
}

/// Represents a glossary built from user-provided data.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Glossary {
    /// Required. The resource name of the glossary. Glossary names have the form
    /// `projects/{project-number-or-id}/locations/{location-id}/glossaries/{glossary-id}`.
    pub name: std::string::String,

    /// Required. Provides examples to build the glossary from.
    /// Total glossary must not exceed 10M Unicode codepoints.
    pub input_config: std::option::Option<crate::model::GlossaryInputConfig>,

    /// Output only. The number of entries defined in the glossary.
    pub entry_count: i32,

    /// Output only. When CreateGlossary was called.
    pub submit_time: std::option::Option<wkt::Timestamp>,

    /// Output only. When the glossary creation was finished.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The display name of the glossary.
    pub display_name: std::string::String,

    /// Languages supported by the glossary.
    pub languages: std::option::Option<crate::model::glossary::Languages>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Glossary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Glossary::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [input_config][crate::model::Glossary::input_config].
    pub fn set_input_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GlossaryInputConfig>,
    {
        self.input_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [input_config][crate::model::Glossary::input_config].
    pub fn set_or_clear_input_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GlossaryInputConfig>,
    {
        self.input_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [entry_count][crate::model::Glossary::entry_count].
    pub fn set_entry_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.entry_count = v.into();
        self
    }

    /// Sets the value of [submit_time][crate::model::Glossary::submit_time].
    pub fn set_submit_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.submit_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [submit_time][crate::model::Glossary::submit_time].
    pub fn set_or_clear_submit_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.submit_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::Glossary::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::Glossary::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [display_name][crate::model::Glossary::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [languages][crate::model::Glossary::languages].
    ///
    /// Note that all the setters affecting `languages` are mutually
    /// exclusive.
    pub fn set_languages<
        T: std::convert::Into<std::option::Option<crate::model::glossary::Languages>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.languages = v.into();
        self
    }

    /// The value of [languages][crate::model::Glossary::languages]
    /// if it holds a `LanguagePair`, `None` if the field is not set or
    /// holds a different branch.
    pub fn language_pair(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::glossary::LanguageCodePair>> {
        #[allow(unreachable_patterns)]
        self.languages.as_ref().and_then(|v| match v {
            crate::model::glossary::Languages::LanguagePair(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [languages][crate::model::Glossary::languages]
    /// to hold a `LanguagePair`.
    ///
    /// Note that all the setters affecting `languages` are
    /// mutually exclusive.
    pub fn set_language_pair<
        T: std::convert::Into<std::boxed::Box<crate::model::glossary::LanguageCodePair>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.languages =
            std::option::Option::Some(crate::model::glossary::Languages::LanguagePair(v.into()));
        self
    }

    /// The value of [languages][crate::model::Glossary::languages]
    /// if it holds a `LanguageCodesSet`, `None` if the field is not set or
    /// holds a different branch.
    pub fn language_codes_set(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::glossary::LanguageCodesSet>> {
        #[allow(unreachable_patterns)]
        self.languages.as_ref().and_then(|v| match v {
            crate::model::glossary::Languages::LanguageCodesSet(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [languages][crate::model::Glossary::languages]
    /// to hold a `LanguageCodesSet`.
    ///
    /// Note that all the setters affecting `languages` are
    /// mutually exclusive.
    pub fn set_language_codes_set<
        T: std::convert::Into<std::boxed::Box<crate::model::glossary::LanguageCodesSet>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.languages = std::option::Option::Some(
            crate::model::glossary::Languages::LanguageCodesSet(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Glossary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.Glossary"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Glossary {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __language_pair,
            __language_codes_set,
            __input_config,
            __entry_count,
            __submit_time,
            __end_time,
            __display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Glossary")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "languagePair" => Ok(__FieldTag::__language_pair),
                            "language_pair" => Ok(__FieldTag::__language_pair),
                            "languageCodesSet" => Ok(__FieldTag::__language_codes_set),
                            "language_codes_set" => Ok(__FieldTag::__language_codes_set),
                            "inputConfig" => Ok(__FieldTag::__input_config),
                            "input_config" => Ok(__FieldTag::__input_config),
                            "entryCount" => Ok(__FieldTag::__entry_count),
                            "entry_count" => Ok(__FieldTag::__entry_count),
                            "submitTime" => Ok(__FieldTag::__submit_time),
                            "submit_time" => Ok(__FieldTag::__submit_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Glossary;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Glossary")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_pair => {
                            if !fields.insert(__FieldTag::__language_pair) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_pair",
                                ));
                            }
                            if result.languages.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `languages`, a oneof with full ID .google.cloud.translation.v3.Glossary.language_pair, latest field was languagePair",
                                ));
                            }
                            result.languages = std::option::Option::Some(
                                crate::model::glossary::Languages::LanguagePair(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::glossary::LanguageCodePair>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__language_codes_set => {
                            if !fields.insert(__FieldTag::__language_codes_set) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_codes_set",
                                ));
                            }
                            if result.languages.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `languages`, a oneof with full ID .google.cloud.translation.v3.Glossary.language_codes_set, latest field was languageCodesSet",
                                ));
                            }
                            result.languages = std::option::Option::Some(
                                crate::model::glossary::Languages::LanguageCodesSet(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::glossary::LanguageCodesSet>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__input_config => {
                            if !fields.insert(__FieldTag::__input_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_config",
                                ));
                            }
                            result.input_config = map.next_value::<std::option::Option<crate::model::GlossaryInputConfig>>()?
                                ;
                        }
                        __FieldTag::__entry_count => {
                            if !fields.insert(__FieldTag::__entry_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.entry_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__submit_time => {
                            if !fields.insert(__FieldTag::__submit_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for submit_time",
                                ));
                            }
                            result.submit_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Glossary {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.language_pair() {
            state.serialize_entry("languagePair", value)?;
        }
        if let Some(value) = self.language_codes_set() {
            state.serialize_entry("languageCodesSet", value)?;
        }
        if self.input_config.is_some() {
            state.serialize_entry("inputConfig", &self.input_config)?;
        }
        if !wkt::internal::is_default(&self.entry_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("entryCount", &__With(&self.entry_count))?;
        }
        if self.submit_time.is_some() {
            state.serialize_entry("submitTime", &self.submit_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Glossary].
pub mod glossary {
    #[allow(unused_imports)]
    use super::*;

    /// Used with unidirectional glossaries.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LanguageCodePair {
        /// Required. The ISO-639 language code of the input text, for example,
        /// "en-US". Expected to be an exact match for GlossaryTerm.language_code.
        pub source_language_code: std::string::String,

        /// Required. The ISO-639 language code for translation output, for example,
        /// "zh-CN". Expected to be an exact match for GlossaryTerm.language_code.
        pub target_language_code: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LanguageCodePair {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_language_code][crate::model::glossary::LanguageCodePair::source_language_code].
        pub fn set_source_language_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_language_code = v.into();
            self
        }

        /// Sets the value of [target_language_code][crate::model::glossary::LanguageCodePair::target_language_code].
        pub fn set_target_language_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.target_language_code = v.into();
            self
        }
    }

    impl wkt::message::Message for LanguageCodePair {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.translation.v3.Glossary.LanguageCodePair"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for LanguageCodePair {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __source_language_code,
                __target_language_code,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for LanguageCodePair")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sourceLanguageCode" => Ok(__FieldTag::__source_language_code),
                                "source_language_code" => Ok(__FieldTag::__source_language_code),
                                "targetLanguageCode" => Ok(__FieldTag::__target_language_code),
                                "target_language_code" => Ok(__FieldTag::__target_language_code),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = LanguageCodePair;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct LanguageCodePair")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__source_language_code => {
                                if !fields.insert(__FieldTag::__source_language_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for source_language_code",
                                    ));
                                }
                                result.source_language_code = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__target_language_code => {
                                if !fields.insert(__FieldTag::__target_language_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for target_language_code",
                                    ));
                                }
                                result.target_language_code = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for LanguageCodePair {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.source_language_code.is_empty() {
                state.serialize_entry("sourceLanguageCode", &self.source_language_code)?;
            }
            if !self.target_language_code.is_empty() {
                state.serialize_entry("targetLanguageCode", &self.target_language_code)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Used with equivalent term set glossaries.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LanguageCodesSet {
        /// The ISO-639 language code(s) for terms defined in the glossary.
        /// All entries are unique. The list contains at least two entries.
        /// Expected to be an exact match for GlossaryTerm.language_code.
        pub language_codes: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LanguageCodesSet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [language_codes][crate::model::glossary::LanguageCodesSet::language_codes].
        pub fn set_language_codes<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.language_codes = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for LanguageCodesSet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.translation.v3.Glossary.LanguageCodesSet"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for LanguageCodesSet {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __language_codes,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for LanguageCodesSet")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "languageCodes" => Ok(__FieldTag::__language_codes),
                                "language_codes" => Ok(__FieldTag::__language_codes),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = LanguageCodesSet;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct LanguageCodesSet")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__language_codes => {
                                if !fields.insert(__FieldTag::__language_codes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for language_codes",
                                    ));
                                }
                                result.language_codes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for LanguageCodesSet {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.language_codes.is_empty() {
                state.serialize_entry("languageCodes", &self.language_codes)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Languages supported by the glossary.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Languages {
        /// Used with unidirectional glossaries.
        LanguagePair(std::boxed::Box<crate::model::glossary::LanguageCodePair>),
        /// Used with equivalent term set glossaries.
        LanguageCodesSet(std::boxed::Box<crate::model::glossary::LanguageCodesSet>),
    }
}

/// Request message for CreateGlossary.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateGlossaryRequest {
    /// Required. The project name.
    pub parent: std::string::String,

    /// Required. The glossary to create.
    pub glossary: std::option::Option<crate::model::Glossary>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateGlossaryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateGlossaryRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [glossary][crate::model::CreateGlossaryRequest::glossary].
    pub fn set_glossary<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Glossary>,
    {
        self.glossary = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [glossary][crate::model::CreateGlossaryRequest::glossary].
    pub fn set_or_clear_glossary<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Glossary>,
    {
        self.glossary = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateGlossaryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.CreateGlossaryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateGlossaryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __glossary,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateGlossaryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "glossary" => Ok(__FieldTag::__glossary),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateGlossaryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateGlossaryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__glossary => {
                            if !fields.insert(__FieldTag::__glossary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for glossary",
                                ));
                            }
                            result.glossary =
                                map.next_value::<std::option::Option<crate::model::Glossary>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateGlossaryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.glossary.is_some() {
            state.serialize_entry("glossary", &self.glossary)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the update glossary flow
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateGlossaryRequest {
    /// Required. The glossary entry to update.
    pub glossary: std::option::Option<crate::model::Glossary>,

    /// The list of fields to be updated. Currently only `display_name` and
    /// 'input_config'
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateGlossaryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [glossary][crate::model::UpdateGlossaryRequest::glossary].
    pub fn set_glossary<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Glossary>,
    {
        self.glossary = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [glossary][crate::model::UpdateGlossaryRequest::glossary].
    pub fn set_or_clear_glossary<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Glossary>,
    {
        self.glossary = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateGlossaryRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateGlossaryRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateGlossaryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.UpdateGlossaryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateGlossaryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __glossary,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateGlossaryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "glossary" => Ok(__FieldTag::__glossary),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateGlossaryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateGlossaryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__glossary => {
                            if !fields.insert(__FieldTag::__glossary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for glossary",
                                ));
                            }
                            result.glossary =
                                map.next_value::<std::option::Option<crate::model::Glossary>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateGlossaryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.glossary.is_some() {
            state.serialize_entry("glossary", &self.glossary)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetGlossary.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetGlossaryRequest {
    /// Required. The name of the glossary to retrieve.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetGlossaryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetGlossaryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetGlossaryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GetGlossaryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetGlossaryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetGlossaryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetGlossaryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetGlossaryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetGlossaryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for DeleteGlossary.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteGlossaryRequest {
    /// Required. The name of the glossary to delete.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteGlossaryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteGlossaryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteGlossaryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DeleteGlossaryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteGlossaryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteGlossaryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteGlossaryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteGlossaryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteGlossaryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListGlossaries.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGlossariesRequest {
    /// Required. The name of the project from which to list all of the glossaries.
    pub parent: std::string::String,

    /// Optional. Requested page size. The server may return fewer glossaries than
    /// requested. If unspecified, the server picks an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    /// Typically, this is the value of [ListGlossariesResponse.next_page_token]
    /// returned from the previous call to `ListGlossaries` method.
    /// The first page is returned if `page_token`is empty or missing.
    pub page_token: std::string::String,

    /// Optional. Filter specifying constraints of a list operation.
    /// Specify the constraint by the format of "key=value", where key must be
    /// "src" or "tgt", and the value must be a valid language code.
    /// For multiple restrictions, concatenate them by "AND" (uppercase only),
    /// such as: "src=en-US AND tgt=zh-CN". Notice that the exact match is used
    /// here, which means using 'en-US' and 'en' can lead to different results,
    /// which depends on the language code you used when you create the glossary.
    /// For the unidirectional glossaries, the "src" and "tgt" add restrictions
    /// on the source and target language code separately.
    /// For the equivalent term set glossaries, the "src" and/or "tgt" add
    /// restrictions on the term set.
    /// For example: "src=en-US AND tgt=zh-CN" will only pick the unidirectional
    /// glossaries which exactly match the source language code as "en-US" and the
    /// target language code "zh-CN", but all equivalent term set glossaries which
    /// contain "en-US" and "zh-CN" in their language set will be picked.
    /// If missing, no filtering is performed.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGlossariesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListGlossariesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGlossariesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGlossariesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListGlossariesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListGlossariesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListGlossariesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGlossariesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGlossariesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGlossariesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGlossariesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGlossariesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListGlossaries.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGlossariesResponse {
    /// The list of glossaries for a project.
    pub glossaries: std::vec::Vec<crate::model::Glossary>,

    /// A token to retrieve a page of results. Pass this value in the
    /// [ListGlossariesRequest.page_token] field in the subsequent call to
    /// `ListGlossaries` method to retrieve the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGlossariesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [glossaries][crate::model::ListGlossariesResponse::glossaries].
    pub fn set_glossaries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Glossary>,
    {
        use std::iter::Iterator;
        self.glossaries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListGlossariesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListGlossariesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListGlossariesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListGlossariesResponse {
    type PageItem = crate::model::Glossary;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.glossaries
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGlossariesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __glossaries,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGlossariesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "glossaries" => Ok(__FieldTag::__glossaries),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGlossariesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGlossariesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__glossaries => {
                            if !fields.insert(__FieldTag::__glossaries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for glossaries",
                                ));
                            }
                            result.glossaries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Glossary>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGlossariesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.glossaries.is_empty() {
            state.serialize_entry("glossaries", &self.glossaries)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the Get Glossary Entry Api
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetGlossaryEntryRequest {
    /// Required. The resource name of the glossary entry to get
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetGlossaryEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetGlossaryEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetGlossaryEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.GetGlossaryEntryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetGlossaryEntryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetGlossaryEntryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetGlossaryEntryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetGlossaryEntryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetGlossaryEntryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for Delete Glossary Entry
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteGlossaryEntryRequest {
    /// Required. The resource name of the glossary entry to delete
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteGlossaryEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteGlossaryEntryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteGlossaryEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DeleteGlossaryEntryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteGlossaryEntryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteGlossaryEntryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteGlossaryEntryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteGlossaryEntryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteGlossaryEntryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListGlossaryEntries
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGlossaryEntriesRequest {
    /// Required. The parent glossary resource name for listing the glossary's
    /// entries.
    pub parent: std::string::String,

    /// Optional. Requested page size. The server may return fewer glossary entries
    /// than requested. If unspecified, the server picks an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    /// Typically, this is the value of
    /// [ListGlossaryEntriesResponse.next_page_token] returned from the previous
    /// call. The first page is returned if `page_token`is empty or missing.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGlossaryEntriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListGlossaryEntriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGlossaryEntriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGlossaryEntriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListGlossaryEntriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListGlossaryEntriesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGlossaryEntriesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGlossaryEntriesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGlossaryEntriesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGlossaryEntriesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGlossaryEntriesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListGlossaryEntries
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGlossaryEntriesResponse {
    /// Optional. The Glossary Entries
    pub glossary_entries: std::vec::Vec<crate::model::GlossaryEntry>,

    /// Optional. A token to retrieve a page of results. Pass this value in the
    /// [ListGLossaryEntriesRequest.page_token] field in the subsequent calls.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGlossaryEntriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [glossary_entries][crate::model::ListGlossaryEntriesResponse::glossary_entries].
    pub fn set_glossary_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GlossaryEntry>,
    {
        use std::iter::Iterator;
        self.glossary_entries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListGlossaryEntriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListGlossaryEntriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.ListGlossaryEntriesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListGlossaryEntriesResponse {
    type PageItem = crate::model::GlossaryEntry;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.glossary_entries
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGlossaryEntriesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __glossary_entries,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGlossaryEntriesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "glossaryEntries" => Ok(__FieldTag::__glossary_entries),
                            "glossary_entries" => Ok(__FieldTag::__glossary_entries),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGlossaryEntriesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGlossaryEntriesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__glossary_entries => {
                            if !fields.insert(__FieldTag::__glossary_entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for glossary_entries",
                                ));
                            }
                            result.glossary_entries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::GlossaryEntry>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGlossaryEntriesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.glossary_entries.is_empty() {
            state.serialize_entry("glossaryEntries", &self.glossary_entries)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for CreateGlossaryEntry
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateGlossaryEntryRequest {
    /// Required. The resource name of the glossary to create the entry under.
    pub parent: std::string::String,

    /// Required. The glossary entry to create
    pub glossary_entry: std::option::Option<crate::model::GlossaryEntry>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateGlossaryEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateGlossaryEntryRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [glossary_entry][crate::model::CreateGlossaryEntryRequest::glossary_entry].
    pub fn set_glossary_entry<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GlossaryEntry>,
    {
        self.glossary_entry = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [glossary_entry][crate::model::CreateGlossaryEntryRequest::glossary_entry].
    pub fn set_or_clear_glossary_entry<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GlossaryEntry>,
    {
        self.glossary_entry = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateGlossaryEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.CreateGlossaryEntryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateGlossaryEntryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __glossary_entry,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateGlossaryEntryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "glossaryEntry" => Ok(__FieldTag::__glossary_entry),
                            "glossary_entry" => Ok(__FieldTag::__glossary_entry),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateGlossaryEntryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateGlossaryEntryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__glossary_entry => {
                            if !fields.insert(__FieldTag::__glossary_entry) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for glossary_entry",
                                ));
                            }
                            result.glossary_entry = map
                                .next_value::<std::option::Option<crate::model::GlossaryEntry>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateGlossaryEntryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.glossary_entry.is_some() {
            state.serialize_entry("glossaryEntry", &self.glossary_entry)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for UpdateGlossaryEntry
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateGlossaryEntryRequest {
    /// Required. The glossary entry to update.
    pub glossary_entry: std::option::Option<crate::model::GlossaryEntry>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateGlossaryEntryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [glossary_entry][crate::model::UpdateGlossaryEntryRequest::glossary_entry].
    pub fn set_glossary_entry<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GlossaryEntry>,
    {
        self.glossary_entry = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [glossary_entry][crate::model::UpdateGlossaryEntryRequest::glossary_entry].
    pub fn set_or_clear_glossary_entry<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GlossaryEntry>,
    {
        self.glossary_entry = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateGlossaryEntryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.UpdateGlossaryEntryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateGlossaryEntryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __glossary_entry,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateGlossaryEntryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "glossaryEntry" => Ok(__FieldTag::__glossary_entry),
                            "glossary_entry" => Ok(__FieldTag::__glossary_entry),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateGlossaryEntryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateGlossaryEntryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__glossary_entry => {
                            if !fields.insert(__FieldTag::__glossary_entry) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for glossary_entry",
                                ));
                            }
                            result.glossary_entry = map
                                .next_value::<std::option::Option<crate::model::GlossaryEntry>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateGlossaryEntryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.glossary_entry.is_some() {
            state.serialize_entry("glossaryEntry", &self.glossary_entry)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Stored in the
/// [google.longrunning.Operation.metadata][google.longrunning.Operation.metadata]
/// field returned by CreateGlossary.
///
/// [google.longrunning.Operation.metadata]: longrunning::model::Operation::metadata
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateGlossaryMetadata {
    /// The name of the glossary that is being created.
    pub name: std::string::String,

    /// The current state of the glossary creation operation.
    pub state: crate::model::create_glossary_metadata::State,

    /// The time when the operation was submitted to the server.
    pub submit_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateGlossaryMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CreateGlossaryMetadata::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::CreateGlossaryMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::create_glossary_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [submit_time][crate::model::CreateGlossaryMetadata::submit_time].
    pub fn set_submit_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.submit_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [submit_time][crate::model::CreateGlossaryMetadata::submit_time].
    pub fn set_or_clear_submit_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.submit_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateGlossaryMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.CreateGlossaryMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateGlossaryMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __state,
            __submit_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateGlossaryMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "state" => Ok(__FieldTag::__state),
                            "submitTime" => Ok(__FieldTag::__submit_time),
                            "submit_time" => Ok(__FieldTag::__submit_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateGlossaryMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateGlossaryMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state =
                                map.next_value::<std::option::Option<
                                    crate::model::create_glossary_metadata::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__submit_time => {
                            if !fields.insert(__FieldTag::__submit_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for submit_time",
                                ));
                            }
                            result.submit_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateGlossaryMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.submit_time.is_some() {
            state.serialize_entry("submitTime", &self.submit_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CreateGlossaryMetadata].
pub mod create_glossary_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Enumerates the possible states that the creation request can be in.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Invalid.
        Unspecified,
        /// Request is being processed.
        Running,
        /// The glossary was successfully created.
        Succeeded,
        /// Failed to create the glossary.
        Failed,
        /// Request is in the process of being canceled after caller invoked
        /// longrunning.Operations.CancelOperation on the request id.
        Cancelling,
        /// The glossary creation request was successfully canceled.
        Cancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Cancelling => std::option::Option::Some(4),
                Self::Cancelled => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Succeeded,
                3 => Self::Failed,
                4 => Self::Cancelling,
                5 => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "CANCELLING" => Self::Cancelling,
                "CANCELLED" => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Cancelling => serializer.serialize_i32(4),
                Self::Cancelled => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.translation.v3.CreateGlossaryMetadata.State",
            ))
        }
    }
}

/// Stored in the
/// [google.longrunning.Operation.metadata][google.longrunning.Operation.metadata]
/// field returned by UpdateGlossary.
///
/// [google.longrunning.Operation.metadata]: longrunning::model::Operation::metadata
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateGlossaryMetadata {
    /// The updated glossary object.
    pub glossary: std::option::Option<crate::model::Glossary>,

    /// The current state of the glossary update operation. If the glossary input
    /// file was not updated this will be completed immediately
    pub state: crate::model::update_glossary_metadata::State,

    /// The time when the operation was submitted to the server.
    pub submit_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateGlossaryMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [glossary][crate::model::UpdateGlossaryMetadata::glossary].
    pub fn set_glossary<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Glossary>,
    {
        self.glossary = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [glossary][crate::model::UpdateGlossaryMetadata::glossary].
    pub fn set_or_clear_glossary<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Glossary>,
    {
        self.glossary = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::UpdateGlossaryMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::update_glossary_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [submit_time][crate::model::UpdateGlossaryMetadata::submit_time].
    pub fn set_submit_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.submit_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [submit_time][crate::model::UpdateGlossaryMetadata::submit_time].
    pub fn set_or_clear_submit_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.submit_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateGlossaryMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.UpdateGlossaryMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateGlossaryMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __glossary,
            __state,
            __submit_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateGlossaryMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "glossary" => Ok(__FieldTag::__glossary),
                            "state" => Ok(__FieldTag::__state),
                            "submitTime" => Ok(__FieldTag::__submit_time),
                            "submit_time" => Ok(__FieldTag::__submit_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateGlossaryMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateGlossaryMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__glossary => {
                            if !fields.insert(__FieldTag::__glossary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for glossary",
                                ));
                            }
                            result.glossary =
                                map.next_value::<std::option::Option<crate::model::Glossary>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state =
                                map.next_value::<std::option::Option<
                                    crate::model::update_glossary_metadata::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__submit_time => {
                            if !fields.insert(__FieldTag::__submit_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for submit_time",
                                ));
                            }
                            result.submit_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateGlossaryMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.glossary.is_some() {
            state.serialize_entry("glossary", &self.glossary)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.submit_time.is_some() {
            state.serialize_entry("submitTime", &self.submit_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [UpdateGlossaryMetadata].
pub mod update_glossary_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Enumerates the possible states that the update request can be in.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Invalid.
        Unspecified,
        /// Request is being processed.
        Running,
        /// The glossary was successfully updated.
        Succeeded,
        /// Failed to update the glossary.
        Failed,
        /// Request is in the process of being canceled after caller invoked
        /// longrunning.Operations.CancelOperation on the request id.
        Cancelling,
        /// The glossary update request was successfully canceled.
        Cancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Cancelling => std::option::Option::Some(4),
                Self::Cancelled => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Succeeded,
                3 => Self::Failed,
                4 => Self::Cancelling,
                5 => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "CANCELLING" => Self::Cancelling,
                "CANCELLED" => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Cancelling => serializer.serialize_i32(4),
                Self::Cancelled => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.translation.v3.UpdateGlossaryMetadata.State",
            ))
        }
    }
}

/// Stored in the
/// [google.longrunning.Operation.metadata][google.longrunning.Operation.metadata]
/// field returned by DeleteGlossary.
///
/// [google.longrunning.Operation.metadata]: longrunning::model::Operation::metadata
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteGlossaryMetadata {
    /// The name of the glossary that is being deleted.
    pub name: std::string::String,

    /// The current state of the glossary deletion operation.
    pub state: crate::model::delete_glossary_metadata::State,

    /// The time when the operation was submitted to the server.
    pub submit_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteGlossaryMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteGlossaryMetadata::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DeleteGlossaryMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::delete_glossary_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [submit_time][crate::model::DeleteGlossaryMetadata::submit_time].
    pub fn set_submit_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.submit_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [submit_time][crate::model::DeleteGlossaryMetadata::submit_time].
    pub fn set_or_clear_submit_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.submit_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeleteGlossaryMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DeleteGlossaryMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteGlossaryMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __state,
            __submit_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteGlossaryMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "state" => Ok(__FieldTag::__state),
                            "submitTime" => Ok(__FieldTag::__submit_time),
                            "submit_time" => Ok(__FieldTag::__submit_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteGlossaryMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteGlossaryMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state =
                                map.next_value::<std::option::Option<
                                    crate::model::delete_glossary_metadata::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__submit_time => {
                            if !fields.insert(__FieldTag::__submit_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for submit_time",
                                ));
                            }
                            result.submit_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteGlossaryMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.submit_time.is_some() {
            state.serialize_entry("submitTime", &self.submit_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DeleteGlossaryMetadata].
pub mod delete_glossary_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Enumerates the possible states that the creation request can be in.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Invalid.
        Unspecified,
        /// Request is being processed.
        Running,
        /// The glossary was successfully deleted.
        Succeeded,
        /// Failed to delete the glossary.
        Failed,
        /// Request is in the process of being canceled after caller invoked
        /// longrunning.Operations.CancelOperation on the request id.
        Cancelling,
        /// The glossary deletion request was successfully canceled.
        Cancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Cancelling => std::option::Option::Some(4),
                Self::Cancelled => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Succeeded,
                3 => Self::Failed,
                4 => Self::Cancelling,
                5 => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "CANCELLING" => Self::Cancelling,
                "CANCELLED" => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Cancelling => serializer.serialize_i32(4),
                Self::Cancelled => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.translation.v3.DeleteGlossaryMetadata.State",
            ))
        }
    }
}

/// Stored in the
/// [google.longrunning.Operation.response][google.longrunning.Operation.response]
/// field returned by DeleteGlossary.
///
/// [google.longrunning.Operation.response]: longrunning::model::Operation::result
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteGlossaryResponse {
    /// The name of the deleted glossary.
    pub name: std::string::String,

    /// The time when the operation was submitted to the server.
    pub submit_time: std::option::Option<wkt::Timestamp>,

    /// The time when the glossary deletion is finished and
    /// [google.longrunning.Operation.done][google.longrunning.Operation.done] is
    /// set to true.
    ///
    /// [google.longrunning.Operation.done]: longrunning::model::Operation::done
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteGlossaryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteGlossaryResponse::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [submit_time][crate::model::DeleteGlossaryResponse::submit_time].
    pub fn set_submit_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.submit_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [submit_time][crate::model::DeleteGlossaryResponse::submit_time].
    pub fn set_or_clear_submit_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.submit_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::DeleteGlossaryResponse::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::DeleteGlossaryResponse::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DeleteGlossaryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.DeleteGlossaryResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteGlossaryResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __submit_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteGlossaryResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "submitTime" => Ok(__FieldTag::__submit_time),
                            "submit_time" => Ok(__FieldTag::__submit_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteGlossaryResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteGlossaryResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__submit_time => {
                            if !fields.insert(__FieldTag::__submit_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for submit_time",
                                ));
                            }
                            result.submit_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteGlossaryResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.submit_time.is_some() {
            state.serialize_entry("submitTime", &self.submit_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The BatchTranslateDocument request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchTranslateDocumentRequest {
    /// Required. Location to make a regional call.
    ///
    /// Format: `projects/{project-number-or-id}/locations/{location-id}`.
    ///
    /// The `global` location is not supported for batch translation.
    ///
    /// Only AutoML Translation models or glossaries within the same region (have
    /// the same location-id) can be used, otherwise an INVALID_ARGUMENT (400)
    /// error is returned.
    pub parent: std::string::String,

    /// Required. The ISO-639 language code of the input document if known, for
    /// example, "en-US" or "sr-Latn". Supported language codes are listed in
    /// [Language Support](https://cloud.google.com/translate/docs/languages).
    pub source_language_code: std::string::String,

    /// Required. The ISO-639 language code to use for translation of the input
    /// document. Specify up to 10 language codes here. Supported language codes
    /// are listed in [Language
    /// Support](https://cloud.google.com/translate/docs/languages).
    pub target_language_codes: std::vec::Vec<std::string::String>,

    /// Required. Input configurations.
    /// The total number of files matched should be <= 100.
    /// The total content size to translate should be <= 100M Unicode codepoints.
    /// The files must use UTF-8 encoding.
    pub input_configs: std::vec::Vec<crate::model::BatchDocumentInputConfig>,

    /// Required. Output configuration.
    /// If 2 input configs match to the same file (that is, same input path),
    /// we don't generate output for duplicate inputs.
    pub output_config: std::option::Option<crate::model::BatchDocumentOutputConfig>,

    /// Optional. The models to use for translation. Map's key is target language
    /// code. Map's value is the model name. Value can be a built-in general model,
    /// or an AutoML Translation model.
    ///
    /// The value format depends on model type:
    ///
    /// - AutoML Translation models:
    ///   `projects/{project-number-or-id}/locations/{location-id}/models/{model-id}`
    ///
    /// - General (built-in) models:
    ///   `projects/{project-number-or-id}/locations/{location-id}/models/general/nmt`,
    ///
    ///
    /// If the map is empty or a specific model is
    /// not requested for a language pair, then default google model (nmt) is used.
    pub models: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Glossaries to be applied. It's keyed by target language code.
    pub glossaries:
        std::collections::HashMap<std::string::String, crate::model::TranslateTextGlossaryConfig>,

    /// Optional. The file format conversion map that is applied to all input
    /// files. The map key is the original mime_type. The map value is the target
    /// mime_type of translated documents.
    ///
    /// Supported file format conversion includes:
    ///
    /// - `application/pdf` to
    ///   `application/vnd.openxmlformats-officedocument.wordprocessingml.document`
    ///
    /// If nothing specified, output files will be in the same format as the
    /// original file.
    pub format_conversions: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. This flag is to support user customized attribution.
    /// If not provided, the default is `Machine Translated by Google`.
    /// Customized attribution should follow rules in
    /// <https://cloud.google.com/translate/attribution#attribution_and_logos>
    pub customized_attribution: std::string::String,

    /// Optional. If true, use the text removal server to remove the shadow text on
    /// background image for native pdf translation.
    /// Shadow removal feature can only be enabled when
    /// is_translate_native_pdf_only: false && pdf_native_only: false
    pub enable_shadow_removal_native_pdf: bool,

    /// Optional. If true, enable auto rotation correction in DVS.
    pub enable_rotation_correction: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchTranslateDocumentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchTranslateDocumentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source_language_code][crate::model::BatchTranslateDocumentRequest::source_language_code].
    pub fn set_source_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_language_code = v.into();
        self
    }

    /// Sets the value of [target_language_codes][crate::model::BatchTranslateDocumentRequest::target_language_codes].
    pub fn set_target_language_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_language_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [input_configs][crate::model::BatchTranslateDocumentRequest::input_configs].
    pub fn set_input_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BatchDocumentInputConfig>,
    {
        use std::iter::Iterator;
        self.input_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [output_config][crate::model::BatchTranslateDocumentRequest::output_config].
    pub fn set_output_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BatchDocumentOutputConfig>,
    {
        self.output_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_config][crate::model::BatchTranslateDocumentRequest::output_config].
    pub fn set_or_clear_output_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BatchDocumentOutputConfig>,
    {
        self.output_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [models][crate::model::BatchTranslateDocumentRequest::models].
    pub fn set_models<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.models = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [glossaries][crate::model::BatchTranslateDocumentRequest::glossaries].
    pub fn set_glossaries<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::TranslateTextGlossaryConfig>,
    {
        use std::iter::Iterator;
        self.glossaries = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [format_conversions][crate::model::BatchTranslateDocumentRequest::format_conversions].
    pub fn set_format_conversions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.format_conversions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [customized_attribution][crate::model::BatchTranslateDocumentRequest::customized_attribution].
    pub fn set_customized_attribution<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.customized_attribution = v.into();
        self
    }

    /// Sets the value of [enable_shadow_removal_native_pdf][crate::model::BatchTranslateDocumentRequest::enable_shadow_removal_native_pdf].
    pub fn set_enable_shadow_removal_native_pdf<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_shadow_removal_native_pdf = v.into();
        self
    }

    /// Sets the value of [enable_rotation_correction][crate::model::BatchTranslateDocumentRequest::enable_rotation_correction].
    pub fn set_enable_rotation_correction<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_rotation_correction = v.into();
        self
    }
}

impl wkt::message::Message for BatchTranslateDocumentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.BatchTranslateDocumentRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchTranslateDocumentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __source_language_code,
            __target_language_codes,
            __input_configs,
            __output_config,
            __models,
            __glossaries,
            __format_conversions,
            __customized_attribution,
            __enable_shadow_removal_native_pdf,
            __enable_rotation_correction,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchTranslateDocumentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "sourceLanguageCode" => Ok(__FieldTag::__source_language_code),
                            "source_language_code" => Ok(__FieldTag::__source_language_code),
                            "targetLanguageCodes" => Ok(__FieldTag::__target_language_codes),
                            "target_language_codes" => Ok(__FieldTag::__target_language_codes),
                            "inputConfigs" => Ok(__FieldTag::__input_configs),
                            "input_configs" => Ok(__FieldTag::__input_configs),
                            "outputConfig" => Ok(__FieldTag::__output_config),
                            "output_config" => Ok(__FieldTag::__output_config),
                            "models" => Ok(__FieldTag::__models),
                            "glossaries" => Ok(__FieldTag::__glossaries),
                            "formatConversions" => Ok(__FieldTag::__format_conversions),
                            "format_conversions" => Ok(__FieldTag::__format_conversions),
                            "customizedAttribution" => Ok(__FieldTag::__customized_attribution),
                            "customized_attribution" => Ok(__FieldTag::__customized_attribution),
                            "enableShadowRemovalNativePdf" => {
                                Ok(__FieldTag::__enable_shadow_removal_native_pdf)
                            }
                            "enable_shadow_removal_native_pdf" => {
                                Ok(__FieldTag::__enable_shadow_removal_native_pdf)
                            }
                            "enableRotationCorrection" => {
                                Ok(__FieldTag::__enable_rotation_correction)
                            }
                            "enable_rotation_correction" => {
                                Ok(__FieldTag::__enable_rotation_correction)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchTranslateDocumentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchTranslateDocumentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_language_code => {
                            if !fields.insert(__FieldTag::__source_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_language_code",
                                ));
                            }
                            result.source_language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_language_codes => {
                            if !fields.insert(__FieldTag::__target_language_codes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_language_codes",
                                ));
                            }
                            result.target_language_codes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__input_configs => {
                            if !fields.insert(__FieldTag::__input_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_configs",
                                ));
                            }
                            result.input_configs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::BatchDocumentInputConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__output_config => {
                            if !fields.insert(__FieldTag::__output_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_config",
                                ));
                            }
                            result.output_config = map.next_value::<std::option::Option<crate::model::BatchDocumentOutputConfig>>()?
                                ;
                        }
                        __FieldTag::__models => {
                            if !fields.insert(__FieldTag::__models) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for models",
                                ));
                            }
                            result.models = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__glossaries => {
                            if !fields.insert(__FieldTag::__glossaries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for glossaries",
                                ));
                            }
                            result.glossaries = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::TranslateTextGlossaryConfig,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__format_conversions => {
                            if !fields.insert(__FieldTag::__format_conversions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for format_conversions",
                                ));
                            }
                            result.format_conversions = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__customized_attribution => {
                            if !fields.insert(__FieldTag::__customized_attribution) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for customized_attribution",
                                ));
                            }
                            result.customized_attribution = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_shadow_removal_native_pdf => {
                            if !fields.insert(__FieldTag::__enable_shadow_removal_native_pdf) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_shadow_removal_native_pdf",
                                ));
                            }
                            result.enable_shadow_removal_native_pdf = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_rotation_correction => {
                            if !fields.insert(__FieldTag::__enable_rotation_correction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_rotation_correction",
                                ));
                            }
                            result.enable_rotation_correction = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchTranslateDocumentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.source_language_code.is_empty() {
            state.serialize_entry("sourceLanguageCode", &self.source_language_code)?;
        }
        if !self.target_language_codes.is_empty() {
            state.serialize_entry("targetLanguageCodes", &self.target_language_codes)?;
        }
        if !self.input_configs.is_empty() {
            state.serialize_entry("inputConfigs", &self.input_configs)?;
        }
        if self.output_config.is_some() {
            state.serialize_entry("outputConfig", &self.output_config)?;
        }
        if !self.models.is_empty() {
            state.serialize_entry("models", &self.models)?;
        }
        if !self.glossaries.is_empty() {
            state.serialize_entry("glossaries", &self.glossaries)?;
        }
        if !self.format_conversions.is_empty() {
            state.serialize_entry("formatConversions", &self.format_conversions)?;
        }
        if !self.customized_attribution.is_empty() {
            state.serialize_entry("customizedAttribution", &self.customized_attribution)?;
        }
        if !wkt::internal::is_default(&self.enable_shadow_removal_native_pdf) {
            state.serialize_entry(
                "enableShadowRemovalNativePdf",
                &self.enable_shadow_removal_native_pdf,
            )?;
        }
        if !wkt::internal::is_default(&self.enable_rotation_correction) {
            state.serialize_entry("enableRotationCorrection", &self.enable_rotation_correction)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Input configuration for BatchTranslateDocument request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchDocumentInputConfig {
    /// Specify the input.
    pub source: std::option::Option<crate::model::batch_document_input_config::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchDocumentInputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::BatchDocumentInputConfig::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::batch_document_input_config::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::BatchDocumentInputConfig::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::batch_document_input_config::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::BatchDocumentInputConfig::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::batch_document_input_config::Source::GcsSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BatchDocumentInputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.BatchDocumentInputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchDocumentInputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchDocumentInputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsSource" => Ok(__FieldTag::__gcs_source),
                            "gcs_source" => Ok(__FieldTag::__gcs_source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchDocumentInputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchDocumentInputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_source => {
                            if !fields.insert(__FieldTag::__gcs_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.translation.v3.BatchDocumentInputConfig.gcs_source, latest field was gcsSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::batch_document_input_config::Source::GcsSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchDocumentInputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_source() {
            state.serialize_entry("gcsSource", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BatchDocumentInputConfig].
pub mod batch_document_input_config {
    #[allow(unused_imports)]
    use super::*;

    /// Specify the input.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Google Cloud Storage location for the source input.
        /// This can be a single file (for example,
        /// `gs://translation-test/input.docx`) or a wildcard (for example,
        /// `gs://translation-test/*`).
        ///
        /// File mime type is determined based on extension. Supported mime type
        /// includes:
        ///
        /// - `pdf`, application/pdf
        /// - `docx`,
        ///   application/vnd.openxmlformats-officedocument.wordprocessingml.document
        /// - `pptx`,
        ///   application/vnd.openxmlformats-officedocument.presentationml.presentation
        /// - `xlsx`,
        ///   application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
        ///
        /// The max file size to support for `.docx`, `.pptx` and `.xlsx` is 100MB.
        /// The max file size to support for `.pdf` is 1GB and the max page limit is
        /// 1000 pages.
        /// The max file size to support for all input documents is 1GB.
        GcsSource(std::boxed::Box<crate::model::GcsSource>),
    }
}

/// Output configuration for BatchTranslateDocument request.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchDocumentOutputConfig {
    /// The destination of output. The destination directory provided must exist
    /// and be empty.
    pub destination: std::option::Option<crate::model::batch_document_output_config::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchDocumentOutputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination][crate::model::BatchDocumentOutputConfig::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<
                std::option::Option<crate::model::batch_document_output_config::Destination>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::BatchDocumentOutputConfig::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::batch_document_output_config::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::BatchDocumentOutputConfig::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::batch_document_output_config::Destination::GcsDestination(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BatchDocumentOutputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.BatchDocumentOutputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchDocumentOutputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_destination,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchDocumentOutputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsDestination" => Ok(__FieldTag::__gcs_destination),
                            "gcs_destination" => Ok(__FieldTag::__gcs_destination),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchDocumentOutputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchDocumentOutputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_destination => {
                            if !fields.insert(__FieldTag::__gcs_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_destination",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.translation.v3.BatchDocumentOutputConfig.gcs_destination, latest field was gcsDestination",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::batch_document_output_config::Destination::GcsDestination(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::GcsDestination>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchDocumentOutputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_destination() {
            state.serialize_entry("gcsDestination", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BatchDocumentOutputConfig].
pub mod batch_document_output_config {
    #[allow(unused_imports)]
    use super::*;

    /// The destination of output. The destination directory provided must exist
    /// and be empty.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Google Cloud Storage destination for output content.
        /// For every single input document (for example, gs://a/b/c.[extension]), we
        /// generate at most 2 * n output files. (n is the # of target_language_codes
        /// in the BatchTranslateDocumentRequest).
        ///
        /// While the input documents are being processed, we write/update an index
        /// file `index.csv` under `gcs_destination.output_uri_prefix` (for example,
        /// gs://translation_output/index.csv) The index file is generated/updated as
        /// new files are being translated. The format is:
        ///
        /// input_document,target_language_code,translation_output,error_output,
        /// glossary_translation_output,glossary_error_output
        ///
        /// `input_document` is one file we matched using gcs_source.input_uri.
        /// `target_language_code` is provided in the request.
        /// `translation_output` contains the translations. (details provided below)
        /// `error_output` contains the error message during processing of the file.
        /// Both translations_file and errors_file could be empty strings if we have
        /// no content to output.
        /// `glossary_translation_output` and `glossary_error_output` are the
        /// translated output/error when we apply glossaries. They could also be
        /// empty if we have no content to output.
        ///
        /// Once a row is present in index.csv, the input/output matching never
        /// changes. Callers should also expect all the content in input_file are
        /// processed and ready to be consumed (that is, no partial output file is
        /// written).
        ///
        /// Since index.csv will be keeping updated during the process, please make
        /// sure there is no custom retention policy applied on the output bucket
        /// that may avoid file updating.
        /// (<https://cloud.google.com/storage/docs/bucket-lock#retention-policy>)
        ///
        /// The naming format of translation output files follows (for target
        /// language code [trg]): `translation_output`:
        /// `gs://translation_output/a_b_c_[trg]_translation.[extension]`
        /// `glossary_translation_output`:
        /// `gs://translation_test/a_b_c_[trg]_glossary_translation.[extension]`. The
        /// output document will maintain the same file format as the input document.
        ///
        /// The naming format of error output files follows (for target language code
        /// [trg]): `error_output`: `gs://translation_test/a_b_c_[trg]_errors.txt`
        /// `glossary_error_output`:
        /// `gs://translation_test/a_b_c_[trg]_glossary_translation.txt`. The error
        /// output is a txt file containing error details.
        GcsDestination(std::boxed::Box<crate::model::GcsDestination>),
    }
}

/// Stored in the
/// [google.longrunning.Operation.response][google.longrunning.Operation.response]
/// field returned by BatchTranslateDocument if at least one document is
/// translated successfully.
///
/// [google.longrunning.Operation.response]: longrunning::model::Operation::result
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchTranslateDocumentResponse {
    /// Total number of pages to translate in all documents. Documents without
    /// clear page definition (such as XLSX) are not counted.
    pub total_pages: i64,

    /// Number of successfully translated pages in all documents. Documents without
    /// clear page definition (such as XLSX) are not counted.
    pub translated_pages: i64,

    /// Number of pages that failed to process in all documents. Documents without
    /// clear page definition (such as XLSX) are not counted.
    pub failed_pages: i64,

    /// Number of billable pages in documents with clear page definition (such as
    /// PDF, DOCX, PPTX)
    pub total_billable_pages: i64,

    /// Total number of characters (Unicode codepoints) in all documents.
    pub total_characters: i64,

    /// Number of successfully translated characters (Unicode codepoints) in all
    /// documents.
    pub translated_characters: i64,

    /// Number of characters that have failed to process (Unicode codepoints) in
    /// all documents.
    pub failed_characters: i64,

    /// Number of billable characters (Unicode codepoints) in documents without
    /// clear page definition, such as XLSX.
    pub total_billable_characters: i64,

    /// Time when the operation was submitted.
    pub submit_time: std::option::Option<wkt::Timestamp>,

    /// The time when the operation is finished and
    /// [google.longrunning.Operation.done][google.longrunning.Operation.done] is
    /// set to true.
    ///
    /// [google.longrunning.Operation.done]: longrunning::model::Operation::done
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchTranslateDocumentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_pages][crate::model::BatchTranslateDocumentResponse::total_pages].
    pub fn set_total_pages<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_pages = v.into();
        self
    }

    /// Sets the value of [translated_pages][crate::model::BatchTranslateDocumentResponse::translated_pages].
    pub fn set_translated_pages<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.translated_pages = v.into();
        self
    }

    /// Sets the value of [failed_pages][crate::model::BatchTranslateDocumentResponse::failed_pages].
    pub fn set_failed_pages<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failed_pages = v.into();
        self
    }

    /// Sets the value of [total_billable_pages][crate::model::BatchTranslateDocumentResponse::total_billable_pages].
    pub fn set_total_billable_pages<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_billable_pages = v.into();
        self
    }

    /// Sets the value of [total_characters][crate::model::BatchTranslateDocumentResponse::total_characters].
    pub fn set_total_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_characters = v.into();
        self
    }

    /// Sets the value of [translated_characters][crate::model::BatchTranslateDocumentResponse::translated_characters].
    pub fn set_translated_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.translated_characters = v.into();
        self
    }

    /// Sets the value of [failed_characters][crate::model::BatchTranslateDocumentResponse::failed_characters].
    pub fn set_failed_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failed_characters = v.into();
        self
    }

    /// Sets the value of [total_billable_characters][crate::model::BatchTranslateDocumentResponse::total_billable_characters].
    pub fn set_total_billable_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_billable_characters = v.into();
        self
    }

    /// Sets the value of [submit_time][crate::model::BatchTranslateDocumentResponse::submit_time].
    pub fn set_submit_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.submit_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [submit_time][crate::model::BatchTranslateDocumentResponse::submit_time].
    pub fn set_or_clear_submit_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.submit_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::BatchTranslateDocumentResponse::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::BatchTranslateDocumentResponse::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BatchTranslateDocumentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.BatchTranslateDocumentResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchTranslateDocumentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __total_pages,
            __translated_pages,
            __failed_pages,
            __total_billable_pages,
            __total_characters,
            __translated_characters,
            __failed_characters,
            __total_billable_characters,
            __submit_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchTranslateDocumentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "totalPages" => Ok(__FieldTag::__total_pages),
                            "total_pages" => Ok(__FieldTag::__total_pages),
                            "translatedPages" => Ok(__FieldTag::__translated_pages),
                            "translated_pages" => Ok(__FieldTag::__translated_pages),
                            "failedPages" => Ok(__FieldTag::__failed_pages),
                            "failed_pages" => Ok(__FieldTag::__failed_pages),
                            "totalBillablePages" => Ok(__FieldTag::__total_billable_pages),
                            "total_billable_pages" => Ok(__FieldTag::__total_billable_pages),
                            "totalCharacters" => Ok(__FieldTag::__total_characters),
                            "total_characters" => Ok(__FieldTag::__total_characters),
                            "translatedCharacters" => Ok(__FieldTag::__translated_characters),
                            "translated_characters" => Ok(__FieldTag::__translated_characters),
                            "failedCharacters" => Ok(__FieldTag::__failed_characters),
                            "failed_characters" => Ok(__FieldTag::__failed_characters),
                            "totalBillableCharacters" => {
                                Ok(__FieldTag::__total_billable_characters)
                            }
                            "total_billable_characters" => {
                                Ok(__FieldTag::__total_billable_characters)
                            }
                            "submitTime" => Ok(__FieldTag::__submit_time),
                            "submit_time" => Ok(__FieldTag::__submit_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchTranslateDocumentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchTranslateDocumentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__total_pages => {
                            if !fields.insert(__FieldTag::__total_pages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_pages",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_pages = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__translated_pages => {
                            if !fields.insert(__FieldTag::__translated_pages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for translated_pages",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.translated_pages =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__failed_pages => {
                            if !fields.insert(__FieldTag::__failed_pages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failed_pages",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.failed_pages = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_billable_pages => {
                            if !fields.insert(__FieldTag::__total_billable_pages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_billable_pages",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_billable_pages =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_characters => {
                            if !fields.insert(__FieldTag::__total_characters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_characters",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_characters =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__translated_characters => {
                            if !fields.insert(__FieldTag::__translated_characters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for translated_characters",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.translated_characters =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__failed_characters => {
                            if !fields.insert(__FieldTag::__failed_characters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failed_characters",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.failed_characters =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_billable_characters => {
                            if !fields.insert(__FieldTag::__total_billable_characters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_billable_characters",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_billable_characters =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__submit_time => {
                            if !fields.insert(__FieldTag::__submit_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for submit_time",
                                ));
                            }
                            result.submit_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchTranslateDocumentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.total_pages) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalPages", &__With(&self.total_pages))?;
        }
        if !wkt::internal::is_default(&self.translated_pages) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("translatedPages", &__With(&self.translated_pages))?;
        }
        if !wkt::internal::is_default(&self.failed_pages) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failedPages", &__With(&self.failed_pages))?;
        }
        if !wkt::internal::is_default(&self.total_billable_pages) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalBillablePages", &__With(&self.total_billable_pages))?;
        }
        if !wkt::internal::is_default(&self.total_characters) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalCharacters", &__With(&self.total_characters))?;
        }
        if !wkt::internal::is_default(&self.translated_characters) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("translatedCharacters", &__With(&self.translated_characters))?;
        }
        if !wkt::internal::is_default(&self.failed_characters) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failedCharacters", &__With(&self.failed_characters))?;
        }
        if !wkt::internal::is_default(&self.total_billable_characters) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "totalBillableCharacters",
                &__With(&self.total_billable_characters),
            )?;
        }
        if self.submit_time.is_some() {
            state.serialize_entry("submitTime", &self.submit_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// State metadata for the batch translation operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchTranslateDocumentMetadata {
    /// The state of the operation.
    pub state: crate::model::batch_translate_document_metadata::State,

    /// Total number of pages to translate in all documents so far. Documents
    /// without clear page definition (such as XLSX) are not counted.
    pub total_pages: i64,

    /// Number of successfully translated pages in all documents so far. Documents
    /// without clear page definition (such as XLSX) are not counted.
    pub translated_pages: i64,

    /// Number of pages that failed to process in all documents so far. Documents
    /// without clear page definition (such as XLSX) are not counted.
    pub failed_pages: i64,

    /// Number of billable pages in documents with clear page definition (such as
    /// PDF, DOCX, PPTX) so far.
    pub total_billable_pages: i64,

    /// Total number of characters (Unicode codepoints) in all documents so far.
    pub total_characters: i64,

    /// Number of successfully translated characters (Unicode codepoints) in all
    /// documents so far.
    pub translated_characters: i64,

    /// Number of characters that have failed to process (Unicode codepoints) in
    /// all documents so far.
    pub failed_characters: i64,

    /// Number of billable characters (Unicode codepoints) in documents without
    /// clear page definition (such as XLSX) so far.
    pub total_billable_characters: i64,

    /// Time when the operation was submitted.
    pub submit_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchTranslateDocumentMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::BatchTranslateDocumentMetadata::state].
    pub fn set_state<
        T: std::convert::Into<crate::model::batch_translate_document_metadata::State>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [total_pages][crate::model::BatchTranslateDocumentMetadata::total_pages].
    pub fn set_total_pages<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_pages = v.into();
        self
    }

    /// Sets the value of [translated_pages][crate::model::BatchTranslateDocumentMetadata::translated_pages].
    pub fn set_translated_pages<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.translated_pages = v.into();
        self
    }

    /// Sets the value of [failed_pages][crate::model::BatchTranslateDocumentMetadata::failed_pages].
    pub fn set_failed_pages<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failed_pages = v.into();
        self
    }

    /// Sets the value of [total_billable_pages][crate::model::BatchTranslateDocumentMetadata::total_billable_pages].
    pub fn set_total_billable_pages<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_billable_pages = v.into();
        self
    }

    /// Sets the value of [total_characters][crate::model::BatchTranslateDocumentMetadata::total_characters].
    pub fn set_total_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_characters = v.into();
        self
    }

    /// Sets the value of [translated_characters][crate::model::BatchTranslateDocumentMetadata::translated_characters].
    pub fn set_translated_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.translated_characters = v.into();
        self
    }

    /// Sets the value of [failed_characters][crate::model::BatchTranslateDocumentMetadata::failed_characters].
    pub fn set_failed_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failed_characters = v.into();
        self
    }

    /// Sets the value of [total_billable_characters][crate::model::BatchTranslateDocumentMetadata::total_billable_characters].
    pub fn set_total_billable_characters<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_billable_characters = v.into();
        self
    }

    /// Sets the value of [submit_time][crate::model::BatchTranslateDocumentMetadata::submit_time].
    pub fn set_submit_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.submit_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [submit_time][crate::model::BatchTranslateDocumentMetadata::submit_time].
    pub fn set_or_clear_submit_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.submit_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BatchTranslateDocumentMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.BatchTranslateDocumentMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchTranslateDocumentMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __total_pages,
            __translated_pages,
            __failed_pages,
            __total_billable_pages,
            __total_characters,
            __translated_characters,
            __failed_characters,
            __total_billable_characters,
            __submit_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchTranslateDocumentMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "totalPages" => Ok(__FieldTag::__total_pages),
                            "total_pages" => Ok(__FieldTag::__total_pages),
                            "translatedPages" => Ok(__FieldTag::__translated_pages),
                            "translated_pages" => Ok(__FieldTag::__translated_pages),
                            "failedPages" => Ok(__FieldTag::__failed_pages),
                            "failed_pages" => Ok(__FieldTag::__failed_pages),
                            "totalBillablePages" => Ok(__FieldTag::__total_billable_pages),
                            "total_billable_pages" => Ok(__FieldTag::__total_billable_pages),
                            "totalCharacters" => Ok(__FieldTag::__total_characters),
                            "total_characters" => Ok(__FieldTag::__total_characters),
                            "translatedCharacters" => Ok(__FieldTag::__translated_characters),
                            "translated_characters" => Ok(__FieldTag::__translated_characters),
                            "failedCharacters" => Ok(__FieldTag::__failed_characters),
                            "failed_characters" => Ok(__FieldTag::__failed_characters),
                            "totalBillableCharacters" => {
                                Ok(__FieldTag::__total_billable_characters)
                            }
                            "total_billable_characters" => {
                                Ok(__FieldTag::__total_billable_characters)
                            }
                            "submitTime" => Ok(__FieldTag::__submit_time),
                            "submit_time" => Ok(__FieldTag::__submit_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchTranslateDocumentMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchTranslateDocumentMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<
                                    crate::model::batch_translate_document_metadata::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_pages => {
                            if !fields.insert(__FieldTag::__total_pages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_pages",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_pages = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__translated_pages => {
                            if !fields.insert(__FieldTag::__translated_pages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for translated_pages",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.translated_pages =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__failed_pages => {
                            if !fields.insert(__FieldTag::__failed_pages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failed_pages",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.failed_pages = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_billable_pages => {
                            if !fields.insert(__FieldTag::__total_billable_pages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_billable_pages",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_billable_pages =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_characters => {
                            if !fields.insert(__FieldTag::__total_characters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_characters",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_characters =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__translated_characters => {
                            if !fields.insert(__FieldTag::__translated_characters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for translated_characters",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.translated_characters =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__failed_characters => {
                            if !fields.insert(__FieldTag::__failed_characters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failed_characters",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.failed_characters =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_billable_characters => {
                            if !fields.insert(__FieldTag::__total_billable_characters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_billable_characters",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_billable_characters =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__submit_time => {
                            if !fields.insert(__FieldTag::__submit_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for submit_time",
                                ));
                            }
                            result.submit_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchTranslateDocumentMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.total_pages) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalPages", &__With(&self.total_pages))?;
        }
        if !wkt::internal::is_default(&self.translated_pages) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("translatedPages", &__With(&self.translated_pages))?;
        }
        if !wkt::internal::is_default(&self.failed_pages) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failedPages", &__With(&self.failed_pages))?;
        }
        if !wkt::internal::is_default(&self.total_billable_pages) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalBillablePages", &__With(&self.total_billable_pages))?;
        }
        if !wkt::internal::is_default(&self.total_characters) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalCharacters", &__With(&self.total_characters))?;
        }
        if !wkt::internal::is_default(&self.translated_characters) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("translatedCharacters", &__With(&self.translated_characters))?;
        }
        if !wkt::internal::is_default(&self.failed_characters) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failedCharacters", &__With(&self.failed_characters))?;
        }
        if !wkt::internal::is_default(&self.total_billable_characters) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "totalBillableCharacters",
                &__With(&self.total_billable_characters),
            )?;
        }
        if self.submit_time.is_some() {
            state.serialize_entry("submitTime", &self.submit_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BatchTranslateDocumentMetadata].
pub mod batch_translate_document_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// State of the job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Invalid.
        Unspecified,
        /// Request is being processed.
        Running,
        /// The batch is processed, and at least one item was successfully processed.
        Succeeded,
        /// The batch is done and no item was successfully processed.
        Failed,
        /// Request is in the process of being canceled after caller invoked
        /// longrunning.Operations.CancelOperation on the request id.
        Cancelling,
        /// The batch is done after the user has called the
        /// longrunning.Operations.CancelOperation. Any records processed before the
        /// cancel command are output as specified in the request.
        Cancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Cancelling => std::option::Option::Some(4),
                Self::Cancelled => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Succeeded,
                3 => Self::Failed,
                4 => Self::Cancelling,
                5 => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "CANCELLING" => Self::Cancelling,
                "CANCELLED" => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Cancelling => serializer.serialize_i32(4),
                Self::Cancelled => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.translation.v3.BatchTranslateDocumentMetadata.State",
            ))
        }
    }
}

/// Configures which glossary is used for a specific target language and defines
/// options for applying that glossary.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TranslateTextGlossaryConfig {
    /// Required. The `glossary` to be applied for this translation.
    ///
    /// The format depends on the glossary:
    ///
    /// - User-provided custom glossary:
    ///   `projects/{project-number-or-id}/locations/{location-id}/glossaries/{glossary-id}`
    pub glossary: std::string::String,

    /// Optional. Indicates match is case insensitive. The default value is `false`
    /// if missing.
    pub ignore_case: bool,

    /// Optional. If set to true, the glossary will be used for contextual
    /// translation.
    pub contextual_translation_enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TranslateTextGlossaryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [glossary][crate::model::TranslateTextGlossaryConfig::glossary].
    pub fn set_glossary<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.glossary = v.into();
        self
    }

    /// Sets the value of [ignore_case][crate::model::TranslateTextGlossaryConfig::ignore_case].
    pub fn set_ignore_case<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_case = v.into();
        self
    }

    /// Sets the value of [contextual_translation_enabled][crate::model::TranslateTextGlossaryConfig::contextual_translation_enabled].
    pub fn set_contextual_translation_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.contextual_translation_enabled = v.into();
        self
    }
}

impl wkt::message::Message for TranslateTextGlossaryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.translation.v3.TranslateTextGlossaryConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TranslateTextGlossaryConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __glossary,
            __ignore_case,
            __contextual_translation_enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TranslateTextGlossaryConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "glossary" => Ok(__FieldTag::__glossary),
                            "ignoreCase" => Ok(__FieldTag::__ignore_case),
                            "ignore_case" => Ok(__FieldTag::__ignore_case),
                            "contextualTranslationEnabled" => {
                                Ok(__FieldTag::__contextual_translation_enabled)
                            }
                            "contextual_translation_enabled" => {
                                Ok(__FieldTag::__contextual_translation_enabled)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TranslateTextGlossaryConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TranslateTextGlossaryConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__glossary => {
                            if !fields.insert(__FieldTag::__glossary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for glossary",
                                ));
                            }
                            result.glossary = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore_case => {
                            if !fields.insert(__FieldTag::__ignore_case) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_case",
                                ));
                            }
                            result.ignore_case = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__contextual_translation_enabled => {
                            if !fields.insert(__FieldTag::__contextual_translation_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contextual_translation_enabled",
                                ));
                            }
                            result.contextual_translation_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TranslateTextGlossaryConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.glossary.is_empty() {
            state.serialize_entry("glossary", &self.glossary)?;
        }
        if !wkt::internal::is_default(&self.ignore_case) {
            state.serialize_entry("ignoreCase", &self.ignore_case)?;
        }
        if !wkt::internal::is_default(&self.contextual_translation_enabled) {
            state.serialize_entry(
                "contextualTranslationEnabled",
                &self.contextual_translation_enabled,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Possible states of long running operations.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum OperationState {
    /// Invalid.
    Unspecified,
    /// Request is being processed.
    Running,
    /// The operation was successful.
    Succeeded,
    /// Failed to process operation.
    Failed,
    /// Request is in the process of being canceled after caller invoked
    /// longrunning.Operations.CancelOperation on the request id.
    Cancelling,
    /// The operation request was successfully canceled.
    Cancelled,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [OperationState::value] or
    /// [OperationState::name].
    UnknownValue(operation_state::UnknownValue),
}

#[doc(hidden)]
pub mod operation_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl OperationState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Running => std::option::Option::Some(1),
            Self::Succeeded => std::option::Option::Some(2),
            Self::Failed => std::option::Option::Some(3),
            Self::Cancelling => std::option::Option::Some(4),
            Self::Cancelled => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("OPERATION_STATE_UNSPECIFIED"),
            Self::Running => std::option::Option::Some("OPERATION_STATE_RUNNING"),
            Self::Succeeded => std::option::Option::Some("OPERATION_STATE_SUCCEEDED"),
            Self::Failed => std::option::Option::Some("OPERATION_STATE_FAILED"),
            Self::Cancelling => std::option::Option::Some("OPERATION_STATE_CANCELLING"),
            Self::Cancelled => std::option::Option::Some("OPERATION_STATE_CANCELLED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for OperationState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for OperationState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for OperationState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Running,
            2 => Self::Succeeded,
            3 => Self::Failed,
            4 => Self::Cancelling,
            5 => Self::Cancelled,
            _ => Self::UnknownValue(operation_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for OperationState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "OPERATION_STATE_UNSPECIFIED" => Self::Unspecified,
            "OPERATION_STATE_RUNNING" => Self::Running,
            "OPERATION_STATE_SUCCEEDED" => Self::Succeeded,
            "OPERATION_STATE_FAILED" => Self::Failed,
            "OPERATION_STATE_CANCELLING" => Self::Cancelling,
            "OPERATION_STATE_CANCELLED" => Self::Cancelled,
            _ => Self::UnknownValue(operation_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for OperationState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Running => serializer.serialize_i32(1),
            Self::Succeeded => serializer.serialize_i32(2),
            Self::Failed => serializer.serialize_i32(3),
            Self::Cancelling => serializer.serialize_i32(4),
            Self::Cancelled => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for OperationState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<OperationState>::new(
            ".google.cloud.translation.v3.OperationState",
        ))
    }
}
