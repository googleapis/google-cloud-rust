// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for super::AutoscalingPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutoscalingPolicy");
        debug_struct.field("id", &self.id);
        debug_struct.field("name", &self.name);
        debug_struct.field("worker_config", &self.worker_config);
        debug_struct.field("secondary_worker_config", &self.secondary_worker_config);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("algorithm", &self.algorithm);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BasicAutoscalingAlgorithm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BasicAutoscalingAlgorithm");
        debug_struct.field("cooldown_period", &self.cooldown_period);
        debug_struct.field("config", &self.config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BasicYarnAutoscalingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BasicYarnAutoscalingConfig");
        debug_struct.field(
            "graceful_decommission_timeout",
            &self.graceful_decommission_timeout,
        );
        debug_struct.field("scale_up_factor", &self.scale_up_factor);
        debug_struct.field("scale_down_factor", &self.scale_down_factor);
        debug_struct.field(
            "scale_up_min_worker_fraction",
            &self.scale_up_min_worker_fraction,
        );
        debug_struct.field(
            "scale_down_min_worker_fraction",
            &self.scale_down_min_worker_fraction,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstanceGroupAutoscalingPolicyConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstanceGroupAutoscalingPolicyConfig");
        debug_struct.field("min_instances", &self.min_instances);
        debug_struct.field("max_instances", &self.max_instances);
        debug_struct.field("weight", &self.weight);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateAutoscalingPolicyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateAutoscalingPolicyRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("policy", &self.policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetAutoscalingPolicyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetAutoscalingPolicyRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateAutoscalingPolicyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateAutoscalingPolicyRequest");
        debug_struct.field("policy", &self.policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteAutoscalingPolicyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteAutoscalingPolicyRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListAutoscalingPoliciesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAutoscalingPoliciesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListAutoscalingPoliciesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAutoscalingPoliciesResponse");
        debug_struct.field("policies", &self.policies);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateBatchRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateBatchRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("batch", &self.batch);
        debug_struct.field("batch_id", &self.batch_id);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetBatchRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetBatchRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListBatchesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBatchesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListBatchesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBatchesResponse");
        debug_struct.field("batches", &self.batches);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteBatchRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteBatchRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Batch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Batch");
        debug_struct.field("name", &self.name);
        debug_struct.field("uuid", &self.uuid);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("runtime_info", &self.runtime_info);
        debug_struct.field("state", &self.state);
        debug_struct.field("state_message", &self.state_message);
        debug_struct.field("state_time", &self.state_time);
        debug_struct.field("creator", &self.creator);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("runtime_config", &self.runtime_config);
        debug_struct.field("environment_config", &self.environment_config);
        debug_struct.field("operation", &self.operation);
        debug_struct.field("state_history", &self.state_history);
        debug_struct.field("batch_config", &self.batch_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::batch::StateHistory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StateHistory");
        debug_struct.field("state", &self.state);
        debug_struct.field("state_message", &self.state_message);
        debug_struct.field("state_start_time", &self.state_start_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PySparkBatch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PySparkBatch");
        debug_struct.field("main_python_file_uri", &self.main_python_file_uri);
        debug_struct.field("args", &self.args);
        debug_struct.field("python_file_uris", &self.python_file_uris);
        debug_struct.field("jar_file_uris", &self.jar_file_uris);
        debug_struct.field("file_uris", &self.file_uris);
        debug_struct.field("archive_uris", &self.archive_uris);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SparkBatch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SparkBatch");
        debug_struct.field("args", &self.args);
        debug_struct.field("jar_file_uris", &self.jar_file_uris);
        debug_struct.field("file_uris", &self.file_uris);
        debug_struct.field("archive_uris", &self.archive_uris);
        debug_struct.field("driver", &self.driver);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SparkRBatch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SparkRBatch");
        debug_struct.field("main_r_file_uri", &self.main_r_file_uri);
        debug_struct.field("args", &self.args);
        debug_struct.field("file_uris", &self.file_uris);
        debug_struct.field("archive_uris", &self.archive_uris);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SparkSqlBatch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SparkSqlBatch");
        debug_struct.field("query_file_uri", &self.query_file_uri);
        debug_struct.field("query_variables", &self.query_variables);
        debug_struct.field("jar_file_uris", &self.jar_file_uris);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Cluster {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Cluster");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("cluster_name", &self.cluster_name);
        debug_struct.field("config", &self.config);
        debug_struct.field("virtual_cluster_config", &self.virtual_cluster_config);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("status", &self.status);
        debug_struct.field("status_history", &self.status_history);
        debug_struct.field("cluster_uuid", &self.cluster_uuid);
        debug_struct.field("metrics", &self.metrics);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ClusterConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClusterConfig");
        debug_struct.field("cluster_tier", &self.cluster_tier);
        debug_struct.field("config_bucket", &self.config_bucket);
        debug_struct.field("temp_bucket", &self.temp_bucket);
        debug_struct.field("gce_cluster_config", &self.gce_cluster_config);
        debug_struct.field("master_config", &self.master_config);
        debug_struct.field("worker_config", &self.worker_config);
        debug_struct.field("secondary_worker_config", &self.secondary_worker_config);
        debug_struct.field("software_config", &self.software_config);
        debug_struct.field("initialization_actions", &self.initialization_actions);
        debug_struct.field("encryption_config", &self.encryption_config);
        debug_struct.field("autoscaling_config", &self.autoscaling_config);
        debug_struct.field("security_config", &self.security_config);
        debug_struct.field("lifecycle_config", &self.lifecycle_config);
        debug_struct.field("endpoint_config", &self.endpoint_config);
        debug_struct.field("metastore_config", &self.metastore_config);
        debug_struct.field("dataproc_metric_config", &self.dataproc_metric_config);
        debug_struct.field("auxiliary_node_groups", &self.auxiliary_node_groups);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::VirtualClusterConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VirtualClusterConfig");
        debug_struct.field("staging_bucket", &self.staging_bucket);
        debug_struct.field("auxiliary_services_config", &self.auxiliary_services_config);
        debug_struct.field("infrastructure_config", &self.infrastructure_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AuxiliaryServicesConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AuxiliaryServicesConfig");
        debug_struct.field("metastore_config", &self.metastore_config);
        debug_struct.field(
            "spark_history_server_config",
            &self.spark_history_server_config,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EndpointConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EndpointConfig");
        debug_struct.field("http_ports", &self.http_ports);
        debug_struct.field("enable_http_port_access", &self.enable_http_port_access);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AutoscalingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutoscalingConfig");
        debug_struct.field("policy_uri", &self.policy_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EncryptionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EncryptionConfig");
        debug_struct.field("gce_pd_kms_key_name", &self.gce_pd_kms_key_name);
        debug_struct.field("kms_key", &self.kms_key);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GceClusterConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GceClusterConfig");
        debug_struct.field("zone_uri", &self.zone_uri);
        debug_struct.field("network_uri", &self.network_uri);
        debug_struct.field("subnetwork_uri", &self.subnetwork_uri);
        debug_struct.field("internal_ip_only", &self.internal_ip_only);
        debug_struct.field(
            "private_ipv6_google_access",
            &self.private_ipv6_google_access,
        );
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("service_account_scopes", &self.service_account_scopes);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("reservation_affinity", &self.reservation_affinity);
        debug_struct.field("node_group_affinity", &self.node_group_affinity);
        debug_struct.field("shielded_instance_config", &self.shielded_instance_config);
        debug_struct.field(
            "confidential_instance_config",
            &self.confidential_instance_config,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NodeGroupAffinity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeGroupAffinity");
        debug_struct.field("node_group_uri", &self.node_group_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ShieldedInstanceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ShieldedInstanceConfig");
        debug_struct.field("enable_secure_boot", &self.enable_secure_boot);
        debug_struct.field("enable_vtpm", &self.enable_vtpm);
        debug_struct.field(
            "enable_integrity_monitoring",
            &self.enable_integrity_monitoring,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ConfidentialInstanceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConfidentialInstanceConfig");
        debug_struct.field(
            "enable_confidential_compute",
            &self.enable_confidential_compute,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstanceGroupConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstanceGroupConfig");
        debug_struct.field("num_instances", &self.num_instances);
        debug_struct.field("instance_names", &self.instance_names);
        debug_struct.field("instance_references", &self.instance_references);
        debug_struct.field("image_uri", &self.image_uri);
        debug_struct.field("machine_type_uri", &self.machine_type_uri);
        debug_struct.field("disk_config", &self.disk_config);
        debug_struct.field("is_preemptible", &self.is_preemptible);
        debug_struct.field("preemptibility", &self.preemptibility);
        debug_struct.field("managed_group_config", &self.managed_group_config);
        debug_struct.field("accelerators", &self.accelerators);
        debug_struct.field("min_cpu_platform", &self.min_cpu_platform);
        debug_struct.field("min_num_instances", &self.min_num_instances);
        debug_struct.field(
            "instance_flexibility_policy",
            &self.instance_flexibility_policy,
        );
        debug_struct.field("startup_config", &self.startup_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StartupConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StartupConfig");
        debug_struct.field(
            "required_registration_fraction",
            &self.required_registration_fraction,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstanceReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstanceReference");
        debug_struct.field("instance_name", &self.instance_name);
        debug_struct.field("instance_id", &self.instance_id);
        debug_struct.field("public_key", &self.public_key);
        debug_struct.field("public_ecies_key", &self.public_ecies_key);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ManagedGroupConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ManagedGroupConfig");
        debug_struct.field("instance_template_name", &self.instance_template_name);
        debug_struct.field(
            "instance_group_manager_name",
            &self.instance_group_manager_name,
        );
        debug_struct.field(
            "instance_group_manager_uri",
            &self.instance_group_manager_uri,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstanceFlexibilityPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstanceFlexibilityPolicy");
        debug_struct.field("provisioning_model_mix", &self.provisioning_model_mix);
        debug_struct.field("instance_selection_list", &self.instance_selection_list);
        debug_struct.field(
            "instance_selection_results",
            &self.instance_selection_results,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::instance_flexibility_policy::ProvisioningModelMix {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProvisioningModelMix");
        debug_struct.field("standard_capacity_base", &self.standard_capacity_base);
        debug_struct.field(
            "standard_capacity_percent_above_base",
            &self.standard_capacity_percent_above_base,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::instance_flexibility_policy::InstanceSelection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstanceSelection");
        debug_struct.field("machine_types", &self.machine_types);
        debug_struct.field("rank", &self.rank);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::instance_flexibility_policy::InstanceSelectionResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstanceSelectionResult");
        debug_struct.field("machine_type", &self.machine_type);
        debug_struct.field("vm_count", &self.vm_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AcceleratorConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AcceleratorConfig");
        debug_struct.field("accelerator_type_uri", &self.accelerator_type_uri);
        debug_struct.field("accelerator_count", &self.accelerator_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DiskConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiskConfig");
        debug_struct.field("boot_disk_type", &self.boot_disk_type);
        debug_struct.field("boot_disk_size_gb", &self.boot_disk_size_gb);
        debug_struct.field("num_local_ssds", &self.num_local_ssds);
        debug_struct.field("local_ssd_interface", &self.local_ssd_interface);
        debug_struct.field(
            "boot_disk_provisioned_iops",
            &self.boot_disk_provisioned_iops,
        );
        debug_struct.field(
            "boot_disk_provisioned_throughput",
            &self.boot_disk_provisioned_throughput,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AuxiliaryNodeGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AuxiliaryNodeGroup");
        debug_struct.field("node_group", &self.node_group);
        debug_struct.field("node_group_id", &self.node_group_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NodeGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeGroup");
        debug_struct.field("name", &self.name);
        debug_struct.field("roles", &self.roles);
        debug_struct.field("node_group_config", &self.node_group_config);
        debug_struct.field("labels", &self.labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NodeInitializationAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeInitializationAction");
        debug_struct.field("executable_file", &self.executable_file);
        debug_struct.field("execution_timeout", &self.execution_timeout);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ClusterStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClusterStatus");
        debug_struct.field("state", &self.state);
        debug_struct.field("detail", &self.detail);
        debug_struct.field("state_start_time", &self.state_start_time);
        debug_struct.field("substate", &self.substate);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SecurityConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecurityConfig");
        debug_struct.field("kerberos_config", &self.kerberos_config);
        debug_struct.field("identity_config", &self.identity_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::KerberosConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("KerberosConfig");
        debug_struct.field("enable_kerberos", &self.enable_kerberos);
        debug_struct.field(
            "root_principal_password_uri",
            &self.root_principal_password_uri,
        );
        debug_struct.field("kms_key_uri", &self.kms_key_uri);
        debug_struct.field("keystore_uri", &self.keystore_uri);
        debug_struct.field("truststore_uri", &self.truststore_uri);
        debug_struct.field("keystore_password_uri", &self.keystore_password_uri);
        debug_struct.field("key_password_uri", &self.key_password_uri);
        debug_struct.field("truststore_password_uri", &self.truststore_password_uri);
        debug_struct.field("cross_realm_trust_realm", &self.cross_realm_trust_realm);
        debug_struct.field("cross_realm_trust_kdc", &self.cross_realm_trust_kdc);
        debug_struct.field(
            "cross_realm_trust_admin_server",
            &self.cross_realm_trust_admin_server,
        );
        debug_struct.field(
            "cross_realm_trust_shared_password_uri",
            &self.cross_realm_trust_shared_password_uri,
        );
        debug_struct.field("kdc_db_key_uri", &self.kdc_db_key_uri);
        debug_struct.field("tgt_lifetime_hours", &self.tgt_lifetime_hours);
        debug_struct.field("realm", &self.realm);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::IdentityConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IdentityConfig");
        debug_struct.field(
            "user_service_account_mapping",
            &self.user_service_account_mapping,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SoftwareConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SoftwareConfig");
        debug_struct.field("image_version", &self.image_version);
        debug_struct.field("properties", &self.properties);
        debug_struct.field("optional_components", &self.optional_components);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LifecycleConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LifecycleConfig");
        debug_struct.field("idle_delete_ttl", &self.idle_delete_ttl);
        debug_struct.field("idle_start_time", &self.idle_start_time);
        debug_struct.field("ttl", &self.ttl);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MetastoreConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MetastoreConfig");
        debug_struct.field(
            "dataproc_metastore_service",
            &self.dataproc_metastore_service,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ClusterMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClusterMetrics");
        debug_struct.field("hdfs_metrics", &self.hdfs_metrics);
        debug_struct.field("yarn_metrics", &self.yarn_metrics);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DataprocMetricConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataprocMetricConfig");
        debug_struct.field("metrics", &self.metrics);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::dataproc_metric_config::Metric {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Metric");
        debug_struct.field("metric_source", &self.metric_source);
        debug_struct.field("metric_overrides", &self.metric_overrides);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateClusterRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("region", &self.region);
        debug_struct.field("cluster", &self.cluster);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field(
            "action_on_failed_primary_workers",
            &self.action_on_failed_primary_workers,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateClusterRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("region", &self.region);
        debug_struct.field("cluster_name", &self.cluster_name);
        debug_struct.field("cluster", &self.cluster);
        debug_struct.field(
            "graceful_decommission_timeout",
            &self.graceful_decommission_timeout,
        );
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StopClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StopClusterRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("region", &self.region);
        debug_struct.field("cluster_name", &self.cluster_name);
        debug_struct.field("cluster_uuid", &self.cluster_uuid);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StartClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StartClusterRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("region", &self.region);
        debug_struct.field("cluster_name", &self.cluster_name);
        debug_struct.field("cluster_uuid", &self.cluster_uuid);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteClusterRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("region", &self.region);
        debug_struct.field("cluster_name", &self.cluster_name);
        debug_struct.field("cluster_uuid", &self.cluster_uuid);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetClusterRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("region", &self.region);
        debug_struct.field("cluster_name", &self.cluster_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListClustersRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListClustersRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("region", &self.region);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListClustersResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListClustersResponse");
        debug_struct.field("clusters", &self.clusters);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DiagnoseClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiagnoseClusterRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("region", &self.region);
        debug_struct.field("cluster_name", &self.cluster_name);
        debug_struct.field("tarball_gcs_dir", &self.tarball_gcs_dir);
        debug_struct.field("tarball_access", &self.tarball_access);
        debug_struct.field("diagnosis_interval", &self.diagnosis_interval);
        debug_struct.field("jobs", &self.jobs);
        debug_struct.field("yarn_application_ids", &self.yarn_application_ids);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DiagnoseClusterResults {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiagnoseClusterResults");
        debug_struct.field("output_uri", &self.output_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ReservationAffinity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReservationAffinity");
        debug_struct.field("consume_reservation_type", &self.consume_reservation_type);
        debug_struct.field("key", &self.key);
        debug_struct.field("values", &self.values);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LoggingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoggingConfig");
        debug_struct.field("driver_log_levels", &self.driver_log_levels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::HadoopJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HadoopJob");
        debug_struct.field("args", &self.args);
        debug_struct.field("jar_file_uris", &self.jar_file_uris);
        debug_struct.field("file_uris", &self.file_uris);
        debug_struct.field("archive_uris", &self.archive_uris);
        debug_struct.field("properties", &self.properties);
        debug_struct.field("logging_config", &self.logging_config);
        debug_struct.field("driver", &self.driver);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SparkJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SparkJob");
        debug_struct.field("args", &self.args);
        debug_struct.field("jar_file_uris", &self.jar_file_uris);
        debug_struct.field("file_uris", &self.file_uris);
        debug_struct.field("archive_uris", &self.archive_uris);
        debug_struct.field("properties", &self.properties);
        debug_struct.field("logging_config", &self.logging_config);
        debug_struct.field("driver", &self.driver);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PySparkJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PySparkJob");
        debug_struct.field("main_python_file_uri", &self.main_python_file_uri);
        debug_struct.field("args", &self.args);
        debug_struct.field("python_file_uris", &self.python_file_uris);
        debug_struct.field("jar_file_uris", &self.jar_file_uris);
        debug_struct.field("file_uris", &self.file_uris);
        debug_struct.field("archive_uris", &self.archive_uris);
        debug_struct.field("properties", &self.properties);
        debug_struct.field("logging_config", &self.logging_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::QueryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QueryList");
        debug_struct.field("queries", &self.queries);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::HiveJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HiveJob");
        debug_struct.field("continue_on_failure", &self.continue_on_failure);
        debug_struct.field("script_variables", &self.script_variables);
        debug_struct.field("properties", &self.properties);
        debug_struct.field("jar_file_uris", &self.jar_file_uris);
        debug_struct.field("queries", &self.queries);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SparkSqlJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SparkSqlJob");
        debug_struct.field("script_variables", &self.script_variables);
        debug_struct.field("properties", &self.properties);
        debug_struct.field("jar_file_uris", &self.jar_file_uris);
        debug_struct.field("logging_config", &self.logging_config);
        debug_struct.field("queries", &self.queries);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PigJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PigJob");
        debug_struct.field("continue_on_failure", &self.continue_on_failure);
        debug_struct.field("script_variables", &self.script_variables);
        debug_struct.field("properties", &self.properties);
        debug_struct.field("jar_file_uris", &self.jar_file_uris);
        debug_struct.field("logging_config", &self.logging_config);
        debug_struct.field("queries", &self.queries);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SparkRJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SparkRJob");
        debug_struct.field("main_r_file_uri", &self.main_r_file_uri);
        debug_struct.field("args", &self.args);
        debug_struct.field("file_uris", &self.file_uris);
        debug_struct.field("archive_uris", &self.archive_uris);
        debug_struct.field("properties", &self.properties);
        debug_struct.field("logging_config", &self.logging_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PrestoJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrestoJob");
        debug_struct.field("continue_on_failure", &self.continue_on_failure);
        debug_struct.field("output_format", &self.output_format);
        debug_struct.field("client_tags", &self.client_tags);
        debug_struct.field("properties", &self.properties);
        debug_struct.field("logging_config", &self.logging_config);
        debug_struct.field("queries", &self.queries);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TrinoJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TrinoJob");
        debug_struct.field("continue_on_failure", &self.continue_on_failure);
        debug_struct.field("output_format", &self.output_format);
        debug_struct.field("client_tags", &self.client_tags);
        debug_struct.field("properties", &self.properties);
        debug_struct.field("logging_config", &self.logging_config);
        debug_struct.field("queries", &self.queries);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FlinkJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FlinkJob");
        debug_struct.field("args", &self.args);
        debug_struct.field("jar_file_uris", &self.jar_file_uris);
        debug_struct.field("savepoint_uri", &self.savepoint_uri);
        debug_struct.field("properties", &self.properties);
        debug_struct.field("logging_config", &self.logging_config);
        debug_struct.field("driver", &self.driver);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JobPlacement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobPlacement");
        debug_struct.field("cluster_name", &self.cluster_name);
        debug_struct.field("cluster_uuid", &self.cluster_uuid);
        debug_struct.field("cluster_labels", &self.cluster_labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JobStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobStatus");
        debug_struct.field("state", &self.state);
        debug_struct.field("details", &self.details);
        debug_struct.field("state_start_time", &self.state_start_time);
        debug_struct.field("substate", &self.substate);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JobReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobReference");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("job_id", &self.job_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::YarnApplication {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("YarnApplication");
        debug_struct.field("name", &self.name);
        debug_struct.field("state", &self.state);
        debug_struct.field("progress", &self.progress);
        debug_struct.field("tracking_url", &self.tracking_url);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Job {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Job");
        debug_struct.field("reference", &self.reference);
        debug_struct.field("placement", &self.placement);
        debug_struct.field("status", &self.status);
        debug_struct.field("status_history", &self.status_history);
        debug_struct.field("yarn_applications", &self.yarn_applications);
        debug_struct.field(
            "driver_output_resource_uri",
            &self.driver_output_resource_uri,
        );
        debug_struct.field("driver_control_files_uri", &self.driver_control_files_uri);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("scheduling", &self.scheduling);
        debug_struct.field("job_uuid", &self.job_uuid);
        debug_struct.field("done", &self.done);
        debug_struct.field("driver_scheduling_config", &self.driver_scheduling_config);
        debug_struct.field("type_job", &self.type_job);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DriverSchedulingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DriverSchedulingConfig");
        debug_struct.field("memory_mb", &self.memory_mb);
        debug_struct.field("vcores", &self.vcores);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JobScheduling {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobScheduling");
        debug_struct.field("max_failures_per_hour", &self.max_failures_per_hour);
        debug_struct.field("max_failures_total", &self.max_failures_total);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SubmitJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SubmitJobRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("region", &self.region);
        debug_struct.field("job", &self.job);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JobMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JobMetadata");
        debug_struct.field("job_id", &self.job_id);
        debug_struct.field("status", &self.status);
        debug_struct.field("operation_type", &self.operation_type);
        debug_struct.field("start_time", &self.start_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetJobRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("region", &self.region);
        debug_struct.field("job_id", &self.job_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListJobsRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("region", &self.region);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("cluster_name", &self.cluster_name);
        debug_struct.field("job_state_matcher", &self.job_state_matcher);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateJobRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("region", &self.region);
        debug_struct.field("job_id", &self.job_id);
        debug_struct.field("job", &self.job);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListJobsResponse");
        debug_struct.field("jobs", &self.jobs);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CancelJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelJobRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("region", &self.region);
        debug_struct.field("job_id", &self.job_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteJobRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("region", &self.region);
        debug_struct.field("job_id", &self.job_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateNodeGroupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateNodeGroupRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("node_group", &self.node_group);
        debug_struct.field("node_group_id", &self.node_group_id);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ResizeNodeGroupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResizeNodeGroupRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("size", &self.size);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field(
            "graceful_decommission_timeout",
            &self.graceful_decommission_timeout,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetNodeGroupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetNodeGroupRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BatchOperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchOperationMetadata");
        debug_struct.field("batch", &self.batch);
        debug_struct.field("batch_uuid", &self.batch_uuid);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("done_time", &self.done_time);
        debug_struct.field("operation_type", &self.operation_type);
        debug_struct.field("description", &self.description);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("warnings", &self.warnings);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SessionOperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SessionOperationMetadata");
        debug_struct.field("session", &self.session);
        debug_struct.field("session_uuid", &self.session_uuid);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("done_time", &self.done_time);
        debug_struct.field("operation_type", &self.operation_type);
        debug_struct.field("description", &self.description);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("warnings", &self.warnings);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ClusterOperationStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClusterOperationStatus");
        debug_struct.field("state", &self.state);
        debug_struct.field("inner_state", &self.inner_state);
        debug_struct.field("details", &self.details);
        debug_struct.field("state_start_time", &self.state_start_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ClusterOperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClusterOperationMetadata");
        debug_struct.field("cluster_name", &self.cluster_name);
        debug_struct.field("cluster_uuid", &self.cluster_uuid);
        debug_struct.field("status", &self.status);
        debug_struct.field("status_history", &self.status_history);
        debug_struct.field("operation_type", &self.operation_type);
        debug_struct.field("description", &self.description);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("warnings", &self.warnings);
        debug_struct.field("child_operation_ids", &self.child_operation_ids);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NodeGroupOperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeGroupOperationMetadata");
        debug_struct.field("node_group_id", &self.node_group_id);
        debug_struct.field("cluster_uuid", &self.cluster_uuid);
        debug_struct.field("status", &self.status);
        debug_struct.field("status_history", &self.status_history);
        debug_struct.field("operation_type", &self.operation_type);
        debug_struct.field("description", &self.description);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("warnings", &self.warnings);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateSessionTemplateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateSessionTemplateRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("session_template", &self.session_template);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateSessionTemplateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateSessionTemplateRequest");
        debug_struct.field("session_template", &self.session_template);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetSessionTemplateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetSessionTemplateRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListSessionTemplatesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSessionTemplatesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListSessionTemplatesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSessionTemplatesResponse");
        debug_struct.field("session_templates", &self.session_templates);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteSessionTemplateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteSessionTemplateRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SessionTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SessionTemplate");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("creator", &self.creator);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("runtime_config", &self.runtime_config);
        debug_struct.field("environment_config", &self.environment_config);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("uuid", &self.uuid);
        debug_struct.field("session_config", &self.session_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateSessionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateSessionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("session", &self.session);
        debug_struct.field("session_id", &self.session_id);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetSessionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetSessionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListSessionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSessionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListSessionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSessionsResponse");
        debug_struct.field("sessions", &self.sessions);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TerminateSessionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TerminateSessionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteSessionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteSessionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Session {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Session");
        debug_struct.field("name", &self.name);
        debug_struct.field("uuid", &self.uuid);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("runtime_info", &self.runtime_info);
        debug_struct.field("state", &self.state);
        debug_struct.field("state_message", &self.state_message);
        debug_struct.field("state_time", &self.state_time);
        debug_struct.field("creator", &self.creator);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("runtime_config", &self.runtime_config);
        debug_struct.field("environment_config", &self.environment_config);
        debug_struct.field("user", &self.user);
        debug_struct.field("state_history", &self.state_history);
        debug_struct.field("session_template", &self.session_template);
        debug_struct.field("session_config", &self.session_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::session::SessionStateHistory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SessionStateHistory");
        debug_struct.field("state", &self.state);
        debug_struct.field("state_message", &self.state_message);
        debug_struct.field("state_start_time", &self.state_start_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JupyterConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JupyterConfig");
        debug_struct.field("kernel", &self.kernel);
        debug_struct.field("display_name", &self.display_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SparkConnectConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SparkConnectConfig");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RuntimeConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RuntimeConfig");
        debug_struct.field("version", &self.version);
        debug_struct.field("container_image", &self.container_image);
        debug_struct.field("properties", &self.properties);
        debug_struct.field("repository_config", &self.repository_config);
        debug_struct.field("autotuning_config", &self.autotuning_config);
        debug_struct.field("cohort", &self.cohort);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EnvironmentConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EnvironmentConfig");
        debug_struct.field("execution_config", &self.execution_config);
        debug_struct.field("peripherals_config", &self.peripherals_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ExecutionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExecutionConfig");
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("network_tags", &self.network_tags);
        debug_struct.field("kms_key", &self.kms_key);
        debug_struct.field("idle_ttl", &self.idle_ttl);
        debug_struct.field("ttl", &self.ttl);
        debug_struct.field("staging_bucket", &self.staging_bucket);
        debug_struct.field("authentication_config", &self.authentication_config);
        debug_struct.field("network", &self.network);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SparkHistoryServerConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SparkHistoryServerConfig");
        debug_struct.field("dataproc_cluster", &self.dataproc_cluster);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PeripheralsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PeripheralsConfig");
        debug_struct.field("metastore_service", &self.metastore_service);
        debug_struct.field(
            "spark_history_server_config",
            &self.spark_history_server_config,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RuntimeInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RuntimeInfo");
        debug_struct.field("endpoints", &self.endpoints);
        debug_struct.field("output_uri", &self.output_uri);
        debug_struct.field("diagnostic_output_uri", &self.diagnostic_output_uri);
        debug_struct.field("approximate_usage", &self.approximate_usage);
        debug_struct.field("current_usage", &self.current_usage);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UsageMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UsageMetrics");
        debug_struct.field("milli_dcu_seconds", &self.milli_dcu_seconds);
        debug_struct.field(
            "shuffle_storage_gb_seconds",
            &self.shuffle_storage_gb_seconds,
        );
        debug_struct.field("milli_accelerator_seconds", &self.milli_accelerator_seconds);
        debug_struct.field("accelerator_type", &self.accelerator_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UsageSnapshot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UsageSnapshot");
        debug_struct.field("milli_dcu", &self.milli_dcu);
        debug_struct.field("shuffle_storage_gb", &self.shuffle_storage_gb);
        debug_struct.field("milli_dcu_premium", &self.milli_dcu_premium);
        debug_struct.field(
            "shuffle_storage_gb_premium",
            &self.shuffle_storage_gb_premium,
        );
        debug_struct.field("milli_accelerator", &self.milli_accelerator);
        debug_struct.field("accelerator_type", &self.accelerator_type);
        debug_struct.field("snapshot_time", &self.snapshot_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GkeClusterConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GkeClusterConfig");
        debug_struct.field("gke_cluster_target", &self.gke_cluster_target);
        debug_struct.field("node_pool_target", &self.node_pool_target);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::KubernetesClusterConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("KubernetesClusterConfig");
        debug_struct.field("kubernetes_namespace", &self.kubernetes_namespace);
        debug_struct.field(
            "kubernetes_software_config",
            &self.kubernetes_software_config,
        );
        debug_struct.field("config", &self.config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::KubernetesSoftwareConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("KubernetesSoftwareConfig");
        debug_struct.field("component_version", &self.component_version);
        debug_struct.field("properties", &self.properties);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GkeNodePoolTarget {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GkeNodePoolTarget");
        debug_struct.field("node_pool", &self.node_pool);
        debug_struct.field("roles", &self.roles);
        debug_struct.field("node_pool_config", &self.node_pool_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GkeNodePoolConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GkeNodePoolConfig");
        debug_struct.field("config", &self.config);
        debug_struct.field("locations", &self.locations);
        debug_struct.field("autoscaling", &self.autoscaling);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::gke_node_pool_config::GkeNodeConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GkeNodeConfig");
        debug_struct.field("machine_type", &self.machine_type);
        debug_struct.field("local_ssd_count", &self.local_ssd_count);
        debug_struct.field("preemptible", &self.preemptible);
        debug_struct.field("accelerators", &self.accelerators);
        debug_struct.field("min_cpu_platform", &self.min_cpu_platform);
        debug_struct.field("boot_disk_kms_key", &self.boot_disk_kms_key);
        debug_struct.field("spot", &self.spot);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::gke_node_pool_config::GkeNodePoolAcceleratorConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GkeNodePoolAcceleratorConfig");
        debug_struct.field("accelerator_count", &self.accelerator_count);
        debug_struct.field("accelerator_type", &self.accelerator_type);
        debug_struct.field("gpu_partition_size", &self.gpu_partition_size);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::gke_node_pool_config::GkeNodePoolAutoscalingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GkeNodePoolAutoscalingConfig");
        debug_struct.field("min_node_count", &self.min_node_count);
        debug_struct.field("max_node_count", &self.max_node_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AuthenticationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AuthenticationConfig");
        debug_struct.field(
            "user_workload_authentication_type",
            &self.user_workload_authentication_type,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AutotuningConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutotuningConfig");
        debug_struct.field("scenarios", &self.scenarios);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RepositoryConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RepositoryConfig");
        debug_struct.field("pypi_repository_config", &self.pypi_repository_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PyPiRepositoryConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PyPiRepositoryConfig");
        debug_struct.field("pypi_repository", &self.pypi_repository);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::WorkflowTemplate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WorkflowTemplate");
        debug_struct.field("id", &self.id);
        debug_struct.field("name", &self.name);
        debug_struct.field("version", &self.version);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("placement", &self.placement);
        debug_struct.field("jobs", &self.jobs);
        debug_struct.field("parameters", &self.parameters);
        debug_struct.field("dag_timeout", &self.dag_timeout);
        debug_struct.field("encryption_config", &self.encryption_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::workflow_template::EncryptionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EncryptionConfig");
        debug_struct.field("kms_key", &self.kms_key);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::WorkflowTemplatePlacement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WorkflowTemplatePlacement");
        debug_struct.field("placement", &self.placement);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ManagedCluster {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ManagedCluster");
        debug_struct.field("cluster_name", &self.cluster_name);
        debug_struct.field("config", &self.config);
        debug_struct.field("labels", &self.labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ClusterSelector {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClusterSelector");
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_labels", &self.cluster_labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::OrderedJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OrderedJob");
        debug_struct.field("step_id", &self.step_id);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("scheduling", &self.scheduling);
        debug_struct.field("prerequisite_step_ids", &self.prerequisite_step_ids);
        debug_struct.field("job_type", &self.job_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TemplateParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TemplateParameter");
        debug_struct.field("name", &self.name);
        debug_struct.field("fields", &self.fields);
        debug_struct.field("description", &self.description);
        debug_struct.field("validation", &self.validation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ParameterValidation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ParameterValidation");
        debug_struct.field("validation_type", &self.validation_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RegexValidation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RegexValidation");
        debug_struct.field("regexes", &self.regexes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ValueValidation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ValueValidation");
        debug_struct.field("values", &self.values);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::WorkflowMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WorkflowMetadata");
        debug_struct.field("template", &self.template);
        debug_struct.field("version", &self.version);
        debug_struct.field("create_cluster", &self.create_cluster);
        debug_struct.field("graph", &self.graph);
        debug_struct.field("delete_cluster", &self.delete_cluster);
        debug_struct.field("state", &self.state);
        debug_struct.field("cluster_name", &self.cluster_name);
        debug_struct.field("parameters", &self.parameters);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("cluster_uuid", &self.cluster_uuid);
        debug_struct.field("dag_timeout", &self.dag_timeout);
        debug_struct.field("dag_start_time", &self.dag_start_time);
        debug_struct.field("dag_end_time", &self.dag_end_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ClusterOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClusterOperation");
        debug_struct.field("operation_id", &self.operation_id);
        debug_struct.field("error", &self.error);
        debug_struct.field("done", &self.done);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::WorkflowGraph {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WorkflowGraph");
        debug_struct.field("nodes", &self.nodes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::WorkflowNode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WorkflowNode");
        debug_struct.field("step_id", &self.step_id);
        debug_struct.field("prerequisite_step_ids", &self.prerequisite_step_ids);
        debug_struct.field("job_id", &self.job_id);
        debug_struct.field("state", &self.state);
        debug_struct.field("error", &self.error);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateWorkflowTemplateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateWorkflowTemplateRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("template", &self.template);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetWorkflowTemplateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetWorkflowTemplateRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("version", &self.version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstantiateWorkflowTemplateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstantiateWorkflowTemplateRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("version", &self.version);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("parameters", &self.parameters);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstantiateInlineWorkflowTemplateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstantiateInlineWorkflowTemplateRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("template", &self.template);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateWorkflowTemplateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateWorkflowTemplateRequest");
        debug_struct.field("template", &self.template);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListWorkflowTemplatesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListWorkflowTemplatesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListWorkflowTemplatesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListWorkflowTemplatesResponse");
        debug_struct.field("templates", &self.templates);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteWorkflowTemplateRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteWorkflowTemplateRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("version", &self.version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
