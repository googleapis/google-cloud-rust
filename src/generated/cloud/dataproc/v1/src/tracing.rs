// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
use crate::Result;

/// Implements a [AutoscalingPolicyService](super::stub::AutoscalingPolicyService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct AutoscalingPolicyService<T>
where
    T: super::stub::AutoscalingPolicyService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> AutoscalingPolicyService<T>
where
    T: super::stub::AutoscalingPolicyService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::AutoscalingPolicyService for AutoscalingPolicyService<T>
where
    T: super::stub::AutoscalingPolicyService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_autoscaling_policy(
        &self,
        req: crate::model::CreateAutoscalingPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AutoscalingPolicy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "AutoscalingPolicyService",
            "::create_autoscaling_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_autoscaling_policy",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_autoscaling_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_autoscaling_policy(
        &self,
        req: crate::model::CreateAutoscalingPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AutoscalingPolicy>> {
        self.inner.create_autoscaling_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_autoscaling_policy(
        &self,
        req: crate::model::UpdateAutoscalingPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AutoscalingPolicy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "AutoscalingPolicyService",
            "::update_autoscaling_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_autoscaling_policy",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_autoscaling_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_autoscaling_policy(
        &self,
        req: crate::model::UpdateAutoscalingPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AutoscalingPolicy>> {
        self.inner.update_autoscaling_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_autoscaling_policy(
        &self,
        req: crate::model::GetAutoscalingPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AutoscalingPolicy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "AutoscalingPolicyService",
            "::get_autoscaling_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_autoscaling_policy",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_autoscaling_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_autoscaling_policy(
        &self,
        req: crate::model::GetAutoscalingPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AutoscalingPolicy>> {
        self.inner.get_autoscaling_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_autoscaling_policies(
        &self,
        req: crate::model::ListAutoscalingPoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListAutoscalingPoliciesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "AutoscalingPolicyService",
            "::list_autoscaling_policies"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_autoscaling_policies",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_autoscaling_policies(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_autoscaling_policies(
        &self,
        req: crate::model::ListAutoscalingPoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListAutoscalingPoliciesResponse>> {
        self.inner.list_autoscaling_policies(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_autoscaling_policy(
        &self,
        req: crate::model::DeleteAutoscalingPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "AutoscalingPolicyService",
            "::delete_autoscaling_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_autoscaling_policy",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_autoscaling_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_autoscaling_policy(
        &self,
        req: crate::model::DeleteAutoscalingPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_autoscaling_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "AutoscalingPolicyService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "AutoscalingPolicyService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "AutoscalingPolicyService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "AutoscalingPolicyService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "AutoscalingPolicyService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "AutoscalingPolicyService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "AutoscalingPolicyService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [BatchController](super::stub::BatchController) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct BatchController<T>
where
    T: super::stub::BatchController + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> BatchController<T>
where
    T: super::stub::BatchController + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::BatchController for BatchController<T>
where
    T: super::stub::BatchController + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_batch(
        &self,
        req: crate::model::CreateBatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BatchController",
            "::create_batch"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_batch",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_batch(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_batch(
        &self,
        req: crate::model::CreateBatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_batch(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_batch(
        &self,
        req: crate::model::GetBatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Batch>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BatchController",
            "::get_batch"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_batch",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_batch(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_batch(
        &self,
        req: crate::model::GetBatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Batch>> {
        self.inner.get_batch(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_batches(
        &self,
        req: crate::model::ListBatchesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListBatchesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BatchController",
            "::list_batches"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_batches",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_batches(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_batches(
        &self,
        req: crate::model::ListBatchesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListBatchesResponse>> {
        self.inner.list_batches(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_batch(
        &self,
        req: crate::model::DeleteBatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BatchController",
            "::delete_batch"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_batch",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_batch(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_batch(
        &self,
        req: crate::model::DeleteBatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_batch(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BatchController",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BatchController",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BatchController",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BatchController",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BatchController",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BatchController",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BatchController",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ClusterController](super::stub::ClusterController) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct ClusterController<T>
where
    T: super::stub::ClusterController + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> ClusterController<T>
where
    T: super::stub::ClusterController + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::ClusterController for ClusterController<T>
where
    T: super::stub::ClusterController + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_cluster(
        &self,
        req: crate::model::CreateClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ClusterController",
            "::create_cluster"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_cluster",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_cluster(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_cluster(
        &self,
        req: crate::model::CreateClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_cluster(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_cluster(
        &self,
        req: crate::model::UpdateClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ClusterController",
            "::update_cluster"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_cluster",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_cluster(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_cluster(
        &self,
        req: crate::model::UpdateClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_cluster(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn stop_cluster(
        &self,
        req: crate::model::StopClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ClusterController",
            "::stop_cluster"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "stop_cluster",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .stop_cluster(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn stop_cluster(
        &self,
        req: crate::model::StopClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.stop_cluster(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn start_cluster(
        &self,
        req: crate::model::StartClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ClusterController",
            "::start_cluster"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "start_cluster",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .start_cluster(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn start_cluster(
        &self,
        req: crate::model::StartClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.start_cluster(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_cluster(
        &self,
        req: crate::model::DeleteClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ClusterController",
            "::delete_cluster"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_cluster",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_cluster(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_cluster(
        &self,
        req: crate::model::DeleteClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_cluster(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_cluster(
        &self,
        req: crate::model::GetClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Cluster>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ClusterController",
            "::get_cluster"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_cluster",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_cluster(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_cluster(
        &self,
        req: crate::model::GetClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Cluster>> {
        self.inner.get_cluster(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_clusters(
        &self,
        req: crate::model::ListClustersRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListClustersResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ClusterController",
            "::list_clusters"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_clusters",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_clusters(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_clusters(
        &self,
        req: crate::model::ListClustersRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListClustersResponse>> {
        self.inner.list_clusters(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn diagnose_cluster(
        &self,
        req: crate::model::DiagnoseClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ClusterController",
            "::diagnose_cluster"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "diagnose_cluster",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .diagnose_cluster(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn diagnose_cluster(
        &self,
        req: crate::model::DiagnoseClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.diagnose_cluster(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ClusterController",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ClusterController",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ClusterController",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ClusterController",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ClusterController",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ClusterController",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "ClusterController",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [JobController](super::stub::JobController) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct JobController<T>
where
    T: super::stub::JobController + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> JobController<T>
where
    T: super::stub::JobController + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::JobController for JobController<T>
where
    T: super::stub::JobController + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn submit_job(
        &self,
        req: crate::model::SubmitJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Job>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobController",
            "::submit_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "submit_job",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .submit_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn submit_job(
        &self,
        req: crate::model::SubmitJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Job>> {
        self.inner.submit_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn submit_job_as_operation(
        &self,
        req: crate::model::SubmitJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobController",
            "::submit_job_as_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "submit_job_as_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .submit_job_as_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn submit_job_as_operation(
        &self,
        req: crate::model::SubmitJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.submit_job_as_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_job(
        &self,
        req: crate::model::GetJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Job>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobController",
            "::get_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_job",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_job(
        &self,
        req: crate::model::GetJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Job>> {
        self.inner.get_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_jobs(
        &self,
        req: crate::model::ListJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListJobsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobController",
            "::list_jobs"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_jobs",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_jobs(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_jobs(
        &self,
        req: crate::model::ListJobsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListJobsResponse>> {
        self.inner.list_jobs(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_job(
        &self,
        req: crate::model::UpdateJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Job>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobController",
            "::update_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_job",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_job(
        &self,
        req: crate::model::UpdateJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Job>> {
        self.inner.update_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_job(
        &self,
        req: crate::model::CancelJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Job>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobController",
            "::cancel_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_job",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_job(
        &self,
        req: crate::model::CancelJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Job>> {
        self.inner.cancel_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_job(
        &self,
        req: crate::model::DeleteJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobController",
            "::delete_job"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_job",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_job(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_job(
        &self,
        req: crate::model::DeleteJobRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_job(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobController",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobController",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobController",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobController",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobController",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobController",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "JobController",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [NodeGroupController](super::stub::NodeGroupController) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct NodeGroupController<T>
where
    T: super::stub::NodeGroupController + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> NodeGroupController<T>
where
    T: super::stub::NodeGroupController + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::NodeGroupController for NodeGroupController<T>
where
    T: super::stub::NodeGroupController + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_node_group(
        &self,
        req: crate::model::CreateNodeGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NodeGroupController",
            "::create_node_group"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_node_group",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_node_group(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_node_group(
        &self,
        req: crate::model::CreateNodeGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_node_group(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn resize_node_group(
        &self,
        req: crate::model::ResizeNodeGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NodeGroupController",
            "::resize_node_group"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "resize_node_group",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .resize_node_group(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn resize_node_group(
        &self,
        req: crate::model::ResizeNodeGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.resize_node_group(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_node_group(
        &self,
        req: crate::model::GetNodeGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodeGroup>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NodeGroupController",
            "::get_node_group"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_node_group",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_node_group(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_node_group(
        &self,
        req: crate::model::GetNodeGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodeGroup>> {
        self.inner.get_node_group(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NodeGroupController",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NodeGroupController",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NodeGroupController",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NodeGroupController",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NodeGroupController",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NodeGroupController",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "NodeGroupController",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [SessionTemplateController](super::stub::SessionTemplateController) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct SessionTemplateController<T>
where
    T: super::stub::SessionTemplateController + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> SessionTemplateController<T>
where
    T: super::stub::SessionTemplateController + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::SessionTemplateController for SessionTemplateController<T>
where
    T: super::stub::SessionTemplateController + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_session_template(
        &self,
        req: crate::model::CreateSessionTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SessionTemplate>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionTemplateController",
            "::create_session_template"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_session_template",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_session_template(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_session_template(
        &self,
        req: crate::model::CreateSessionTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SessionTemplate>> {
        self.inner.create_session_template(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_session_template(
        &self,
        req: crate::model::UpdateSessionTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SessionTemplate>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionTemplateController",
            "::update_session_template"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_session_template",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_session_template(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_session_template(
        &self,
        req: crate::model::UpdateSessionTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SessionTemplate>> {
        self.inner.update_session_template(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_session_template(
        &self,
        req: crate::model::GetSessionTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SessionTemplate>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionTemplateController",
            "::get_session_template"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_session_template",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_session_template(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_session_template(
        &self,
        req: crate::model::GetSessionTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SessionTemplate>> {
        self.inner.get_session_template(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_session_templates(
        &self,
        req: crate::model::ListSessionTemplatesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSessionTemplatesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionTemplateController",
            "::list_session_templates"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_session_templates",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_session_templates(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_session_templates(
        &self,
        req: crate::model::ListSessionTemplatesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSessionTemplatesResponse>> {
        self.inner.list_session_templates(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_session_template(
        &self,
        req: crate::model::DeleteSessionTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionTemplateController",
            "::delete_session_template"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_session_template",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_session_template(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_session_template(
        &self,
        req: crate::model::DeleteSessionTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_session_template(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionTemplateController",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionTemplateController",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionTemplateController",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionTemplateController",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionTemplateController",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionTemplateController",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionTemplateController",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [SessionController](super::stub::SessionController) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct SessionController<T>
where
    T: super::stub::SessionController + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> SessionController<T>
where
    T: super::stub::SessionController + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::SessionController for SessionController<T>
where
    T: super::stub::SessionController + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_session(
        &self,
        req: crate::model::CreateSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionController",
            "::create_session"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_session",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_session(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_session(
        &self,
        req: crate::model::CreateSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_session(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_session(
        &self,
        req: crate::model::GetSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Session>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionController",
            "::get_session"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_session",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_session(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_session(
        &self,
        req: crate::model::GetSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Session>> {
        self.inner.get_session(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_sessions(
        &self,
        req: crate::model::ListSessionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSessionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionController",
            "::list_sessions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_sessions",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_sessions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_sessions(
        &self,
        req: crate::model::ListSessionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSessionsResponse>> {
        self.inner.list_sessions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn terminate_session(
        &self,
        req: crate::model::TerminateSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionController",
            "::terminate_session"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "terminate_session",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .terminate_session(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn terminate_session(
        &self,
        req: crate::model::TerminateSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.terminate_session(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_session(
        &self,
        req: crate::model::DeleteSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionController",
            "::delete_session"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_session",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_session(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_session(
        &self,
        req: crate::model::DeleteSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_session(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionController",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionController",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionController",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionController",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionController",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionController",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionController",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [WorkflowTemplateService](super::stub::WorkflowTemplateService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct WorkflowTemplateService<T>
where
    T: super::stub::WorkflowTemplateService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> WorkflowTemplateService<T>
where
    T: super::stub::WorkflowTemplateService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::WorkflowTemplateService for WorkflowTemplateService<T>
where
    T: super::stub::WorkflowTemplateService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_workflow_template(
        &self,
        req: crate::model::CreateWorkflowTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::WorkflowTemplate>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "WorkflowTemplateService",
            "::create_workflow_template"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_workflow_template",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_workflow_template(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_workflow_template(
        &self,
        req: crate::model::CreateWorkflowTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::WorkflowTemplate>> {
        self.inner.create_workflow_template(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_workflow_template(
        &self,
        req: crate::model::GetWorkflowTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::WorkflowTemplate>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "WorkflowTemplateService",
            "::get_workflow_template"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_workflow_template",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_workflow_template(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_workflow_template(
        &self,
        req: crate::model::GetWorkflowTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::WorkflowTemplate>> {
        self.inner.get_workflow_template(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn instantiate_workflow_template(
        &self,
        req: crate::model::InstantiateWorkflowTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "WorkflowTemplateService",
            "::instantiate_workflow_template"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "instantiate_workflow_template",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .instantiate_workflow_template(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn instantiate_workflow_template(
        &self,
        req: crate::model::InstantiateWorkflowTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.instantiate_workflow_template(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn instantiate_inline_workflow_template(
        &self,
        req: crate::model::InstantiateInlineWorkflowTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "WorkflowTemplateService",
            "::instantiate_inline_workflow_template"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "instantiate_inline_workflow_template",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .instantiate_inline_workflow_template(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn instantiate_inline_workflow_template(
        &self,
        req: crate::model::InstantiateInlineWorkflowTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner
            .instantiate_inline_workflow_template(req, options)
            .await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_workflow_template(
        &self,
        req: crate::model::UpdateWorkflowTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::WorkflowTemplate>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "WorkflowTemplateService",
            "::update_workflow_template"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_workflow_template",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_workflow_template(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_workflow_template(
        &self,
        req: crate::model::UpdateWorkflowTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::WorkflowTemplate>> {
        self.inner.update_workflow_template(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_workflow_templates(
        &self,
        req: crate::model::ListWorkflowTemplatesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListWorkflowTemplatesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "WorkflowTemplateService",
            "::list_workflow_templates"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_workflow_templates",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_workflow_templates(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_workflow_templates(
        &self,
        req: crate::model::ListWorkflowTemplatesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListWorkflowTemplatesResponse>> {
        self.inner.list_workflow_templates(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_workflow_template(
        &self,
        req: crate::model::DeleteWorkflowTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "WorkflowTemplateService",
            "::delete_workflow_template"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_workflow_template",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_workflow_template(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_workflow_template(
        &self,
        req: crate::model::DeleteWorkflowTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_workflow_template(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "WorkflowTemplateService",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "WorkflowTemplateService",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "WorkflowTemplateService",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "WorkflowTemplateService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "WorkflowTemplateService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "WorkflowTemplateService",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "WorkflowTemplateService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

#[cfg(google_cloud_unstable_tracing)]
pub(crate) mod info {
    const NAME: &str = env!("CARGO_PKG_NAME");
    const VERSION: &str = env!("CARGO_PKG_VERSION");
    lazy_static::lazy_static! {
        pub(crate) static ref INSTRUMENTATION_CLIENT_INFO: gaxi::options::InstrumentationClientInfo = {
            let mut info = gaxi::options::InstrumentationClientInfo::default();
            info.service_name = "dataproc";
            info.client_version = VERSION;
            info.client_artifact = NAME;
            info.default_host = "dataproc";
            info
        };
    }
}
