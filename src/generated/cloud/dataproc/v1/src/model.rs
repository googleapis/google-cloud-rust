// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate iam_v1;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Describes an autoscaling policy for Dataproc cluster autoscaler.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoscalingPolicy {
    /// Required. The policy id.
    ///
    /// The id must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). Cannot begin or end with underscore
    /// or hyphen. Must consist of between 3 and 50 characters.
    pub id: std::string::String,

    /// Output only. The "resource name" of the autoscaling policy, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.autoscalingPolicies`, the resource name of the
    ///   policy has the following format:
    ///   `projects/{project_id}/regions/{region}/autoscalingPolicies/{policy_id}`
    ///
    /// * For `projects.locations.autoscalingPolicies`, the resource name of the
    ///   policy has the following format:
    ///   `projects/{project_id}/locations/{location}/autoscalingPolicies/{policy_id}`
    ///
    pub name: std::string::String,

    /// Required. Describes how the autoscaler will operate for primary workers.
    pub worker_config: std::option::Option<crate::model::InstanceGroupAutoscalingPolicyConfig>,

    /// Optional. Describes how the autoscaler will operate for secondary workers.
    pub secondary_worker_config:
        std::option::Option<crate::model::InstanceGroupAutoscalingPolicyConfig>,

    /// Optional. The labels to associate with this autoscaling policy.
    /// Label **keys** must contain 1 to 63 characters, and must conform to
    /// [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt).
    /// Label **values** may be empty, but, if present, must contain 1 to 63
    /// characters, and must conform to [RFC
    /// 1035](https://www.ietf.org/rfc/rfc1035.txt). No more than 32 labels can be
    /// associated with an autoscaling policy.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Autoscaling algorithm for policy.
    pub algorithm: std::option::Option<crate::model::autoscaling_policy::Algorithm>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoscalingPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::AutoscalingPolicy::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::AutoscalingPolicy::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [worker_config][crate::model::AutoscalingPolicy::worker_config].
    pub fn set_worker_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupAutoscalingPolicyConfig>,
    {
        self.worker_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [worker_config][crate::model::AutoscalingPolicy::worker_config].
    pub fn set_or_clear_worker_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupAutoscalingPolicyConfig>,
    {
        self.worker_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secondary_worker_config][crate::model::AutoscalingPolicy::secondary_worker_config].
    pub fn set_secondary_worker_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupAutoscalingPolicyConfig>,
    {
        self.secondary_worker_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [secondary_worker_config][crate::model::AutoscalingPolicy::secondary_worker_config].
    pub fn set_or_clear_secondary_worker_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupAutoscalingPolicyConfig>,
    {
        self.secondary_worker_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::AutoscalingPolicy::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [algorithm][crate::model::AutoscalingPolicy::algorithm].
    ///
    /// Note that all the setters affecting `algorithm` are mutually
    /// exclusive.
    pub fn set_algorithm<
        T: std::convert::Into<std::option::Option<crate::model::autoscaling_policy::Algorithm>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.algorithm = v.into();
        self
    }

    /// The value of [algorithm][crate::model::AutoscalingPolicy::algorithm]
    /// if it holds a `BasicAlgorithm`, `None` if the field is not set or
    /// holds a different branch.
    pub fn basic_algorithm(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BasicAutoscalingAlgorithm>> {
        #[allow(unreachable_patterns)]
        self.algorithm.as_ref().and_then(|v| match v {
            crate::model::autoscaling_policy::Algorithm::BasicAlgorithm(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [algorithm][crate::model::AutoscalingPolicy::algorithm]
    /// to hold a `BasicAlgorithm`.
    ///
    /// Note that all the setters affecting `algorithm` are
    /// mutually exclusive.
    pub fn set_basic_algorithm<
        T: std::convert::Into<std::boxed::Box<crate::model::BasicAutoscalingAlgorithm>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.algorithm = std::option::Option::Some(
            crate::model::autoscaling_policy::Algorithm::BasicAlgorithm(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AutoscalingPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.AutoscalingPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutoscalingPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __name,
            __basic_algorithm,
            __worker_config,
            __secondary_worker_config,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutoscalingPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "name" => Ok(__FieldTag::__name),
                            "basicAlgorithm" => Ok(__FieldTag::__basic_algorithm),
                            "basic_algorithm" => Ok(__FieldTag::__basic_algorithm),
                            "workerConfig" => Ok(__FieldTag::__worker_config),
                            "worker_config" => Ok(__FieldTag::__worker_config),
                            "secondaryWorkerConfig" => Ok(__FieldTag::__secondary_worker_config),
                            "secondary_worker_config" => Ok(__FieldTag::__secondary_worker_config),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutoscalingPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutoscalingPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__basic_algorithm => {
                            if !fields.insert(__FieldTag::__basic_algorithm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for basic_algorithm",
                                ));
                            }
                            if result.algorithm.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `algorithm`, a oneof with full ID .google.cloud.dataproc.v1.AutoscalingPolicy.basic_algorithm, latest field was basicAlgorithm",
                                ));
                            }
                            result.algorithm = std::option::Option::Some(
                                crate::model::autoscaling_policy::Algorithm::BasicAlgorithm(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BasicAutoscalingAlgorithm>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__worker_config => {
                            if !fields.insert(__FieldTag::__worker_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_config",
                                ));
                            }
                            result.worker_config = map.next_value::<std::option::Option<
                                crate::model::InstanceGroupAutoscalingPolicyConfig,
                            >>()?;
                        }
                        __FieldTag::__secondary_worker_config => {
                            if !fields.insert(__FieldTag::__secondary_worker_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_worker_config",
                                ));
                            }
                            result.secondary_worker_config = map.next_value::<std::option::Option<
                                crate::model::InstanceGroupAutoscalingPolicyConfig,
                            >>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutoscalingPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.basic_algorithm() {
            state.serialize_entry("basicAlgorithm", value)?;
        }
        if self.worker_config.is_some() {
            state.serialize_entry("workerConfig", &self.worker_config)?;
        }
        if self.secondary_worker_config.is_some() {
            state.serialize_entry("secondaryWorkerConfig", &self.secondary_worker_config)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AutoscalingPolicy].
pub mod autoscaling_policy {
    #[allow(unused_imports)]
    use super::*;

    /// Autoscaling algorithm for policy.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Algorithm {
        BasicAlgorithm(std::boxed::Box<crate::model::BasicAutoscalingAlgorithm>),
    }
}

/// Basic algorithm for autoscaling.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BasicAutoscalingAlgorithm {
    /// Optional. Duration between scaling events. A scaling period starts after
    /// the update operation from the previous event has completed.
    ///
    /// Bounds: [2m, 1d]. Default: 2m.
    pub cooldown_period: std::option::Option<wkt::Duration>,

    pub config: std::option::Option<crate::model::basic_autoscaling_algorithm::Config>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BasicAutoscalingAlgorithm {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cooldown_period][crate::model::BasicAutoscalingAlgorithm::cooldown_period].
    pub fn set_cooldown_period<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.cooldown_period = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cooldown_period][crate::model::BasicAutoscalingAlgorithm::cooldown_period].
    pub fn set_or_clear_cooldown_period<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.cooldown_period = v.map(|x| x.into());
        self
    }

    /// Sets the value of [config][crate::model::BasicAutoscalingAlgorithm::config].
    ///
    /// Note that all the setters affecting `config` are mutually
    /// exclusive.
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::basic_autoscaling_algorithm::Config>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// The value of [config][crate::model::BasicAutoscalingAlgorithm::config]
    /// if it holds a `YarnConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn yarn_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BasicYarnAutoscalingConfig>> {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::basic_autoscaling_algorithm::Config::YarnConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [config][crate::model::BasicAutoscalingAlgorithm::config]
    /// to hold a `YarnConfig`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_yarn_config<
        T: std::convert::Into<std::boxed::Box<crate::model::BasicYarnAutoscalingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = std::option::Option::Some(
            crate::model::basic_autoscaling_algorithm::Config::YarnConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BasicAutoscalingAlgorithm {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.BasicAutoscalingAlgorithm"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BasicAutoscalingAlgorithm {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __yarn_config,
            __cooldown_period,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BasicAutoscalingAlgorithm")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "yarnConfig" => Ok(__FieldTag::__yarn_config),
                            "yarn_config" => Ok(__FieldTag::__yarn_config),
                            "cooldownPeriod" => Ok(__FieldTag::__cooldown_period),
                            "cooldown_period" => Ok(__FieldTag::__cooldown_period),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BasicAutoscalingAlgorithm;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BasicAutoscalingAlgorithm")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__yarn_config => {
                            if !fields.insert(__FieldTag::__yarn_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for yarn_config",
                                ));
                            }
                            if result.config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `config`, a oneof with full ID .google.cloud.dataproc.v1.BasicAutoscalingAlgorithm.yarn_config, latest field was yarnConfig",
                                ));
                            }
                            result.config = std::option::Option::Some(
                                crate::model::basic_autoscaling_algorithm::Config::YarnConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BasicYarnAutoscalingConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__cooldown_period => {
                            if !fields.insert(__FieldTag::__cooldown_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cooldown_period",
                                ));
                            }
                            result.cooldown_period =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BasicAutoscalingAlgorithm {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.yarn_config() {
            state.serialize_entry("yarnConfig", value)?;
        }
        if self.cooldown_period.is_some() {
            state.serialize_entry("cooldownPeriod", &self.cooldown_period)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BasicAutoscalingAlgorithm].
pub mod basic_autoscaling_algorithm {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Config {
        /// Required. YARN autoscaling configuration.
        YarnConfig(std::boxed::Box<crate::model::BasicYarnAutoscalingConfig>),
    }
}

/// Basic autoscaling configurations for YARN.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BasicYarnAutoscalingConfig {
    /// Required. Timeout for YARN graceful decommissioning of Node Managers.
    /// Specifies the duration to wait for jobs to complete before forcefully
    /// removing workers (and potentially interrupting jobs). Only applicable to
    /// downscaling operations.
    ///
    /// Bounds: [0s, 1d].
    pub graceful_decommission_timeout: std::option::Option<wkt::Duration>,

    /// Required. Fraction of average YARN pending memory in the last cooldown
    /// period for which to add workers. A scale-up factor of 1.0 will result in
    /// scaling up so that there is no pending memory remaining after the update
    /// (more aggressive scaling). A scale-up factor closer to 0 will result in a
    /// smaller magnitude of scaling up (less aggressive scaling). See [How
    /// autoscaling
    /// works](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/autoscaling#how_autoscaling_works)
    /// for more information.
    ///
    /// Bounds: [0.0, 1.0].
    pub scale_up_factor: f64,

    /// Required. Fraction of average YARN pending memory in the last cooldown
    /// period for which to remove workers. A scale-down factor of 1 will result in
    /// scaling down so that there is no available memory remaining after the
    /// update (more aggressive scaling). A scale-down factor of 0 disables
    /// removing workers, which can be beneficial for autoscaling a single job.
    /// See [How autoscaling
    /// works](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/autoscaling#how_autoscaling_works)
    /// for more information.
    ///
    /// Bounds: [0.0, 1.0].
    pub scale_down_factor: f64,

    /// Optional. Minimum scale-up threshold as a fraction of total cluster size
    /// before scaling occurs. For example, in a 20-worker cluster, a threshold of
    /// 0.1 means the autoscaler must recommend at least a 2-worker scale-up for
    /// the cluster to scale. A threshold of 0 means the autoscaler will scale up
    /// on any recommended change.
    ///
    /// Bounds: [0.0, 1.0]. Default: 0.0.
    pub scale_up_min_worker_fraction: f64,

    /// Optional. Minimum scale-down threshold as a fraction of total cluster size
    /// before scaling occurs. For example, in a 20-worker cluster, a threshold of
    /// 0.1 means the autoscaler must recommend at least a 2 worker scale-down for
    /// the cluster to scale. A threshold of 0 means the autoscaler will scale down
    /// on any recommended change.
    ///
    /// Bounds: [0.0, 1.0]. Default: 0.0.
    pub scale_down_min_worker_fraction: f64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BasicYarnAutoscalingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [graceful_decommission_timeout][crate::model::BasicYarnAutoscalingConfig::graceful_decommission_timeout].
    pub fn set_graceful_decommission_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.graceful_decommission_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [graceful_decommission_timeout][crate::model::BasicYarnAutoscalingConfig::graceful_decommission_timeout].
    pub fn set_or_clear_graceful_decommission_timeout<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.graceful_decommission_timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [scale_up_factor][crate::model::BasicYarnAutoscalingConfig::scale_up_factor].
    pub fn set_scale_up_factor<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.scale_up_factor = v.into();
        self
    }

    /// Sets the value of [scale_down_factor][crate::model::BasicYarnAutoscalingConfig::scale_down_factor].
    pub fn set_scale_down_factor<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.scale_down_factor = v.into();
        self
    }

    /// Sets the value of [scale_up_min_worker_fraction][crate::model::BasicYarnAutoscalingConfig::scale_up_min_worker_fraction].
    pub fn set_scale_up_min_worker_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.scale_up_min_worker_fraction = v.into();
        self
    }

    /// Sets the value of [scale_down_min_worker_fraction][crate::model::BasicYarnAutoscalingConfig::scale_down_min_worker_fraction].
    pub fn set_scale_down_min_worker_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.scale_down_min_worker_fraction = v.into();
        self
    }
}

impl wkt::message::Message for BasicYarnAutoscalingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.BasicYarnAutoscalingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BasicYarnAutoscalingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __graceful_decommission_timeout,
            __scale_up_factor,
            __scale_down_factor,
            __scale_up_min_worker_fraction,
            __scale_down_min_worker_fraction,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BasicYarnAutoscalingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gracefulDecommissionTimeout" => {
                                Ok(__FieldTag::__graceful_decommission_timeout)
                            }
                            "graceful_decommission_timeout" => {
                                Ok(__FieldTag::__graceful_decommission_timeout)
                            }
                            "scaleUpFactor" => Ok(__FieldTag::__scale_up_factor),
                            "scale_up_factor" => Ok(__FieldTag::__scale_up_factor),
                            "scaleDownFactor" => Ok(__FieldTag::__scale_down_factor),
                            "scale_down_factor" => Ok(__FieldTag::__scale_down_factor),
                            "scaleUpMinWorkerFraction" => {
                                Ok(__FieldTag::__scale_up_min_worker_fraction)
                            }
                            "scale_up_min_worker_fraction" => {
                                Ok(__FieldTag::__scale_up_min_worker_fraction)
                            }
                            "scaleDownMinWorkerFraction" => {
                                Ok(__FieldTag::__scale_down_min_worker_fraction)
                            }
                            "scale_down_min_worker_fraction" => {
                                Ok(__FieldTag::__scale_down_min_worker_fraction)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BasicYarnAutoscalingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BasicYarnAutoscalingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__graceful_decommission_timeout => {
                            if !fields.insert(__FieldTag::__graceful_decommission_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for graceful_decommission_timeout",
                                ));
                            }
                            result.graceful_decommission_timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__scale_up_factor => {
                            if !fields.insert(__FieldTag::__scale_up_factor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scale_up_factor",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scale_up_factor =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__scale_down_factor => {
                            if !fields.insert(__FieldTag::__scale_down_factor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scale_down_factor",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scale_down_factor =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__scale_up_min_worker_fraction => {
                            if !fields.insert(__FieldTag::__scale_up_min_worker_fraction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scale_up_min_worker_fraction",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scale_up_min_worker_fraction =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__scale_down_min_worker_fraction => {
                            if !fields.insert(__FieldTag::__scale_down_min_worker_fraction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scale_down_min_worker_fraction",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.scale_down_min_worker_fraction =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BasicYarnAutoscalingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.graceful_decommission_timeout.is_some() {
            state.serialize_entry(
                "gracefulDecommissionTimeout",
                &self.graceful_decommission_timeout,
            )?;
        }
        if !wkt::internal::is_default(&self.scale_up_factor) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("scaleUpFactor", &__With(&self.scale_up_factor))?;
        }
        if !wkt::internal::is_default(&self.scale_down_factor) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("scaleDownFactor", &__With(&self.scale_down_factor))?;
        }
        if !wkt::internal::is_default(&self.scale_up_min_worker_fraction) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "scaleUpMinWorkerFraction",
                &__With(&self.scale_up_min_worker_fraction),
            )?;
        }
        if !wkt::internal::is_default(&self.scale_down_min_worker_fraction) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "scaleDownMinWorkerFraction",
                &__With(&self.scale_down_min_worker_fraction),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for the size bounds of an instance group, including its
/// proportional size to other groups.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupAutoscalingPolicyConfig {
    /// Optional. Minimum number of instances for this group.
    ///
    /// Primary workers - Bounds: [2, max_instances]. Default: 2.
    /// Secondary workers - Bounds: [0, max_instances]. Default: 0.
    pub min_instances: i32,

    /// Required. Maximum number of instances for this group. Required for primary
    /// workers. Note that by default, clusters will not use secondary workers.
    /// Required for secondary workers if the minimum secondary instances is set.
    ///
    /// Primary workers - Bounds: [min_instances, ).
    /// Secondary workers - Bounds: [min_instances, ). Default: 0.
    pub max_instances: i32,

    /// Optional. Weight for the instance group, which is used to determine the
    /// fraction of total workers in the cluster from this instance group.
    /// For example, if primary workers have weight 2, and secondary workers have
    /// weight 1, the cluster will have approximately 2 primary workers for each
    /// secondary worker.
    ///
    /// The cluster may not reach the specified balance if constrained
    /// by min/max bounds or other autoscaling settings. For example, if
    /// `max_instances` for secondary workers is 0, then only primary workers will
    /// be added. The cluster can also be out of balance when created.
    ///
    /// If weight is not set on any instance group, the cluster will default to
    /// equal weight for all groups: the cluster will attempt to maintain an equal
    /// number of workers in each group within the configured size bounds for each
    /// group. If weight is set for one group only, the cluster will default to
    /// zero weight on the unset group. For example if weight is set only on
    /// primary workers, the cluster will use primary workers only and no
    /// secondary workers.
    pub weight: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstanceGroupAutoscalingPolicyConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_instances][crate::model::InstanceGroupAutoscalingPolicyConfig::min_instances].
    pub fn set_min_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_instances = v.into();
        self
    }

    /// Sets the value of [max_instances][crate::model::InstanceGroupAutoscalingPolicyConfig::max_instances].
    pub fn set_max_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_instances = v.into();
        self
    }

    /// Sets the value of [weight][crate::model::InstanceGroupAutoscalingPolicyConfig::weight].
    pub fn set_weight<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.weight = v.into();
        self
    }
}

impl wkt::message::Message for InstanceGroupAutoscalingPolicyConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.InstanceGroupAutoscalingPolicyConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstanceGroupAutoscalingPolicyConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __min_instances,
            __max_instances,
            __weight,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstanceGroupAutoscalingPolicyConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "minInstances" => Ok(__FieldTag::__min_instances),
                            "min_instances" => Ok(__FieldTag::__min_instances),
                            "maxInstances" => Ok(__FieldTag::__max_instances),
                            "max_instances" => Ok(__FieldTag::__max_instances),
                            "weight" => Ok(__FieldTag::__weight),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstanceGroupAutoscalingPolicyConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstanceGroupAutoscalingPolicyConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__min_instances => {
                            if !fields.insert(__FieldTag::__min_instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_instances",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_instances =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_instances => {
                            if !fields.insert(__FieldTag::__max_instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_instances",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_instances =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__weight => {
                            if !fields.insert(__FieldTag::__weight) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for weight",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.weight = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstanceGroupAutoscalingPolicyConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.min_instances) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minInstances", &__With(&self.min_instances))?;
        }
        if !wkt::internal::is_default(&self.max_instances) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxInstances", &__With(&self.max_instances))?;
        }
        if !wkt::internal::is_default(&self.weight) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("weight", &__With(&self.weight))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to create an autoscaling policy.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAutoscalingPolicyRequest {
    /// Required. The "resource name" of the region or location, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.autoscalingPolicies.create`, the resource name
    ///   of the region has the following format:
    ///   `projects/{project_id}/regions/{region}`
    ///
    /// * For `projects.locations.autoscalingPolicies.create`, the resource name
    ///   of the location has the following format:
    ///   `projects/{project_id}/locations/{location}`
    ///
    pub parent: std::string::String,

    /// Required. The autoscaling policy to create.
    pub policy: std::option::Option<crate::model::AutoscalingPolicy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAutoscalingPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAutoscalingPolicyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [policy][crate::model::CreateAutoscalingPolicyRequest::policy].
    pub fn set_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutoscalingPolicy>,
    {
        self.policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [policy][crate::model::CreateAutoscalingPolicyRequest::policy].
    pub fn set_or_clear_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutoscalingPolicy>,
    {
        self.policy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateAutoscalingPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.CreateAutoscalingPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAutoscalingPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAutoscalingPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "policy" => Ok(__FieldTag::__policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAutoscalingPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAutoscalingPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy",
                                ));
                            }
                            result.policy = map
                                .next_value::<std::option::Option<crate::model::AutoscalingPolicy>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAutoscalingPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.policy.is_some() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to fetch an autoscaling policy.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAutoscalingPolicyRequest {
    /// Required. The "resource name" of the autoscaling policy, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.autoscalingPolicies.get`, the resource name
    ///   of the policy has the following format:
    ///   `projects/{project_id}/regions/{region}/autoscalingPolicies/{policy_id}`
    ///
    /// * For `projects.locations.autoscalingPolicies.get`, the resource name
    ///   of the policy has the following format:
    ///   `projects/{project_id}/locations/{location}/autoscalingPolicies/{policy_id}`
    ///
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAutoscalingPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAutoscalingPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAutoscalingPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GetAutoscalingPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAutoscalingPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAutoscalingPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAutoscalingPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAutoscalingPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAutoscalingPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to update an autoscaling policy.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAutoscalingPolicyRequest {
    /// Required. The updated autoscaling policy.
    pub policy: std::option::Option<crate::model::AutoscalingPolicy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAutoscalingPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy][crate::model::UpdateAutoscalingPolicyRequest::policy].
    pub fn set_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutoscalingPolicy>,
    {
        self.policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [policy][crate::model::UpdateAutoscalingPolicyRequest::policy].
    pub fn set_or_clear_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutoscalingPolicy>,
    {
        self.policy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateAutoscalingPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.UpdateAutoscalingPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAutoscalingPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAutoscalingPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "policy" => Ok(__FieldTag::__policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAutoscalingPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAutoscalingPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy",
                                ));
                            }
                            result.policy = map
                                .next_value::<std::option::Option<crate::model::AutoscalingPolicy>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAutoscalingPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.policy.is_some() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to delete an autoscaling policy.
///
/// Autoscaling policies in use by one or more clusters will not be deleted.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAutoscalingPolicyRequest {
    /// Required. The "resource name" of the autoscaling policy, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.autoscalingPolicies.delete`, the resource name
    ///   of the policy has the following format:
    ///   `projects/{project_id}/regions/{region}/autoscalingPolicies/{policy_id}`
    ///
    /// * For `projects.locations.autoscalingPolicies.delete`, the resource name
    ///   of the policy has the following format:
    ///   `projects/{project_id}/locations/{location}/autoscalingPolicies/{policy_id}`
    ///
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAutoscalingPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAutoscalingPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAutoscalingPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DeleteAutoscalingPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAutoscalingPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAutoscalingPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAutoscalingPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAutoscalingPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAutoscalingPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to list autoscaling policies in a project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAutoscalingPoliciesRequest {
    /// Required. The "resource name" of the region or location, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.autoscalingPolicies.list`, the resource name
    ///   of the region has the following format:
    ///   `projects/{project_id}/regions/{region}`
    ///
    /// * For `projects.locations.autoscalingPolicies.list`, the resource name
    ///   of the location has the following format:
    ///   `projects/{project_id}/locations/{location}`
    ///
    pub parent: std::string::String,

    /// Optional. The maximum number of results to return in each response.
    /// Must be less than or equal to 1000. Defaults to 100.
    pub page_size: i32,

    /// Optional. The page token, returned by a previous call, to request the
    /// next page of results.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutoscalingPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAutoscalingPoliciesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAutoscalingPoliciesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAutoscalingPoliciesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutoscalingPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListAutoscalingPoliciesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAutoscalingPoliciesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAutoscalingPoliciesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAutoscalingPoliciesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAutoscalingPoliciesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAutoscalingPoliciesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A response to a request to list autoscaling policies in a project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAutoscalingPoliciesResponse {
    /// Output only. Autoscaling policies list.
    pub policies: std::vec::Vec<crate::model::AutoscalingPolicy>,

    /// Output only. This token is included in the response if there are more
    /// results to fetch.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutoscalingPoliciesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policies][crate::model::ListAutoscalingPoliciesResponse::policies].
    pub fn set_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutoscalingPolicy>,
    {
        use std::iter::Iterator;
        self.policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAutoscalingPoliciesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutoscalingPoliciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListAutoscalingPoliciesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAutoscalingPoliciesResponse {
    type PageItem = crate::model::AutoscalingPolicy;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.policies
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAutoscalingPoliciesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __policies,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAutoscalingPoliciesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "policies" => Ok(__FieldTag::__policies),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAutoscalingPoliciesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAutoscalingPoliciesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__policies => {
                            if !fields.insert(__FieldTag::__policies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policies",
                                ));
                            }
                            result.policies =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AutoscalingPolicy>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAutoscalingPoliciesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.policies.is_empty() {
            state.serialize_entry("policies", &self.policies)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to create a batch workload.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateBatchRequest {
    /// Required. The parent resource where this batch will be created.
    pub parent: std::string::String,

    /// Required. The batch to create.
    pub batch: std::option::Option<crate::model::Batch>,

    /// Optional. The ID to use for the batch, which will become the final
    /// component of the batch's resource name.
    ///
    /// This value must be 4-63 characters. Valid characters are `/[a-z][0-9]-/`.
    pub batch_id: std::string::String,

    /// Optional. A unique ID used to identify the request. If the service
    /// receives two
    /// [CreateBatchRequest](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.CreateBatchRequest)s
    /// with the same request_id, the second request is ignored and the
    /// Operation that corresponds to the first Batch created and stored
    /// in the backend is returned.
    ///
    /// Recommendation: Set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The value must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBatchRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBatchRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [batch][crate::model::CreateBatchRequest::batch].
    pub fn set_batch<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Batch>,
    {
        self.batch = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [batch][crate::model::CreateBatchRequest::batch].
    pub fn set_or_clear_batch<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Batch>,
    {
        self.batch = v.map(|x| x.into());
        self
    }

    /// Sets the value of [batch_id][crate::model::CreateBatchRequest::batch_id].
    pub fn set_batch_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.batch_id = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateBatchRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateBatchRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.CreateBatchRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateBatchRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __batch,
            __batch_id,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBatchRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "batch" => Ok(__FieldTag::__batch),
                            "batchId" => Ok(__FieldTag::__batch_id),
                            "batch_id" => Ok(__FieldTag::__batch_id),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateBatchRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBatchRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__batch => {
                            if !fields.insert(__FieldTag::__batch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for batch",
                                ));
                            }
                            result.batch =
                                map.next_value::<std::option::Option<crate::model::Batch>>()?;
                        }
                        __FieldTag::__batch_id => {
                            if !fields.insert(__FieldTag::__batch_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for batch_id",
                                ));
                            }
                            result.batch_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateBatchRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.batch.is_some() {
            state.serialize_entry("batch", &self.batch)?;
        }
        if !self.batch_id.is_empty() {
            state.serialize_entry("batchId", &self.batch_id)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to get the resource representation for a batch workload.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBatchRequest {
    /// Required. The fully qualified name of the batch to retrieve
    /// in the format
    /// "projects/PROJECT_ID/locations/DATAPROC_REGION/batches/BATCH_ID"
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBatchRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBatchRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBatchRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GetBatchRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBatchRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBatchRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBatchRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBatchRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBatchRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to list batch workloads in a project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBatchesRequest {
    /// Required. The parent, which owns this collection of batches.
    pub parent: std::string::String,

    /// Optional. The maximum number of batches to return in each response.
    /// The service may return fewer than this value.
    /// The default page size is 20; the maximum page size is 1000.
    pub page_size: i32,

    /// Optional. A page token received from a previous `ListBatches` call.
    /// Provide this token to retrieve the subsequent page.
    pub page_token: std::string::String,

    /// Optional. A filter for the batches to return in the response.
    ///
    /// A filter is a logical expression constraining the values of various fields
    /// in each batch resource. Filters are case sensitive, and may contain
    /// multiple clauses combined with logical operators (AND/OR).
    /// Supported fields are `batch_id`, `batch_uuid`, `state`, and `create_time`.
    ///
    /// e.g. `state = RUNNING and create_time < "2023-01-01T00:00:00Z"`
    /// filters for batches in state RUNNING that were created before 2023-01-01
    ///
    /// See <https://google.aip.dev/assets/misc/ebnf-filtering.txt> for a detailed
    /// description of the filter syntax and a list of supported comparisons.
    pub filter: std::string::String,

    /// Optional. Field(s) on which to sort the list of batches.
    ///
    /// Currently the only supported sort orders are unspecified (empty) and
    /// `create_time desc` to sort by most recently created batches first.
    ///
    /// See <https://google.aip.dev/132#ordering> for more details.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBatchesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBatchesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBatchesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBatchesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBatchesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBatchesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListBatchesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListBatchesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBatchesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBatchesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBatchesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBatchesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBatchesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A list of batch workloads.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBatchesResponse {
    /// The batches from the specified collection.
    pub batches: std::vec::Vec<crate::model::Batch>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Output only. List of Batches that could not be included in the response.
    /// Attempting to get one of these resources may indicate why it was not
    /// included in the list response.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBatchesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [batches][crate::model::ListBatchesResponse::batches].
    pub fn set_batches<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Batch>,
    {
        use std::iter::Iterator;
        self.batches = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBatchesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBatchesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBatchesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListBatchesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBatchesResponse {
    type PageItem = crate::model::Batch;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.batches
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBatchesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __batches,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBatchesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "batches" => Ok(__FieldTag::__batches),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBatchesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBatchesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__batches => {
                            if !fields.insert(__FieldTag::__batches) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for batches",
                                ));
                            }
                            result.batches = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Batch>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBatchesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.batches.is_empty() {
            state.serialize_entry("batches", &self.batches)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to delete a batch workload.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteBatchRequest {
    /// Required. The fully qualified name of the batch to retrieve
    /// in the format
    /// "projects/PROJECT_ID/locations/DATAPROC_REGION/batches/BATCH_ID"
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBatchRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBatchRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBatchRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DeleteBatchRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteBatchRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteBatchRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteBatchRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteBatchRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteBatchRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A representation of a batch workload in the service.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Batch {
    /// Output only. The resource name of the batch.
    pub name: std::string::String,

    /// Output only. A batch UUID (Unique Universal Identifier). The service
    /// generates this value when it creates the batch.
    pub uuid: std::string::String,

    /// Output only. The time when the batch was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Runtime information about batch execution.
    pub runtime_info: std::option::Option<crate::model::RuntimeInfo>,

    /// Output only. The state of the batch.
    pub state: crate::model::batch::State,

    /// Output only. Batch state details, such as a failure
    /// description if the state is `FAILED`.
    pub state_message: std::string::String,

    /// Output only. The time when the batch entered a current state.
    pub state_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The email address of the user who created the batch.
    pub creator: std::string::String,

    /// Optional. The labels to associate with this batch.
    /// Label **keys** must contain 1 to 63 characters, and must conform to
    /// [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt).
    /// Label **values** may be empty, but, if present, must contain 1 to 63
    /// characters, and must conform to [RFC
    /// 1035](https://www.ietf.org/rfc/rfc1035.txt). No more than 32 labels can be
    /// associated with a batch.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Runtime configuration for the batch execution.
    pub runtime_config: std::option::Option<crate::model::RuntimeConfig>,

    /// Optional. Environment configuration for the batch execution.
    pub environment_config: std::option::Option<crate::model::EnvironmentConfig>,

    /// Output only. The resource name of the operation associated with this batch.
    pub operation: std::string::String,

    /// Output only. Historical state information for the batch.
    pub state_history: std::vec::Vec<crate::model::batch::StateHistory>,

    /// The application/framework-specific portion of the batch configuration.
    pub batch_config: std::option::Option<crate::model::batch::BatchConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Batch {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Batch::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uuid][crate::model::Batch::uuid].
    pub fn set_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uuid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Batch::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Batch::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [runtime_info][crate::model::Batch::runtime_info].
    pub fn set_runtime_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RuntimeInfo>,
    {
        self.runtime_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [runtime_info][crate::model::Batch::runtime_info].
    pub fn set_or_clear_runtime_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RuntimeInfo>,
    {
        self.runtime_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Batch::state].
    pub fn set_state<T: std::convert::Into<crate::model::batch::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_message][crate::model::Batch::state_message].
    pub fn set_state_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_message = v.into();
        self
    }

    /// Sets the value of [state_time][crate::model::Batch::state_time].
    pub fn set_state_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_time][crate::model::Batch::state_time].
    pub fn set_or_clear_state_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creator][crate::model::Batch::creator].
    pub fn set_creator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.creator = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Batch::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [runtime_config][crate::model::Batch::runtime_config].
    pub fn set_runtime_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RuntimeConfig>,
    {
        self.runtime_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [runtime_config][crate::model::Batch::runtime_config].
    pub fn set_or_clear_runtime_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RuntimeConfig>,
    {
        self.runtime_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [environment_config][crate::model::Batch::environment_config].
    pub fn set_environment_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EnvironmentConfig>,
    {
        self.environment_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [environment_config][crate::model::Batch::environment_config].
    pub fn set_or_clear_environment_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EnvironmentConfig>,
    {
        self.environment_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [operation][crate::model::Batch::operation].
    pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation = v.into();
        self
    }

    /// Sets the value of [state_history][crate::model::Batch::state_history].
    pub fn set_state_history<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::batch::StateHistory>,
    {
        use std::iter::Iterator;
        self.state_history = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [batch_config][crate::model::Batch::batch_config].
    ///
    /// Note that all the setters affecting `batch_config` are mutually
    /// exclusive.
    pub fn set_batch_config<
        T: std::convert::Into<std::option::Option<crate::model::batch::BatchConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.batch_config = v.into();
        self
    }

    /// The value of [batch_config][crate::model::Batch::batch_config]
    /// if it holds a `PysparkBatch`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pyspark_batch(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PySparkBatch>> {
        #[allow(unreachable_patterns)]
        self.batch_config.as_ref().and_then(|v| match v {
            crate::model::batch::BatchConfig::PysparkBatch(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [batch_config][crate::model::Batch::batch_config]
    /// to hold a `PysparkBatch`.
    ///
    /// Note that all the setters affecting `batch_config` are
    /// mutually exclusive.
    pub fn set_pyspark_batch<T: std::convert::Into<std::boxed::Box<crate::model::PySparkBatch>>>(
        mut self,
        v: T,
    ) -> Self {
        self.batch_config =
            std::option::Option::Some(crate::model::batch::BatchConfig::PysparkBatch(v.into()));
        self
    }

    /// The value of [batch_config][crate::model::Batch::batch_config]
    /// if it holds a `SparkBatch`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_batch(&self) -> std::option::Option<&std::boxed::Box<crate::model::SparkBatch>> {
        #[allow(unreachable_patterns)]
        self.batch_config.as_ref().and_then(|v| match v {
            crate::model::batch::BatchConfig::SparkBatch(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [batch_config][crate::model::Batch::batch_config]
    /// to hold a `SparkBatch`.
    ///
    /// Note that all the setters affecting `batch_config` are
    /// mutually exclusive.
    pub fn set_spark_batch<T: std::convert::Into<std::boxed::Box<crate::model::SparkBatch>>>(
        mut self,
        v: T,
    ) -> Self {
        self.batch_config =
            std::option::Option::Some(crate::model::batch::BatchConfig::SparkBatch(v.into()));
        self
    }

    /// The value of [batch_config][crate::model::Batch::batch_config]
    /// if it holds a `SparkRBatch`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_r_batch(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SparkRBatch>> {
        #[allow(unreachable_patterns)]
        self.batch_config.as_ref().and_then(|v| match v {
            crate::model::batch::BatchConfig::SparkRBatch(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [batch_config][crate::model::Batch::batch_config]
    /// to hold a `SparkRBatch`.
    ///
    /// Note that all the setters affecting `batch_config` are
    /// mutually exclusive.
    pub fn set_spark_r_batch<T: std::convert::Into<std::boxed::Box<crate::model::SparkRBatch>>>(
        mut self,
        v: T,
    ) -> Self {
        self.batch_config =
            std::option::Option::Some(crate::model::batch::BatchConfig::SparkRBatch(v.into()));
        self
    }

    /// The value of [batch_config][crate::model::Batch::batch_config]
    /// if it holds a `SparkSqlBatch`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_sql_batch(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SparkSqlBatch>> {
        #[allow(unreachable_patterns)]
        self.batch_config.as_ref().and_then(|v| match v {
            crate::model::batch::BatchConfig::SparkSqlBatch(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [batch_config][crate::model::Batch::batch_config]
    /// to hold a `SparkSqlBatch`.
    ///
    /// Note that all the setters affecting `batch_config` are
    /// mutually exclusive.
    pub fn set_spark_sql_batch<
        T: std::convert::Into<std::boxed::Box<crate::model::SparkSqlBatch>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.batch_config =
            std::option::Option::Some(crate::model::batch::BatchConfig::SparkSqlBatch(v.into()));
        self
    }
}

impl wkt::message::Message for Batch {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.Batch"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Batch {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uuid,
            __create_time,
            __pyspark_batch,
            __spark_batch,
            __spark_r_batch,
            __spark_sql_batch,
            __runtime_info,
            __state,
            __state_message,
            __state_time,
            __creator,
            __labels,
            __runtime_config,
            __environment_config,
            __operation,
            __state_history,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Batch")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uuid" => Ok(__FieldTag::__uuid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "pysparkBatch" => Ok(__FieldTag::__pyspark_batch),
                            "pyspark_batch" => Ok(__FieldTag::__pyspark_batch),
                            "sparkBatch" => Ok(__FieldTag::__spark_batch),
                            "spark_batch" => Ok(__FieldTag::__spark_batch),
                            "sparkRBatch" => Ok(__FieldTag::__spark_r_batch),
                            "spark_r_batch" => Ok(__FieldTag::__spark_r_batch),
                            "sparkSqlBatch" => Ok(__FieldTag::__spark_sql_batch),
                            "spark_sql_batch" => Ok(__FieldTag::__spark_sql_batch),
                            "runtimeInfo" => Ok(__FieldTag::__runtime_info),
                            "runtime_info" => Ok(__FieldTag::__runtime_info),
                            "state" => Ok(__FieldTag::__state),
                            "stateMessage" => Ok(__FieldTag::__state_message),
                            "state_message" => Ok(__FieldTag::__state_message),
                            "stateTime" => Ok(__FieldTag::__state_time),
                            "state_time" => Ok(__FieldTag::__state_time),
                            "creator" => Ok(__FieldTag::__creator),
                            "labels" => Ok(__FieldTag::__labels),
                            "runtimeConfig" => Ok(__FieldTag::__runtime_config),
                            "runtime_config" => Ok(__FieldTag::__runtime_config),
                            "environmentConfig" => Ok(__FieldTag::__environment_config),
                            "environment_config" => Ok(__FieldTag::__environment_config),
                            "operation" => Ok(__FieldTag::__operation),
                            "stateHistory" => Ok(__FieldTag::__state_history),
                            "state_history" => Ok(__FieldTag::__state_history),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Batch;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Batch")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uuid => {
                            if !fields.insert(__FieldTag::__uuid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uuid",
                                ));
                            }
                            result.uuid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__pyspark_batch => {
                            if !fields.insert(__FieldTag::__pyspark_batch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pyspark_batch",
                                ));
                            }
                            if result.batch_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `batch_config`, a oneof with full ID .google.cloud.dataproc.v1.Batch.pyspark_batch, latest field was pysparkBatch",
                                ));
                            }
                            result.batch_config = std::option::Option::Some(
                                crate::model::batch::BatchConfig::PysparkBatch(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PySparkBatch>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__spark_batch => {
                            if !fields.insert(__FieldTag::__spark_batch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark_batch",
                                ));
                            }
                            if result.batch_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `batch_config`, a oneof with full ID .google.cloud.dataproc.v1.Batch.spark_batch, latest field was sparkBatch",
                                ));
                            }
                            result.batch_config = std::option::Option::Some(
                                crate::model::batch::BatchConfig::SparkBatch(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SparkBatch>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__spark_r_batch => {
                            if !fields.insert(__FieldTag::__spark_r_batch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark_r_batch",
                                ));
                            }
                            if result.batch_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `batch_config`, a oneof with full ID .google.cloud.dataproc.v1.Batch.spark_r_batch, latest field was sparkRBatch",
                                ));
                            }
                            result.batch_config = std::option::Option::Some(
                                crate::model::batch::BatchConfig::SparkRBatch(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SparkRBatch>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__spark_sql_batch => {
                            if !fields.insert(__FieldTag::__spark_sql_batch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark_sql_batch",
                                ));
                            }
                            if result.batch_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `batch_config`, a oneof with full ID .google.cloud.dataproc.v1.Batch.spark_sql_batch, latest field was sparkSqlBatch",
                                ));
                            }
                            result.batch_config = std::option::Option::Some(
                                crate::model::batch::BatchConfig::SparkSqlBatch(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SparkSqlBatch>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__runtime_info => {
                            if !fields.insert(__FieldTag::__runtime_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_info",
                                ));
                            }
                            result.runtime_info =
                                map.next_value::<std::option::Option<crate::model::RuntimeInfo>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::batch::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_message => {
                            if !fields.insert(__FieldTag::__state_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_message",
                                ));
                            }
                            result.state_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_time => {
                            if !fields.insert(__FieldTag::__state_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_time",
                                ));
                            }
                            result.state_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__creator => {
                            if !fields.insert(__FieldTag::__creator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creator",
                                ));
                            }
                            result.creator = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__runtime_config => {
                            if !fields.insert(__FieldTag::__runtime_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_config",
                                ));
                            }
                            result.runtime_config = map
                                .next_value::<std::option::Option<crate::model::RuntimeConfig>>()?;
                        }
                        __FieldTag::__environment_config => {
                            if !fields.insert(__FieldTag::__environment_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment_config",
                                ));
                            }
                            result.environment_config = map
                                .next_value::<std::option::Option<crate::model::EnvironmentConfig>>(
                                )?;
                        }
                        __FieldTag::__operation => {
                            if !fields.insert(__FieldTag::__operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation",
                                ));
                            }
                            result.operation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_history => {
                            if !fields.insert(__FieldTag::__state_history) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_history",
                                ));
                            }
                            result.state_history = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::batch::StateHistory>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Batch {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uuid.is_empty() {
            state.serialize_entry("uuid", &self.uuid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if let Some(value) = self.pyspark_batch() {
            state.serialize_entry("pysparkBatch", value)?;
        }
        if let Some(value) = self.spark_batch() {
            state.serialize_entry("sparkBatch", value)?;
        }
        if let Some(value) = self.spark_r_batch() {
            state.serialize_entry("sparkRBatch", value)?;
        }
        if let Some(value) = self.spark_sql_batch() {
            state.serialize_entry("sparkSqlBatch", value)?;
        }
        if self.runtime_info.is_some() {
            state.serialize_entry("runtimeInfo", &self.runtime_info)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_message.is_empty() {
            state.serialize_entry("stateMessage", &self.state_message)?;
        }
        if self.state_time.is_some() {
            state.serialize_entry("stateTime", &self.state_time)?;
        }
        if !self.creator.is_empty() {
            state.serialize_entry("creator", &self.creator)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.runtime_config.is_some() {
            state.serialize_entry("runtimeConfig", &self.runtime_config)?;
        }
        if self.environment_config.is_some() {
            state.serialize_entry("environmentConfig", &self.environment_config)?;
        }
        if !self.operation.is_empty() {
            state.serialize_entry("operation", &self.operation)?;
        }
        if !self.state_history.is_empty() {
            state.serialize_entry("stateHistory", &self.state_history)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Batch].
pub mod batch {
    #[allow(unused_imports)]
    use super::*;

    /// Historical state information.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StateHistory {
        /// Output only. The state of the batch at this point in history.
        pub state: crate::model::batch::State,

        /// Output only. Details about the state at this point in history.
        pub state_message: std::string::String,

        /// Output only. The time when the batch entered the historical state.
        pub state_start_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StateHistory {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::batch::StateHistory::state].
        pub fn set_state<T: std::convert::Into<crate::model::batch::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [state_message][crate::model::batch::StateHistory::state_message].
        pub fn set_state_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.state_message = v.into();
            self
        }

        /// Sets the value of [state_start_time][crate::model::batch::StateHistory::state_start_time].
        pub fn set_state_start_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.state_start_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [state_start_time][crate::model::batch::StateHistory::state_start_time].
        pub fn set_or_clear_state_start_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.state_start_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for StateHistory {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataproc.v1.Batch.StateHistory"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for StateHistory {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __state,
                __state_message,
                __state_start_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for StateHistory")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "state" => Ok(__FieldTag::__state),
                                "stateMessage" => Ok(__FieldTag::__state_message),
                                "state_message" => Ok(__FieldTag::__state_message),
                                "stateStartTime" => Ok(__FieldTag::__state_start_time),
                                "state_start_time" => Ok(__FieldTag::__state_start_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = StateHistory;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct StateHistory")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map
                                    .next_value::<std::option::Option<crate::model::batch::State>>(
                                    )?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__state_message => {
                                if !fields.insert(__FieldTag::__state_message) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state_message",
                                    ));
                                }
                                result.state_message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__state_start_time => {
                                if !fields.insert(__FieldTag::__state_start_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state_start_time",
                                    ));
                                }
                                result.state_start_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for StateHistory {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if !self.state_message.is_empty() {
                state.serialize_entry("stateMessage", &self.state_message)?;
            }
            if self.state_start_time.is_some() {
                state.serialize_entry("stateStartTime", &self.state_start_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The batch state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The batch state is unknown.
        Unspecified,
        /// The batch is created before running.
        Pending,
        /// The batch is running.
        Running,
        /// The batch is cancelling.
        Cancelling,
        /// The batch cancellation was successful.
        Cancelled,
        /// The batch completed successfully.
        Succeeded,
        /// The batch is no longer running due to an error.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Cancelling => std::option::Option::Some(3),
                Self::Cancelled => std::option::Option::Some(4),
                Self::Succeeded => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Running,
                3 => Self::Cancelling,
                4 => Self::Cancelled,
                5 => Self::Succeeded,
                6 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "RUNNING" => Self::Running,
                "CANCELLING" => Self::Cancelling,
                "CANCELLED" => Self::Cancelled,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Cancelling => serializer.serialize_i32(3),
                Self::Cancelled => serializer.serialize_i32(4),
                Self::Succeeded => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataproc.v1.Batch.State",
            ))
        }
    }

    /// The application/framework-specific portion of the batch configuration.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BatchConfig {
        /// Optional. PySpark batch config.
        PysparkBatch(std::boxed::Box<crate::model::PySparkBatch>),
        /// Optional. Spark batch config.
        SparkBatch(std::boxed::Box<crate::model::SparkBatch>),
        /// Optional. SparkR batch config.
        SparkRBatch(std::boxed::Box<crate::model::SparkRBatch>),
        /// Optional. SparkSql batch config.
        SparkSqlBatch(std::boxed::Box<crate::model::SparkSqlBatch>),
    }
}

/// A configuration for running an
/// [Apache
/// PySpark](https://spark.apache.org/docs/latest/api/python/getting_started/quickstart.html)
/// batch workload.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PySparkBatch {
    /// Required. The HCFS URI of the main Python file to use as the Spark driver.
    /// Must be a .py file.
    pub main_python_file_uri: std::string::String,

    /// Optional. The arguments to pass to the driver. Do not include arguments
    /// that can be set as batch properties, such as `--conf`, since a collision
    /// can occur that causes an incorrect batch submission.
    pub args: std::vec::Vec<std::string::String>,

    /// Optional. HCFS file URIs of Python files to pass to the PySpark
    /// framework. Supported file types: `.py`, `.egg`, and `.zip`.
    pub python_file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of jar files to add to the classpath of the
    /// Spark driver and tasks.
    pub jar_file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of files to be placed in the working directory of
    /// each executor.
    pub file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of archives to be extracted into the working directory
    /// of each executor. Supported file types:
    /// `.jar`, `.tar`, `.tar.gz`, `.tgz`, and `.zip`.
    pub archive_uris: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PySparkBatch {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [main_python_file_uri][crate::model::PySparkBatch::main_python_file_uri].
    pub fn set_main_python_file_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.main_python_file_uri = v.into();
        self
    }

    /// Sets the value of [args][crate::model::PySparkBatch::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [python_file_uris][crate::model::PySparkBatch::python_file_uris].
    pub fn set_python_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.python_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [jar_file_uris][crate::model::PySparkBatch::jar_file_uris].
    pub fn set_jar_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jar_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_uris][crate::model::PySparkBatch::file_uris].
    pub fn set_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [archive_uris][crate::model::PySparkBatch::archive_uris].
    pub fn set_archive_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.archive_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PySparkBatch {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.PySparkBatch"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PySparkBatch {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __main_python_file_uri,
            __args,
            __python_file_uris,
            __jar_file_uris,
            __file_uris,
            __archive_uris,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PySparkBatch")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mainPythonFileUri" => Ok(__FieldTag::__main_python_file_uri),
                            "main_python_file_uri" => Ok(__FieldTag::__main_python_file_uri),
                            "args" => Ok(__FieldTag::__args),
                            "pythonFileUris" => Ok(__FieldTag::__python_file_uris),
                            "python_file_uris" => Ok(__FieldTag::__python_file_uris),
                            "jarFileUris" => Ok(__FieldTag::__jar_file_uris),
                            "jar_file_uris" => Ok(__FieldTag::__jar_file_uris),
                            "fileUris" => Ok(__FieldTag::__file_uris),
                            "file_uris" => Ok(__FieldTag::__file_uris),
                            "archiveUris" => Ok(__FieldTag::__archive_uris),
                            "archive_uris" => Ok(__FieldTag::__archive_uris),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PySparkBatch;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PySparkBatch")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__main_python_file_uri => {
                            if !fields.insert(__FieldTag::__main_python_file_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for main_python_file_uri",
                                ));
                            }
                            result.main_python_file_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__args => {
                            if !fields.insert(__FieldTag::__args) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for args",
                                ));
                            }
                            result.args = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__python_file_uris => {
                            if !fields.insert(__FieldTag::__python_file_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for python_file_uris",
                                ));
                            }
                            result.python_file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__jar_file_uris => {
                            if !fields.insert(__FieldTag::__jar_file_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jar_file_uris",
                                ));
                            }
                            result.jar_file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__file_uris => {
                            if !fields.insert(__FieldTag::__file_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_uris",
                                ));
                            }
                            result.file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__archive_uris => {
                            if !fields.insert(__FieldTag::__archive_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for archive_uris",
                                ));
                            }
                            result.archive_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PySparkBatch {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.main_python_file_uri.is_empty() {
            state.serialize_entry("mainPythonFileUri", &self.main_python_file_uri)?;
        }
        if !self.args.is_empty() {
            state.serialize_entry("args", &self.args)?;
        }
        if !self.python_file_uris.is_empty() {
            state.serialize_entry("pythonFileUris", &self.python_file_uris)?;
        }
        if !self.jar_file_uris.is_empty() {
            state.serialize_entry("jarFileUris", &self.jar_file_uris)?;
        }
        if !self.file_uris.is_empty() {
            state.serialize_entry("fileUris", &self.file_uris)?;
        }
        if !self.archive_uris.is_empty() {
            state.serialize_entry("archiveUris", &self.archive_uris)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A configuration for running an [Apache Spark](https://spark.apache.org/)
/// batch workload.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SparkBatch {
    /// Optional. The arguments to pass to the driver. Do not include arguments
    /// that can be set as batch properties, such as `--conf`, since a collision
    /// can occur that causes an incorrect batch submission.
    pub args: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of jar files to add to the classpath of the
    /// Spark driver and tasks.
    pub jar_file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of files to be placed in the working directory of
    /// each executor.
    pub file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of archives to be extracted into the working directory
    /// of each executor. Supported file types:
    /// `.jar`, `.tar`, `.tar.gz`, `.tgz`, and `.zip`.
    pub archive_uris: std::vec::Vec<std::string::String>,

    /// The specification of the main method to call to drive the Spark
    /// workload. Specify either the jar file that contains the main class or the
    /// main class name. To pass both a main jar and a main class in that jar, add
    /// the jar to `jar_file_uris`, and then specify the main class
    /// name in `main_class`.
    pub driver: std::option::Option<crate::model::spark_batch::Driver>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SparkBatch {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [args][crate::model::SparkBatch::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [jar_file_uris][crate::model::SparkBatch::jar_file_uris].
    pub fn set_jar_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jar_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_uris][crate::model::SparkBatch::file_uris].
    pub fn set_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [archive_uris][crate::model::SparkBatch::archive_uris].
    pub fn set_archive_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.archive_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [driver][crate::model::SparkBatch::driver].
    ///
    /// Note that all the setters affecting `driver` are mutually
    /// exclusive.
    pub fn set_driver<
        T: std::convert::Into<std::option::Option<crate::model::spark_batch::Driver>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.driver = v.into();
        self
    }

    /// The value of [driver][crate::model::SparkBatch::driver]
    /// if it holds a `MainJarFileUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn main_jar_file_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.driver.as_ref().and_then(|v| match v {
            crate::model::spark_batch::Driver::MainJarFileUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [driver][crate::model::SparkBatch::driver]
    /// to hold a `MainJarFileUri`.
    ///
    /// Note that all the setters affecting `driver` are
    /// mutually exclusive.
    pub fn set_main_jar_file_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.driver =
            std::option::Option::Some(crate::model::spark_batch::Driver::MainJarFileUri(v.into()));
        self
    }

    /// The value of [driver][crate::model::SparkBatch::driver]
    /// if it holds a `MainClass`, `None` if the field is not set or
    /// holds a different branch.
    pub fn main_class(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.driver.as_ref().and_then(|v| match v {
            crate::model::spark_batch::Driver::MainClass(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [driver][crate::model::SparkBatch::driver]
    /// to hold a `MainClass`.
    ///
    /// Note that all the setters affecting `driver` are
    /// mutually exclusive.
    pub fn set_main_class<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.driver =
            std::option::Option::Some(crate::model::spark_batch::Driver::MainClass(v.into()));
        self
    }
}

impl wkt::message::Message for SparkBatch {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SparkBatch"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SparkBatch {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __main_jar_file_uri,
            __main_class,
            __args,
            __jar_file_uris,
            __file_uris,
            __archive_uris,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SparkBatch")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mainJarFileUri" => Ok(__FieldTag::__main_jar_file_uri),
                            "main_jar_file_uri" => Ok(__FieldTag::__main_jar_file_uri),
                            "mainClass" => Ok(__FieldTag::__main_class),
                            "main_class" => Ok(__FieldTag::__main_class),
                            "args" => Ok(__FieldTag::__args),
                            "jarFileUris" => Ok(__FieldTag::__jar_file_uris),
                            "jar_file_uris" => Ok(__FieldTag::__jar_file_uris),
                            "fileUris" => Ok(__FieldTag::__file_uris),
                            "file_uris" => Ok(__FieldTag::__file_uris),
                            "archiveUris" => Ok(__FieldTag::__archive_uris),
                            "archive_uris" => Ok(__FieldTag::__archive_uris),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SparkBatch;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SparkBatch")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__main_jar_file_uri => {
                            if !fields.insert(__FieldTag::__main_jar_file_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for main_jar_file_uri",
                                ));
                            }
                            if result.driver.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `driver`, a oneof with full ID .google.cloud.dataproc.v1.SparkBatch.main_jar_file_uri, latest field was mainJarFileUri",
                                ));
                            }
                            result.driver = std::option::Option::Some(
                                crate::model::spark_batch::Driver::MainJarFileUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__main_class => {
                            if !fields.insert(__FieldTag::__main_class) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for main_class",
                                ));
                            }
                            if result.driver.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `driver`, a oneof with full ID .google.cloud.dataproc.v1.SparkBatch.main_class, latest field was mainClass",
                                ));
                            }
                            result.driver = std::option::Option::Some(
                                crate::model::spark_batch::Driver::MainClass(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__args => {
                            if !fields.insert(__FieldTag::__args) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for args",
                                ));
                            }
                            result.args = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__jar_file_uris => {
                            if !fields.insert(__FieldTag::__jar_file_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jar_file_uris",
                                ));
                            }
                            result.jar_file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__file_uris => {
                            if !fields.insert(__FieldTag::__file_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_uris",
                                ));
                            }
                            result.file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__archive_uris => {
                            if !fields.insert(__FieldTag::__archive_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for archive_uris",
                                ));
                            }
                            result.archive_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SparkBatch {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.main_jar_file_uri() {
            state.serialize_entry("mainJarFileUri", value)?;
        }
        if let Some(value) = self.main_class() {
            state.serialize_entry("mainClass", value)?;
        }
        if !self.args.is_empty() {
            state.serialize_entry("args", &self.args)?;
        }
        if !self.jar_file_uris.is_empty() {
            state.serialize_entry("jarFileUris", &self.jar_file_uris)?;
        }
        if !self.file_uris.is_empty() {
            state.serialize_entry("fileUris", &self.file_uris)?;
        }
        if !self.archive_uris.is_empty() {
            state.serialize_entry("archiveUris", &self.archive_uris)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SparkBatch].
pub mod spark_batch {
    #[allow(unused_imports)]
    use super::*;

    /// The specification of the main method to call to drive the Spark
    /// workload. Specify either the jar file that contains the main class or the
    /// main class name. To pass both a main jar and a main class in that jar, add
    /// the jar to `jar_file_uris`, and then specify the main class
    /// name in `main_class`.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Driver {
        /// Optional. The HCFS URI of the jar file that contains the main class.
        MainJarFileUri(std::string::String),
        /// Optional. The name of the driver main class. The jar file that contains
        /// the class must be in the classpath or specified in `jar_file_uris`.
        MainClass(std::string::String),
    }
}

/// A configuration for running an
/// [Apache SparkR](https://spark.apache.org/docs/latest/sparkr.html)
/// batch workload.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SparkRBatch {
    /// Required. The HCFS URI of the main R file to use as the driver.
    /// Must be a `.R` or `.r` file.
    pub main_r_file_uri: std::string::String,

    /// Optional. The arguments to pass to the Spark driver. Do not include
    /// arguments that can be set as batch properties, such as `--conf`, since a
    /// collision can occur that causes an incorrect batch submission.
    pub args: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of files to be placed in the working directory of
    /// each executor.
    pub file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of archives to be extracted into the working directory
    /// of each executor. Supported file types:
    /// `.jar`, `.tar`, `.tar.gz`, `.tgz`, and `.zip`.
    pub archive_uris: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SparkRBatch {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [main_r_file_uri][crate::model::SparkRBatch::main_r_file_uri].
    pub fn set_main_r_file_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.main_r_file_uri = v.into();
        self
    }

    /// Sets the value of [args][crate::model::SparkRBatch::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_uris][crate::model::SparkRBatch::file_uris].
    pub fn set_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [archive_uris][crate::model::SparkRBatch::archive_uris].
    pub fn set_archive_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.archive_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SparkRBatch {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SparkRBatch"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SparkRBatch {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __main_r_file_uri,
            __args,
            __file_uris,
            __archive_uris,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SparkRBatch")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mainRFileUri" => Ok(__FieldTag::__main_r_file_uri),
                            "main_r_file_uri" => Ok(__FieldTag::__main_r_file_uri),
                            "args" => Ok(__FieldTag::__args),
                            "fileUris" => Ok(__FieldTag::__file_uris),
                            "file_uris" => Ok(__FieldTag::__file_uris),
                            "archiveUris" => Ok(__FieldTag::__archive_uris),
                            "archive_uris" => Ok(__FieldTag::__archive_uris),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SparkRBatch;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SparkRBatch")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__main_r_file_uri => {
                            if !fields.insert(__FieldTag::__main_r_file_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for main_r_file_uri",
                                ));
                            }
                            result.main_r_file_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__args => {
                            if !fields.insert(__FieldTag::__args) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for args",
                                ));
                            }
                            result.args = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__file_uris => {
                            if !fields.insert(__FieldTag::__file_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_uris",
                                ));
                            }
                            result.file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__archive_uris => {
                            if !fields.insert(__FieldTag::__archive_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for archive_uris",
                                ));
                            }
                            result.archive_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SparkRBatch {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.main_r_file_uri.is_empty() {
            state.serialize_entry("mainRFileUri", &self.main_r_file_uri)?;
        }
        if !self.args.is_empty() {
            state.serialize_entry("args", &self.args)?;
        }
        if !self.file_uris.is_empty() {
            state.serialize_entry("fileUris", &self.file_uris)?;
        }
        if !self.archive_uris.is_empty() {
            state.serialize_entry("archiveUris", &self.archive_uris)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A configuration for running
/// [Apache Spark SQL](https://spark.apache.org/sql/) queries as a batch
/// workload.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SparkSqlBatch {
    /// Required. The HCFS URI of the script that contains Spark SQL queries to
    /// execute.
    pub query_file_uri: std::string::String,

    /// Optional. Mapping of query variable names to values (equivalent to the
    /// Spark SQL command: `SET name="value";`).
    pub query_variables: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. HCFS URIs of jar files to be added to the Spark CLASSPATH.
    pub jar_file_uris: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SparkSqlBatch {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query_file_uri][crate::model::SparkSqlBatch::query_file_uri].
    pub fn set_query_file_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query_file_uri = v.into();
        self
    }

    /// Sets the value of [query_variables][crate::model::SparkSqlBatch::query_variables].
    pub fn set_query_variables<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.query_variables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [jar_file_uris][crate::model::SparkSqlBatch::jar_file_uris].
    pub fn set_jar_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jar_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SparkSqlBatch {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SparkSqlBatch"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SparkSqlBatch {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query_file_uri,
            __query_variables,
            __jar_file_uris,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SparkSqlBatch")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "queryFileUri" => Ok(__FieldTag::__query_file_uri),
                            "query_file_uri" => Ok(__FieldTag::__query_file_uri),
                            "queryVariables" => Ok(__FieldTag::__query_variables),
                            "query_variables" => Ok(__FieldTag::__query_variables),
                            "jarFileUris" => Ok(__FieldTag::__jar_file_uris),
                            "jar_file_uris" => Ok(__FieldTag::__jar_file_uris),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SparkSqlBatch;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SparkSqlBatch")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query_file_uri => {
                            if !fields.insert(__FieldTag::__query_file_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_file_uri",
                                ));
                            }
                            result.query_file_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_variables => {
                            if !fields.insert(__FieldTag::__query_variables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_variables",
                                ));
                            }
                            result.query_variables = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__jar_file_uris => {
                            if !fields.insert(__FieldTag::__jar_file_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jar_file_uris",
                                ));
                            }
                            result.jar_file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SparkSqlBatch {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.query_file_uri.is_empty() {
            state.serialize_entry("queryFileUri", &self.query_file_uri)?;
        }
        if !self.query_variables.is_empty() {
            state.serialize_entry("queryVariables", &self.query_variables)?;
        }
        if !self.jar_file_uris.is_empty() {
            state.serialize_entry("jarFileUris", &self.jar_file_uris)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes the identifying information, config, and status of
/// a Dataproc cluster
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Cluster {
    /// Required. The Google Cloud Platform project ID that the cluster belongs to.
    pub project_id: std::string::String,

    /// Required. The cluster name, which must be unique within a project.
    /// The name must start with a lowercase letter, and can contain
    /// up to 51 lowercase letters, numbers, and hyphens. It cannot end
    /// with a hyphen. The name of a deleted cluster can be reused.
    pub cluster_name: std::string::String,

    /// Optional. The cluster config for a cluster of Compute Engine Instances.
    /// Note that Dataproc may set default values, and values may change
    /// when clusters are updated.
    ///
    /// Exactly one of ClusterConfig or VirtualClusterConfig must be specified.
    pub config: std::option::Option<crate::model::ClusterConfig>,

    /// Optional. The virtual cluster config is used when creating a Dataproc
    /// cluster that does not directly control the underlying compute resources,
    /// for example, when creating a [Dataproc-on-GKE
    /// cluster](https://cloud.google.com/dataproc/docs/guides/dpgke/dataproc-gke-overview).
    /// Dataproc may set default values, and values may change when
    /// clusters are updated. Exactly one of
    /// [config][google.cloud.dataproc.v1.Cluster.config] or
    /// [virtual_cluster_config][google.cloud.dataproc.v1.Cluster.virtual_cluster_config]
    /// must be specified.
    ///
    /// [google.cloud.dataproc.v1.Cluster.config]: crate::model::Cluster::config
    /// [google.cloud.dataproc.v1.Cluster.virtual_cluster_config]: crate::model::Cluster::virtual_cluster_config
    pub virtual_cluster_config: std::option::Option<crate::model::VirtualClusterConfig>,

    /// Optional. The labels to associate with this cluster.
    /// Label **keys** must contain 1 to 63 characters, and must conform to
    /// [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt).
    /// Label **values** may be empty, but, if present, must contain 1 to 63
    /// characters, and must conform to [RFC
    /// 1035](https://www.ietf.org/rfc/rfc1035.txt). No more than 32 labels can be
    /// associated with a cluster.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Cluster status.
    pub status: std::option::Option<crate::model::ClusterStatus>,

    /// Output only. The previous cluster status.
    pub status_history: std::vec::Vec<crate::model::ClusterStatus>,

    /// Output only. A cluster UUID (Unique Universal Identifier). Dataproc
    /// generates this value when it creates the cluster.
    pub cluster_uuid: std::string::String,

    /// Output only. Contains cluster daemon metrics such as HDFS and YARN stats.
    ///
    /// **Beta Feature**: This report is available for testing purposes only. It
    /// may be changed before final release.
    pub metrics: std::option::Option<crate::model::ClusterMetrics>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Cluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::Cluster::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::Cluster::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [config][crate::model::Cluster::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ClusterConfig>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::Cluster::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ClusterConfig>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [virtual_cluster_config][crate::model::Cluster::virtual_cluster_config].
    pub fn set_virtual_cluster_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VirtualClusterConfig>,
    {
        self.virtual_cluster_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [virtual_cluster_config][crate::model::Cluster::virtual_cluster_config].
    pub fn set_or_clear_virtual_cluster_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VirtualClusterConfig>,
    {
        self.virtual_cluster_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Cluster::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [status][crate::model::Cluster::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ClusterStatus>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::Cluster::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ClusterStatus>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status_history][crate::model::Cluster::status_history].
    pub fn set_status_history<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClusterStatus>,
    {
        use std::iter::Iterator;
        self.status_history = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cluster_uuid][crate::model::Cluster::cluster_uuid].
    pub fn set_cluster_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uuid = v.into();
        self
    }

    /// Sets the value of [metrics][crate::model::Cluster::metrics].
    pub fn set_metrics<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ClusterMetrics>,
    {
        self.metrics = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metrics][crate::model::Cluster::metrics].
    pub fn set_or_clear_metrics<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ClusterMetrics>,
    {
        self.metrics = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Cluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.Cluster"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Cluster {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __cluster_name,
            __config,
            __virtual_cluster_config,
            __labels,
            __status,
            __status_history,
            __cluster_uuid,
            __metrics,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Cluster")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "clusterName" => Ok(__FieldTag::__cluster_name),
                            "cluster_name" => Ok(__FieldTag::__cluster_name),
                            "config" => Ok(__FieldTag::__config),
                            "virtualClusterConfig" => Ok(__FieldTag::__virtual_cluster_config),
                            "virtual_cluster_config" => Ok(__FieldTag::__virtual_cluster_config),
                            "labels" => Ok(__FieldTag::__labels),
                            "status" => Ok(__FieldTag::__status),
                            "statusHistory" => Ok(__FieldTag::__status_history),
                            "status_history" => Ok(__FieldTag::__status_history),
                            "clusterUuid" => Ok(__FieldTag::__cluster_uuid),
                            "cluster_uuid" => Ok(__FieldTag::__cluster_uuid),
                            "metrics" => Ok(__FieldTag::__metrics),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Cluster;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Cluster")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_name => {
                            if !fields.insert(__FieldTag::__cluster_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_name",
                                ));
                            }
                            result.cluster_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map
                                .next_value::<std::option::Option<crate::model::ClusterConfig>>()?;
                        }
                        __FieldTag::__virtual_cluster_config => {
                            if !fields.insert(__FieldTag::__virtual_cluster_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for virtual_cluster_config",
                                ));
                            }
                            result.virtual_cluster_config = map.next_value::<std::option::Option<crate::model::VirtualClusterConfig>>()?
                                ;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<crate::model::ClusterStatus>>()?;
                        }
                        __FieldTag::__status_history => {
                            if !fields.insert(__FieldTag::__status_history) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_history",
                                ));
                            }
                            result.status_history = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ClusterStatus>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cluster_uuid => {
                            if !fields.insert(__FieldTag::__cluster_uuid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_uuid",
                                ));
                            }
                            result.cluster_uuid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metrics => {
                            if !fields.insert(__FieldTag::__metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metrics",
                                ));
                            }
                            result.metrics = map
                                .next_value::<std::option::Option<crate::model::ClusterMetrics>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Cluster {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.cluster_name.is_empty() {
            state.serialize_entry("clusterName", &self.cluster_name)?;
        }
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if self.virtual_cluster_config.is_some() {
            state.serialize_entry("virtualClusterConfig", &self.virtual_cluster_config)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.status_history.is_empty() {
            state.serialize_entry("statusHistory", &self.status_history)?;
        }
        if !self.cluster_uuid.is_empty() {
            state.serialize_entry("clusterUuid", &self.cluster_uuid)?;
        }
        if self.metrics.is_some() {
            state.serialize_entry("metrics", &self.metrics)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The cluster config.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ClusterConfig {
    /// Optional. The cluster tier.
    pub cluster_tier: crate::model::cluster_config::ClusterTier,

    /// Optional. A Cloud Storage bucket used to stage job
    /// dependencies, config files, and job driver console output.
    /// If you do not specify a staging bucket, Cloud
    /// Dataproc will determine a Cloud Storage location (US,
    /// ASIA, or EU) for your cluster's staging bucket according to the
    /// Compute Engine zone where your cluster is deployed, and then create
    /// and manage this project-level, per-location bucket (see
    /// [Dataproc staging and temp
    /// buckets](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/staging-bucket)).
    /// **This field requires a Cloud Storage bucket name, not a `gs://...` URI to
    /// a Cloud Storage bucket.**
    pub config_bucket: std::string::String,

    /// Optional. A Cloud Storage bucket used to store ephemeral cluster and jobs
    /// data, such as Spark and MapReduce history files. If you do not specify a
    /// temp bucket, Dataproc will determine a Cloud Storage location (US, ASIA, or
    /// EU) for your cluster's temp bucket according to the Compute Engine zone
    /// where your cluster is deployed, and then create and manage this
    /// project-level, per-location bucket. The default bucket has a TTL of 90
    /// days, but you can use any TTL (or none) if you specify a bucket (see
    /// [Dataproc staging and temp
    /// buckets](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/staging-bucket)).
    /// **This field requires a Cloud Storage bucket name, not a `gs://...` URI to
    /// a Cloud Storage bucket.**
    pub temp_bucket: std::string::String,

    /// Optional. The shared Compute Engine config settings for
    /// all instances in a cluster.
    pub gce_cluster_config: std::option::Option<crate::model::GceClusterConfig>,

    /// Optional. The Compute Engine config settings for
    /// the cluster's master instance.
    pub master_config: std::option::Option<crate::model::InstanceGroupConfig>,

    /// Optional. The Compute Engine config settings for
    /// the cluster's worker instances.
    pub worker_config: std::option::Option<crate::model::InstanceGroupConfig>,

    /// Optional. The Compute Engine config settings for
    /// a cluster's secondary worker instances
    pub secondary_worker_config: std::option::Option<crate::model::InstanceGroupConfig>,

    /// Optional. The config settings for cluster software.
    pub software_config: std::option::Option<crate::model::SoftwareConfig>,

    /// Optional. Commands to execute on each node after config is
    /// completed. By default, executables are run on master and all worker nodes.
    /// You can test a node's `role` metadata to run an executable on
    /// a master or worker node, as shown below using `curl` (you can also use
    /// `wget`):
    ///
    /// ```norust
    /// ROLE=$(curl -H Metadata-Flavor:Google
    /// http://metadata/computeMetadata/v1/instance/attributes/dataproc-role)
    /// if [[ "${ROLE}" == 'Master' ]]; then
    ///   ... master specific actions ...
    /// else
    ///   ... worker specific actions ...
    /// fi
    /// ```
    pub initialization_actions: std::vec::Vec<crate::model::NodeInitializationAction>,

    /// Optional. Encryption settings for the cluster.
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,

    /// Optional. Autoscaling config for the policy associated with the cluster.
    /// Cluster does not autoscale if this field is unset.
    pub autoscaling_config: std::option::Option<crate::model::AutoscalingConfig>,

    /// Optional. Security settings for the cluster.
    pub security_config: std::option::Option<crate::model::SecurityConfig>,

    /// Optional. Lifecycle setting for the cluster.
    pub lifecycle_config: std::option::Option<crate::model::LifecycleConfig>,

    /// Optional. Port/endpoint configuration for this cluster
    pub endpoint_config: std::option::Option<crate::model::EndpointConfig>,

    /// Optional. Metastore configuration.
    pub metastore_config: std::option::Option<crate::model::MetastoreConfig>,

    /// Optional. The config for Dataproc metrics.
    pub dataproc_metric_config: std::option::Option<crate::model::DataprocMetricConfig>,

    /// Optional. The node group settings.
    pub auxiliary_node_groups: std::vec::Vec<crate::model::AuxiliaryNodeGroup>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_tier][crate::model::ClusterConfig::cluster_tier].
    pub fn set_cluster_tier<T: std::convert::Into<crate::model::cluster_config::ClusterTier>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_tier = v.into();
        self
    }

    /// Sets the value of [config_bucket][crate::model::ClusterConfig::config_bucket].
    pub fn set_config_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.config_bucket = v.into();
        self
    }

    /// Sets the value of [temp_bucket][crate::model::ClusterConfig::temp_bucket].
    pub fn set_temp_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.temp_bucket = v.into();
        self
    }

    /// Sets the value of [gce_cluster_config][crate::model::ClusterConfig::gce_cluster_config].
    pub fn set_gce_cluster_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GceClusterConfig>,
    {
        self.gce_cluster_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gce_cluster_config][crate::model::ClusterConfig::gce_cluster_config].
    pub fn set_or_clear_gce_cluster_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GceClusterConfig>,
    {
        self.gce_cluster_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [master_config][crate::model::ClusterConfig::master_config].
    pub fn set_master_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupConfig>,
    {
        self.master_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [master_config][crate::model::ClusterConfig::master_config].
    pub fn set_or_clear_master_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupConfig>,
    {
        self.master_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [worker_config][crate::model::ClusterConfig::worker_config].
    pub fn set_worker_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupConfig>,
    {
        self.worker_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [worker_config][crate::model::ClusterConfig::worker_config].
    pub fn set_or_clear_worker_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupConfig>,
    {
        self.worker_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secondary_worker_config][crate::model::ClusterConfig::secondary_worker_config].
    pub fn set_secondary_worker_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupConfig>,
    {
        self.secondary_worker_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [secondary_worker_config][crate::model::ClusterConfig::secondary_worker_config].
    pub fn set_or_clear_secondary_worker_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupConfig>,
    {
        self.secondary_worker_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [software_config][crate::model::ClusterConfig::software_config].
    pub fn set_software_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SoftwareConfig>,
    {
        self.software_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [software_config][crate::model::ClusterConfig::software_config].
    pub fn set_or_clear_software_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SoftwareConfig>,
    {
        self.software_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [initialization_actions][crate::model::ClusterConfig::initialization_actions].
    pub fn set_initialization_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NodeInitializationAction>,
    {
        use std::iter::Iterator;
        self.initialization_actions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [encryption_config][crate::model::ClusterConfig::encryption_config].
    pub fn set_encryption_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_config][crate::model::ClusterConfig::encryption_config].
    pub fn set_or_clear_encryption_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionConfig>,
    {
        self.encryption_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [autoscaling_config][crate::model::ClusterConfig::autoscaling_config].
    pub fn set_autoscaling_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutoscalingConfig>,
    {
        self.autoscaling_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autoscaling_config][crate::model::ClusterConfig::autoscaling_config].
    pub fn set_or_clear_autoscaling_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutoscalingConfig>,
    {
        self.autoscaling_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [security_config][crate::model::ClusterConfig::security_config].
    pub fn set_security_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SecurityConfig>,
    {
        self.security_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [security_config][crate::model::ClusterConfig::security_config].
    pub fn set_or_clear_security_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SecurityConfig>,
    {
        self.security_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [lifecycle_config][crate::model::ClusterConfig::lifecycle_config].
    pub fn set_lifecycle_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LifecycleConfig>,
    {
        self.lifecycle_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [lifecycle_config][crate::model::ClusterConfig::lifecycle_config].
    pub fn set_or_clear_lifecycle_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LifecycleConfig>,
    {
        self.lifecycle_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [endpoint_config][crate::model::ClusterConfig::endpoint_config].
    pub fn set_endpoint_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EndpointConfig>,
    {
        self.endpoint_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [endpoint_config][crate::model::ClusterConfig::endpoint_config].
    pub fn set_or_clear_endpoint_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EndpointConfig>,
    {
        self.endpoint_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metastore_config][crate::model::ClusterConfig::metastore_config].
    pub fn set_metastore_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MetastoreConfig>,
    {
        self.metastore_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metastore_config][crate::model::ClusterConfig::metastore_config].
    pub fn set_or_clear_metastore_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MetastoreConfig>,
    {
        self.metastore_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dataproc_metric_config][crate::model::ClusterConfig::dataproc_metric_config].
    pub fn set_dataproc_metric_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataprocMetricConfig>,
    {
        self.dataproc_metric_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dataproc_metric_config][crate::model::ClusterConfig::dataproc_metric_config].
    pub fn set_or_clear_dataproc_metric_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataprocMetricConfig>,
    {
        self.dataproc_metric_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [auxiliary_node_groups][crate::model::ClusterConfig::auxiliary_node_groups].
    pub fn set_auxiliary_node_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AuxiliaryNodeGroup>,
    {
        use std::iter::Iterator;
        self.auxiliary_node_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ClusterConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ClusterConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClusterConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster_tier,
            __config_bucket,
            __temp_bucket,
            __gce_cluster_config,
            __master_config,
            __worker_config,
            __secondary_worker_config,
            __software_config,
            __initialization_actions,
            __encryption_config,
            __autoscaling_config,
            __security_config,
            __lifecycle_config,
            __endpoint_config,
            __metastore_config,
            __dataproc_metric_config,
            __auxiliary_node_groups,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClusterConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusterTier" => Ok(__FieldTag::__cluster_tier),
                            "cluster_tier" => Ok(__FieldTag::__cluster_tier),
                            "configBucket" => Ok(__FieldTag::__config_bucket),
                            "config_bucket" => Ok(__FieldTag::__config_bucket),
                            "tempBucket" => Ok(__FieldTag::__temp_bucket),
                            "temp_bucket" => Ok(__FieldTag::__temp_bucket),
                            "gceClusterConfig" => Ok(__FieldTag::__gce_cluster_config),
                            "gce_cluster_config" => Ok(__FieldTag::__gce_cluster_config),
                            "masterConfig" => Ok(__FieldTag::__master_config),
                            "master_config" => Ok(__FieldTag::__master_config),
                            "workerConfig" => Ok(__FieldTag::__worker_config),
                            "worker_config" => Ok(__FieldTag::__worker_config),
                            "secondaryWorkerConfig" => Ok(__FieldTag::__secondary_worker_config),
                            "secondary_worker_config" => Ok(__FieldTag::__secondary_worker_config),
                            "softwareConfig" => Ok(__FieldTag::__software_config),
                            "software_config" => Ok(__FieldTag::__software_config),
                            "initializationActions" => Ok(__FieldTag::__initialization_actions),
                            "initialization_actions" => Ok(__FieldTag::__initialization_actions),
                            "encryptionConfig" => Ok(__FieldTag::__encryption_config),
                            "encryption_config" => Ok(__FieldTag::__encryption_config),
                            "autoscalingConfig" => Ok(__FieldTag::__autoscaling_config),
                            "autoscaling_config" => Ok(__FieldTag::__autoscaling_config),
                            "securityConfig" => Ok(__FieldTag::__security_config),
                            "security_config" => Ok(__FieldTag::__security_config),
                            "lifecycleConfig" => Ok(__FieldTag::__lifecycle_config),
                            "lifecycle_config" => Ok(__FieldTag::__lifecycle_config),
                            "endpointConfig" => Ok(__FieldTag::__endpoint_config),
                            "endpoint_config" => Ok(__FieldTag::__endpoint_config),
                            "metastoreConfig" => Ok(__FieldTag::__metastore_config),
                            "metastore_config" => Ok(__FieldTag::__metastore_config),
                            "dataprocMetricConfig" => Ok(__FieldTag::__dataproc_metric_config),
                            "dataproc_metric_config" => Ok(__FieldTag::__dataproc_metric_config),
                            "auxiliaryNodeGroups" => Ok(__FieldTag::__auxiliary_node_groups),
                            "auxiliary_node_groups" => Ok(__FieldTag::__auxiliary_node_groups),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClusterConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClusterConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster_tier => {
                            if !fields.insert(__FieldTag::__cluster_tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_tier",
                                ));
                            }
                            result.cluster_tier = map.next_value::<std::option::Option<crate::model::cluster_config::ClusterTier>>()?.unwrap_or_default();
                        }
                        __FieldTag::__config_bucket => {
                            if !fields.insert(__FieldTag::__config_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_bucket",
                                ));
                            }
                            result.config_bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__temp_bucket => {
                            if !fields.insert(__FieldTag::__temp_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for temp_bucket",
                                ));
                            }
                            result.temp_bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gce_cluster_config => {
                            if !fields.insert(__FieldTag::__gce_cluster_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gce_cluster_config",
                                ));
                            }
                            result.gce_cluster_config = map
                                .next_value::<std::option::Option<crate::model::GceClusterConfig>>(
                                )?;
                        }
                        __FieldTag::__master_config => {
                            if !fields.insert(__FieldTag::__master_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for master_config",
                                ));
                            }
                            result.master_config = map.next_value::<std::option::Option<crate::model::InstanceGroupConfig>>()?
                                ;
                        }
                        __FieldTag::__worker_config => {
                            if !fields.insert(__FieldTag::__worker_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for worker_config",
                                ));
                            }
                            result.worker_config = map.next_value::<std::option::Option<crate::model::InstanceGroupConfig>>()?
                                ;
                        }
                        __FieldTag::__secondary_worker_config => {
                            if !fields.insert(__FieldTag::__secondary_worker_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_worker_config",
                                ));
                            }
                            result.secondary_worker_config = map.next_value::<std::option::Option<crate::model::InstanceGroupConfig>>()?
                                ;
                        }
                        __FieldTag::__software_config => {
                            if !fields.insert(__FieldTag::__software_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for software_config",
                                ));
                            }
                            result.software_config = map
                                .next_value::<std::option::Option<crate::model::SoftwareConfig>>(
                                )?;
                        }
                        __FieldTag::__initialization_actions => {
                            if !fields.insert(__FieldTag::__initialization_actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initialization_actions",
                                ));
                            }
                            result.initialization_actions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::NodeInitializationAction>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption_config => {
                            if !fields.insert(__FieldTag::__encryption_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_config",
                                ));
                            }
                            result.encryption_config = map
                                .next_value::<std::option::Option<crate::model::EncryptionConfig>>(
                                )?;
                        }
                        __FieldTag::__autoscaling_config => {
                            if !fields.insert(__FieldTag::__autoscaling_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoscaling_config",
                                ));
                            }
                            result.autoscaling_config = map
                                .next_value::<std::option::Option<crate::model::AutoscalingConfig>>(
                                )?;
                        }
                        __FieldTag::__security_config => {
                            if !fields.insert(__FieldTag::__security_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_config",
                                ));
                            }
                            result.security_config = map
                                .next_value::<std::option::Option<crate::model::SecurityConfig>>(
                                )?;
                        }
                        __FieldTag::__lifecycle_config => {
                            if !fields.insert(__FieldTag::__lifecycle_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lifecycle_config",
                                ));
                            }
                            result.lifecycle_config = map
                                .next_value::<std::option::Option<crate::model::LifecycleConfig>>(
                                )?;
                        }
                        __FieldTag::__endpoint_config => {
                            if !fields.insert(__FieldTag::__endpoint_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint_config",
                                ));
                            }
                            result.endpoint_config = map
                                .next_value::<std::option::Option<crate::model::EndpointConfig>>(
                                )?;
                        }
                        __FieldTag::__metastore_config => {
                            if !fields.insert(__FieldTag::__metastore_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metastore_config",
                                ));
                            }
                            result.metastore_config = map
                                .next_value::<std::option::Option<crate::model::MetastoreConfig>>(
                                )?;
                        }
                        __FieldTag::__dataproc_metric_config => {
                            if !fields.insert(__FieldTag::__dataproc_metric_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataproc_metric_config",
                                ));
                            }
                            result.dataproc_metric_config = map.next_value::<std::option::Option<crate::model::DataprocMetricConfig>>()?
                                ;
                        }
                        __FieldTag::__auxiliary_node_groups => {
                            if !fields.insert(__FieldTag::__auxiliary_node_groups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auxiliary_node_groups",
                                ));
                            }
                            result.auxiliary_node_groups = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AuxiliaryNodeGroup>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ClusterConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.cluster_tier) {
            state.serialize_entry("clusterTier", &self.cluster_tier)?;
        }
        if !self.config_bucket.is_empty() {
            state.serialize_entry("configBucket", &self.config_bucket)?;
        }
        if !self.temp_bucket.is_empty() {
            state.serialize_entry("tempBucket", &self.temp_bucket)?;
        }
        if self.gce_cluster_config.is_some() {
            state.serialize_entry("gceClusterConfig", &self.gce_cluster_config)?;
        }
        if self.master_config.is_some() {
            state.serialize_entry("masterConfig", &self.master_config)?;
        }
        if self.worker_config.is_some() {
            state.serialize_entry("workerConfig", &self.worker_config)?;
        }
        if self.secondary_worker_config.is_some() {
            state.serialize_entry("secondaryWorkerConfig", &self.secondary_worker_config)?;
        }
        if self.software_config.is_some() {
            state.serialize_entry("softwareConfig", &self.software_config)?;
        }
        if !self.initialization_actions.is_empty() {
            state.serialize_entry("initializationActions", &self.initialization_actions)?;
        }
        if self.encryption_config.is_some() {
            state.serialize_entry("encryptionConfig", &self.encryption_config)?;
        }
        if self.autoscaling_config.is_some() {
            state.serialize_entry("autoscalingConfig", &self.autoscaling_config)?;
        }
        if self.security_config.is_some() {
            state.serialize_entry("securityConfig", &self.security_config)?;
        }
        if self.lifecycle_config.is_some() {
            state.serialize_entry("lifecycleConfig", &self.lifecycle_config)?;
        }
        if self.endpoint_config.is_some() {
            state.serialize_entry("endpointConfig", &self.endpoint_config)?;
        }
        if self.metastore_config.is_some() {
            state.serialize_entry("metastoreConfig", &self.metastore_config)?;
        }
        if self.dataproc_metric_config.is_some() {
            state.serialize_entry("dataprocMetricConfig", &self.dataproc_metric_config)?;
        }
        if !self.auxiliary_node_groups.is_empty() {
            state.serialize_entry("auxiliaryNodeGroups", &self.auxiliary_node_groups)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ClusterConfig].
pub mod cluster_config {
    #[allow(unused_imports)]
    use super::*;

    /// The cluster tier.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ClusterTier {
        /// Not set. Works the same as CLUSTER_TIER_STANDARD.
        Unspecified,
        /// Standard Dataproc cluster.
        Standard,
        /// Premium Dataproc cluster.
        Premium,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ClusterTier::value] or
        /// [ClusterTier::name].
        UnknownValue(cluster_tier::UnknownValue),
    }

    #[doc(hidden)]
    pub mod cluster_tier {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ClusterTier {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Standard => std::option::Option::Some(1),
                Self::Premium => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CLUSTER_TIER_UNSPECIFIED"),
                Self::Standard => std::option::Option::Some("CLUSTER_TIER_STANDARD"),
                Self::Premium => std::option::Option::Some("CLUSTER_TIER_PREMIUM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ClusterTier {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ClusterTier {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ClusterTier {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Standard,
                2 => Self::Premium,
                _ => Self::UnknownValue(cluster_tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ClusterTier {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CLUSTER_TIER_UNSPECIFIED" => Self::Unspecified,
                "CLUSTER_TIER_STANDARD" => Self::Standard,
                "CLUSTER_TIER_PREMIUM" => Self::Premium,
                _ => Self::UnknownValue(cluster_tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ClusterTier {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Standard => serializer.serialize_i32(1),
                Self::Premium => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ClusterTier {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ClusterTier>::new(
                ".google.cloud.dataproc.v1.ClusterConfig.ClusterTier",
            ))
        }
    }
}

/// The Dataproc cluster config for a cluster that does not directly control the
/// underlying compute resources, such as a [Dataproc-on-GKE
/// cluster](https://cloud.google.com/dataproc/docs/guides/dpgke/dataproc-gke-overview).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VirtualClusterConfig {
    /// Optional. A Cloud Storage bucket used to stage job
    /// dependencies, config files, and job driver console output.
    /// If you do not specify a staging bucket, Cloud
    /// Dataproc will determine a Cloud Storage location (US,
    /// ASIA, or EU) for your cluster's staging bucket according to the
    /// Compute Engine zone where your cluster is deployed, and then create
    /// and manage this project-level, per-location bucket (see
    /// [Dataproc staging and temp
    /// buckets](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/staging-bucket)).
    /// **This field requires a Cloud Storage bucket name, not a `gs://...` URI to
    /// a Cloud Storage bucket.**
    pub staging_bucket: std::string::String,

    /// Optional. Configuration of auxiliary services used by this cluster.
    pub auxiliary_services_config: std::option::Option<crate::model::AuxiliaryServicesConfig>,

    pub infrastructure_config:
        std::option::Option<crate::model::virtual_cluster_config::InfrastructureConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VirtualClusterConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [staging_bucket][crate::model::VirtualClusterConfig::staging_bucket].
    pub fn set_staging_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.staging_bucket = v.into();
        self
    }

    /// Sets the value of [auxiliary_services_config][crate::model::VirtualClusterConfig::auxiliary_services_config].
    pub fn set_auxiliary_services_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AuxiliaryServicesConfig>,
    {
        self.auxiliary_services_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [auxiliary_services_config][crate::model::VirtualClusterConfig::auxiliary_services_config].
    pub fn set_or_clear_auxiliary_services_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AuxiliaryServicesConfig>,
    {
        self.auxiliary_services_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [infrastructure_config][crate::model::VirtualClusterConfig::infrastructure_config].
    ///
    /// Note that all the setters affecting `infrastructure_config` are mutually
    /// exclusive.
    pub fn set_infrastructure_config<
        T: std::convert::Into<
                std::option::Option<crate::model::virtual_cluster_config::InfrastructureConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.infrastructure_config = v.into();
        self
    }

    /// The value of [infrastructure_config][crate::model::VirtualClusterConfig::infrastructure_config]
    /// if it holds a `KubernetesClusterConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn kubernetes_cluster_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::KubernetesClusterConfig>> {
        #[allow(unreachable_patterns)]
        self.infrastructure_config.as_ref().and_then(|v| match v {
            crate::model::virtual_cluster_config::InfrastructureConfig::KubernetesClusterConfig(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [infrastructure_config][crate::model::VirtualClusterConfig::infrastructure_config]
    /// to hold a `KubernetesClusterConfig`.
    ///
    /// Note that all the setters affecting `infrastructure_config` are
    /// mutually exclusive.
    pub fn set_kubernetes_cluster_config<
        T: std::convert::Into<std::boxed::Box<crate::model::KubernetesClusterConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.infrastructure_config = std::option::Option::Some(
            crate::model::virtual_cluster_config::InfrastructureConfig::KubernetesClusterConfig(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for VirtualClusterConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.VirtualClusterConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VirtualClusterConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __staging_bucket,
            __kubernetes_cluster_config,
            __auxiliary_services_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VirtualClusterConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "stagingBucket" => Ok(__FieldTag::__staging_bucket),
                            "staging_bucket" => Ok(__FieldTag::__staging_bucket),
                            "kubernetesClusterConfig" => {
                                Ok(__FieldTag::__kubernetes_cluster_config)
                            }
                            "kubernetes_cluster_config" => {
                                Ok(__FieldTag::__kubernetes_cluster_config)
                            }
                            "auxiliaryServicesConfig" => {
                                Ok(__FieldTag::__auxiliary_services_config)
                            }
                            "auxiliary_services_config" => {
                                Ok(__FieldTag::__auxiliary_services_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VirtualClusterConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VirtualClusterConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__staging_bucket => {
                            if !fields.insert(__FieldTag::__staging_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for staging_bucket",
                                ));
                            }
                            result.staging_bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kubernetes_cluster_config => {
                            if !fields.insert(__FieldTag::__kubernetes_cluster_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kubernetes_cluster_config",
                                ));
                            }
                            if result.infrastructure_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `infrastructure_config`, a oneof with full ID .google.cloud.dataproc.v1.VirtualClusterConfig.kubernetes_cluster_config, latest field was kubernetesClusterConfig",
                                ));
                            }
                            result.infrastructure_config = std::option::Option::Some(
                                crate::model::virtual_cluster_config::InfrastructureConfig::KubernetesClusterConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::KubernetesClusterConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__auxiliary_services_config => {
                            if !fields.insert(__FieldTag::__auxiliary_services_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auxiliary_services_config",
                                ));
                            }
                            result.auxiliary_services_config = map.next_value::<std::option::Option<crate::model::AuxiliaryServicesConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VirtualClusterConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.staging_bucket.is_empty() {
            state.serialize_entry("stagingBucket", &self.staging_bucket)?;
        }
        if let Some(value) = self.kubernetes_cluster_config() {
            state.serialize_entry("kubernetesClusterConfig", value)?;
        }
        if self.auxiliary_services_config.is_some() {
            state.serialize_entry("auxiliaryServicesConfig", &self.auxiliary_services_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VirtualClusterConfig].
pub mod virtual_cluster_config {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InfrastructureConfig {
        /// Required. The configuration for running the Dataproc cluster on
        /// Kubernetes.
        KubernetesClusterConfig(std::boxed::Box<crate::model::KubernetesClusterConfig>),
    }
}

/// Auxiliary services configuration for a Cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AuxiliaryServicesConfig {
    /// Optional. The Hive Metastore configuration for this workload.
    pub metastore_config: std::option::Option<crate::model::MetastoreConfig>,

    /// Optional. The Spark History Server configuration for the workload.
    pub spark_history_server_config: std::option::Option<crate::model::SparkHistoryServerConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuxiliaryServicesConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metastore_config][crate::model::AuxiliaryServicesConfig::metastore_config].
    pub fn set_metastore_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MetastoreConfig>,
    {
        self.metastore_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metastore_config][crate::model::AuxiliaryServicesConfig::metastore_config].
    pub fn set_or_clear_metastore_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MetastoreConfig>,
    {
        self.metastore_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [spark_history_server_config][crate::model::AuxiliaryServicesConfig::spark_history_server_config].
    pub fn set_spark_history_server_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SparkHistoryServerConfig>,
    {
        self.spark_history_server_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [spark_history_server_config][crate::model::AuxiliaryServicesConfig::spark_history_server_config].
    pub fn set_or_clear_spark_history_server_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SparkHistoryServerConfig>,
    {
        self.spark_history_server_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AuxiliaryServicesConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.AuxiliaryServicesConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AuxiliaryServicesConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __metastore_config,
            __spark_history_server_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AuxiliaryServicesConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "metastoreConfig" => Ok(__FieldTag::__metastore_config),
                            "metastore_config" => Ok(__FieldTag::__metastore_config),
                            "sparkHistoryServerConfig" => {
                                Ok(__FieldTag::__spark_history_server_config)
                            }
                            "spark_history_server_config" => {
                                Ok(__FieldTag::__spark_history_server_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AuxiliaryServicesConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AuxiliaryServicesConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__metastore_config => {
                            if !fields.insert(__FieldTag::__metastore_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metastore_config",
                                ));
                            }
                            result.metastore_config = map
                                .next_value::<std::option::Option<crate::model::MetastoreConfig>>(
                                )?;
                        }
                        __FieldTag::__spark_history_server_config => {
                            if !fields.insert(__FieldTag::__spark_history_server_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark_history_server_config",
                                ));
                            }
                            result.spark_history_server_config = map.next_value::<std::option::Option<crate::model::SparkHistoryServerConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AuxiliaryServicesConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.metastore_config.is_some() {
            state.serialize_entry("metastoreConfig", &self.metastore_config)?;
        }
        if self.spark_history_server_config.is_some() {
            state.serialize_entry(
                "sparkHistoryServerConfig",
                &self.spark_history_server_config,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Endpoint config for this cluster
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EndpointConfig {
    /// Output only. The map of port descriptions to URLs. Will only be populated
    /// if enable_http_port_access is true.
    pub http_ports: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. If true, enable http access to specific ports on the cluster
    /// from external sources. Defaults to false.
    pub enable_http_port_access: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EndpointConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [http_ports][crate::model::EndpointConfig::http_ports].
    pub fn set_http_ports<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.http_ports = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [enable_http_port_access][crate::model::EndpointConfig::enable_http_port_access].
    pub fn set_enable_http_port_access<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_http_port_access = v.into();
        self
    }
}

impl wkt::message::Message for EndpointConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.EndpointConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EndpointConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __http_ports,
            __enable_http_port_access,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EndpointConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "httpPorts" => Ok(__FieldTag::__http_ports),
                            "http_ports" => Ok(__FieldTag::__http_ports),
                            "enableHttpPortAccess" => Ok(__FieldTag::__enable_http_port_access),
                            "enable_http_port_access" => Ok(__FieldTag::__enable_http_port_access),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EndpointConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EndpointConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__http_ports => {
                            if !fields.insert(__FieldTag::__http_ports) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_ports",
                                ));
                            }
                            result.http_ports = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_http_port_access => {
                            if !fields.insert(__FieldTag::__enable_http_port_access) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_http_port_access",
                                ));
                            }
                            result.enable_http_port_access = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EndpointConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.http_ports.is_empty() {
            state.serialize_entry("httpPorts", &self.http_ports)?;
        }
        if !wkt::internal::is_default(&self.enable_http_port_access) {
            state.serialize_entry("enableHttpPortAccess", &self.enable_http_port_access)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Autoscaling Policy config associated with the cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoscalingConfig {
    /// Optional. The autoscaling policy used by the cluster.
    ///
    /// Only resource names including projectid and location (region) are valid.
    /// Examples:
    ///
    /// * `<https://www.googleapis.com/compute/v1/projects/>[project_id]/locations/[dataproc_region]/autoscalingPolicies/[policy_id]`
    /// * `projects/[project_id]/locations/[dataproc_region]/autoscalingPolicies/[policy_id]`
    ///
    /// Note that the policy must be in the same project and Dataproc region.
    pub policy_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoscalingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy_uri][crate::model::AutoscalingConfig::policy_uri].
    pub fn set_policy_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy_uri = v.into();
        self
    }
}

impl wkt::message::Message for AutoscalingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.AutoscalingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutoscalingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __policy_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutoscalingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "policyUri" => Ok(__FieldTag::__policy_uri),
                            "policy_uri" => Ok(__FieldTag::__policy_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutoscalingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutoscalingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__policy_uri => {
                            if !fields.insert(__FieldTag::__policy_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_uri",
                                ));
                            }
                            result.policy_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutoscalingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.policy_uri.is_empty() {
            state.serialize_entry("policyUri", &self.policy_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Encryption settings for the cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EncryptionConfig {
    /// Optional. The Cloud KMS key resource name to use for persistent disk
    /// encryption for all instances in the cluster. See [Use CMEK with cluster
    /// data]
    /// (<https://cloud.google.com//dataproc/docs/concepts/configuring-clusters/customer-managed-encryption#use_cmek_with_cluster_data>)
    /// for more information.
    pub gce_pd_kms_key_name: std::string::String,

    /// Optional. The Cloud KMS key resource name to use for cluster persistent
    /// disk and job argument encryption. See [Use CMEK with cluster data]
    /// (<https://cloud.google.com//dataproc/docs/concepts/configuring-clusters/customer-managed-encryption#use_cmek_with_cluster_data>)
    /// for more information.
    ///
    /// When this key resource name is provided, the following job arguments of
    /// the following job types submitted to the cluster are encrypted using CMEK:
    ///
    /// * [FlinkJob
    ///   args](https://cloud.google.com/dataproc/docs/reference/rest/v1/FlinkJob)
    /// * [HadoopJob
    ///   args](https://cloud.google.com/dataproc/docs/reference/rest/v1/HadoopJob)
    /// * [SparkJob
    ///   args](https://cloud.google.com/dataproc/docs/reference/rest/v1/SparkJob)
    /// * [SparkRJob
    ///   args](https://cloud.google.com/dataproc/docs/reference/rest/v1/SparkRJob)
    /// * [PySparkJob
    ///   args](https://cloud.google.com/dataproc/docs/reference/rest/v1/PySparkJob)
    /// * [SparkSqlJob](https://cloud.google.com/dataproc/docs/reference/rest/v1/SparkSqlJob)
    ///   scriptVariables and queryList.queries
    /// * [HiveJob](https://cloud.google.com/dataproc/docs/reference/rest/v1/HiveJob)
    ///   scriptVariables and queryList.queries
    /// * [PigJob](https://cloud.google.com/dataproc/docs/reference/rest/v1/PigJob)
    ///   scriptVariables and queryList.queries
    /// * [PrestoJob](https://cloud.google.com/dataproc/docs/reference/rest/v1/PrestoJob)
    ///   scriptVariables and queryList.queries
    pub kms_key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EncryptionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gce_pd_kms_key_name][crate::model::EncryptionConfig::gce_pd_kms_key_name].
    pub fn set_gce_pd_kms_key_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.gce_pd_kms_key_name = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::EncryptionConfig::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }
}

impl wkt::message::Message for EncryptionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.EncryptionConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EncryptionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gce_pd_kms_key_name,
            __kms_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EncryptionConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcePdKmsKeyName" => Ok(__FieldTag::__gce_pd_kms_key_name),
                            "gce_pd_kms_key_name" => Ok(__FieldTag::__gce_pd_kms_key_name),
                            "kmsKey" => Ok(__FieldTag::__kms_key),
                            "kms_key" => Ok(__FieldTag::__kms_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EncryptionConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EncryptionConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gce_pd_kms_key_name => {
                            if !fields.insert(__FieldTag::__gce_pd_kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gce_pd_kms_key_name",
                                ));
                            }
                            result.gce_pd_kms_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key => {
                            if !fields.insert(__FieldTag::__kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key",
                                ));
                            }
                            result.kms_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EncryptionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.gce_pd_kms_key_name.is_empty() {
            state.serialize_entry("gcePdKmsKeyName", &self.gce_pd_kms_key_name)?;
        }
        if !self.kms_key.is_empty() {
            state.serialize_entry("kmsKey", &self.kms_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Common config settings for resources of Compute Engine cluster
/// instances, applicable to all instances in the cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GceClusterConfig {
    /// Optional. The Compute Engine zone where the Dataproc cluster will be
    /// located. If omitted, the service will pick a zone in the cluster's Compute
    /// Engine region. On a get request, zone will always be present.
    ///
    /// A full URL, partial URI, or short name are valid. Examples:
    ///
    /// * `<https://www.googleapis.com/compute/v1/projects/>[project_id]/zones/[zone]`
    /// * `projects/[project_id]/zones/[zone]`
    /// * `[zone]`
    pub zone_uri: std::string::String,

    /// Optional. The Compute Engine network to be used for machine
    /// communications. Cannot be specified with subnetwork_uri. If neither
    /// `network_uri` nor `subnetwork_uri` is specified, the "default" network of
    /// the project is used, if it exists. Cannot be a "Custom Subnet Network" (see
    /// [Using Subnetworks](https://cloud.google.com/compute/docs/subnetworks) for
    /// more information).
    ///
    /// A full URL, partial URI, or short name are valid. Examples:
    ///
    /// * `<https://www.googleapis.com/compute/v1/projects/>[project_id]/global/networks/default`
    /// * `projects/[project_id]/global/networks/default`
    /// * `default`
    pub network_uri: std::string::String,

    /// Optional. The Compute Engine subnetwork to be used for machine
    /// communications. Cannot be specified with network_uri.
    ///
    /// A full URL, partial URI, or short name are valid. Examples:
    ///
    /// * `<https://www.googleapis.com/compute/v1/projects/>[project_id]/regions/[region]/subnetworks/sub0`
    /// * `projects/[project_id]/regions/[region]/subnetworks/sub0`
    /// * `sub0`
    pub subnetwork_uri: std::string::String,

    /// Optional. This setting applies to subnetwork-enabled networks. It is set to
    /// `true` by default in clusters created with image versions 2.2.x.
    ///
    /// When set to `true`:
    ///
    /// * All cluster VMs have internal IP addresses.
    /// * [Google Private Access]
    ///   (<https://cloud.google.com/vpc/docs/private-google-access>)
    ///   must be enabled to access Dataproc and other Google Cloud APIs.
    /// * Off-cluster dependencies must be configured to be accessible
    ///   without external IP addresses.
    ///
    /// When set to `false`:
    ///
    /// * Cluster VMs are not restricted to internal IP addresses.
    /// * Ephemeral external IP addresses are assigned to each cluster VM.
    pub internal_ip_only: std::option::Option<bool>,

    /// Optional. The type of IPv6 access for a cluster.
    pub private_ipv6_google_access: crate::model::gce_cluster_config::PrivateIpv6GoogleAccess,

    /// Optional. The [Dataproc service
    /// account](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/service-accounts#service_accounts_in_dataproc)
    /// (also see [VM Data Plane
    /// identity](https://cloud.google.com/dataproc/docs/concepts/iam/dataproc-principals#vm_service_account_data_plane_identity))
    /// used by Dataproc cluster VM instances to access Google Cloud Platform
    /// services.
    ///
    /// If not specified, the
    /// [Compute Engine default service
    /// account](https://cloud.google.com/compute/docs/access/service-accounts#default_service_account)
    /// is used.
    pub service_account: std::string::String,

    /// Optional. The URIs of service account scopes to be included in
    /// Compute Engine instances. The following base set of scopes is always
    /// included:
    ///
    /// * <https://www.googleapis.com/auth/cloud.useraccounts.readonly>
    /// * <https://www.googleapis.com/auth/devstorage.read_write>
    /// * <https://www.googleapis.com/auth/logging.write>
    ///
    /// If no scopes are specified, the following defaults are also provided:
    ///
    /// * <https://www.googleapis.com/auth/bigquery>
    /// * <https://www.googleapis.com/auth/bigtable.admin.table>
    /// * <https://www.googleapis.com/auth/bigtable.data>
    /// * <https://www.googleapis.com/auth/devstorage.full_control>
    pub service_account_scopes: std::vec::Vec<std::string::String>,

    /// The Compute Engine network tags to add to all instances (see [Tagging
    /// instances](https://cloud.google.com/vpc/docs/add-remove-network-tags)).
    pub tags: std::vec::Vec<std::string::String>,

    /// Optional. The Compute Engine metadata entries to add to all instances (see
    /// [Project and instance
    /// metadata](https://cloud.google.com/compute/docs/storing-retrieving-metadata#project_and_instance_metadata)).
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Reservation Affinity for consuming Zonal reservation.
    pub reservation_affinity: std::option::Option<crate::model::ReservationAffinity>,

    /// Optional. Node Group Affinity for sole-tenant clusters.
    pub node_group_affinity: std::option::Option<crate::model::NodeGroupAffinity>,

    /// Optional. Shielded Instance Config for clusters using [Compute Engine
    /// Shielded
    /// VMs](https://cloud.google.com/security/shielded-cloud/shielded-vm).
    pub shielded_instance_config: std::option::Option<crate::model::ShieldedInstanceConfig>,

    /// Optional. Confidential Instance Config for clusters using [Confidential
    /// VMs](https://cloud.google.com/compute/confidential-vm/docs).
    pub confidential_instance_config: std::option::Option<crate::model::ConfidentialInstanceConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GceClusterConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [zone_uri][crate::model::GceClusterConfig::zone_uri].
    pub fn set_zone_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone_uri = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::GceClusterConfig::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }

    /// Sets the value of [subnetwork_uri][crate::model::GceClusterConfig::subnetwork_uri].
    pub fn set_subnetwork_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork_uri = v.into();
        self
    }

    /// Sets the value of [internal_ip_only][crate::model::GceClusterConfig::internal_ip_only].
    pub fn set_internal_ip_only<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.internal_ip_only = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [internal_ip_only][crate::model::GceClusterConfig::internal_ip_only].
    pub fn set_or_clear_internal_ip_only<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.internal_ip_only = v.map(|x| x.into());
        self
    }

    /// Sets the value of [private_ipv6_google_access][crate::model::GceClusterConfig::private_ipv6_google_access].
    pub fn set_private_ipv6_google_access<
        T: std::convert::Into<crate::model::gce_cluster_config::PrivateIpv6GoogleAccess>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_ipv6_google_access = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::GceClusterConfig::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [service_account_scopes][crate::model::GceClusterConfig::service_account_scopes].
    pub fn set_service_account_scopes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.service_account_scopes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tags][crate::model::GceClusterConfig::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metadata][crate::model::GceClusterConfig::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [reservation_affinity][crate::model::GceClusterConfig::reservation_affinity].
    pub fn set_reservation_affinity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReservationAffinity>,
    {
        self.reservation_affinity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reservation_affinity][crate::model::GceClusterConfig::reservation_affinity].
    pub fn set_or_clear_reservation_affinity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReservationAffinity>,
    {
        self.reservation_affinity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [node_group_affinity][crate::model::GceClusterConfig::node_group_affinity].
    pub fn set_node_group_affinity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeGroupAffinity>,
    {
        self.node_group_affinity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_group_affinity][crate::model::GceClusterConfig::node_group_affinity].
    pub fn set_or_clear_node_group_affinity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeGroupAffinity>,
    {
        self.node_group_affinity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [shielded_instance_config][crate::model::GceClusterConfig::shielded_instance_config].
    pub fn set_shielded_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceConfig>,
    {
        self.shielded_instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [shielded_instance_config][crate::model::GceClusterConfig::shielded_instance_config].
    pub fn set_or_clear_shielded_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceConfig>,
    {
        self.shielded_instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [confidential_instance_config][crate::model::GceClusterConfig::confidential_instance_config].
    pub fn set_confidential_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConfidentialInstanceConfig>,
    {
        self.confidential_instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [confidential_instance_config][crate::model::GceClusterConfig::confidential_instance_config].
    pub fn set_or_clear_confidential_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConfidentialInstanceConfig>,
    {
        self.confidential_instance_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GceClusterConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GceClusterConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GceClusterConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __zone_uri,
            __network_uri,
            __subnetwork_uri,
            __internal_ip_only,
            __private_ipv6_google_access,
            __service_account,
            __service_account_scopes,
            __tags,
            __metadata,
            __reservation_affinity,
            __node_group_affinity,
            __shielded_instance_config,
            __confidential_instance_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GceClusterConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "zoneUri" => Ok(__FieldTag::__zone_uri),
                            "zone_uri" => Ok(__FieldTag::__zone_uri),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "subnetworkUri" => Ok(__FieldTag::__subnetwork_uri),
                            "subnetwork_uri" => Ok(__FieldTag::__subnetwork_uri),
                            "internalIpOnly" => Ok(__FieldTag::__internal_ip_only),
                            "internal_ip_only" => Ok(__FieldTag::__internal_ip_only),
                            "privateIpv6GoogleAccess" => {
                                Ok(__FieldTag::__private_ipv6_google_access)
                            }
                            "private_ipv6_google_access" => {
                                Ok(__FieldTag::__private_ipv6_google_access)
                            }
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "serviceAccountScopes" => Ok(__FieldTag::__service_account_scopes),
                            "service_account_scopes" => Ok(__FieldTag::__service_account_scopes),
                            "tags" => Ok(__FieldTag::__tags),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "reservationAffinity" => Ok(__FieldTag::__reservation_affinity),
                            "reservation_affinity" => Ok(__FieldTag::__reservation_affinity),
                            "nodeGroupAffinity" => Ok(__FieldTag::__node_group_affinity),
                            "node_group_affinity" => Ok(__FieldTag::__node_group_affinity),
                            "shieldedInstanceConfig" => Ok(__FieldTag::__shielded_instance_config),
                            "shielded_instance_config" => {
                                Ok(__FieldTag::__shielded_instance_config)
                            }
                            "confidentialInstanceConfig" => {
                                Ok(__FieldTag::__confidential_instance_config)
                            }
                            "confidential_instance_config" => {
                                Ok(__FieldTag::__confidential_instance_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GceClusterConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GceClusterConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__zone_uri => {
                            if !fields.insert(__FieldTag::__zone_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone_uri",
                                ));
                            }
                            result.zone_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            result.network_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subnetwork_uri => {
                            if !fields.insert(__FieldTag::__subnetwork_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork_uri",
                                ));
                            }
                            result.subnetwork_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__internal_ip_only => {
                            if !fields.insert(__FieldTag::__internal_ip_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for internal_ip_only",
                                ));
                            }
                            result.internal_ip_only =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__private_ipv6_google_access => {
                            if !fields.insert(__FieldTag::__private_ipv6_google_access) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_ipv6_google_access",
                                ));
                            }
                            result.private_ipv6_google_access = map
                                .next_value::<std::option::Option<
                                    crate::model::gce_cluster_config::PrivateIpv6GoogleAccess,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account_scopes => {
                            if !fields.insert(__FieldTag::__service_account_scopes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account_scopes",
                                ));
                            }
                            result.service_account_scopes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reservation_affinity => {
                            if !fields.insert(__FieldTag::__reservation_affinity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reservation_affinity",
                                ));
                            }
                            result.reservation_affinity = map.next_value::<std::option::Option<crate::model::ReservationAffinity>>()?
                                ;
                        }
                        __FieldTag::__node_group_affinity => {
                            if !fields.insert(__FieldTag::__node_group_affinity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_group_affinity",
                                ));
                            }
                            result.node_group_affinity = map
                                .next_value::<std::option::Option<crate::model::NodeGroupAffinity>>(
                                )?;
                        }
                        __FieldTag::__shielded_instance_config => {
                            if !fields.insert(__FieldTag::__shielded_instance_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shielded_instance_config",
                                ));
                            }
                            result.shielded_instance_config = map.next_value::<std::option::Option<crate::model::ShieldedInstanceConfig>>()?
                                ;
                        }
                        __FieldTag::__confidential_instance_config => {
                            if !fields.insert(__FieldTag::__confidential_instance_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidential_instance_config",
                                ));
                            }
                            result.confidential_instance_config = map.next_value::<std::option::Option<crate::model::ConfidentialInstanceConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GceClusterConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.zone_uri.is_empty() {
            state.serialize_entry("zoneUri", &self.zone_uri)?;
        }
        if !self.network_uri.is_empty() {
            state.serialize_entry("networkUri", &self.network_uri)?;
        }
        if !self.subnetwork_uri.is_empty() {
            state.serialize_entry("subnetworkUri", &self.subnetwork_uri)?;
        }
        if self.internal_ip_only.is_some() {
            state.serialize_entry("internalIpOnly", &self.internal_ip_only)?;
        }
        if !wkt::internal::is_default(&self.private_ipv6_google_access) {
            state.serialize_entry("privateIpv6GoogleAccess", &self.private_ipv6_google_access)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self.service_account_scopes.is_empty() {
            state.serialize_entry("serviceAccountScopes", &self.service_account_scopes)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if self.reservation_affinity.is_some() {
            state.serialize_entry("reservationAffinity", &self.reservation_affinity)?;
        }
        if self.node_group_affinity.is_some() {
            state.serialize_entry("nodeGroupAffinity", &self.node_group_affinity)?;
        }
        if self.shielded_instance_config.is_some() {
            state.serialize_entry("shieldedInstanceConfig", &self.shielded_instance_config)?;
        }
        if self.confidential_instance_config.is_some() {
            state.serialize_entry(
                "confidentialInstanceConfig",
                &self.confidential_instance_config,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GceClusterConfig].
pub mod gce_cluster_config {
    #[allow(unused_imports)]
    use super::*;

    /// `PrivateIpv6GoogleAccess` controls whether and how Dataproc cluster nodes
    /// can communicate with Google Services through gRPC over IPv6.
    /// These values are directly mapped to corresponding values in the
    /// [Compute Engine Instance
    /// fields](https://cloud.google.com/compute/docs/reference/rest/v1/instances).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PrivateIpv6GoogleAccess {
        /// If unspecified, Compute Engine default behavior will apply, which
        /// is the same as
        /// [INHERIT_FROM_SUBNETWORK][google.cloud.dataproc.v1.GceClusterConfig.PrivateIpv6GoogleAccess.INHERIT_FROM_SUBNETWORK].
        ///
        /// [google.cloud.dataproc.v1.GceClusterConfig.PrivateIpv6GoogleAccess.INHERIT_FROM_SUBNETWORK]: crate::model::gce_cluster_config::PrivateIpv6GoogleAccess::InheritFromSubnetwork
        Unspecified,
        /// Private access to and from Google Services configuration
        /// inherited from the subnetwork configuration. This is the
        /// default Compute Engine behavior.
        InheritFromSubnetwork,
        /// Enables outbound private IPv6 access to Google Services from the Dataproc
        /// cluster.
        Outbound,
        /// Enables bidirectional private IPv6 access between Google Services and the
        /// Dataproc cluster.
        Bidirectional,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PrivateIpv6GoogleAccess::value] or
        /// [PrivateIpv6GoogleAccess::name].
        UnknownValue(private_ipv_6_google_access::UnknownValue),
    }

    #[doc(hidden)]
    pub mod private_ipv_6_google_access {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PrivateIpv6GoogleAccess {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InheritFromSubnetwork => std::option::Option::Some(1),
                Self::Outbound => std::option::Option::Some(2),
                Self::Bidirectional => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED")
                }
                Self::InheritFromSubnetwork => std::option::Option::Some("INHERIT_FROM_SUBNETWORK"),
                Self::Outbound => std::option::Option::Some("OUTBOUND"),
                Self::Bidirectional => std::option::Option::Some("BIDIRECTIONAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PrivateIpv6GoogleAccess {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PrivateIpv6GoogleAccess {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PrivateIpv6GoogleAccess {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InheritFromSubnetwork,
                2 => Self::Outbound,
                3 => Self::Bidirectional,
                _ => Self::UnknownValue(private_ipv_6_google_access::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PrivateIpv6GoogleAccess {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED" => Self::Unspecified,
                "INHERIT_FROM_SUBNETWORK" => Self::InheritFromSubnetwork,
                "OUTBOUND" => Self::Outbound,
                "BIDIRECTIONAL" => Self::Bidirectional,
                _ => Self::UnknownValue(private_ipv_6_google_access::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PrivateIpv6GoogleAccess {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InheritFromSubnetwork => serializer.serialize_i32(1),
                Self::Outbound => serializer.serialize_i32(2),
                Self::Bidirectional => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PrivateIpv6GoogleAccess {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<PrivateIpv6GoogleAccess>::new(
                    ".google.cloud.dataproc.v1.GceClusterConfig.PrivateIpv6GoogleAccess",
                ),
            )
        }
    }
}

/// Node Group Affinity for clusters using sole-tenant node groups.
/// **The Dataproc `NodeGroupAffinity` resource is not related to the
/// Dataproc [NodeGroup][google.cloud.dataproc.v1.NodeGroup] resource.**
///
/// [google.cloud.dataproc.v1.NodeGroup]: crate::model::NodeGroup
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NodeGroupAffinity {
    /// Required. The URI of a
    /// sole-tenant [node group
    /// resource](https://cloud.google.com/compute/docs/reference/rest/v1/nodeGroups)
    /// that the cluster will be created on.
    ///
    /// A full URL, partial URI, or node group name are valid. Examples:
    ///
    /// * `<https://www.googleapis.com/compute/v1/projects/>[project_id]/zones/[zone]/nodeGroups/node-group-1`
    /// * `projects/[project_id]/zones/[zone]/nodeGroups/node-group-1`
    /// * `node-group-1`
    pub node_group_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeGroupAffinity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [node_group_uri][crate::model::NodeGroupAffinity::node_group_uri].
    pub fn set_node_group_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_group_uri = v.into();
        self
    }
}

impl wkt::message::Message for NodeGroupAffinity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.NodeGroupAffinity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodeGroupAffinity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __node_group_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeGroupAffinity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nodeGroupUri" => Ok(__FieldTag::__node_group_uri),
                            "node_group_uri" => Ok(__FieldTag::__node_group_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodeGroupAffinity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeGroupAffinity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__node_group_uri => {
                            if !fields.insert(__FieldTag::__node_group_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_group_uri",
                                ));
                            }
                            result.node_group_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodeGroupAffinity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.node_group_uri.is_empty() {
            state.serialize_entry("nodeGroupUri", &self.node_group_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Shielded Instance Config for clusters using [Compute Engine Shielded
/// VMs](https://cloud.google.com/security/shielded-cloud/shielded-vm).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ShieldedInstanceConfig {
    /// Optional. Defines whether instances have Secure Boot enabled.
    pub enable_secure_boot: std::option::Option<bool>,

    /// Optional. Defines whether instances have the vTPM enabled.
    pub enable_vtpm: std::option::Option<bool>,

    /// Optional. Defines whether instances have integrity monitoring enabled.
    pub enable_integrity_monitoring: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ShieldedInstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_secure_boot][crate::model::ShieldedInstanceConfig::enable_secure_boot].
    pub fn set_enable_secure_boot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_secure_boot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_secure_boot][crate::model::ShieldedInstanceConfig::enable_secure_boot].
    pub fn set_or_clear_enable_secure_boot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_secure_boot = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_vtpm][crate::model::ShieldedInstanceConfig::enable_vtpm].
    pub fn set_enable_vtpm<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_vtpm = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_vtpm][crate::model::ShieldedInstanceConfig::enable_vtpm].
    pub fn set_or_clear_enable_vtpm<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_vtpm = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_integrity_monitoring][crate::model::ShieldedInstanceConfig::enable_integrity_monitoring].
    pub fn set_enable_integrity_monitoring<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_integrity_monitoring = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_integrity_monitoring][crate::model::ShieldedInstanceConfig::enable_integrity_monitoring].
    pub fn set_or_clear_enable_integrity_monitoring<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_integrity_monitoring = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ShieldedInstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ShieldedInstanceConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ShieldedInstanceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_secure_boot,
            __enable_vtpm,
            __enable_integrity_monitoring,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ShieldedInstanceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableSecureBoot" => Ok(__FieldTag::__enable_secure_boot),
                            "enable_secure_boot" => Ok(__FieldTag::__enable_secure_boot),
                            "enableVtpm" => Ok(__FieldTag::__enable_vtpm),
                            "enable_vtpm" => Ok(__FieldTag::__enable_vtpm),
                            "enableIntegrityMonitoring" => {
                                Ok(__FieldTag::__enable_integrity_monitoring)
                            }
                            "enable_integrity_monitoring" => {
                                Ok(__FieldTag::__enable_integrity_monitoring)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ShieldedInstanceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ShieldedInstanceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_secure_boot => {
                            if !fields.insert(__FieldTag::__enable_secure_boot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_secure_boot",
                                ));
                            }
                            result.enable_secure_boot =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__enable_vtpm => {
                            if !fields.insert(__FieldTag::__enable_vtpm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_vtpm",
                                ));
                            }
                            result.enable_vtpm = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__enable_integrity_monitoring => {
                            if !fields.insert(__FieldTag::__enable_integrity_monitoring) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_integrity_monitoring",
                                ));
                            }
                            result.enable_integrity_monitoring =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ShieldedInstanceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enable_secure_boot.is_some() {
            state.serialize_entry("enableSecureBoot", &self.enable_secure_boot)?;
        }
        if self.enable_vtpm.is_some() {
            state.serialize_entry("enableVtpm", &self.enable_vtpm)?;
        }
        if self.enable_integrity_monitoring.is_some() {
            state.serialize_entry(
                "enableIntegrityMonitoring",
                &self.enable_integrity_monitoring,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Confidential Instance Config for clusters using [Confidential
/// VMs](https://cloud.google.com/compute/confidential-vm/docs)
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ConfidentialInstanceConfig {
    /// Optional. Defines whether the instance should have confidential compute
    /// enabled.
    pub enable_confidential_compute: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfidentialInstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_confidential_compute][crate::model::ConfidentialInstanceConfig::enable_confidential_compute].
    pub fn set_enable_confidential_compute<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_confidential_compute = v.into();
        self
    }
}

impl wkt::message::Message for ConfidentialInstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ConfidentialInstanceConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConfidentialInstanceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_confidential_compute,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConfidentialInstanceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableConfidentialCompute" => {
                                Ok(__FieldTag::__enable_confidential_compute)
                            }
                            "enable_confidential_compute" => {
                                Ok(__FieldTag::__enable_confidential_compute)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConfidentialInstanceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConfidentialInstanceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_confidential_compute => {
                            if !fields.insert(__FieldTag::__enable_confidential_compute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_confidential_compute",
                                ));
                            }
                            result.enable_confidential_compute = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConfidentialInstanceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_confidential_compute) {
            state.serialize_entry(
                "enableConfidentialCompute",
                &self.enable_confidential_compute,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The config settings for Compute Engine resources in
/// an instance group, such as a master or worker group.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupConfig {
    /// Optional. The number of VM instances in the instance group.
    /// For [HA
    /// cluster](/dataproc/docs/concepts/configuring-clusters/high-availability)
    /// [master_config](#FIELDS.master_config) groups, **must be set to 3**.
    /// For standard cluster [master_config](#FIELDS.master_config) groups,
    /// **must be set to 1**.
    pub num_instances: i32,

    /// Output only. The list of instance names. Dataproc derives the names
    /// from `cluster_name`, `num_instances`, and the instance group.
    pub instance_names: std::vec::Vec<std::string::String>,

    /// Output only. List of references to Compute Engine instances.
    pub instance_references: std::vec::Vec<crate::model::InstanceReference>,

    /// Optional. The Compute Engine image resource used for cluster instances.
    ///
    /// The URI can represent an image or image family.
    ///
    /// Image examples:
    ///
    /// * `<https://www.googleapis.com/compute/v1/projects/>[project_id]/global/images/[image-id]`
    /// * `projects/[project_id]/global/images/[image-id]`
    /// * `image-id`
    ///
    /// Image family examples. Dataproc will use the most recent
    /// image from the family:
    ///
    /// * `<https://www.googleapis.com/compute/v1/projects/>[project_id]/global/images/family/[custom-image-family-name]`
    /// * `projects/[project_id]/global/images/family/[custom-image-family-name]`
    ///
    /// If the URI is unspecified, it will be inferred from
    /// `SoftwareConfig.image_version` or the system default.
    pub image_uri: std::string::String,

    /// Optional. The Compute Engine machine type used for cluster instances.
    ///
    /// A full URL, partial URI, or short name are valid. Examples:
    ///
    /// * `<https://www.googleapis.com/compute/v1/projects/>[project_id]/zones/[zone]/machineTypes/n1-standard-2`
    /// * `projects/[project_id]/zones/[zone]/machineTypes/n1-standard-2`
    /// * `n1-standard-2`
    ///
    /// **Auto Zone Exception**: If you are using the Dataproc
    /// [Auto Zone
    /// Placement](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/auto-zone#using_auto_zone_placement)
    /// feature, you must use the short name of the machine type
    /// resource, for example, `n1-standard-2`.
    pub machine_type_uri: std::string::String,

    /// Optional. Disk option config settings.
    pub disk_config: std::option::Option<crate::model::DiskConfig>,

    /// Output only. Specifies that this instance group contains preemptible
    /// instances.
    pub is_preemptible: bool,

    /// Optional. Specifies the preemptibility of the instance group.
    ///
    /// The default value for master and worker groups is
    /// `NON_PREEMPTIBLE`. This default cannot be changed.
    ///
    /// The default value for secondary instances is
    /// `PREEMPTIBLE`.
    pub preemptibility: crate::model::instance_group_config::Preemptibility,

    /// Output only. The config for Compute Engine Instance Group
    /// Manager that manages this group.
    /// This is only used for preemptible instance groups.
    pub managed_group_config: std::option::Option<crate::model::ManagedGroupConfig>,

    /// Optional. The Compute Engine accelerator configuration for these
    /// instances.
    pub accelerators: std::vec::Vec<crate::model::AcceleratorConfig>,

    /// Optional. Specifies the minimum cpu platform for the Instance Group.
    /// See [Dataproc -> Minimum CPU
    /// Platform](https://cloud.google.com/dataproc/docs/concepts/compute/dataproc-min-cpu).
    pub min_cpu_platform: std::string::String,

    /// Optional. The minimum number of primary worker instances to create.
    /// If `min_num_instances` is set, cluster creation will succeed if
    /// the number of primary workers created is at least equal to the
    /// `min_num_instances` number.
    ///
    /// Example: Cluster creation request with `num_instances` = `5` and
    /// `min_num_instances` = `3`:
    ///
    /// * If 4 VMs are created and 1 instance fails,
    ///   the failed VM is deleted. The cluster is
    ///   resized to 4 instances and placed in a `RUNNING` state.
    /// * If 2 instances are created and 3 instances fail,
    ///   the cluster in placed in an `ERROR` state. The failed VMs
    ///   are not deleted.
    pub min_num_instances: i32,

    /// Optional. Instance flexibility Policy allowing a mixture of VM shapes and
    /// provisioning models.
    pub instance_flexibility_policy: std::option::Option<crate::model::InstanceFlexibilityPolicy>,

    /// Optional. Configuration to handle the startup of instances during cluster
    /// create and update process.
    pub startup_config: std::option::Option<crate::model::StartupConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstanceGroupConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [num_instances][crate::model::InstanceGroupConfig::num_instances].
    pub fn set_num_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.num_instances = v.into();
        self
    }

    /// Sets the value of [instance_names][crate::model::InstanceGroupConfig::instance_names].
    pub fn set_instance_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instance_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [instance_references][crate::model::InstanceGroupConfig::instance_references].
    pub fn set_instance_references<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceReference>,
    {
        use std::iter::Iterator;
        self.instance_references = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [image_uri][crate::model::InstanceGroupConfig::image_uri].
    pub fn set_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_uri = v.into();
        self
    }

    /// Sets the value of [machine_type_uri][crate::model::InstanceGroupConfig::machine_type_uri].
    pub fn set_machine_type_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_type_uri = v.into();
        self
    }

    /// Sets the value of [disk_config][crate::model::InstanceGroupConfig::disk_config].
    pub fn set_disk_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiskConfig>,
    {
        self.disk_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_config][crate::model::InstanceGroupConfig::disk_config].
    pub fn set_or_clear_disk_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiskConfig>,
    {
        self.disk_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [is_preemptible][crate::model::InstanceGroupConfig::is_preemptible].
    pub fn set_is_preemptible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_preemptible = v.into();
        self
    }

    /// Sets the value of [preemptibility][crate::model::InstanceGroupConfig::preemptibility].
    pub fn set_preemptibility<
        T: std::convert::Into<crate::model::instance_group_config::Preemptibility>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.preemptibility = v.into();
        self
    }

    /// Sets the value of [managed_group_config][crate::model::InstanceGroupConfig::managed_group_config].
    pub fn set_managed_group_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ManagedGroupConfig>,
    {
        self.managed_group_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [managed_group_config][crate::model::InstanceGroupConfig::managed_group_config].
    pub fn set_or_clear_managed_group_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ManagedGroupConfig>,
    {
        self.managed_group_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [accelerators][crate::model::InstanceGroupConfig::accelerators].
    pub fn set_accelerators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AcceleratorConfig>,
    {
        use std::iter::Iterator;
        self.accelerators = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [min_cpu_platform][crate::model::InstanceGroupConfig::min_cpu_platform].
    pub fn set_min_cpu_platform<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.min_cpu_platform = v.into();
        self
    }

    /// Sets the value of [min_num_instances][crate::model::InstanceGroupConfig::min_num_instances].
    pub fn set_min_num_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_num_instances = v.into();
        self
    }

    /// Sets the value of [instance_flexibility_policy][crate::model::InstanceGroupConfig::instance_flexibility_policy].
    pub fn set_instance_flexibility_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceFlexibilityPolicy>,
    {
        self.instance_flexibility_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_flexibility_policy][crate::model::InstanceGroupConfig::instance_flexibility_policy].
    pub fn set_or_clear_instance_flexibility_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceFlexibilityPolicy>,
    {
        self.instance_flexibility_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [startup_config][crate::model::InstanceGroupConfig::startup_config].
    pub fn set_startup_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StartupConfig>,
    {
        self.startup_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [startup_config][crate::model::InstanceGroupConfig::startup_config].
    pub fn set_or_clear_startup_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StartupConfig>,
    {
        self.startup_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for InstanceGroupConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.InstanceGroupConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstanceGroupConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __num_instances,
            __instance_names,
            __instance_references,
            __image_uri,
            __machine_type_uri,
            __disk_config,
            __is_preemptible,
            __preemptibility,
            __managed_group_config,
            __accelerators,
            __min_cpu_platform,
            __min_num_instances,
            __instance_flexibility_policy,
            __startup_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstanceGroupConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "numInstances" => Ok(__FieldTag::__num_instances),
                            "num_instances" => Ok(__FieldTag::__num_instances),
                            "instanceNames" => Ok(__FieldTag::__instance_names),
                            "instance_names" => Ok(__FieldTag::__instance_names),
                            "instanceReferences" => Ok(__FieldTag::__instance_references),
                            "instance_references" => Ok(__FieldTag::__instance_references),
                            "imageUri" => Ok(__FieldTag::__image_uri),
                            "image_uri" => Ok(__FieldTag::__image_uri),
                            "machineTypeUri" => Ok(__FieldTag::__machine_type_uri),
                            "machine_type_uri" => Ok(__FieldTag::__machine_type_uri),
                            "diskConfig" => Ok(__FieldTag::__disk_config),
                            "disk_config" => Ok(__FieldTag::__disk_config),
                            "isPreemptible" => Ok(__FieldTag::__is_preemptible),
                            "is_preemptible" => Ok(__FieldTag::__is_preemptible),
                            "preemptibility" => Ok(__FieldTag::__preemptibility),
                            "managedGroupConfig" => Ok(__FieldTag::__managed_group_config),
                            "managed_group_config" => Ok(__FieldTag::__managed_group_config),
                            "accelerators" => Ok(__FieldTag::__accelerators),
                            "minCpuPlatform" => Ok(__FieldTag::__min_cpu_platform),
                            "min_cpu_platform" => Ok(__FieldTag::__min_cpu_platform),
                            "minNumInstances" => Ok(__FieldTag::__min_num_instances),
                            "min_num_instances" => Ok(__FieldTag::__min_num_instances),
                            "instanceFlexibilityPolicy" => {
                                Ok(__FieldTag::__instance_flexibility_policy)
                            }
                            "instance_flexibility_policy" => {
                                Ok(__FieldTag::__instance_flexibility_policy)
                            }
                            "startupConfig" => Ok(__FieldTag::__startup_config),
                            "startup_config" => Ok(__FieldTag::__startup_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstanceGroupConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstanceGroupConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__num_instances => {
                            if !fields.insert(__FieldTag::__num_instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_instances",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_instances =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__instance_names => {
                            if !fields.insert(__FieldTag::__instance_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_names",
                                ));
                            }
                            result.instance_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__instance_references => {
                            if !fields.insert(__FieldTag::__instance_references) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_references",
                                ));
                            }
                            result.instance_references =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::InstanceReference>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__image_uri => {
                            if !fields.insert(__FieldTag::__image_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_uri",
                                ));
                            }
                            result.image_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_type_uri => {
                            if !fields.insert(__FieldTag::__machine_type_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type_uri",
                                ));
                            }
                            result.machine_type_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_config => {
                            if !fields.insert(__FieldTag::__disk_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_config",
                                ));
                            }
                            result.disk_config =
                                map.next_value::<std::option::Option<crate::model::DiskConfig>>()?;
                        }
                        __FieldTag::__is_preemptible => {
                            if !fields.insert(__FieldTag::__is_preemptible) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_preemptible",
                                ));
                            }
                            result.is_preemptible = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__preemptibility => {
                            if !fields.insert(__FieldTag::__preemptibility) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preemptibility",
                                ));
                            }
                            result.preemptibility = map
                                .next_value::<std::option::Option<
                                    crate::model::instance_group_config::Preemptibility,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__managed_group_config => {
                            if !fields.insert(__FieldTag::__managed_group_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for managed_group_config",
                                ));
                            }
                            result.managed_group_config = map.next_value::<std::option::Option<crate::model::ManagedGroupConfig>>()?
                                ;
                        }
                        __FieldTag::__accelerators => {
                            if !fields.insert(__FieldTag::__accelerators) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accelerators",
                                ));
                            }
                            result.accelerators =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AcceleratorConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__min_cpu_platform => {
                            if !fields.insert(__FieldTag::__min_cpu_platform) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_cpu_platform",
                                ));
                            }
                            result.min_cpu_platform = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__min_num_instances => {
                            if !fields.insert(__FieldTag::__min_num_instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_num_instances",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_num_instances =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__instance_flexibility_policy => {
                            if !fields.insert(__FieldTag::__instance_flexibility_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_flexibility_policy",
                                ));
                            }
                            result.instance_flexibility_policy = map.next_value::<std::option::Option<crate::model::InstanceFlexibilityPolicy>>()?
                                ;
                        }
                        __FieldTag::__startup_config => {
                            if !fields.insert(__FieldTag::__startup_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for startup_config",
                                ));
                            }
                            result.startup_config = map
                                .next_value::<std::option::Option<crate::model::StartupConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstanceGroupConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.num_instances) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("numInstances", &__With(&self.num_instances))?;
        }
        if !self.instance_names.is_empty() {
            state.serialize_entry("instanceNames", &self.instance_names)?;
        }
        if !self.instance_references.is_empty() {
            state.serialize_entry("instanceReferences", &self.instance_references)?;
        }
        if !self.image_uri.is_empty() {
            state.serialize_entry("imageUri", &self.image_uri)?;
        }
        if !self.machine_type_uri.is_empty() {
            state.serialize_entry("machineTypeUri", &self.machine_type_uri)?;
        }
        if self.disk_config.is_some() {
            state.serialize_entry("diskConfig", &self.disk_config)?;
        }
        if !wkt::internal::is_default(&self.is_preemptible) {
            state.serialize_entry("isPreemptible", &self.is_preemptible)?;
        }
        if !wkt::internal::is_default(&self.preemptibility) {
            state.serialize_entry("preemptibility", &self.preemptibility)?;
        }
        if self.managed_group_config.is_some() {
            state.serialize_entry("managedGroupConfig", &self.managed_group_config)?;
        }
        if !self.accelerators.is_empty() {
            state.serialize_entry("accelerators", &self.accelerators)?;
        }
        if !self.min_cpu_platform.is_empty() {
            state.serialize_entry("minCpuPlatform", &self.min_cpu_platform)?;
        }
        if !wkt::internal::is_default(&self.min_num_instances) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minNumInstances", &__With(&self.min_num_instances))?;
        }
        if self.instance_flexibility_policy.is_some() {
            state.serialize_entry(
                "instanceFlexibilityPolicy",
                &self.instance_flexibility_policy,
            )?;
        }
        if self.startup_config.is_some() {
            state.serialize_entry("startupConfig", &self.startup_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [InstanceGroupConfig].
pub mod instance_group_config {
    #[allow(unused_imports)]
    use super::*;

    /// Controls the use of preemptible instances within the group.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Preemptibility {
        /// Preemptibility is unspecified, the system will choose the
        /// appropriate setting for each instance group.
        Unspecified,
        /// Instances are non-preemptible.
        ///
        /// This option is allowed for all instance groups and is the only valid
        /// value for Master and Worker instance groups.
        NonPreemptible,
        /// Instances are [preemptible]
        /// (<https://cloud.google.com/compute/docs/instances/preemptible>).
        ///
        /// This option is allowed only for [secondary worker]
        /// (<https://cloud.google.com/dataproc/docs/concepts/compute/secondary-vms>)
        /// groups.
        Preemptible,
        /// Instances are [Spot VMs]
        /// (<https://cloud.google.com/compute/docs/instances/spot>).
        ///
        /// This option is allowed only for [secondary worker]
        /// (<https://cloud.google.com/dataproc/docs/concepts/compute/secondary-vms>)
        /// groups. Spot VMs are the latest version of [preemptible VMs]
        /// (<https://cloud.google.com/compute/docs/instances/preemptible>), and
        /// provide additional features.
        Spot,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Preemptibility::value] or
        /// [Preemptibility::name].
        UnknownValue(preemptibility::UnknownValue),
    }

    #[doc(hidden)]
    pub mod preemptibility {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Preemptibility {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NonPreemptible => std::option::Option::Some(1),
                Self::Preemptible => std::option::Option::Some(2),
                Self::Spot => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PREEMPTIBILITY_UNSPECIFIED"),
                Self::NonPreemptible => std::option::Option::Some("NON_PREEMPTIBLE"),
                Self::Preemptible => std::option::Option::Some("PREEMPTIBLE"),
                Self::Spot => std::option::Option::Some("SPOT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Preemptibility {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Preemptibility {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Preemptibility {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NonPreemptible,
                2 => Self::Preemptible,
                3 => Self::Spot,
                _ => Self::UnknownValue(preemptibility::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Preemptibility {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PREEMPTIBILITY_UNSPECIFIED" => Self::Unspecified,
                "NON_PREEMPTIBLE" => Self::NonPreemptible,
                "PREEMPTIBLE" => Self::Preemptible,
                "SPOT" => Self::Spot,
                _ => Self::UnknownValue(preemptibility::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Preemptibility {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NonPreemptible => serializer.serialize_i32(1),
                Self::Preemptible => serializer.serialize_i32(2),
                Self::Spot => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Preemptibility {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Preemptibility>::new(
                ".google.cloud.dataproc.v1.InstanceGroupConfig.Preemptibility",
            ))
        }
    }
}

/// Configuration to handle the startup of instances during cluster create and
/// update process.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StartupConfig {
    /// Optional. The config setting to enable cluster creation/ updation to be
    /// successful only after required_registration_fraction of instances are up
    /// and running. This configuration is applicable to only secondary workers for
    /// now. The cluster will fail if required_registration_fraction of instances
    /// are not available. This will include instance creation, agent registration,
    /// and service registration (if enabled).
    pub required_registration_fraction: std::option::Option<f64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartupConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [required_registration_fraction][crate::model::StartupConfig::required_registration_fraction].
    pub fn set_required_registration_fraction<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.required_registration_fraction = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [required_registration_fraction][crate::model::StartupConfig::required_registration_fraction].
    pub fn set_or_clear_required_registration_fraction<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.required_registration_fraction = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for StartupConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.StartupConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StartupConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __required_registration_fraction,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StartupConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "requiredRegistrationFraction" => {
                                Ok(__FieldTag::__required_registration_fraction)
                            }
                            "required_registration_fraction" => {
                                Ok(__FieldTag::__required_registration_fraction)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StartupConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StartupConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__required_registration_fraction => {
                            if !fields.insert(__FieldTag::__required_registration_fraction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for required_registration_fraction",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.required_registration_fraction = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StartupConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.required_registration_fraction.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "requiredRegistrationFraction",
                &__With(&self.required_registration_fraction),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A reference to a Compute Engine instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceReference {
    /// The user-friendly name of the Compute Engine instance.
    pub instance_name: std::string::String,

    /// The unique identifier of the Compute Engine instance.
    pub instance_id: std::string::String,

    /// The public RSA key used for sharing data with this instance.
    pub public_key: std::string::String,

    /// The public ECIES key used for sharing data with this instance.
    pub public_ecies_key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstanceReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_name][crate::model::InstanceReference::instance_name].
    pub fn set_instance_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_name = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::InstanceReference::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [public_key][crate::model::InstanceReference::public_key].
    pub fn set_public_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_key = v.into();
        self
    }

    /// Sets the value of [public_ecies_key][crate::model::InstanceReference::public_ecies_key].
    pub fn set_public_ecies_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.public_ecies_key = v.into();
        self
    }
}

impl wkt::message::Message for InstanceReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.InstanceReference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstanceReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance_name,
            __instance_id,
            __public_key,
            __public_ecies_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstanceReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instanceName" => Ok(__FieldTag::__instance_name),
                            "instance_name" => Ok(__FieldTag::__instance_name),
                            "instanceId" => Ok(__FieldTag::__instance_id),
                            "instance_id" => Ok(__FieldTag::__instance_id),
                            "publicKey" => Ok(__FieldTag::__public_key),
                            "public_key" => Ok(__FieldTag::__public_key),
                            "publicEciesKey" => Ok(__FieldTag::__public_ecies_key),
                            "public_ecies_key" => Ok(__FieldTag::__public_ecies_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstanceReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstanceReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance_name => {
                            if !fields.insert(__FieldTag::__instance_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_name",
                                ));
                            }
                            result.instance_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_id => {
                            if !fields.insert(__FieldTag::__instance_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_id",
                                ));
                            }
                            result.instance_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__public_key => {
                            if !fields.insert(__FieldTag::__public_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_key",
                                ));
                            }
                            result.public_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__public_ecies_key => {
                            if !fields.insert(__FieldTag::__public_ecies_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_ecies_key",
                                ));
                            }
                            result.public_ecies_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstanceReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance_name.is_empty() {
            state.serialize_entry("instanceName", &self.instance_name)?;
        }
        if !self.instance_id.is_empty() {
            state.serialize_entry("instanceId", &self.instance_id)?;
        }
        if !self.public_key.is_empty() {
            state.serialize_entry("publicKey", &self.public_key)?;
        }
        if !self.public_ecies_key.is_empty() {
            state.serialize_entry("publicEciesKey", &self.public_ecies_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Specifies the resources used to actively manage an instance group.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ManagedGroupConfig {
    /// Output only. The name of the Instance Template used for the Managed
    /// Instance Group.
    pub instance_template_name: std::string::String,

    /// Output only. The name of the Instance Group Manager for this group.
    pub instance_group_manager_name: std::string::String,

    /// Output only. The partial URI to the instance group manager for this group.
    /// E.g. projects/my-project/regions/us-central1/instanceGroupManagers/my-igm.
    pub instance_group_manager_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManagedGroupConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_template_name][crate::model::ManagedGroupConfig::instance_template_name].
    pub fn set_instance_template_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_template_name = v.into();
        self
    }

    /// Sets the value of [instance_group_manager_name][crate::model::ManagedGroupConfig::instance_group_manager_name].
    pub fn set_instance_group_manager_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_group_manager_name = v.into();
        self
    }

    /// Sets the value of [instance_group_manager_uri][crate::model::ManagedGroupConfig::instance_group_manager_uri].
    pub fn set_instance_group_manager_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_group_manager_uri = v.into();
        self
    }
}

impl wkt::message::Message for ManagedGroupConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ManagedGroupConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ManagedGroupConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance_template_name,
            __instance_group_manager_name,
            __instance_group_manager_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ManagedGroupConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instanceTemplateName" => Ok(__FieldTag::__instance_template_name),
                            "instance_template_name" => Ok(__FieldTag::__instance_template_name),
                            "instanceGroupManagerName" => {
                                Ok(__FieldTag::__instance_group_manager_name)
                            }
                            "instance_group_manager_name" => {
                                Ok(__FieldTag::__instance_group_manager_name)
                            }
                            "instanceGroupManagerUri" => {
                                Ok(__FieldTag::__instance_group_manager_uri)
                            }
                            "instance_group_manager_uri" => {
                                Ok(__FieldTag::__instance_group_manager_uri)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ManagedGroupConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagedGroupConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance_template_name => {
                            if !fields.insert(__FieldTag::__instance_template_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_template_name",
                                ));
                            }
                            result.instance_template_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_group_manager_name => {
                            if !fields.insert(__FieldTag::__instance_group_manager_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_group_manager_name",
                                ));
                            }
                            result.instance_group_manager_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_group_manager_uri => {
                            if !fields.insert(__FieldTag::__instance_group_manager_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_group_manager_uri",
                                ));
                            }
                            result.instance_group_manager_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ManagedGroupConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instance_template_name.is_empty() {
            state.serialize_entry("instanceTemplateName", &self.instance_template_name)?;
        }
        if !self.instance_group_manager_name.is_empty() {
            state.serialize_entry(
                "instanceGroupManagerName",
                &self.instance_group_manager_name,
            )?;
        }
        if !self.instance_group_manager_uri.is_empty() {
            state.serialize_entry("instanceGroupManagerUri", &self.instance_group_manager_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instance flexibility Policy allowing a mixture of VM shapes and provisioning
/// models.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceFlexibilityPolicy {
    /// Optional. Defines how the Group selects the provisioning model to ensure
    /// required reliability.
    pub provisioning_model_mix:
        std::option::Option<crate::model::instance_flexibility_policy::ProvisioningModelMix>,

    /// Optional. List of instance selection options that the group will use when
    /// creating new VMs.
    pub instance_selection_list:
        std::vec::Vec<crate::model::instance_flexibility_policy::InstanceSelection>,

    /// Output only. A list of instance selection results in the group.
    pub instance_selection_results:
        std::vec::Vec<crate::model::instance_flexibility_policy::InstanceSelectionResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstanceFlexibilityPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [provisioning_model_mix][crate::model::InstanceFlexibilityPolicy::provisioning_model_mix].
    pub fn set_provisioning_model_mix<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_flexibility_policy::ProvisioningModelMix>,
    {
        self.provisioning_model_mix = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [provisioning_model_mix][crate::model::InstanceFlexibilityPolicy::provisioning_model_mix].
    pub fn set_or_clear_provisioning_model_mix<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_flexibility_policy::ProvisioningModelMix>,
    {
        self.provisioning_model_mix = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance_selection_list][crate::model::InstanceFlexibilityPolicy::instance_selection_list].
    pub fn set_instance_selection_list<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::instance_flexibility_policy::InstanceSelection>,
    {
        use std::iter::Iterator;
        self.instance_selection_list = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [instance_selection_results][crate::model::InstanceFlexibilityPolicy::instance_selection_results].
    pub fn set_instance_selection_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::instance_flexibility_policy::InstanceSelectionResult>,
    {
        use std::iter::Iterator;
        self.instance_selection_results = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InstanceFlexibilityPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.InstanceFlexibilityPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstanceFlexibilityPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __provisioning_model_mix,
            __instance_selection_list,
            __instance_selection_results,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstanceFlexibilityPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "provisioningModelMix" => Ok(__FieldTag::__provisioning_model_mix),
                            "provisioning_model_mix" => Ok(__FieldTag::__provisioning_model_mix),
                            "instanceSelectionList" => Ok(__FieldTag::__instance_selection_list),
                            "instance_selection_list" => Ok(__FieldTag::__instance_selection_list),
                            "instanceSelectionResults" => {
                                Ok(__FieldTag::__instance_selection_results)
                            }
                            "instance_selection_results" => {
                                Ok(__FieldTag::__instance_selection_results)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstanceFlexibilityPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstanceFlexibilityPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__provisioning_model_mix => {
                            if !fields.insert(__FieldTag::__provisioning_model_mix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provisioning_model_mix",
                                ));
                            }
                            result.provisioning_model_mix = map.next_value::<std::option::Option<
                                crate::model::instance_flexibility_policy::ProvisioningModelMix,
                            >>()?;
                        }
                        __FieldTag::__instance_selection_list => {
                            if !fields.insert(__FieldTag::__instance_selection_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_selection_list",
                                ));
                            }
                            result.instance_selection_list = map.next_value::<std::option::Option<std::vec::Vec<crate::model::instance_flexibility_policy::InstanceSelection>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__instance_selection_results => {
                            if !fields.insert(__FieldTag::__instance_selection_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_selection_results",
                                ));
                            }
                            result.instance_selection_results = map.next_value::<std::option::Option<std::vec::Vec<crate::model::instance_flexibility_policy::InstanceSelectionResult>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstanceFlexibilityPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.provisioning_model_mix.is_some() {
            state.serialize_entry("provisioningModelMix", &self.provisioning_model_mix)?;
        }
        if !self.instance_selection_list.is_empty() {
            state.serialize_entry("instanceSelectionList", &self.instance_selection_list)?;
        }
        if !self.instance_selection_results.is_empty() {
            state.serialize_entry("instanceSelectionResults", &self.instance_selection_results)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [InstanceFlexibilityPolicy].
pub mod instance_flexibility_policy {
    #[allow(unused_imports)]
    use super::*;

    /// Defines how Dataproc should create VMs with a mixture of provisioning
    /// models.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ProvisioningModelMix {
        /// Optional. The base capacity that will always use Standard VMs to avoid
        /// risk of more preemption than the minimum capacity you need. Dataproc will
        /// create only standard VMs until it reaches standard_capacity_base, then it
        /// will start using standard_capacity_percent_above_base to mix Spot with
        /// Standard VMs. eg. If 15 instances are requested and
        /// standard_capacity_base is 5, Dataproc will create 5 standard VMs and then
        /// start mixing spot and standard VMs for remaining 10 instances.
        pub standard_capacity_base: std::option::Option<i32>,

        /// Optional. The percentage of target capacity that should use Standard VM.
        /// The remaining percentage will use Spot VMs. The percentage applies only
        /// to the capacity above standard_capacity_base. eg. If 15 instances are
        /// requested and standard_capacity_base is 5 and
        /// standard_capacity_percent_above_base is 30, Dataproc will create 5
        /// standard VMs and then start mixing spot and standard VMs for remaining 10
        /// instances. The mix will be 30% standard and 70% spot.
        pub standard_capacity_percent_above_base: std::option::Option<i32>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ProvisioningModelMix {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [standard_capacity_base][crate::model::instance_flexibility_policy::ProvisioningModelMix::standard_capacity_base].
        pub fn set_standard_capacity_base<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.standard_capacity_base = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [standard_capacity_base][crate::model::instance_flexibility_policy::ProvisioningModelMix::standard_capacity_base].
        pub fn set_or_clear_standard_capacity_base<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.standard_capacity_base = v.map(|x| x.into());
            self
        }

        /// Sets the value of [standard_capacity_percent_above_base][crate::model::instance_flexibility_policy::ProvisioningModelMix::standard_capacity_percent_above_base].
        pub fn set_standard_capacity_percent_above_base<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.standard_capacity_percent_above_base = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [standard_capacity_percent_above_base][crate::model::instance_flexibility_policy::ProvisioningModelMix::standard_capacity_percent_above_base].
        pub fn set_or_clear_standard_capacity_percent_above_base<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.standard_capacity_percent_above_base = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ProvisioningModelMix {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataproc.v1.InstanceFlexibilityPolicy.ProvisioningModelMix"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ProvisioningModelMix {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __standard_capacity_base,
                __standard_capacity_percent_above_base,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ProvisioningModelMix")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "standardCapacityBase" => Ok(__FieldTag::__standard_capacity_base),
                                "standard_capacity_base" => {
                                    Ok(__FieldTag::__standard_capacity_base)
                                }
                                "standardCapacityPercentAboveBase" => {
                                    Ok(__FieldTag::__standard_capacity_percent_above_base)
                                }
                                "standard_capacity_percent_above_base" => {
                                    Ok(__FieldTag::__standard_capacity_percent_above_base)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ProvisioningModelMix;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ProvisioningModelMix")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__standard_capacity_base => {
                                if !fields.insert(__FieldTag::__standard_capacity_base) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for standard_capacity_base",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.standard_capacity_base = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__standard_capacity_percent_above_base => {
                                if !fields
                                    .insert(__FieldTag::__standard_capacity_percent_above_base)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for standard_capacity_percent_above_base",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.standard_capacity_percent_above_base =
                                    map.next_value::<__With>()?.0;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ProvisioningModelMix {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.standard_capacity_base.is_some() {
                struct __With<'a>(&'a std::option::Option<i32>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry(
                    "standardCapacityBase",
                    &__With(&self.standard_capacity_base),
                )?;
            }
            if self.standard_capacity_percent_above_base.is_some() {
                struct __With<'a>(&'a std::option::Option<i32>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry(
                    "standardCapacityPercentAboveBase",
                    &__With(&self.standard_capacity_percent_above_base),
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines machines types and a rank to which the machines types belong.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InstanceSelection {
        /// Optional. Full machine-type names, e.g. "n1-standard-16".
        pub machine_types: std::vec::Vec<std::string::String>,

        /// Optional. Preference of this instance selection. Lower number means
        /// higher preference. Dataproc will first try to create a VM based on the
        /// machine-type with priority rank and fallback to next rank based on
        /// availability. Machine types and instance selections with the same
        /// priority have the same preference.
        pub rank: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InstanceSelection {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [machine_types][crate::model::instance_flexibility_policy::InstanceSelection::machine_types].
        pub fn set_machine_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.machine_types = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [rank][crate::model::instance_flexibility_policy::InstanceSelection::rank].
        pub fn set_rank<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.rank = v.into();
            self
        }
    }

    impl wkt::message::Message for InstanceSelection {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataproc.v1.InstanceFlexibilityPolicy.InstanceSelection"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for InstanceSelection {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __machine_types,
                __rank,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for InstanceSelection")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "machineTypes" => Ok(__FieldTag::__machine_types),
                                "machine_types" => Ok(__FieldTag::__machine_types),
                                "rank" => Ok(__FieldTag::__rank),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = InstanceSelection;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct InstanceSelection")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__machine_types => {
                                if !fields.insert(__FieldTag::__machine_types) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for machine_types",
                                    ));
                                }
                                result.machine_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__rank => {
                                if !fields.insert(__FieldTag::__rank) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for rank",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.rank = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for InstanceSelection {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.machine_types.is_empty() {
                state.serialize_entry("machineTypes", &self.machine_types)?;
            }
            if !wkt::internal::is_default(&self.rank) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("rank", &__With(&self.rank))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines a mapping from machine types to the number of VMs that are created
    /// with each machine type.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InstanceSelectionResult {
        /// Output only. Full machine-type names, e.g. "n1-standard-16".
        pub machine_type: std::option::Option<std::string::String>,

        /// Output only. Number of VM provisioned with the machine_type.
        pub vm_count: std::option::Option<i32>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InstanceSelectionResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [machine_type][crate::model::instance_flexibility_policy::InstanceSelectionResult::machine_type].
        pub fn set_machine_type<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.machine_type = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [machine_type][crate::model::instance_flexibility_policy::InstanceSelectionResult::machine_type].
        pub fn set_or_clear_machine_type<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.machine_type = v.map(|x| x.into());
            self
        }

        /// Sets the value of [vm_count][crate::model::instance_flexibility_policy::InstanceSelectionResult::vm_count].
        pub fn set_vm_count<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.vm_count = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [vm_count][crate::model::instance_flexibility_policy::InstanceSelectionResult::vm_count].
        pub fn set_or_clear_vm_count<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.vm_count = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for InstanceSelectionResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataproc.v1.InstanceFlexibilityPolicy.InstanceSelectionResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for InstanceSelectionResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __machine_type,
                __vm_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for InstanceSelectionResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "machineType" => Ok(__FieldTag::__machine_type),
                                "machine_type" => Ok(__FieldTag::__machine_type),
                                "vmCount" => Ok(__FieldTag::__vm_count),
                                "vm_count" => Ok(__FieldTag::__vm_count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = InstanceSelectionResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct InstanceSelectionResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__machine_type => {
                                if !fields.insert(__FieldTag::__machine_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for machine_type",
                                    ));
                                }
                                result.machine_type =
                                    map.next_value::<std::option::Option<std::string::String>>()?;
                            }
                            __FieldTag::__vm_count => {
                                if !fields.insert(__FieldTag::__vm_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for vm_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.vm_count = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for InstanceSelectionResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.machine_type.is_some() {
                state.serialize_entry("machineType", &self.machine_type)?;
            }
            if self.vm_count.is_some() {
                struct __With<'a>(&'a std::option::Option<i32>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("vmCount", &__With(&self.vm_count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Specifies the type and number of accelerator cards attached to the instances
/// of an instance. See [GPUs on Compute
/// Engine](https://cloud.google.com/compute/docs/gpus/).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AcceleratorConfig {
    /// Full URL, partial URI, or short name of the accelerator type resource to
    /// expose to this instance. See
    /// [Compute Engine
    /// AcceleratorTypes](https://cloud.google.com/compute/docs/reference/v1/acceleratorTypes).
    ///
    /// Examples:
    ///
    /// * `<https://www.googleapis.com/compute/v1/projects/>[project_id]/zones/[zone]/acceleratorTypes/nvidia-tesla-t4`
    /// * `projects/[project_id]/zones/[zone]/acceleratorTypes/nvidia-tesla-t4`
    /// * `nvidia-tesla-t4`
    ///
    /// **Auto Zone Exception**: If you are using the Dataproc
    /// [Auto Zone
    /// Placement](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/auto-zone#using_auto_zone_placement)
    /// feature, you must use the short name of the accelerator type
    /// resource, for example, `nvidia-tesla-t4`.
    pub accelerator_type_uri: std::string::String,

    /// The number of the accelerator cards of this type exposed to this instance.
    pub accelerator_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AcceleratorConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [accelerator_type_uri][crate::model::AcceleratorConfig::accelerator_type_uri].
    pub fn set_accelerator_type_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.accelerator_type_uri = v.into();
        self
    }

    /// Sets the value of [accelerator_count][crate::model::AcceleratorConfig::accelerator_count].
    pub fn set_accelerator_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.accelerator_count = v.into();
        self
    }
}

impl wkt::message::Message for AcceleratorConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.AcceleratorConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AcceleratorConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __accelerator_type_uri,
            __accelerator_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AcceleratorConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "acceleratorTypeUri" => Ok(__FieldTag::__accelerator_type_uri),
                            "accelerator_type_uri" => Ok(__FieldTag::__accelerator_type_uri),
                            "acceleratorCount" => Ok(__FieldTag::__accelerator_count),
                            "accelerator_count" => Ok(__FieldTag::__accelerator_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AcceleratorConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AcceleratorConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__accelerator_type_uri => {
                            if !fields.insert(__FieldTag::__accelerator_type_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accelerator_type_uri",
                                ));
                            }
                            result.accelerator_type_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__accelerator_count => {
                            if !fields.insert(__FieldTag::__accelerator_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accelerator_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.accelerator_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AcceleratorConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.accelerator_type_uri.is_empty() {
            state.serialize_entry("acceleratorTypeUri", &self.accelerator_type_uri)?;
        }
        if !wkt::internal::is_default(&self.accelerator_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("acceleratorCount", &__With(&self.accelerator_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Specifies the config of disk options for a group of VM instances.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiskConfig {
    /// Optional. Type of the boot disk (default is "pd-standard").
    /// Valid values: "pd-balanced" (Persistent Disk Balanced Solid State Drive),
    /// "pd-ssd" (Persistent Disk Solid State Drive),
    /// or "pd-standard" (Persistent Disk Hard Disk Drive).
    /// See [Disk types](https://cloud.google.com/compute/docs/disks#disk-types).
    pub boot_disk_type: std::string::String,

    /// Optional. Size in GB of the boot disk (default is 500GB).
    pub boot_disk_size_gb: i32,

    /// Optional. Number of attached SSDs, from 0 to 8 (default is 0).
    /// If SSDs are not attached, the boot disk is used to store runtime logs and
    /// [HDFS](https://hadoop.apache.org/docs/r1.2.1/hdfs_user_guide.html) data.
    /// If one or more SSDs are attached, this runtime bulk
    /// data is spread across them, and the boot disk contains only basic
    /// config and installed binaries.
    ///
    /// Note: Local SSD options may vary by machine type and number of vCPUs
    /// selected.
    pub num_local_ssds: i32,

    /// Optional. Interface type of local SSDs (default is "scsi").
    /// Valid values: "scsi" (Small Computer System Interface),
    /// "nvme" (Non-Volatile Memory Express).
    /// See [local SSD
    /// performance](https://cloud.google.com/compute/docs/disks/local-ssd#performance).
    pub local_ssd_interface: std::string::String,

    /// Optional. Indicates how many IOPS to provision for the disk. This sets the
    /// number of I/O operations per second that the disk can handle. Note: This
    /// field is only supported if boot_disk_type is hyperdisk-balanced.
    pub boot_disk_provisioned_iops: std::option::Option<i64>,

    /// Optional. Indicates how much throughput to provision for the disk. This
    /// sets the number of throughput mb per second that the disk can handle.
    /// Values must be greater than or equal to 1. Note: This field is only
    /// supported if boot_disk_type is hyperdisk-balanced.
    pub boot_disk_provisioned_throughput: std::option::Option<i64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiskConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [boot_disk_type][crate::model::DiskConfig::boot_disk_type].
    pub fn set_boot_disk_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.boot_disk_type = v.into();
        self
    }

    /// Sets the value of [boot_disk_size_gb][crate::model::DiskConfig::boot_disk_size_gb].
    pub fn set_boot_disk_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.boot_disk_size_gb = v.into();
        self
    }

    /// Sets the value of [num_local_ssds][crate::model::DiskConfig::num_local_ssds].
    pub fn set_num_local_ssds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.num_local_ssds = v.into();
        self
    }

    /// Sets the value of [local_ssd_interface][crate::model::DiskConfig::local_ssd_interface].
    pub fn set_local_ssd_interface<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.local_ssd_interface = v.into();
        self
    }

    /// Sets the value of [boot_disk_provisioned_iops][crate::model::DiskConfig::boot_disk_provisioned_iops].
    pub fn set_boot_disk_provisioned_iops<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.boot_disk_provisioned_iops = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [boot_disk_provisioned_iops][crate::model::DiskConfig::boot_disk_provisioned_iops].
    pub fn set_or_clear_boot_disk_provisioned_iops<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.boot_disk_provisioned_iops = v.map(|x| x.into());
        self
    }

    /// Sets the value of [boot_disk_provisioned_throughput][crate::model::DiskConfig::boot_disk_provisioned_throughput].
    pub fn set_boot_disk_provisioned_throughput<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.boot_disk_provisioned_throughput = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [boot_disk_provisioned_throughput][crate::model::DiskConfig::boot_disk_provisioned_throughput].
    pub fn set_or_clear_boot_disk_provisioned_throughput<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.boot_disk_provisioned_throughput = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DiskConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DiskConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiskConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __boot_disk_type,
            __boot_disk_size_gb,
            __num_local_ssds,
            __local_ssd_interface,
            __boot_disk_provisioned_iops,
            __boot_disk_provisioned_throughput,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiskConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bootDiskType" => Ok(__FieldTag::__boot_disk_type),
                            "boot_disk_type" => Ok(__FieldTag::__boot_disk_type),
                            "bootDiskSizeGb" => Ok(__FieldTag::__boot_disk_size_gb),
                            "boot_disk_size_gb" => Ok(__FieldTag::__boot_disk_size_gb),
                            "numLocalSsds" => Ok(__FieldTag::__num_local_ssds),
                            "num_local_ssds" => Ok(__FieldTag::__num_local_ssds),
                            "localSsdInterface" => Ok(__FieldTag::__local_ssd_interface),
                            "local_ssd_interface" => Ok(__FieldTag::__local_ssd_interface),
                            "bootDiskProvisionedIops" => {
                                Ok(__FieldTag::__boot_disk_provisioned_iops)
                            }
                            "boot_disk_provisioned_iops" => {
                                Ok(__FieldTag::__boot_disk_provisioned_iops)
                            }
                            "bootDiskProvisionedThroughput" => {
                                Ok(__FieldTag::__boot_disk_provisioned_throughput)
                            }
                            "boot_disk_provisioned_throughput" => {
                                Ok(__FieldTag::__boot_disk_provisioned_throughput)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiskConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiskConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__boot_disk_type => {
                            if !fields.insert(__FieldTag::__boot_disk_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_disk_type",
                                ));
                            }
                            result.boot_disk_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__boot_disk_size_gb => {
                            if !fields.insert(__FieldTag::__boot_disk_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_disk_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.boot_disk_size_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__num_local_ssds => {
                            if !fields.insert(__FieldTag::__num_local_ssds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for num_local_ssds",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.num_local_ssds =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__local_ssd_interface => {
                            if !fields.insert(__FieldTag::__local_ssd_interface) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_ssd_interface",
                                ));
                            }
                            result.local_ssd_interface = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__boot_disk_provisioned_iops => {
                            if !fields.insert(__FieldTag::__boot_disk_provisioned_iops) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_disk_provisioned_iops",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.boot_disk_provisioned_iops = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__boot_disk_provisioned_throughput => {
                            if !fields.insert(__FieldTag::__boot_disk_provisioned_throughput) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_disk_provisioned_throughput",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.boot_disk_provisioned_throughput = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiskConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.boot_disk_type.is_empty() {
            state.serialize_entry("bootDiskType", &self.boot_disk_type)?;
        }
        if !wkt::internal::is_default(&self.boot_disk_size_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("bootDiskSizeGb", &__With(&self.boot_disk_size_gb))?;
        }
        if !wkt::internal::is_default(&self.num_local_ssds) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("numLocalSsds", &__With(&self.num_local_ssds))?;
        }
        if !self.local_ssd_interface.is_empty() {
            state.serialize_entry("localSsdInterface", &self.local_ssd_interface)?;
        }
        if self.boot_disk_provisioned_iops.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "bootDiskProvisionedIops",
                &__With(&self.boot_disk_provisioned_iops),
            )?;
        }
        if self.boot_disk_provisioned_throughput.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "bootDiskProvisionedThroughput",
                &__With(&self.boot_disk_provisioned_throughput),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Node group identification and configuration information.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AuxiliaryNodeGroup {
    /// Required. Node group configuration.
    pub node_group: std::option::Option<crate::model::NodeGroup>,

    /// Optional. A node group ID. Generated if not specified.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). Cannot begin or end with underscore
    /// or hyphen. Must consist of from 3 to 33 characters.
    pub node_group_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuxiliaryNodeGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [node_group][crate::model::AuxiliaryNodeGroup::node_group].
    pub fn set_node_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeGroup>,
    {
        self.node_group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_group][crate::model::AuxiliaryNodeGroup::node_group].
    pub fn set_or_clear_node_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeGroup>,
    {
        self.node_group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [node_group_id][crate::model::AuxiliaryNodeGroup::node_group_id].
    pub fn set_node_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_group_id = v.into();
        self
    }
}

impl wkt::message::Message for AuxiliaryNodeGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.AuxiliaryNodeGroup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AuxiliaryNodeGroup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __node_group,
            __node_group_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AuxiliaryNodeGroup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nodeGroup" => Ok(__FieldTag::__node_group),
                            "node_group" => Ok(__FieldTag::__node_group),
                            "nodeGroupId" => Ok(__FieldTag::__node_group_id),
                            "node_group_id" => Ok(__FieldTag::__node_group_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AuxiliaryNodeGroup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AuxiliaryNodeGroup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__node_group => {
                            if !fields.insert(__FieldTag::__node_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_group",
                                ));
                            }
                            result.node_group =
                                map.next_value::<std::option::Option<crate::model::NodeGroup>>()?;
                        }
                        __FieldTag::__node_group_id => {
                            if !fields.insert(__FieldTag::__node_group_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_group_id",
                                ));
                            }
                            result.node_group_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AuxiliaryNodeGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.node_group.is_some() {
            state.serialize_entry("nodeGroup", &self.node_group)?;
        }
        if !self.node_group_id.is_empty() {
            state.serialize_entry("nodeGroupId", &self.node_group_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Dataproc Node Group.
/// **The Dataproc `NodeGroup` resource is not related to the
/// Dataproc [NodeGroupAffinity][google.cloud.dataproc.v1.NodeGroupAffinity]
/// resource.**
///
/// [google.cloud.dataproc.v1.NodeGroupAffinity]: crate::model::NodeGroupAffinity
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NodeGroup {
    /// The Node group [resource name](https://aip.dev/122).
    pub name: std::string::String,

    /// Required. Node group roles.
    pub roles: std::vec::Vec<crate::model::node_group::Role>,

    /// Optional. The node group instance group configuration.
    pub node_group_config: std::option::Option<crate::model::InstanceGroupConfig>,

    /// Optional. Node group labels.
    ///
    /// * Label **keys** must consist of from 1 to 63 characters and conform to
    ///   [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt).
    /// * Label **values** can be empty. If specified, they must consist of from
    ///   1 to 63 characters and conform to [RFC 1035]
    ///   (<https://www.ietf.org/rfc/rfc1035.txt>).
    /// * The node group must have no more than 32 labels.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NodeGroup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [roles][crate::model::NodeGroup::roles].
    pub fn set_roles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::node_group::Role>,
    {
        use std::iter::Iterator;
        self.roles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [node_group_config][crate::model::NodeGroup::node_group_config].
    pub fn set_node_group_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupConfig>,
    {
        self.node_group_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_group_config][crate::model::NodeGroup::node_group_config].
    pub fn set_or_clear_node_group_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupConfig>,
    {
        self.node_group_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::NodeGroup::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for NodeGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.NodeGroup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodeGroup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __roles,
            __node_group_config,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeGroup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "roles" => Ok(__FieldTag::__roles),
                            "nodeGroupConfig" => Ok(__FieldTag::__node_group_config),
                            "node_group_config" => Ok(__FieldTag::__node_group_config),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodeGroup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeGroup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__roles => {
                            if !fields.insert(__FieldTag::__roles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for roles",
                                ));
                            }
                            result.roles =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::node_group::Role>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_group_config => {
                            if !fields.insert(__FieldTag::__node_group_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_group_config",
                                ));
                            }
                            result.node_group_config = map.next_value::<std::option::Option<crate::model::InstanceGroupConfig>>()?
                                ;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodeGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.roles.is_empty() {
            state.serialize_entry("roles", &self.roles)?;
        }
        if self.node_group_config.is_some() {
            state.serialize_entry("nodeGroupConfig", &self.node_group_config)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [NodeGroup].
pub mod node_group {
    #[allow(unused_imports)]
    use super::*;

    /// Node pool roles.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Role {
        /// Required unspecified role.
        Unspecified,
        /// Job drivers run on the node pool.
        Driver,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Role::value] or
        /// [Role::name].
        UnknownValue(role::UnknownValue),
    }

    #[doc(hidden)]
    pub mod role {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Role {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Driver => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROLE_UNSPECIFIED"),
                Self::Driver => std::option::Option::Some("DRIVER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Role {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Role {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Role {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Driver,
                _ => Self::UnknownValue(role::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Role {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROLE_UNSPECIFIED" => Self::Unspecified,
                "DRIVER" => Self::Driver,
                _ => Self::UnknownValue(role::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Role {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Driver => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Role {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Role>::new(
                ".google.cloud.dataproc.v1.NodeGroup.Role",
            ))
        }
    }
}

/// Specifies an executable to run on a fully configured node and a
/// timeout period for executable completion.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NodeInitializationAction {
    /// Required. Cloud Storage URI of executable file.
    pub executable_file: std::string::String,

    /// Optional. Amount of time executable has to complete. Default is
    /// 10 minutes (see JSON representation of
    /// [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json)).
    ///
    /// Cluster creation fails with an explanatory error message (the
    /// name of the executable that caused the error and the exceeded timeout
    /// period) if the executable is not completed at end of the timeout period.
    pub execution_timeout: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeInitializationAction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [executable_file][crate::model::NodeInitializationAction::executable_file].
    pub fn set_executable_file<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.executable_file = v.into();
        self
    }

    /// Sets the value of [execution_timeout][crate::model::NodeInitializationAction::execution_timeout].
    pub fn set_execution_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.execution_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [execution_timeout][crate::model::NodeInitializationAction::execution_timeout].
    pub fn set_or_clear_execution_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.execution_timeout = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for NodeInitializationAction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.NodeInitializationAction"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodeInitializationAction {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __executable_file,
            __execution_timeout,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeInitializationAction")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "executableFile" => Ok(__FieldTag::__executable_file),
                            "executable_file" => Ok(__FieldTag::__executable_file),
                            "executionTimeout" => Ok(__FieldTag::__execution_timeout),
                            "execution_timeout" => Ok(__FieldTag::__execution_timeout),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodeInitializationAction;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeInitializationAction")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__executable_file => {
                            if !fields.insert(__FieldTag::__executable_file) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for executable_file",
                                ));
                            }
                            result.executable_file = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__execution_timeout => {
                            if !fields.insert(__FieldTag::__execution_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_timeout",
                                ));
                            }
                            result.execution_timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodeInitializationAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.executable_file.is_empty() {
            state.serialize_entry("executableFile", &self.executable_file)?;
        }
        if self.execution_timeout.is_some() {
            state.serialize_entry("executionTimeout", &self.execution_timeout)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The status of a cluster and its instances.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ClusterStatus {
    /// Output only. The cluster's state.
    pub state: crate::model::cluster_status::State,

    /// Optional. Output only. Details of cluster's state.
    pub detail: std::string::String,

    /// Output only. Time when this state was entered (see JSON representation of
    /// [Timestamp](https://developers.google.com/protocol-buffers/docs/proto3#json)).
    pub state_start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Additional state information that includes
    /// status reported by the agent.
    pub substate: crate::model::cluster_status::Substate,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::ClusterStatus::state].
    pub fn set_state<T: std::convert::Into<crate::model::cluster_status::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [detail][crate::model::ClusterStatus::detail].
    pub fn set_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.detail = v.into();
        self
    }

    /// Sets the value of [state_start_time][crate::model::ClusterStatus::state_start_time].
    pub fn set_state_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_start_time][crate::model::ClusterStatus::state_start_time].
    pub fn set_or_clear_state_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [substate][crate::model::ClusterStatus::substate].
    pub fn set_substate<T: std::convert::Into<crate::model::cluster_status::Substate>>(
        mut self,
        v: T,
    ) -> Self {
        self.substate = v.into();
        self
    }
}

impl wkt::message::Message for ClusterStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ClusterStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClusterStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __detail,
            __state_start_time,
            __substate,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClusterStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "detail" => Ok(__FieldTag::__detail),
                            "stateStartTime" => Ok(__FieldTag::__state_start_time),
                            "state_start_time" => Ok(__FieldTag::__state_start_time),
                            "substate" => Ok(__FieldTag::__substate),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClusterStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClusterStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::cluster_status::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__detail => {
                            if !fields.insert(__FieldTag::__detail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detail",
                                ));
                            }
                            result.detail = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_start_time => {
                            if !fields.insert(__FieldTag::__state_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_start_time",
                                ));
                            }
                            result.state_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__substate => {
                            if !fields.insert(__FieldTag::__substate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for substate",
                                ));
                            }
                            result.substate = map.next_value::<std::option::Option<crate::model::cluster_status::Substate>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ClusterStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.detail.is_empty() {
            state.serialize_entry("detail", &self.detail)?;
        }
        if self.state_start_time.is_some() {
            state.serialize_entry("stateStartTime", &self.state_start_time)?;
        }
        if !wkt::internal::is_default(&self.substate) {
            state.serialize_entry("substate", &self.substate)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ClusterStatus].
pub mod cluster_status {
    #[allow(unused_imports)]
    use super::*;

    /// The cluster state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The cluster state is unknown.
        Unknown,
        /// The cluster is being created and set up. It is not ready for use.
        Creating,
        /// The cluster is currently running and healthy. It is ready for use.
        ///
        /// **Note:** The cluster state changes from "creating" to "running" status
        /// after the master node(s), first two primary worker nodes (and the last
        /// primary worker node if primary workers > 2) are running.
        Running,
        /// The cluster encountered an error. It is not ready for use.
        Error,
        /// The cluster has encountered an error while being updated. Jobs can
        /// be submitted to the cluster, but the cluster cannot be updated.
        ErrorDueToUpdate,
        /// The cluster is being deleted. It cannot be used.
        Deleting,
        /// The cluster is being updated. It continues to accept and process jobs.
        Updating,
        /// The cluster is being stopped. It cannot be used.
        Stopping,
        /// The cluster is currently stopped. It is not ready for use.
        Stopped,
        /// The cluster is being started. It is not ready for use.
        Starting,
        /// The cluster is being repaired. It is not ready for use.
        Repairing,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Error => std::option::Option::Some(3),
                Self::ErrorDueToUpdate => std::option::Option::Some(9),
                Self::Deleting => std::option::Option::Some(4),
                Self::Updating => std::option::Option::Some(5),
                Self::Stopping => std::option::Option::Some(6),
                Self::Stopped => std::option::Option::Some(7),
                Self::Starting => std::option::Option::Some(8),
                Self::Repairing => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::ErrorDueToUpdate => std::option::Option::Some("ERROR_DUE_TO_UPDATE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::Starting => std::option::Option::Some("STARTING"),
                Self::Repairing => std::option::Option::Some("REPAIRING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Creating,
                2 => Self::Running,
                3 => Self::Error,
                4 => Self::Deleting,
                5 => Self::Updating,
                6 => Self::Stopping,
                7 => Self::Stopped,
                8 => Self::Starting,
                9 => Self::ErrorDueToUpdate,
                10 => Self::Repairing,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "CREATING" => Self::Creating,
                "RUNNING" => Self::Running,
                "ERROR" => Self::Error,
                "ERROR_DUE_TO_UPDATE" => Self::ErrorDueToUpdate,
                "DELETING" => Self::Deleting,
                "UPDATING" => Self::Updating,
                "STOPPING" => Self::Stopping,
                "STOPPED" => Self::Stopped,
                "STARTING" => Self::Starting,
                "REPAIRING" => Self::Repairing,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Error => serializer.serialize_i32(3),
                Self::ErrorDueToUpdate => serializer.serialize_i32(9),
                Self::Deleting => serializer.serialize_i32(4),
                Self::Updating => serializer.serialize_i32(5),
                Self::Stopping => serializer.serialize_i32(6),
                Self::Stopped => serializer.serialize_i32(7),
                Self::Starting => serializer.serialize_i32(8),
                Self::Repairing => serializer.serialize_i32(10),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataproc.v1.ClusterStatus.State",
            ))
        }
    }

    /// The cluster substate.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Substate {
        /// The cluster substate is unknown.
        Unspecified,
        /// The cluster is known to be in an unhealthy state
        /// (for example, critical daemons are not running or HDFS capacity is
        /// exhausted).
        ///
        /// Applies to RUNNING state.
        Unhealthy,
        /// The agent-reported status is out of date (may occur if
        /// Dataproc loses communication with Agent).
        ///
        /// Applies to RUNNING state.
        StaleStatus,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Substate::value] or
        /// [Substate::name].
        UnknownValue(substate::UnknownValue),
    }

    #[doc(hidden)]
    pub mod substate {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Substate {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unhealthy => std::option::Option::Some(1),
                Self::StaleStatus => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::Unhealthy => std::option::Option::Some("UNHEALTHY"),
                Self::StaleStatus => std::option::Option::Some("STALE_STATUS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Substate {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Substate {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Substate {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unhealthy,
                2 => Self::StaleStatus,
                _ => Self::UnknownValue(substate::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Substate {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "UNHEALTHY" => Self::Unhealthy,
                "STALE_STATUS" => Self::StaleStatus,
                _ => Self::UnknownValue(substate::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Substate {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unhealthy => serializer.serialize_i32(1),
                Self::StaleStatus => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Substate {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Substate>::new(
                ".google.cloud.dataproc.v1.ClusterStatus.Substate",
            ))
        }
    }
}

/// Security related configuration, including encryption, Kerberos, etc.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SecurityConfig {
    /// Optional. Kerberos related configuration.
    pub kerberos_config: std::option::Option<crate::model::KerberosConfig>,

    /// Optional. Identity related configuration, including service account based
    /// secure multi-tenancy user mappings.
    pub identity_config: std::option::Option<crate::model::IdentityConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecurityConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kerberos_config][crate::model::SecurityConfig::kerberos_config].
    pub fn set_kerberos_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::KerberosConfig>,
    {
        self.kerberos_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kerberos_config][crate::model::SecurityConfig::kerberos_config].
    pub fn set_or_clear_kerberos_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::KerberosConfig>,
    {
        self.kerberos_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [identity_config][crate::model::SecurityConfig::identity_config].
    pub fn set_identity_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IdentityConfig>,
    {
        self.identity_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [identity_config][crate::model::SecurityConfig::identity_config].
    pub fn set_or_clear_identity_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::IdentityConfig>,
    {
        self.identity_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SecurityConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SecurityConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecurityConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kerberos_config,
            __identity_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecurityConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kerberosConfig" => Ok(__FieldTag::__kerberos_config),
                            "kerberos_config" => Ok(__FieldTag::__kerberos_config),
                            "identityConfig" => Ok(__FieldTag::__identity_config),
                            "identity_config" => Ok(__FieldTag::__identity_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecurityConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecurityConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kerberos_config => {
                            if !fields.insert(__FieldTag::__kerberos_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kerberos_config",
                                ));
                            }
                            result.kerberos_config = map
                                .next_value::<std::option::Option<crate::model::KerberosConfig>>(
                                )?;
                        }
                        __FieldTag::__identity_config => {
                            if !fields.insert(__FieldTag::__identity_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for identity_config",
                                ));
                            }
                            result.identity_config = map
                                .next_value::<std::option::Option<crate::model::IdentityConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SecurityConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.kerberos_config.is_some() {
            state.serialize_entry("kerberosConfig", &self.kerberos_config)?;
        }
        if self.identity_config.is_some() {
            state.serialize_entry("identityConfig", &self.identity_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Specifies Kerberos related configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct KerberosConfig {
    /// Optional. Flag to indicate whether to Kerberize the cluster (default:
    /// false). Set this field to true to enable Kerberos on a cluster.
    pub enable_kerberos: bool,

    /// Optional. The Cloud Storage URI of a KMS encrypted file containing the root
    /// principal password.
    pub root_principal_password_uri: std::string::String,

    /// Optional. The URI of the KMS key used to encrypt sensitive
    /// files.
    pub kms_key_uri: std::string::String,

    /// Optional. The Cloud Storage URI of the keystore file used for SSL
    /// encryption. If not provided, Dataproc will provide a self-signed
    /// certificate.
    pub keystore_uri: std::string::String,

    /// Optional. The Cloud Storage URI of the truststore file used for SSL
    /// encryption. If not provided, Dataproc will provide a self-signed
    /// certificate.
    pub truststore_uri: std::string::String,

    /// Optional. The Cloud Storage URI of a KMS encrypted file containing the
    /// password to the user provided keystore. For the self-signed certificate,
    /// this password is generated by Dataproc.
    pub keystore_password_uri: std::string::String,

    /// Optional. The Cloud Storage URI of a KMS encrypted file containing the
    /// password to the user provided key. For the self-signed certificate, this
    /// password is generated by Dataproc.
    pub key_password_uri: std::string::String,

    /// Optional. The Cloud Storage URI of a KMS encrypted file containing the
    /// password to the user provided truststore. For the self-signed certificate,
    /// this password is generated by Dataproc.
    pub truststore_password_uri: std::string::String,

    /// Optional. The remote realm the Dataproc on-cluster KDC will trust, should
    /// the user enable cross realm trust.
    pub cross_realm_trust_realm: std::string::String,

    /// Optional. The KDC (IP or hostname) for the remote trusted realm in a cross
    /// realm trust relationship.
    pub cross_realm_trust_kdc: std::string::String,

    /// Optional. The admin server (IP or hostname) for the remote trusted realm in
    /// a cross realm trust relationship.
    pub cross_realm_trust_admin_server: std::string::String,

    /// Optional. The Cloud Storage URI of a KMS encrypted file containing the
    /// shared password between the on-cluster Kerberos realm and the remote
    /// trusted realm, in a cross realm trust relationship.
    pub cross_realm_trust_shared_password_uri: std::string::String,

    /// Optional. The Cloud Storage URI of a KMS encrypted file containing the
    /// master key of the KDC database.
    pub kdc_db_key_uri: std::string::String,

    /// Optional. The lifetime of the ticket granting ticket, in hours.
    /// If not specified, or user specifies 0, then default value 10
    /// will be used.
    pub tgt_lifetime_hours: i32,

    /// Optional. The name of the on-cluster Kerberos realm.
    /// If not specified, the uppercased domain of hostnames will be the realm.
    pub realm: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KerberosConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_kerberos][crate::model::KerberosConfig::enable_kerberos].
    pub fn set_enable_kerberos<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_kerberos = v.into();
        self
    }

    /// Sets the value of [root_principal_password_uri][crate::model::KerberosConfig::root_principal_password_uri].
    pub fn set_root_principal_password_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.root_principal_password_uri = v.into();
        self
    }

    /// Sets the value of [kms_key_uri][crate::model::KerberosConfig::kms_key_uri].
    pub fn set_kms_key_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_uri = v.into();
        self
    }

    /// Sets the value of [keystore_uri][crate::model::KerberosConfig::keystore_uri].
    pub fn set_keystore_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.keystore_uri = v.into();
        self
    }

    /// Sets the value of [truststore_uri][crate::model::KerberosConfig::truststore_uri].
    pub fn set_truststore_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.truststore_uri = v.into();
        self
    }

    /// Sets the value of [keystore_password_uri][crate::model::KerberosConfig::keystore_password_uri].
    pub fn set_keystore_password_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.keystore_password_uri = v.into();
        self
    }

    /// Sets the value of [key_password_uri][crate::model::KerberosConfig::key_password_uri].
    pub fn set_key_password_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.key_password_uri = v.into();
        self
    }

    /// Sets the value of [truststore_password_uri][crate::model::KerberosConfig::truststore_password_uri].
    pub fn set_truststore_password_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.truststore_password_uri = v.into();
        self
    }

    /// Sets the value of [cross_realm_trust_realm][crate::model::KerberosConfig::cross_realm_trust_realm].
    pub fn set_cross_realm_trust_realm<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cross_realm_trust_realm = v.into();
        self
    }

    /// Sets the value of [cross_realm_trust_kdc][crate::model::KerberosConfig::cross_realm_trust_kdc].
    pub fn set_cross_realm_trust_kdc<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cross_realm_trust_kdc = v.into();
        self
    }

    /// Sets the value of [cross_realm_trust_admin_server][crate::model::KerberosConfig::cross_realm_trust_admin_server].
    pub fn set_cross_realm_trust_admin_server<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cross_realm_trust_admin_server = v.into();
        self
    }

    /// Sets the value of [cross_realm_trust_shared_password_uri][crate::model::KerberosConfig::cross_realm_trust_shared_password_uri].
    pub fn set_cross_realm_trust_shared_password_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cross_realm_trust_shared_password_uri = v.into();
        self
    }

    /// Sets the value of [kdc_db_key_uri][crate::model::KerberosConfig::kdc_db_key_uri].
    pub fn set_kdc_db_key_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kdc_db_key_uri = v.into();
        self
    }

    /// Sets the value of [tgt_lifetime_hours][crate::model::KerberosConfig::tgt_lifetime_hours].
    pub fn set_tgt_lifetime_hours<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.tgt_lifetime_hours = v.into();
        self
    }

    /// Sets the value of [realm][crate::model::KerberosConfig::realm].
    pub fn set_realm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.realm = v.into();
        self
    }
}

impl wkt::message::Message for KerberosConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.KerberosConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for KerberosConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_kerberos,
            __root_principal_password_uri,
            __kms_key_uri,
            __keystore_uri,
            __truststore_uri,
            __keystore_password_uri,
            __key_password_uri,
            __truststore_password_uri,
            __cross_realm_trust_realm,
            __cross_realm_trust_kdc,
            __cross_realm_trust_admin_server,
            __cross_realm_trust_shared_password_uri,
            __kdc_db_key_uri,
            __tgt_lifetime_hours,
            __realm,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KerberosConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableKerberos" => Ok(__FieldTag::__enable_kerberos),
                            "enable_kerberos" => Ok(__FieldTag::__enable_kerberos),
                            "rootPrincipalPasswordUri" => {
                                Ok(__FieldTag::__root_principal_password_uri)
                            }
                            "root_principal_password_uri" => {
                                Ok(__FieldTag::__root_principal_password_uri)
                            }
                            "kmsKeyUri" => Ok(__FieldTag::__kms_key_uri),
                            "kms_key_uri" => Ok(__FieldTag::__kms_key_uri),
                            "keystoreUri" => Ok(__FieldTag::__keystore_uri),
                            "keystore_uri" => Ok(__FieldTag::__keystore_uri),
                            "truststoreUri" => Ok(__FieldTag::__truststore_uri),
                            "truststore_uri" => Ok(__FieldTag::__truststore_uri),
                            "keystorePasswordUri" => Ok(__FieldTag::__keystore_password_uri),
                            "keystore_password_uri" => Ok(__FieldTag::__keystore_password_uri),
                            "keyPasswordUri" => Ok(__FieldTag::__key_password_uri),
                            "key_password_uri" => Ok(__FieldTag::__key_password_uri),
                            "truststorePasswordUri" => Ok(__FieldTag::__truststore_password_uri),
                            "truststore_password_uri" => Ok(__FieldTag::__truststore_password_uri),
                            "crossRealmTrustRealm" => Ok(__FieldTag::__cross_realm_trust_realm),
                            "cross_realm_trust_realm" => Ok(__FieldTag::__cross_realm_trust_realm),
                            "crossRealmTrustKdc" => Ok(__FieldTag::__cross_realm_trust_kdc),
                            "cross_realm_trust_kdc" => Ok(__FieldTag::__cross_realm_trust_kdc),
                            "crossRealmTrustAdminServer" => {
                                Ok(__FieldTag::__cross_realm_trust_admin_server)
                            }
                            "cross_realm_trust_admin_server" => {
                                Ok(__FieldTag::__cross_realm_trust_admin_server)
                            }
                            "crossRealmTrustSharedPasswordUri" => {
                                Ok(__FieldTag::__cross_realm_trust_shared_password_uri)
                            }
                            "cross_realm_trust_shared_password_uri" => {
                                Ok(__FieldTag::__cross_realm_trust_shared_password_uri)
                            }
                            "kdcDbKeyUri" => Ok(__FieldTag::__kdc_db_key_uri),
                            "kdc_db_key_uri" => Ok(__FieldTag::__kdc_db_key_uri),
                            "tgtLifetimeHours" => Ok(__FieldTag::__tgt_lifetime_hours),
                            "tgt_lifetime_hours" => Ok(__FieldTag::__tgt_lifetime_hours),
                            "realm" => Ok(__FieldTag::__realm),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = KerberosConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KerberosConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_kerberos => {
                            if !fields.insert(__FieldTag::__enable_kerberos) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_kerberos",
                                ));
                            }
                            result.enable_kerberos = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__root_principal_password_uri => {
                            if !fields.insert(__FieldTag::__root_principal_password_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for root_principal_password_uri",
                                ));
                            }
                            result.root_principal_password_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key_uri => {
                            if !fields.insert(__FieldTag::__kms_key_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_uri",
                                ));
                            }
                            result.kms_key_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__keystore_uri => {
                            if !fields.insert(__FieldTag::__keystore_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for keystore_uri",
                                ));
                            }
                            result.keystore_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__truststore_uri => {
                            if !fields.insert(__FieldTag::__truststore_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for truststore_uri",
                                ));
                            }
                            result.truststore_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__keystore_password_uri => {
                            if !fields.insert(__FieldTag::__keystore_password_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for keystore_password_uri",
                                ));
                            }
                            result.keystore_password_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__key_password_uri => {
                            if !fields.insert(__FieldTag::__key_password_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_password_uri",
                                ));
                            }
                            result.key_password_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__truststore_password_uri => {
                            if !fields.insert(__FieldTag::__truststore_password_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for truststore_password_uri",
                                ));
                            }
                            result.truststore_password_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cross_realm_trust_realm => {
                            if !fields.insert(__FieldTag::__cross_realm_trust_realm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cross_realm_trust_realm",
                                ));
                            }
                            result.cross_realm_trust_realm = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cross_realm_trust_kdc => {
                            if !fields.insert(__FieldTag::__cross_realm_trust_kdc) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cross_realm_trust_kdc",
                                ));
                            }
                            result.cross_realm_trust_kdc = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cross_realm_trust_admin_server => {
                            if !fields.insert(__FieldTag::__cross_realm_trust_admin_server) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cross_realm_trust_admin_server",
                                ));
                            }
                            result.cross_realm_trust_admin_server = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cross_realm_trust_shared_password_uri => {
                            if !fields.insert(__FieldTag::__cross_realm_trust_shared_password_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cross_realm_trust_shared_password_uri",
                                ));
                            }
                            result.cross_realm_trust_shared_password_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kdc_db_key_uri => {
                            if !fields.insert(__FieldTag::__kdc_db_key_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kdc_db_key_uri",
                                ));
                            }
                            result.kdc_db_key_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tgt_lifetime_hours => {
                            if !fields.insert(__FieldTag::__tgt_lifetime_hours) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tgt_lifetime_hours",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.tgt_lifetime_hours =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__realm => {
                            if !fields.insert(__FieldTag::__realm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for realm",
                                ));
                            }
                            result.realm = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for KerberosConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_kerberos) {
            state.serialize_entry("enableKerberos", &self.enable_kerberos)?;
        }
        if !self.root_principal_password_uri.is_empty() {
            state.serialize_entry(
                "rootPrincipalPasswordUri",
                &self.root_principal_password_uri,
            )?;
        }
        if !self.kms_key_uri.is_empty() {
            state.serialize_entry("kmsKeyUri", &self.kms_key_uri)?;
        }
        if !self.keystore_uri.is_empty() {
            state.serialize_entry("keystoreUri", &self.keystore_uri)?;
        }
        if !self.truststore_uri.is_empty() {
            state.serialize_entry("truststoreUri", &self.truststore_uri)?;
        }
        if !self.keystore_password_uri.is_empty() {
            state.serialize_entry("keystorePasswordUri", &self.keystore_password_uri)?;
        }
        if !self.key_password_uri.is_empty() {
            state.serialize_entry("keyPasswordUri", &self.key_password_uri)?;
        }
        if !self.truststore_password_uri.is_empty() {
            state.serialize_entry("truststorePasswordUri", &self.truststore_password_uri)?;
        }
        if !self.cross_realm_trust_realm.is_empty() {
            state.serialize_entry("crossRealmTrustRealm", &self.cross_realm_trust_realm)?;
        }
        if !self.cross_realm_trust_kdc.is_empty() {
            state.serialize_entry("crossRealmTrustKdc", &self.cross_realm_trust_kdc)?;
        }
        if !self.cross_realm_trust_admin_server.is_empty() {
            state.serialize_entry(
                "crossRealmTrustAdminServer",
                &self.cross_realm_trust_admin_server,
            )?;
        }
        if !self.cross_realm_trust_shared_password_uri.is_empty() {
            state.serialize_entry(
                "crossRealmTrustSharedPasswordUri",
                &self.cross_realm_trust_shared_password_uri,
            )?;
        }
        if !self.kdc_db_key_uri.is_empty() {
            state.serialize_entry("kdcDbKeyUri", &self.kdc_db_key_uri)?;
        }
        if !wkt::internal::is_default(&self.tgt_lifetime_hours) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("tgtLifetimeHours", &__With(&self.tgt_lifetime_hours))?;
        }
        if !self.realm.is_empty() {
            state.serialize_entry("realm", &self.realm)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Identity related configuration, including service account based
/// secure multi-tenancy user mappings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct IdentityConfig {
    /// Required. Map of user to service account.
    pub user_service_account_mapping:
        std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IdentityConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_service_account_mapping][crate::model::IdentityConfig::user_service_account_mapping].
    pub fn set_user_service_account_mapping<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_service_account_mapping =
            v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for IdentityConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.IdentityConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IdentityConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __user_service_account_mapping,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IdentityConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "userServiceAccountMapping" => {
                                Ok(__FieldTag::__user_service_account_mapping)
                            }
                            "user_service_account_mapping" => {
                                Ok(__FieldTag::__user_service_account_mapping)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IdentityConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IdentityConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__user_service_account_mapping => {
                            if !fields.insert(__FieldTag::__user_service_account_mapping) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_service_account_mapping",
                                ));
                            }
                            result.user_service_account_mapping = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IdentityConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.user_service_account_mapping.is_empty() {
            state.serialize_entry(
                "userServiceAccountMapping",
                &self.user_service_account_mapping,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Specifies the selection and config of software inside the cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SoftwareConfig {
    /// Optional. The version of software inside the cluster. It must be one of the
    /// supported [Dataproc
    /// Versions](https://cloud.google.com/dataproc/docs/concepts/versioning/dataproc-versions#supported-dataproc-image-versions),
    /// such as "1.2" (including a subminor version, such as "1.2.29"), or the
    /// ["preview"
    /// version](https://cloud.google.com/dataproc/docs/concepts/versioning/dataproc-versions#other_versions).
    /// If unspecified, it defaults to the latest Debian version.
    pub image_version: std::string::String,

    /// Optional. The properties to set on daemon config files.
    ///
    /// Property keys are specified in `prefix:property` format, for example
    /// `core:hadoop.tmp.dir`. The following are supported prefixes
    /// and their mappings:
    ///
    /// * capacity-scheduler: `capacity-scheduler.xml`
    /// * core:   `core-site.xml`
    /// * distcp: `distcp-default.xml`
    /// * hdfs:   `hdfs-site.xml`
    /// * hive:   `hive-site.xml`
    /// * mapred: `mapred-site.xml`
    /// * pig:    `pig.properties`
    /// * spark:  `spark-defaults.conf`
    /// * yarn:   `yarn-site.xml`
    ///
    /// For more information, see [Cluster
    /// properties](https://cloud.google.com/dataproc/docs/concepts/cluster-properties).
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The set of components to activate on the cluster.
    pub optional_components: std::vec::Vec<crate::model::Component>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SoftwareConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image_version][crate::model::SoftwareConfig::image_version].
    pub fn set_image_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_version = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::SoftwareConfig::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [optional_components][crate::model::SoftwareConfig::optional_components].
    pub fn set_optional_components<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Component>,
    {
        use std::iter::Iterator;
        self.optional_components = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SoftwareConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SoftwareConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SoftwareConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __image_version,
            __properties,
            __optional_components,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SoftwareConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "imageVersion" => Ok(__FieldTag::__image_version),
                            "image_version" => Ok(__FieldTag::__image_version),
                            "properties" => Ok(__FieldTag::__properties),
                            "optionalComponents" => Ok(__FieldTag::__optional_components),
                            "optional_components" => Ok(__FieldTag::__optional_components),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SoftwareConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SoftwareConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__image_version => {
                            if !fields.insert(__FieldTag::__image_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_version",
                                ));
                            }
                            result.image_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__optional_components => {
                            if !fields.insert(__FieldTag::__optional_components) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optional_components",
                                ));
                            }
                            result.optional_components = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Component>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SoftwareConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.image_version.is_empty() {
            state.serialize_entry("imageVersion", &self.image_version)?;
        }
        if !self.properties.is_empty() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if !self.optional_components.is_empty() {
            state.serialize_entry("optionalComponents", &self.optional_components)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Specifies the cluster auto-delete schedule configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LifecycleConfig {
    /// Optional. The duration to keep the cluster alive while idling (when no jobs
    /// are running). Passing this threshold will cause the cluster to be
    /// deleted. Minimum value is 5 minutes; maximum value is 14 days (see JSON
    /// representation of
    /// [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json)).
    pub idle_delete_ttl: std::option::Option<wkt::Duration>,

    /// Output only. The time when cluster became idle (most recent job finished)
    /// and became eligible for deletion due to idleness (see JSON representation
    /// of
    /// [Timestamp](https://developers.google.com/protocol-buffers/docs/proto3#json)).
    pub idle_start_time: std::option::Option<wkt::Timestamp>,

    /// Either the exact time the cluster should be deleted at or
    /// the cluster maximum age.
    pub ttl: std::option::Option<crate::model::lifecycle_config::Ttl>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LifecycleConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [idle_delete_ttl][crate::model::LifecycleConfig::idle_delete_ttl].
    pub fn set_idle_delete_ttl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.idle_delete_ttl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [idle_delete_ttl][crate::model::LifecycleConfig::idle_delete_ttl].
    pub fn set_or_clear_idle_delete_ttl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.idle_delete_ttl = v.map(|x| x.into());
        self
    }

    /// Sets the value of [idle_start_time][crate::model::LifecycleConfig::idle_start_time].
    pub fn set_idle_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.idle_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [idle_start_time][crate::model::LifecycleConfig::idle_start_time].
    pub fn set_or_clear_idle_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.idle_start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ttl][crate::model::LifecycleConfig::ttl].
    ///
    /// Note that all the setters affecting `ttl` are mutually
    /// exclusive.
    pub fn set_ttl<
        T: std::convert::Into<std::option::Option<crate::model::lifecycle_config::Ttl>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ttl = v.into();
        self
    }

    /// The value of [ttl][crate::model::LifecycleConfig::ttl]
    /// if it holds a `AutoDeleteTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn auto_delete_time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.ttl.as_ref().and_then(|v| match v {
            crate::model::lifecycle_config::Ttl::AutoDeleteTime(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [ttl][crate::model::LifecycleConfig::ttl]
    /// to hold a `AutoDeleteTime`.
    ///
    /// Note that all the setters affecting `ttl` are
    /// mutually exclusive.
    pub fn set_auto_delete_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ttl = std::option::Option::Some(crate::model::lifecycle_config::Ttl::AutoDeleteTime(
            v.into(),
        ));
        self
    }

    /// The value of [ttl][crate::model::LifecycleConfig::ttl]
    /// if it holds a `AutoDeleteTtl`, `None` if the field is not set or
    /// holds a different branch.
    pub fn auto_delete_ttl(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.ttl.as_ref().and_then(|v| match v {
            crate::model::lifecycle_config::Ttl::AutoDeleteTtl(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [ttl][crate::model::LifecycleConfig::ttl]
    /// to hold a `AutoDeleteTtl`.
    ///
    /// Note that all the setters affecting `ttl` are
    /// mutually exclusive.
    pub fn set_auto_delete_ttl<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ttl =
            std::option::Option::Some(crate::model::lifecycle_config::Ttl::AutoDeleteTtl(v.into()));
        self
    }
}

impl wkt::message::Message for LifecycleConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.LifecycleConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LifecycleConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __idle_delete_ttl,
            __auto_delete_time,
            __auto_delete_ttl,
            __idle_start_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LifecycleConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "idleDeleteTtl" => Ok(__FieldTag::__idle_delete_ttl),
                            "idle_delete_ttl" => Ok(__FieldTag::__idle_delete_ttl),
                            "autoDeleteTime" => Ok(__FieldTag::__auto_delete_time),
                            "auto_delete_time" => Ok(__FieldTag::__auto_delete_time),
                            "autoDeleteTtl" => Ok(__FieldTag::__auto_delete_ttl),
                            "auto_delete_ttl" => Ok(__FieldTag::__auto_delete_ttl),
                            "idleStartTime" => Ok(__FieldTag::__idle_start_time),
                            "idle_start_time" => Ok(__FieldTag::__idle_start_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LifecycleConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LifecycleConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__idle_delete_ttl => {
                            if !fields.insert(__FieldTag::__idle_delete_ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for idle_delete_ttl",
                                ));
                            }
                            result.idle_delete_ttl =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__auto_delete_time => {
                            if !fields.insert(__FieldTag::__auto_delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_delete_time",
                                ));
                            }
                            if result.ttl.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `ttl`, a oneof with full ID .google.cloud.dataproc.v1.LifecycleConfig.auto_delete_time, latest field was autoDeleteTime",
                                ));
                            }
                            result.ttl = std::option::Option::Some(
                                crate::model::lifecycle_config::Ttl::AutoDeleteTime(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__auto_delete_ttl => {
                            if !fields.insert(__FieldTag::__auto_delete_ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_delete_ttl",
                                ));
                            }
                            if result.ttl.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `ttl`, a oneof with full ID .google.cloud.dataproc.v1.LifecycleConfig.auto_delete_ttl, latest field was autoDeleteTtl",
                                ));
                            }
                            result.ttl = std::option::Option::Some(
                                crate::model::lifecycle_config::Ttl::AutoDeleteTtl(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Duration>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__idle_start_time => {
                            if !fields.insert(__FieldTag::__idle_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for idle_start_time",
                                ));
                            }
                            result.idle_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LifecycleConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.idle_delete_ttl.is_some() {
            state.serialize_entry("idleDeleteTtl", &self.idle_delete_ttl)?;
        }
        if let Some(value) = self.auto_delete_time() {
            state.serialize_entry("autoDeleteTime", value)?;
        }
        if let Some(value) = self.auto_delete_ttl() {
            state.serialize_entry("autoDeleteTtl", value)?;
        }
        if self.idle_start_time.is_some() {
            state.serialize_entry("idleStartTime", &self.idle_start_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [LifecycleConfig].
pub mod lifecycle_config {
    #[allow(unused_imports)]
    use super::*;

    /// Either the exact time the cluster should be deleted at or
    /// the cluster maximum age.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Ttl {
        /// Optional. The time when cluster will be auto-deleted (see JSON
        /// representation of
        /// [Timestamp](https://developers.google.com/protocol-buffers/docs/proto3#json)).
        AutoDeleteTime(std::boxed::Box<wkt::Timestamp>),
        /// Optional. The lifetime duration of cluster. The cluster will be
        /// auto-deleted at the end of this period. Minimum value is 10 minutes;
        /// maximum value is 14 days (see JSON representation of
        /// [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json)).
        AutoDeleteTtl(std::boxed::Box<wkt::Duration>),
    }
}

/// Specifies a Metastore configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MetastoreConfig {
    /// Required. Resource name of an existing Dataproc Metastore service.
    ///
    /// Example:
    ///
    /// * `projects/[project_id]/locations/[dataproc_region]/services/[service-name]`
    pub dataproc_metastore_service: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MetastoreConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataproc_metastore_service][crate::model::MetastoreConfig::dataproc_metastore_service].
    pub fn set_dataproc_metastore_service<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataproc_metastore_service = v.into();
        self
    }
}

impl wkt::message::Message for MetastoreConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.MetastoreConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MetastoreConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataproc_metastore_service,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MetastoreConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataprocMetastoreService" => {
                                Ok(__FieldTag::__dataproc_metastore_service)
                            }
                            "dataproc_metastore_service" => {
                                Ok(__FieldTag::__dataproc_metastore_service)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MetastoreConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MetastoreConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataproc_metastore_service => {
                            if !fields.insert(__FieldTag::__dataproc_metastore_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataproc_metastore_service",
                                ));
                            }
                            result.dataproc_metastore_service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MetastoreConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dataproc_metastore_service.is_empty() {
            state.serialize_entry("dataprocMetastoreService", &self.dataproc_metastore_service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Contains cluster daemon metrics, such as HDFS and YARN stats.
///
/// **Beta Feature**: This report is available for testing purposes only. It may
/// be changed before final release.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ClusterMetrics {
    /// The HDFS metrics.
    pub hdfs_metrics: std::collections::HashMap<std::string::String, i64>,

    /// YARN metrics.
    pub yarn_metrics: std::collections::HashMap<std::string::String, i64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterMetrics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hdfs_metrics][crate::model::ClusterMetrics::hdfs_metrics].
    pub fn set_hdfs_metrics<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.hdfs_metrics = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [yarn_metrics][crate::model::ClusterMetrics::yarn_metrics].
    pub fn set_yarn_metrics<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.yarn_metrics = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ClusterMetrics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ClusterMetrics"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClusterMetrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hdfs_metrics,
            __yarn_metrics,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClusterMetrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hdfsMetrics" => Ok(__FieldTag::__hdfs_metrics),
                            "hdfs_metrics" => Ok(__FieldTag::__hdfs_metrics),
                            "yarnMetrics" => Ok(__FieldTag::__yarn_metrics),
                            "yarn_metrics" => Ok(__FieldTag::__yarn_metrics),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClusterMetrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClusterMetrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hdfs_metrics => {
                            if !fields.insert(__FieldTag::__hdfs_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hdfs_metrics",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, i64>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::I64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.hdfs_metrics = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__yarn_metrics => {
                            if !fields.insert(__FieldTag::__yarn_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for yarn_metrics",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<std::string::String, i64>,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                serde_with::Same,
                                                wkt::internal::I64,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.yarn_metrics = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ClusterMetrics {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.hdfs_metrics.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<std::string::String, i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::collections::HashMap<serde_with::Same, wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("hdfsMetrics", &__With(&self.hdfs_metrics))?;
        }
        if !self.yarn_metrics.is_empty() {
            struct __With<'a>(&'a std::collections::HashMap<std::string::String, i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::collections::HashMap<serde_with::Same, wkt::internal::I64> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("yarnMetrics", &__With(&self.yarn_metrics))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Dataproc metric config.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataprocMetricConfig {
    /// Required. Metrics sources to enable.
    pub metrics: std::vec::Vec<crate::model::dataproc_metric_config::Metric>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataprocMetricConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metrics][crate::model::DataprocMetricConfig::metrics].
    pub fn set_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::dataproc_metric_config::Metric>,
    {
        use std::iter::Iterator;
        self.metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DataprocMetricConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DataprocMetricConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataprocMetricConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __metrics,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataprocMetricConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "metrics" => Ok(__FieldTag::__metrics),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataprocMetricConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataprocMetricConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__metrics => {
                            if !fields.insert(__FieldTag::__metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metrics",
                                ));
                            }
                            result.metrics = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::dataproc_metric_config::Metric>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataprocMetricConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.metrics.is_empty() {
            state.serialize_entry("metrics", &self.metrics)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataprocMetricConfig].
pub mod dataproc_metric_config {
    #[allow(unused_imports)]
    use super::*;

    /// A Dataproc custom metric.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Metric {
        /// Required. A standard set of metrics is collected unless `metricOverrides`
        /// are specified for the metric source (see [Custom metrics]
        /// (<https://cloud.google.com/dataproc/docs/guides/dataproc-metrics#custom_metrics>)
        /// for more information).
        pub metric_source: crate::model::dataproc_metric_config::MetricSource,

        /// Optional. Specify one or more [Custom metrics]
        /// (<https://cloud.google.com/dataproc/docs/guides/dataproc-metrics#custom_metrics>)
        /// to collect for the metric course (for the `SPARK` metric source (any
        /// [Spark metric]
        /// (<https://spark.apache.org/docs/latest/monitoring.html#metrics>) can be
        /// specified).
        ///
        /// Provide metrics in the following format:
        /// \<code\>\<var\>METRIC_SOURCE\</var\>:\<var\>INSTANCE\</var\>:\<var\>GROUP\</var\>:\<var\>METRIC\</var\>\</code\>
        /// Use camelcase as appropriate.
        ///
        /// Examples:
        ///
        /// ```norust
        /// yarn:ResourceManager:QueueMetrics:AppsCompleted
        /// spark:driver:DAGScheduler:job.allJobs
        /// sparkHistoryServer:JVM:Memory:NonHeapMemoryUsage.committed
        /// hiveserver2:JVM:Memory:NonHeapMemoryUsage.used
        /// ```
        ///
        /// Notes:
        ///
        /// * Only the specified overridden metrics are collected for the
        ///   metric source. For example, if one or more `spark:executive` metrics
        ///   are listed as metric overrides, other `SPARK` metrics are not
        ///   collected. The collection of the metrics for other enabled custom
        ///   metric sources is unaffected. For example, if both `SPARK` andd `YARN`
        ///   metric sources are enabled, and overrides are provided for Spark
        ///   metrics only, all YARN metrics are collected.
        pub metric_overrides: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Metric {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [metric_source][crate::model::dataproc_metric_config::Metric::metric_source].
        pub fn set_metric_source<
            T: std::convert::Into<crate::model::dataproc_metric_config::MetricSource>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.metric_source = v.into();
            self
        }

        /// Sets the value of [metric_overrides][crate::model::dataproc_metric_config::Metric::metric_overrides].
        pub fn set_metric_overrides<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.metric_overrides = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Metric {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataproc.v1.DataprocMetricConfig.Metric"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Metric {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __metric_source,
                __metric_overrides,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Metric")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "metricSource" => Ok(__FieldTag::__metric_source),
                                "metric_source" => Ok(__FieldTag::__metric_source),
                                "metricOverrides" => Ok(__FieldTag::__metric_overrides),
                                "metric_overrides" => Ok(__FieldTag::__metric_overrides),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Metric;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Metric")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__metric_source => {
                                if !fields.insert(__FieldTag::__metric_source) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for metric_source",
                                    ));
                                }
                                result.metric_source = map
                                    .next_value::<std::option::Option<
                                        crate::model::dataproc_metric_config::MetricSource,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__metric_overrides => {
                                if !fields.insert(__FieldTag::__metric_overrides) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for metric_overrides",
                                    ));
                                }
                                result.metric_overrides = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Metric {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.metric_source) {
                state.serialize_entry("metricSource", &self.metric_source)?;
            }
            if !self.metric_overrides.is_empty() {
                state.serialize_entry("metricOverrides", &self.metric_overrides)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A source for the collection of Dataproc custom metrics (see [Custom
    /// metrics]
    /// (<https://cloud.google.com//dataproc/docs/guides/dataproc-metrics#custom_metrics>)).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MetricSource {
        /// Required unspecified metric source.
        Unspecified,
        /// Monitoring agent metrics. If this source is enabled,
        /// Dataproc enables the monitoring agent in Compute Engine,
        /// and collects monitoring agent metrics, which are published
        /// with an `agent.googleapis.com` prefix.
        MonitoringAgentDefaults,
        /// HDFS metric source.
        Hdfs,
        /// Spark metric source.
        Spark,
        /// YARN metric source.
        Yarn,
        /// Spark History Server metric source.
        SparkHistoryServer,
        /// Hiveserver2 metric source.
        Hiveserver2,
        /// hivemetastore metric source
        Hivemetastore,
        /// flink metric source
        Flink,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MetricSource::value] or
        /// [MetricSource::name].
        UnknownValue(metric_source::UnknownValue),
    }

    #[doc(hidden)]
    pub mod metric_source {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MetricSource {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::MonitoringAgentDefaults => std::option::Option::Some(1),
                Self::Hdfs => std::option::Option::Some(2),
                Self::Spark => std::option::Option::Some(3),
                Self::Yarn => std::option::Option::Some(4),
                Self::SparkHistoryServer => std::option::Option::Some(5),
                Self::Hiveserver2 => std::option::Option::Some(6),
                Self::Hivemetastore => std::option::Option::Some(7),
                Self::Flink => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("METRIC_SOURCE_UNSPECIFIED"),
                Self::MonitoringAgentDefaults => {
                    std::option::Option::Some("MONITORING_AGENT_DEFAULTS")
                }
                Self::Hdfs => std::option::Option::Some("HDFS"),
                Self::Spark => std::option::Option::Some("SPARK"),
                Self::Yarn => std::option::Option::Some("YARN"),
                Self::SparkHistoryServer => std::option::Option::Some("SPARK_HISTORY_SERVER"),
                Self::Hiveserver2 => std::option::Option::Some("HIVESERVER2"),
                Self::Hivemetastore => std::option::Option::Some("HIVEMETASTORE"),
                Self::Flink => std::option::Option::Some("FLINK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MetricSource {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MetricSource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MetricSource {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::MonitoringAgentDefaults,
                2 => Self::Hdfs,
                3 => Self::Spark,
                4 => Self::Yarn,
                5 => Self::SparkHistoryServer,
                6 => Self::Hiveserver2,
                7 => Self::Hivemetastore,
                8 => Self::Flink,
                _ => Self::UnknownValue(metric_source::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MetricSource {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "METRIC_SOURCE_UNSPECIFIED" => Self::Unspecified,
                "MONITORING_AGENT_DEFAULTS" => Self::MonitoringAgentDefaults,
                "HDFS" => Self::Hdfs,
                "SPARK" => Self::Spark,
                "YARN" => Self::Yarn,
                "SPARK_HISTORY_SERVER" => Self::SparkHistoryServer,
                "HIVESERVER2" => Self::Hiveserver2,
                "HIVEMETASTORE" => Self::Hivemetastore,
                "FLINK" => Self::Flink,
                _ => Self::UnknownValue(metric_source::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MetricSource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::MonitoringAgentDefaults => serializer.serialize_i32(1),
                Self::Hdfs => serializer.serialize_i32(2),
                Self::Spark => serializer.serialize_i32(3),
                Self::Yarn => serializer.serialize_i32(4),
                Self::SparkHistoryServer => serializer.serialize_i32(5),
                Self::Hiveserver2 => serializer.serialize_i32(6),
                Self::Hivemetastore => serializer.serialize_i32(7),
                Self::Flink => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MetricSource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MetricSource>::new(
                ".google.cloud.dataproc.v1.DataprocMetricConfig.MetricSource",
            ))
        }
    }
}

/// A request to create a cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateClusterRequest {
    /// Required. The ID of the Google Cloud Platform project that the cluster
    /// belongs to.
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    pub region: std::string::String,

    /// Required. The cluster to create.
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two
    /// [CreateClusterRequest](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.CreateClusterRequest)s
    /// with the same id, then the second request will be ignored and the
    /// first [google.longrunning.Operation][google.longrunning.Operation] created
    /// and stored in the backend is returned.
    ///
    /// It is recommended to always set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    ///
    /// [google.longrunning.Operation]: longrunning::model::Operation
    pub request_id: std::string::String,

    /// Optional. Failure action when primary worker creation fails.
    pub action_on_failed_primary_workers: crate::model::FailureAction,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::CreateClusterRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::CreateClusterRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [action_on_failed_primary_workers][crate::model::CreateClusterRequest::action_on_failed_primary_workers].
    pub fn set_action_on_failed_primary_workers<
        T: std::convert::Into<crate::model::FailureAction>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action_on_failed_primary_workers = v.into();
        self
    }
}

impl wkt::message::Message for CreateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.CreateClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __region,
            __cluster,
            __request_id,
            __action_on_failed_primary_workers,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "region" => Ok(__FieldTag::__region),
                            "cluster" => Ok(__FieldTag::__cluster),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "actionOnFailedPrimaryWorkers" => {
                                Ok(__FieldTag::__action_on_failed_primary_workers)
                            }
                            "action_on_failed_primary_workers" => {
                                Ok(__FieldTag::__action_on_failed_primary_workers)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster =
                                map.next_value::<std::option::Option<crate::model::Cluster>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__action_on_failed_primary_workers => {
                            if !fields.insert(__FieldTag::__action_on_failed_primary_workers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action_on_failed_primary_workers",
                                ));
                            }
                            result.action_on_failed_primary_workers = map
                                .next_value::<std::option::Option<crate::model::FailureAction>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.cluster.is_some() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.action_on_failed_primary_workers) {
            state.serialize_entry(
                "actionOnFailedPrimaryWorkers",
                &self.action_on_failed_primary_workers,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to update a cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateClusterRequest {
    /// Required. The ID of the Google Cloud Platform project the
    /// cluster belongs to.
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    pub region: std::string::String,

    /// Required. The cluster name.
    pub cluster_name: std::string::String,

    /// Required. The changes to the cluster.
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Optional. Timeout for graceful YARN decommissioning. Graceful
    /// decommissioning allows removing nodes from the cluster without
    /// interrupting jobs in progress. Timeout specifies how long to wait for jobs
    /// in progress to finish before forcefully removing nodes (and potentially
    /// interrupting jobs). Default timeout is 0 (for forceful decommission), and
    /// the maximum allowed timeout is 1 day. (see JSON representation of
    /// [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json)).
    ///
    /// Only supported on Dataproc image versions 1.2 and higher.
    pub graceful_decommission_timeout: std::option::Option<wkt::Duration>,

    /// Required. Specifies the path, relative to `Cluster`, of
    /// the field to update. For example, to change the number of workers
    /// in a cluster to 5, the `update_mask` parameter would be
    /// specified as `config.worker_config.num_instances`,
    /// and the `PATCH` request body would specify the new value, as follows:
    ///
    /// ```norust
    /// {
    ///   "config":{
    ///     "workerConfig":{
    ///       "numInstances":"5"
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// Similarly, to change the number of preemptible workers in a cluster to 5,
    /// the `update_mask` parameter would be
    /// `config.secondary_worker_config.num_instances`, and the `PATCH` request
    /// body would be set as follows:
    ///
    /// ```norust
    /// {
    ///   "config":{
    ///     "secondaryWorkerConfig":{
    ///       "numInstances":"5"
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// \<strong\>Note:\</strong\> Currently, only the following fields can be updated:
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. A unique ID used to identify the request. If the server
    /// receives two
    /// [UpdateClusterRequest](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.UpdateClusterRequest)s
    /// with the same id, then the second request will be ignored and the
    /// first [google.longrunning.Operation][google.longrunning.Operation] created
    /// and stored in the backend is returned.
    ///
    /// It is recommended to always set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    ///
    /// [google.longrunning.Operation]: longrunning::model::Operation
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::UpdateClusterRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::UpdateClusterRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::UpdateClusterRequest::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::UpdateClusterRequest::cluster].
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::UpdateClusterRequest::cluster].
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [graceful_decommission_timeout][crate::model::UpdateClusterRequest::graceful_decommission_timeout].
    pub fn set_graceful_decommission_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.graceful_decommission_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [graceful_decommission_timeout][crate::model::UpdateClusterRequest::graceful_decommission_timeout].
    pub fn set_or_clear_graceful_decommission_timeout<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.graceful_decommission_timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateClusterRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateClusterRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.UpdateClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __region,
            __cluster_name,
            __cluster,
            __graceful_decommission_timeout,
            __update_mask,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "region" => Ok(__FieldTag::__region),
                            "clusterName" => Ok(__FieldTag::__cluster_name),
                            "cluster_name" => Ok(__FieldTag::__cluster_name),
                            "cluster" => Ok(__FieldTag::__cluster),
                            "gracefulDecommissionTimeout" => {
                                Ok(__FieldTag::__graceful_decommission_timeout)
                            }
                            "graceful_decommission_timeout" => {
                                Ok(__FieldTag::__graceful_decommission_timeout)
                            }
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_name => {
                            if !fields.insert(__FieldTag::__cluster_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_name",
                                ));
                            }
                            result.cluster_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster =
                                map.next_value::<std::option::Option<crate::model::Cluster>>()?;
                        }
                        __FieldTag::__graceful_decommission_timeout => {
                            if !fields.insert(__FieldTag::__graceful_decommission_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for graceful_decommission_timeout",
                                ));
                            }
                            result.graceful_decommission_timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.cluster_name.is_empty() {
            state.serialize_entry("clusterName", &self.cluster_name)?;
        }
        if self.cluster.is_some() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if self.graceful_decommission_timeout.is_some() {
            state.serialize_entry(
                "gracefulDecommissionTimeout",
                &self.graceful_decommission_timeout,
            )?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to stop a cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StopClusterRequest {
    /// Required. The ID of the Google Cloud Platform project the
    /// cluster belongs to.
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    pub region: std::string::String,

    /// Required. The cluster name.
    pub cluster_name: std::string::String,

    /// Optional. Specifying the `cluster_uuid` means the RPC will fail
    /// (with error NOT_FOUND) if a cluster with the specified UUID does not exist.
    pub cluster_uuid: std::string::String,

    /// Optional. A unique ID used to identify the request. If the server
    /// receives two
    /// [StopClusterRequest](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.StopClusterRequest)s
    /// with the same id, then the second request will be ignored and the
    /// first [google.longrunning.Operation][google.longrunning.Operation] created
    /// and stored in the backend is returned.
    ///
    /// Recommendation: Set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    ///
    /// [google.longrunning.Operation]: longrunning::model::Operation
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::StopClusterRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::StopClusterRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::StopClusterRequest::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [cluster_uuid][crate::model::StopClusterRequest::cluster_uuid].
    pub fn set_cluster_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uuid = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::StopClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for StopClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.StopClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StopClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __region,
            __cluster_name,
            __cluster_uuid,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StopClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "region" => Ok(__FieldTag::__region),
                            "clusterName" => Ok(__FieldTag::__cluster_name),
                            "cluster_name" => Ok(__FieldTag::__cluster_name),
                            "clusterUuid" => Ok(__FieldTag::__cluster_uuid),
                            "cluster_uuid" => Ok(__FieldTag::__cluster_uuid),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StopClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StopClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_name => {
                            if !fields.insert(__FieldTag::__cluster_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_name",
                                ));
                            }
                            result.cluster_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_uuid => {
                            if !fields.insert(__FieldTag::__cluster_uuid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_uuid",
                                ));
                            }
                            result.cluster_uuid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StopClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.cluster_name.is_empty() {
            state.serialize_entry("clusterName", &self.cluster_name)?;
        }
        if !self.cluster_uuid.is_empty() {
            state.serialize_entry("clusterUuid", &self.cluster_uuid)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to start a cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StartClusterRequest {
    /// Required. The ID of the Google Cloud Platform project the
    /// cluster belongs to.
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    pub region: std::string::String,

    /// Required. The cluster name.
    pub cluster_name: std::string::String,

    /// Optional. Specifying the `cluster_uuid` means the RPC will fail
    /// (with error NOT_FOUND) if a cluster with the specified UUID does not exist.
    pub cluster_uuid: std::string::String,

    /// Optional. A unique ID used to identify the request. If the server
    /// receives two
    /// [StartClusterRequest](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.StartClusterRequest)s
    /// with the same id, then the second request will be ignored and the
    /// first [google.longrunning.Operation][google.longrunning.Operation] created
    /// and stored in the backend is returned.
    ///
    /// Recommendation: Set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    ///
    /// [google.longrunning.Operation]: longrunning::model::Operation
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::StartClusterRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::StartClusterRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::StartClusterRequest::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [cluster_uuid][crate::model::StartClusterRequest::cluster_uuid].
    pub fn set_cluster_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uuid = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::StartClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for StartClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.StartClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StartClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __region,
            __cluster_name,
            __cluster_uuid,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StartClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "region" => Ok(__FieldTag::__region),
                            "clusterName" => Ok(__FieldTag::__cluster_name),
                            "cluster_name" => Ok(__FieldTag::__cluster_name),
                            "clusterUuid" => Ok(__FieldTag::__cluster_uuid),
                            "cluster_uuid" => Ok(__FieldTag::__cluster_uuid),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StartClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StartClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_name => {
                            if !fields.insert(__FieldTag::__cluster_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_name",
                                ));
                            }
                            result.cluster_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_uuid => {
                            if !fields.insert(__FieldTag::__cluster_uuid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_uuid",
                                ));
                            }
                            result.cluster_uuid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StartClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.cluster_name.is_empty() {
            state.serialize_entry("clusterName", &self.cluster_name)?;
        }
        if !self.cluster_uuid.is_empty() {
            state.serialize_entry("clusterUuid", &self.cluster_uuid)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to delete a cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteClusterRequest {
    /// Required. The ID of the Google Cloud Platform project that the cluster
    /// belongs to.
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    pub region: std::string::String,

    /// Required. The cluster name.
    pub cluster_name: std::string::String,

    /// Optional. Specifying the `cluster_uuid` means the RPC should fail
    /// (with error NOT_FOUND) if cluster with specified UUID does not exist.
    pub cluster_uuid: std::string::String,

    /// Optional. A unique ID used to identify the request. If the server
    /// receives two
    /// [DeleteClusterRequest](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.DeleteClusterRequest)s
    /// with the same id, then the second request will be ignored and the
    /// first [google.longrunning.Operation][google.longrunning.Operation] created
    /// and stored in the backend is returned.
    ///
    /// It is recommended to always set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    ///
    /// [google.longrunning.Operation]: longrunning::model::Operation
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DeleteClusterRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::DeleteClusterRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::DeleteClusterRequest::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [cluster_uuid][crate::model::DeleteClusterRequest::cluster_uuid].
    pub fn set_cluster_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uuid = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DeleteClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __region,
            __cluster_name,
            __cluster_uuid,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "region" => Ok(__FieldTag::__region),
                            "clusterName" => Ok(__FieldTag::__cluster_name),
                            "cluster_name" => Ok(__FieldTag::__cluster_name),
                            "clusterUuid" => Ok(__FieldTag::__cluster_uuid),
                            "cluster_uuid" => Ok(__FieldTag::__cluster_uuid),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_name => {
                            if !fields.insert(__FieldTag::__cluster_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_name",
                                ));
                            }
                            result.cluster_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_uuid => {
                            if !fields.insert(__FieldTag::__cluster_uuid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_uuid",
                                ));
                            }
                            result.cluster_uuid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.cluster_name.is_empty() {
            state.serialize_entry("clusterName", &self.cluster_name)?;
        }
        if !self.cluster_uuid.is_empty() {
            state.serialize_entry("clusterUuid", &self.cluster_uuid)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request to get the resource representation for a cluster in a project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetClusterRequest {
    /// Required. The ID of the Google Cloud Platform project that the cluster
    /// belongs to.
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    pub region: std::string::String,

    /// Required. The cluster name.
    pub cluster_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetClusterRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::GetClusterRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::GetClusterRequest::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }
}

impl wkt::message::Message for GetClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GetClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __region,
            __cluster_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "region" => Ok(__FieldTag::__region),
                            "clusterName" => Ok(__FieldTag::__cluster_name),
                            "cluster_name" => Ok(__FieldTag::__cluster_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_name => {
                            if !fields.insert(__FieldTag::__cluster_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_name",
                                ));
                            }
                            result.cluster_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.cluster_name.is_empty() {
            state.serialize_entry("clusterName", &self.cluster_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to list the clusters in a project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListClustersRequest {
    /// Required. The ID of the Google Cloud Platform project that the cluster
    /// belongs to.
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    pub region: std::string::String,

    /// Optional. A filter constraining the clusters to list. Filters are
    /// case-sensitive and have the following syntax:
    ///
    /// field = value [AND [field = value]] ...
    ///
    /// where **field** is one of `status.state`, `clusterName`, or `labels.[KEY]`,
    /// and `[KEY]` is a label key. **value** can be `*` to match all values.
    /// `status.state` can be one of the following: `ACTIVE`, `INACTIVE`,
    /// `CREATING`, `RUNNING`, `ERROR`, `DELETING`, `UPDATING`, `STOPPING`, or
    /// `STOPPED`. `ACTIVE` contains the `CREATING`, `UPDATING`, and `RUNNING`
    /// states. `INACTIVE` contains the `DELETING`, `ERROR`, `STOPPING`, and
    /// `STOPPED` states. `clusterName` is the name of the cluster provided at
    /// creation time. Only the logical `AND` operator is supported;
    /// space-separated items are treated as having an implicit `AND` operator.
    ///
    /// Example filter:
    ///
    /// status.state = ACTIVE AND clusterName = mycluster
    /// AND labels.env = staging AND labels.starred = *
    pub filter: std::string::String,

    /// Optional. The standard List page size.
    pub page_size: i32,

    /// Optional. The standard List page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListClustersRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::ListClustersRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListClustersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListClustersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListClustersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __region,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListClustersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "region" => Ok(__FieldTag::__region),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListClustersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListClustersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListClustersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The list of all clusters in a project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListClustersResponse {
    /// Output only. The clusters in the project.
    pub clusters: std::vec::Vec<crate::model::Cluster>,

    /// Output only. This token is included in the response if there are more
    /// results to fetch. To fetch additional results, provide this value as the
    /// `page_token` in a subsequent `ListClustersRequest`.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [clusters][crate::model::ListClustersResponse::clusters].
    pub fn set_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Cluster>,
    {
        use std::iter::Iterator;
        self.clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListClustersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListClustersResponse {
    type PageItem = crate::model::Cluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.clusters
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListClustersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __clusters,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListClustersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusters" => Ok(__FieldTag::__clusters),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListClustersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListClustersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__clusters => {
                            if !fields.insert(__FieldTag::__clusters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clusters",
                                ));
                            }
                            result.clusters = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Cluster>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListClustersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.clusters.is_empty() {
            state.serialize_entry("clusters", &self.clusters)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to collect cluster diagnostic information.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiagnoseClusterRequest {
    /// Required. The ID of the Google Cloud Platform project that the cluster
    /// belongs to.
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    pub region: std::string::String,

    /// Required. The cluster name.
    pub cluster_name: std::string::String,

    /// Optional. (Optional) The output Cloud Storage directory for the diagnostic
    /// tarball. If not specified, a task-specific directory in the cluster's
    /// staging bucket will be used.
    pub tarball_gcs_dir: std::string::String,

    /// Optional. (Optional) The access type to the diagnostic tarball. If not
    /// specified, falls back to default access of the bucket
    pub tarball_access: crate::model::diagnose_cluster_request::TarballAccess,

    /// Optional. Time interval in which diagnosis should be carried out on the
    /// cluster.
    pub diagnosis_interval: std::option::Option<gtype::model::Interval>,

    /// Optional. Specifies a list of jobs on which diagnosis is to be performed.
    /// Format: projects/{project}/regions/{region}/jobs/{job}
    pub jobs: std::vec::Vec<std::string::String>,

    /// Optional. Specifies a list of yarn applications on which diagnosis is to be
    /// performed.
    pub yarn_application_ids: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiagnoseClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DiagnoseClusterRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::DiagnoseClusterRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::DiagnoseClusterRequest::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [tarball_gcs_dir][crate::model::DiagnoseClusterRequest::tarball_gcs_dir].
    pub fn set_tarball_gcs_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tarball_gcs_dir = v.into();
        self
    }

    /// Sets the value of [tarball_access][crate::model::DiagnoseClusterRequest::tarball_access].
    pub fn set_tarball_access<
        T: std::convert::Into<crate::model::diagnose_cluster_request::TarballAccess>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tarball_access = v.into();
        self
    }

    /// Sets the value of [diagnosis_interval][crate::model::DiagnoseClusterRequest::diagnosis_interval].
    pub fn set_diagnosis_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Interval>,
    {
        self.diagnosis_interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [diagnosis_interval][crate::model::DiagnoseClusterRequest::diagnosis_interval].
    pub fn set_or_clear_diagnosis_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Interval>,
    {
        self.diagnosis_interval = v.map(|x| x.into());
        self
    }

    /// Sets the value of [jobs][crate::model::DiagnoseClusterRequest::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [yarn_application_ids][crate::model::DiagnoseClusterRequest::yarn_application_ids].
    pub fn set_yarn_application_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.yarn_application_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DiagnoseClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DiagnoseClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiagnoseClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __region,
            __cluster_name,
            __tarball_gcs_dir,
            __tarball_access,
            __diagnosis_interval,
            __jobs,
            __yarn_application_ids,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiagnoseClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "region" => Ok(__FieldTag::__region),
                            "clusterName" => Ok(__FieldTag::__cluster_name),
                            "cluster_name" => Ok(__FieldTag::__cluster_name),
                            "tarballGcsDir" => Ok(__FieldTag::__tarball_gcs_dir),
                            "tarball_gcs_dir" => Ok(__FieldTag::__tarball_gcs_dir),
                            "tarballAccess" => Ok(__FieldTag::__tarball_access),
                            "tarball_access" => Ok(__FieldTag::__tarball_access),
                            "diagnosisInterval" => Ok(__FieldTag::__diagnosis_interval),
                            "diagnosis_interval" => Ok(__FieldTag::__diagnosis_interval),
                            "jobs" => Ok(__FieldTag::__jobs),
                            "yarnApplicationIds" => Ok(__FieldTag::__yarn_application_ids),
                            "yarn_application_ids" => Ok(__FieldTag::__yarn_application_ids),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiagnoseClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiagnoseClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_name => {
                            if !fields.insert(__FieldTag::__cluster_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_name",
                                ));
                            }
                            result.cluster_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tarball_gcs_dir => {
                            if !fields.insert(__FieldTag::__tarball_gcs_dir) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tarball_gcs_dir",
                                ));
                            }
                            result.tarball_gcs_dir = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tarball_access => {
                            if !fields.insert(__FieldTag::__tarball_access) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tarball_access",
                                ));
                            }
                            result.tarball_access = map
                                .next_value::<std::option::Option<
                                    crate::model::diagnose_cluster_request::TarballAccess,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__diagnosis_interval => {
                            if !fields.insert(__FieldTag::__diagnosis_interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for diagnosis_interval",
                                ));
                            }
                            result.diagnosis_interval =
                                map.next_value::<std::option::Option<gtype::model::Interval>>()?;
                        }
                        __FieldTag::__jobs => {
                            if !fields.insert(__FieldTag::__jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jobs",
                                ));
                            }
                            result.jobs = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__yarn_application_ids => {
                            if !fields.insert(__FieldTag::__yarn_application_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for yarn_application_ids",
                                ));
                            }
                            result.yarn_application_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiagnoseClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.cluster_name.is_empty() {
            state.serialize_entry("clusterName", &self.cluster_name)?;
        }
        if !self.tarball_gcs_dir.is_empty() {
            state.serialize_entry("tarballGcsDir", &self.tarball_gcs_dir)?;
        }
        if !wkt::internal::is_default(&self.tarball_access) {
            state.serialize_entry("tarballAccess", &self.tarball_access)?;
        }
        if self.diagnosis_interval.is_some() {
            state.serialize_entry("diagnosisInterval", &self.diagnosis_interval)?;
        }
        if !self.jobs.is_empty() {
            state.serialize_entry("jobs", &self.jobs)?;
        }
        if !self.yarn_application_ids.is_empty() {
            state.serialize_entry("yarnApplicationIds", &self.yarn_application_ids)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DiagnoseClusterRequest].
pub mod diagnose_cluster_request {
    #[allow(unused_imports)]
    use super::*;

    /// Defines who has access to the diagnostic tarball
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TarballAccess {
        /// Tarball Access unspecified. Falls back to default access of the bucket
        Unspecified,
        /// Google Cloud Support group has read access to the
        /// diagnostic tarball
        GoogleCloudSupport,
        /// Google Cloud Dataproc Diagnose service account has read access to the
        /// diagnostic tarball
        GoogleDataprocDiagnose,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TarballAccess::value] or
        /// [TarballAccess::name].
        UnknownValue(tarball_access::UnknownValue),
    }

    #[doc(hidden)]
    pub mod tarball_access {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TarballAccess {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GoogleCloudSupport => std::option::Option::Some(1),
                Self::GoogleDataprocDiagnose => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TARBALL_ACCESS_UNSPECIFIED"),
                Self::GoogleCloudSupport => std::option::Option::Some("GOOGLE_CLOUD_SUPPORT"),
                Self::GoogleDataprocDiagnose => {
                    std::option::Option::Some("GOOGLE_DATAPROC_DIAGNOSE")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TarballAccess {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TarballAccess {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TarballAccess {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GoogleCloudSupport,
                2 => Self::GoogleDataprocDiagnose,
                _ => Self::UnknownValue(tarball_access::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TarballAccess {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TARBALL_ACCESS_UNSPECIFIED" => Self::Unspecified,
                "GOOGLE_CLOUD_SUPPORT" => Self::GoogleCloudSupport,
                "GOOGLE_DATAPROC_DIAGNOSE" => Self::GoogleDataprocDiagnose,
                _ => Self::UnknownValue(tarball_access::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TarballAccess {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GoogleCloudSupport => serializer.serialize_i32(1),
                Self::GoogleDataprocDiagnose => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TarballAccess {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TarballAccess>::new(
                ".google.cloud.dataproc.v1.DiagnoseClusterRequest.TarballAccess",
            ))
        }
    }
}

/// The location of diagnostic output.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiagnoseClusterResults {
    /// Output only. The Cloud Storage URI of the diagnostic output.
    /// The output report is a plain text file with a summary of collected
    /// diagnostics.
    pub output_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiagnoseClusterResults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_uri][crate::model::DiagnoseClusterResults::output_uri].
    pub fn set_output_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output_uri = v.into();
        self
    }
}

impl wkt::message::Message for DiagnoseClusterResults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DiagnoseClusterResults"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiagnoseClusterResults {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __output_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiagnoseClusterResults")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "outputUri" => Ok(__FieldTag::__output_uri),
                            "output_uri" => Ok(__FieldTag::__output_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiagnoseClusterResults;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiagnoseClusterResults")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__output_uri => {
                            if !fields.insert(__FieldTag::__output_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_uri",
                                ));
                            }
                            result.output_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiagnoseClusterResults {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.output_uri.is_empty() {
            state.serialize_entry("outputUri", &self.output_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Reservation Affinity for consuming Zonal reservation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReservationAffinity {
    /// Optional. Type of reservation to consume
    pub consume_reservation_type: crate::model::reservation_affinity::Type,

    /// Optional. Corresponds to the label key of reservation resource.
    pub key: std::string::String,

    /// Optional. Corresponds to the label values of reservation resource.
    pub values: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReservationAffinity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [consume_reservation_type][crate::model::ReservationAffinity::consume_reservation_type].
    pub fn set_consume_reservation_type<
        T: std::convert::Into<crate::model::reservation_affinity::Type>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.consume_reservation_type = v.into();
        self
    }

    /// Sets the value of [key][crate::model::ReservationAffinity::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [values][crate::model::ReservationAffinity::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReservationAffinity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ReservationAffinity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReservationAffinity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __consume_reservation_type,
            __key,
            __values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReservationAffinity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "consumeReservationType" => Ok(__FieldTag::__consume_reservation_type),
                            "consume_reservation_type" => {
                                Ok(__FieldTag::__consume_reservation_type)
                            }
                            "key" => Ok(__FieldTag::__key),
                            "values" => Ok(__FieldTag::__values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReservationAffinity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReservationAffinity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__consume_reservation_type => {
                            if !fields.insert(__FieldTag::__consume_reservation_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for consume_reservation_type",
                                ));
                            }
                            result.consume_reservation_type = map.next_value::<std::option::Option<crate::model::reservation_affinity::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__values => {
                            if !fields.insert(__FieldTag::__values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for values",
                                ));
                            }
                            result.values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReservationAffinity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.consume_reservation_type) {
            state.serialize_entry("consumeReservationType", &self.consume_reservation_type)?;
        }
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self.values.is_empty() {
            state.serialize_entry("values", &self.values)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ReservationAffinity].
pub mod reservation_affinity {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates whether to consume capacity from an reservation or not.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        Unspecified,
        /// Do not consume from any allocated capacity.
        NoReservation,
        /// Consume any reservation available.
        AnyReservation,
        /// Must consume from a specific reservation. Must specify key value fields
        /// for specifying the reservations.
        SpecificReservation,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NoReservation => std::option::Option::Some(1),
                Self::AnyReservation => std::option::Option::Some(2),
                Self::SpecificReservation => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::NoReservation => std::option::Option::Some("NO_RESERVATION"),
                Self::AnyReservation => std::option::Option::Some("ANY_RESERVATION"),
                Self::SpecificReservation => std::option::Option::Some("SPECIFIC_RESERVATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NoReservation,
                2 => Self::AnyReservation,
                3 => Self::SpecificReservation,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "NO_RESERVATION" => Self::NoReservation,
                "ANY_RESERVATION" => Self::AnyReservation,
                "SPECIFIC_RESERVATION" => Self::SpecificReservation,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NoReservation => serializer.serialize_i32(1),
                Self::AnyReservation => serializer.serialize_i32(2),
                Self::SpecificReservation => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.dataproc.v1.ReservationAffinity.Type",
            ))
        }
    }
}

/// The runtime logging config of the job.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LoggingConfig {
    /// The per-package log levels for the driver. This can include
    /// "root" package name to configure rootLogger.
    /// Examples:
    ///
    /// - 'com.google = FATAL'
    /// - 'root = INFO'
    /// - 'org.apache = DEBUG'
    pub driver_log_levels:
        std::collections::HashMap<std::string::String, crate::model::logging_config::Level>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LoggingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [driver_log_levels][crate::model::LoggingConfig::driver_log_levels].
    pub fn set_driver_log_levels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::logging_config::Level>,
    {
        use std::iter::Iterator;
        self.driver_log_levels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for LoggingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.LoggingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LoggingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __driver_log_levels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoggingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "driverLogLevels" => Ok(__FieldTag::__driver_log_levels),
                            "driver_log_levels" => Ok(__FieldTag::__driver_log_levels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LoggingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoggingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__driver_log_levels => {
                            if !fields.insert(__FieldTag::__driver_log_levels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for driver_log_levels",
                                ));
                            }
                            result.driver_log_levels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::logging_config::Level,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LoggingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.driver_log_levels.is_empty() {
            state.serialize_entry("driverLogLevels", &self.driver_log_levels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [LoggingConfig].
pub mod logging_config {
    #[allow(unused_imports)]
    use super::*;

    /// The Log4j level for job execution. When running an
    /// [Apache Hive](https://hive.apache.org/) job, Cloud
    /// Dataproc configures the Hive client to an equivalent verbosity level.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Level {
        /// Level is unspecified. Use default level for log4j.
        Unspecified,
        /// Use ALL level for log4j.
        All,
        /// Use TRACE level for log4j.
        Trace,
        /// Use DEBUG level for log4j.
        Debug,
        /// Use INFO level for log4j.
        Info,
        /// Use WARN level for log4j.
        Warn,
        /// Use ERROR level for log4j.
        Error,
        /// Use FATAL level for log4j.
        Fatal,
        /// Turn off log4j.
        Off,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Level::value] or
        /// [Level::name].
        UnknownValue(level::UnknownValue),
    }

    #[doc(hidden)]
    pub mod level {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Level {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::All => std::option::Option::Some(1),
                Self::Trace => std::option::Option::Some(2),
                Self::Debug => std::option::Option::Some(3),
                Self::Info => std::option::Option::Some(4),
                Self::Warn => std::option::Option::Some(5),
                Self::Error => std::option::Option::Some(6),
                Self::Fatal => std::option::Option::Some(7),
                Self::Off => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LEVEL_UNSPECIFIED"),
                Self::All => std::option::Option::Some("ALL"),
                Self::Trace => std::option::Option::Some("TRACE"),
                Self::Debug => std::option::Option::Some("DEBUG"),
                Self::Info => std::option::Option::Some("INFO"),
                Self::Warn => std::option::Option::Some("WARN"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Fatal => std::option::Option::Some("FATAL"),
                Self::Off => std::option::Option::Some("OFF"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Level {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Level {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Level {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::All,
                2 => Self::Trace,
                3 => Self::Debug,
                4 => Self::Info,
                5 => Self::Warn,
                6 => Self::Error,
                7 => Self::Fatal,
                8 => Self::Off,
                _ => Self::UnknownValue(level::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Level {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LEVEL_UNSPECIFIED" => Self::Unspecified,
                "ALL" => Self::All,
                "TRACE" => Self::Trace,
                "DEBUG" => Self::Debug,
                "INFO" => Self::Info,
                "WARN" => Self::Warn,
                "ERROR" => Self::Error,
                "FATAL" => Self::Fatal,
                "OFF" => Self::Off,
                _ => Self::UnknownValue(level::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Level {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::All => serializer.serialize_i32(1),
                Self::Trace => serializer.serialize_i32(2),
                Self::Debug => serializer.serialize_i32(3),
                Self::Info => serializer.serialize_i32(4),
                Self::Warn => serializer.serialize_i32(5),
                Self::Error => serializer.serialize_i32(6),
                Self::Fatal => serializer.serialize_i32(7),
                Self::Off => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Level {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Level>::new(
                ".google.cloud.dataproc.v1.LoggingConfig.Level",
            ))
        }
    }
}

/// A Dataproc job for running
/// [Apache Hadoop
/// MapReduce](https://hadoop.apache.org/docs/current/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html)
/// jobs on [Apache Hadoop
/// YARN](https://hadoop.apache.org/docs/r2.7.1/hadoop-yarn/hadoop-yarn-site/YARN.html).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct HadoopJob {
    /// Optional. The arguments to pass to the driver. Do not
    /// include arguments, such as `-libjars` or `-Dfoo=bar`, that can be set as
    /// job properties, since a collision might occur that causes an incorrect job
    /// submission.
    pub args: std::vec::Vec<std::string::String>,

    /// Optional. Jar file URIs to add to the CLASSPATHs of the
    /// Hadoop driver and tasks.
    pub jar_file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS (Hadoop Compatible Filesystem) URIs of files to be copied
    /// to the working directory of Hadoop drivers and distributed tasks. Useful
    /// for naively parallel tasks.
    pub file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of archives to be extracted in the working directory of
    /// Hadoop drivers and tasks. Supported file types:
    /// .jar, .tar, .tar.gz, .tgz, or .zip.
    pub archive_uris: std::vec::Vec<std::string::String>,

    /// Optional. A mapping of property names to values, used to configure Hadoop.
    /// Properties that conflict with values set by the Dataproc API might be
    /// overwritten. Can include properties set in `/etc/hadoop/conf/*-site` and
    /// classes in user code.
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The runtime log config for job execution.
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Required. Indicates the location of the driver's main class. Specify
    /// either the jar file that contains the main class or the main class name.
    /// To specify both, add the jar file to `jar_file_uris`, and then specify
    /// the main class name in this property.
    pub driver: std::option::Option<crate::model::hadoop_job::Driver>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HadoopJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [args][crate::model::HadoopJob::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [jar_file_uris][crate::model::HadoopJob::jar_file_uris].
    pub fn set_jar_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jar_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_uris][crate::model::HadoopJob::file_uris].
    pub fn set_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [archive_uris][crate::model::HadoopJob::archive_uris].
    pub fn set_archive_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.archive_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [properties][crate::model::HadoopJob::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [logging_config][crate::model::HadoopJob::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::HadoopJob::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [driver][crate::model::HadoopJob::driver].
    ///
    /// Note that all the setters affecting `driver` are mutually
    /// exclusive.
    pub fn set_driver<
        T: std::convert::Into<std::option::Option<crate::model::hadoop_job::Driver>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.driver = v.into();
        self
    }

    /// The value of [driver][crate::model::HadoopJob::driver]
    /// if it holds a `MainJarFileUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn main_jar_file_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.driver.as_ref().and_then(|v| match v {
            crate::model::hadoop_job::Driver::MainJarFileUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [driver][crate::model::HadoopJob::driver]
    /// to hold a `MainJarFileUri`.
    ///
    /// Note that all the setters affecting `driver` are
    /// mutually exclusive.
    pub fn set_main_jar_file_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.driver =
            std::option::Option::Some(crate::model::hadoop_job::Driver::MainJarFileUri(v.into()));
        self
    }

    /// The value of [driver][crate::model::HadoopJob::driver]
    /// if it holds a `MainClass`, `None` if the field is not set or
    /// holds a different branch.
    pub fn main_class(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.driver.as_ref().and_then(|v| match v {
            crate::model::hadoop_job::Driver::MainClass(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [driver][crate::model::HadoopJob::driver]
    /// to hold a `MainClass`.
    ///
    /// Note that all the setters affecting `driver` are
    /// mutually exclusive.
    pub fn set_main_class<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.driver =
            std::option::Option::Some(crate::model::hadoop_job::Driver::MainClass(v.into()));
        self
    }
}

impl wkt::message::Message for HadoopJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.HadoopJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HadoopJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __main_jar_file_uri,
            __main_class,
            __args,
            __jar_file_uris,
            __file_uris,
            __archive_uris,
            __properties,
            __logging_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HadoopJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mainJarFileUri" => Ok(__FieldTag::__main_jar_file_uri),
                            "main_jar_file_uri" => Ok(__FieldTag::__main_jar_file_uri),
                            "mainClass" => Ok(__FieldTag::__main_class),
                            "main_class" => Ok(__FieldTag::__main_class),
                            "args" => Ok(__FieldTag::__args),
                            "jarFileUris" => Ok(__FieldTag::__jar_file_uris),
                            "jar_file_uris" => Ok(__FieldTag::__jar_file_uris),
                            "fileUris" => Ok(__FieldTag::__file_uris),
                            "file_uris" => Ok(__FieldTag::__file_uris),
                            "archiveUris" => Ok(__FieldTag::__archive_uris),
                            "archive_uris" => Ok(__FieldTag::__archive_uris),
                            "properties" => Ok(__FieldTag::__properties),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HadoopJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HadoopJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__main_jar_file_uri => {
                            if !fields.insert(__FieldTag::__main_jar_file_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for main_jar_file_uri",
                                ));
                            }
                            if result.driver.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `driver`, a oneof with full ID .google.cloud.dataproc.v1.HadoopJob.main_jar_file_uri, latest field was mainJarFileUri",
                                ));
                            }
                            result.driver = std::option::Option::Some(
                                crate::model::hadoop_job::Driver::MainJarFileUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__main_class => {
                            if !fields.insert(__FieldTag::__main_class) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for main_class",
                                ));
                            }
                            if result.driver.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `driver`, a oneof with full ID .google.cloud.dataproc.v1.HadoopJob.main_class, latest field was mainClass",
                                ));
                            }
                            result.driver = std::option::Option::Some(
                                crate::model::hadoop_job::Driver::MainClass(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__args => {
                            if !fields.insert(__FieldTag::__args) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for args",
                                ));
                            }
                            result.args = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__jar_file_uris => {
                            if !fields.insert(__FieldTag::__jar_file_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jar_file_uris",
                                ));
                            }
                            result.jar_file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__file_uris => {
                            if !fields.insert(__FieldTag::__file_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_uris",
                                ));
                            }
                            result.file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__archive_uris => {
                            if !fields.insert(__FieldTag::__archive_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for archive_uris",
                                ));
                            }
                            result.archive_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HadoopJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.main_jar_file_uri() {
            state.serialize_entry("mainJarFileUri", value)?;
        }
        if let Some(value) = self.main_class() {
            state.serialize_entry("mainClass", value)?;
        }
        if !self.args.is_empty() {
            state.serialize_entry("args", &self.args)?;
        }
        if !self.jar_file_uris.is_empty() {
            state.serialize_entry("jarFileUris", &self.jar_file_uris)?;
        }
        if !self.file_uris.is_empty() {
            state.serialize_entry("fileUris", &self.file_uris)?;
        }
        if !self.archive_uris.is_empty() {
            state.serialize_entry("archiveUris", &self.archive_uris)?;
        }
        if !self.properties.is_empty() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [HadoopJob].
pub mod hadoop_job {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Indicates the location of the driver's main class. Specify
    /// either the jar file that contains the main class or the main class name.
    /// To specify both, add the jar file to `jar_file_uris`, and then specify
    /// the main class name in this property.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Driver {
        /// The HCFS URI of the jar file containing the main class.
        /// Examples:
        /// 'gs://foo-bucket/analytics-binaries/extract-useful-metrics-mr.jar'
        /// 'hdfs:/tmp/test-samples/custom-wordcount.jar'
        /// 'file:///home/usr/lib/hadoop-mapreduce/hadoop-mapreduce-examples.jar'
        MainJarFileUri(std::string::String),
        /// The name of the driver's main class. The jar file containing the class
        /// must be in the default CLASSPATH or specified in `jar_file_uris`.
        MainClass(std::string::String),
    }
}

/// A Dataproc job for running [Apache Spark](https://spark.apache.org/)
/// applications on YARN.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SparkJob {
    /// Optional. The arguments to pass to the driver. Do not include arguments,
    /// such as `--conf`, that can be set as job properties, since a collision may
    /// occur that causes an incorrect job submission.
    pub args: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of jar files to add to the CLASSPATHs of the
    /// Spark driver and tasks.
    pub jar_file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of files to be placed in the working directory of
    /// each executor. Useful for naively parallel tasks.
    pub file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of archives to be extracted into the working directory
    /// of each executor. Supported file types:
    /// .jar, .tar, .tar.gz, .tgz, and .zip.
    pub archive_uris: std::vec::Vec<std::string::String>,

    /// Optional. A mapping of property names to values, used to configure Spark.
    /// Properties that conflict with values set by the Dataproc API might be
    /// overwritten. Can include properties set in
    /// /etc/spark/conf/spark-defaults.conf and classes in user code.
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The runtime log config for job execution.
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Required. The specification of the main method to call to drive the job.
    /// Specify either the jar file that contains the main class or the main class
    /// name. To pass both a main jar and a main class in that jar, add the jar to
    /// [jarFileUris][google.cloud.dataproc.v1.SparkJob.jar_file_uris], and then
    /// specify the main class name in
    /// [mainClass][google.cloud.dataproc.v1.SparkJob.main_class].
    ///
    /// [google.cloud.dataproc.v1.SparkJob.jar_file_uris]: crate::model::SparkJob::jar_file_uris
    /// [google.cloud.dataproc.v1.SparkJob.main_class]: crate::model::SparkJob::driver
    pub driver: std::option::Option<crate::model::spark_job::Driver>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SparkJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [args][crate::model::SparkJob::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [jar_file_uris][crate::model::SparkJob::jar_file_uris].
    pub fn set_jar_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jar_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_uris][crate::model::SparkJob::file_uris].
    pub fn set_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [archive_uris][crate::model::SparkJob::archive_uris].
    pub fn set_archive_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.archive_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [properties][crate::model::SparkJob::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [logging_config][crate::model::SparkJob::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::SparkJob::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [driver][crate::model::SparkJob::driver].
    ///
    /// Note that all the setters affecting `driver` are mutually
    /// exclusive.
    pub fn set_driver<
        T: std::convert::Into<std::option::Option<crate::model::spark_job::Driver>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.driver = v.into();
        self
    }

    /// The value of [driver][crate::model::SparkJob::driver]
    /// if it holds a `MainJarFileUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn main_jar_file_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.driver.as_ref().and_then(|v| match v {
            crate::model::spark_job::Driver::MainJarFileUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [driver][crate::model::SparkJob::driver]
    /// to hold a `MainJarFileUri`.
    ///
    /// Note that all the setters affecting `driver` are
    /// mutually exclusive.
    pub fn set_main_jar_file_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.driver =
            std::option::Option::Some(crate::model::spark_job::Driver::MainJarFileUri(v.into()));
        self
    }

    /// The value of [driver][crate::model::SparkJob::driver]
    /// if it holds a `MainClass`, `None` if the field is not set or
    /// holds a different branch.
    pub fn main_class(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.driver.as_ref().and_then(|v| match v {
            crate::model::spark_job::Driver::MainClass(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [driver][crate::model::SparkJob::driver]
    /// to hold a `MainClass`.
    ///
    /// Note that all the setters affecting `driver` are
    /// mutually exclusive.
    pub fn set_main_class<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.driver =
            std::option::Option::Some(crate::model::spark_job::Driver::MainClass(v.into()));
        self
    }
}

impl wkt::message::Message for SparkJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SparkJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SparkJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __main_jar_file_uri,
            __main_class,
            __args,
            __jar_file_uris,
            __file_uris,
            __archive_uris,
            __properties,
            __logging_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SparkJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mainJarFileUri" => Ok(__FieldTag::__main_jar_file_uri),
                            "main_jar_file_uri" => Ok(__FieldTag::__main_jar_file_uri),
                            "mainClass" => Ok(__FieldTag::__main_class),
                            "main_class" => Ok(__FieldTag::__main_class),
                            "args" => Ok(__FieldTag::__args),
                            "jarFileUris" => Ok(__FieldTag::__jar_file_uris),
                            "jar_file_uris" => Ok(__FieldTag::__jar_file_uris),
                            "fileUris" => Ok(__FieldTag::__file_uris),
                            "file_uris" => Ok(__FieldTag::__file_uris),
                            "archiveUris" => Ok(__FieldTag::__archive_uris),
                            "archive_uris" => Ok(__FieldTag::__archive_uris),
                            "properties" => Ok(__FieldTag::__properties),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SparkJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SparkJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__main_jar_file_uri => {
                            if !fields.insert(__FieldTag::__main_jar_file_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for main_jar_file_uri",
                                ));
                            }
                            if result.driver.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `driver`, a oneof with full ID .google.cloud.dataproc.v1.SparkJob.main_jar_file_uri, latest field was mainJarFileUri",
                                ));
                            }
                            result.driver = std::option::Option::Some(
                                crate::model::spark_job::Driver::MainJarFileUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__main_class => {
                            if !fields.insert(__FieldTag::__main_class) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for main_class",
                                ));
                            }
                            if result.driver.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `driver`, a oneof with full ID .google.cloud.dataproc.v1.SparkJob.main_class, latest field was mainClass",
                                ));
                            }
                            result.driver = std::option::Option::Some(
                                crate::model::spark_job::Driver::MainClass(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__args => {
                            if !fields.insert(__FieldTag::__args) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for args",
                                ));
                            }
                            result.args = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__jar_file_uris => {
                            if !fields.insert(__FieldTag::__jar_file_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jar_file_uris",
                                ));
                            }
                            result.jar_file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__file_uris => {
                            if !fields.insert(__FieldTag::__file_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_uris",
                                ));
                            }
                            result.file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__archive_uris => {
                            if !fields.insert(__FieldTag::__archive_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for archive_uris",
                                ));
                            }
                            result.archive_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SparkJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.main_jar_file_uri() {
            state.serialize_entry("mainJarFileUri", value)?;
        }
        if let Some(value) = self.main_class() {
            state.serialize_entry("mainClass", value)?;
        }
        if !self.args.is_empty() {
            state.serialize_entry("args", &self.args)?;
        }
        if !self.jar_file_uris.is_empty() {
            state.serialize_entry("jarFileUris", &self.jar_file_uris)?;
        }
        if !self.file_uris.is_empty() {
            state.serialize_entry("fileUris", &self.file_uris)?;
        }
        if !self.archive_uris.is_empty() {
            state.serialize_entry("archiveUris", &self.archive_uris)?;
        }
        if !self.properties.is_empty() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SparkJob].
pub mod spark_job {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The specification of the main method to call to drive the job.
    /// Specify either the jar file that contains the main class or the main class
    /// name. To pass both a main jar and a main class in that jar, add the jar to
    /// [jarFileUris][google.cloud.dataproc.v1.SparkJob.jar_file_uris], and then
    /// specify the main class name in
    /// [mainClass][google.cloud.dataproc.v1.SparkJob.main_class].
    ///
    /// [google.cloud.dataproc.v1.SparkJob.jar_file_uris]: crate::model::SparkJob::jar_file_uris
    /// [google.cloud.dataproc.v1.SparkJob.main_class]: crate::model::SparkJob::driver
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Driver {
        /// The HCFS URI of the jar file that contains the main class.
        MainJarFileUri(std::string::String),
        /// The name of the driver's main class. The jar file that contains the class
        /// must be in the default CLASSPATH or specified in
        /// SparkJob.jar_file_uris.
        MainClass(std::string::String),
    }
}

/// A Dataproc job for running
/// [Apache
/// PySpark](https://spark.apache.org/docs/0.9.0/python-programming-guide.html)
/// applications on YARN.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PySparkJob {
    /// Required. The HCFS URI of the main Python file to use as the driver. Must
    /// be a .py file.
    pub main_python_file_uri: std::string::String,

    /// Optional. The arguments to pass to the driver.  Do not include arguments,
    /// such as `--conf`, that can be set as job properties, since a collision may
    /// occur that causes an incorrect job submission.
    pub args: std::vec::Vec<std::string::String>,

    /// Optional. HCFS file URIs of Python files to pass to the PySpark
    /// framework. Supported file types: .py, .egg, and .zip.
    pub python_file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of jar files to add to the CLASSPATHs of the
    /// Python driver and tasks.
    pub jar_file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of files to be placed in the working directory of
    /// each executor. Useful for naively parallel tasks.
    pub file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of archives to be extracted into the working directory
    /// of each executor. Supported file types:
    /// .jar, .tar, .tar.gz, .tgz, and .zip.
    pub archive_uris: std::vec::Vec<std::string::String>,

    /// Optional. A mapping of property names to values, used to configure PySpark.
    /// Properties that conflict with values set by the Dataproc API might be
    /// overwritten. Can include properties set in
    /// /etc/spark/conf/spark-defaults.conf and classes in user code.
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The runtime log config for job execution.
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PySparkJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [main_python_file_uri][crate::model::PySparkJob::main_python_file_uri].
    pub fn set_main_python_file_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.main_python_file_uri = v.into();
        self
    }

    /// Sets the value of [args][crate::model::PySparkJob::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [python_file_uris][crate::model::PySparkJob::python_file_uris].
    pub fn set_python_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.python_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [jar_file_uris][crate::model::PySparkJob::jar_file_uris].
    pub fn set_jar_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jar_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_uris][crate::model::PySparkJob::file_uris].
    pub fn set_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [archive_uris][crate::model::PySparkJob::archive_uris].
    pub fn set_archive_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.archive_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [properties][crate::model::PySparkJob::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [logging_config][crate::model::PySparkJob::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::PySparkJob::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PySparkJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.PySparkJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PySparkJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __main_python_file_uri,
            __args,
            __python_file_uris,
            __jar_file_uris,
            __file_uris,
            __archive_uris,
            __properties,
            __logging_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PySparkJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mainPythonFileUri" => Ok(__FieldTag::__main_python_file_uri),
                            "main_python_file_uri" => Ok(__FieldTag::__main_python_file_uri),
                            "args" => Ok(__FieldTag::__args),
                            "pythonFileUris" => Ok(__FieldTag::__python_file_uris),
                            "python_file_uris" => Ok(__FieldTag::__python_file_uris),
                            "jarFileUris" => Ok(__FieldTag::__jar_file_uris),
                            "jar_file_uris" => Ok(__FieldTag::__jar_file_uris),
                            "fileUris" => Ok(__FieldTag::__file_uris),
                            "file_uris" => Ok(__FieldTag::__file_uris),
                            "archiveUris" => Ok(__FieldTag::__archive_uris),
                            "archive_uris" => Ok(__FieldTag::__archive_uris),
                            "properties" => Ok(__FieldTag::__properties),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PySparkJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PySparkJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__main_python_file_uri => {
                            if !fields.insert(__FieldTag::__main_python_file_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for main_python_file_uri",
                                ));
                            }
                            result.main_python_file_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__args => {
                            if !fields.insert(__FieldTag::__args) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for args",
                                ));
                            }
                            result.args = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__python_file_uris => {
                            if !fields.insert(__FieldTag::__python_file_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for python_file_uris",
                                ));
                            }
                            result.python_file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__jar_file_uris => {
                            if !fields.insert(__FieldTag::__jar_file_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jar_file_uris",
                                ));
                            }
                            result.jar_file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__file_uris => {
                            if !fields.insert(__FieldTag::__file_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_uris",
                                ));
                            }
                            result.file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__archive_uris => {
                            if !fields.insert(__FieldTag::__archive_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for archive_uris",
                                ));
                            }
                            result.archive_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PySparkJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.main_python_file_uri.is_empty() {
            state.serialize_entry("mainPythonFileUri", &self.main_python_file_uri)?;
        }
        if !self.args.is_empty() {
            state.serialize_entry("args", &self.args)?;
        }
        if !self.python_file_uris.is_empty() {
            state.serialize_entry("pythonFileUris", &self.python_file_uris)?;
        }
        if !self.jar_file_uris.is_empty() {
            state.serialize_entry("jarFileUris", &self.jar_file_uris)?;
        }
        if !self.file_uris.is_empty() {
            state.serialize_entry("fileUris", &self.file_uris)?;
        }
        if !self.archive_uris.is_empty() {
            state.serialize_entry("archiveUris", &self.archive_uris)?;
        }
        if !self.properties.is_empty() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A list of queries to run on a cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryList {
    /// Required. The queries to execute. You do not need to end a query expression
    /// with a semicolon. Multiple queries can be specified in one
    /// string by separating each with a semicolon. Here is an example of a
    /// Dataproc API snippet that uses a QueryList to specify a HiveJob:
    ///
    /// ```norust
    /// "hiveJob": {
    ///   "queryList": {
    ///     "queries": [
    ///       "query1",
    ///       "query2",
    ///       "query3;query4",
    ///     ]
    ///   }
    /// }
    /// ```
    pub queries: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [queries][crate::model::QueryList::queries].
    pub fn set_queries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.queries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for QueryList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.QueryList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __queries,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "queries" => Ok(__FieldTag::__queries),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__queries => {
                            if !fields.insert(__FieldTag::__queries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for queries",
                                ));
                            }
                            result.queries = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.queries.is_empty() {
            state.serialize_entry("queries", &self.queries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A Dataproc job for running [Apache Hive](https://hive.apache.org/)
/// queries on YARN.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct HiveJob {
    /// Optional. Whether to continue executing queries if a query fails.
    /// The default value is `false`. Setting to `true` can be useful when
    /// executing independent parallel queries.
    pub continue_on_failure: bool,

    /// Optional. Mapping of query variable names to values (equivalent to the
    /// Hive command: `SET name="value";`).
    pub script_variables: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. A mapping of property names and values, used to configure Hive.
    /// Properties that conflict with values set by the Dataproc API might be
    /// overwritten. Can include properties set in `/etc/hadoop/conf/*-site.xml`,
    /// /etc/hive/conf/hive-site.xml, and classes in user code.
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. HCFS URIs of jar files to add to the CLASSPATH of the
    /// Hive server and Hadoop MapReduce (MR) tasks. Can contain Hive SerDes
    /// and UDFs.
    pub jar_file_uris: std::vec::Vec<std::string::String>,

    /// Required. The sequence of Hive queries to execute, specified as either
    /// an HCFS file URI or a list of queries.
    pub queries: std::option::Option<crate::model::hive_job::Queries>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HiveJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [continue_on_failure][crate::model::HiveJob::continue_on_failure].
    pub fn set_continue_on_failure<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.continue_on_failure = v.into();
        self
    }

    /// Sets the value of [script_variables][crate::model::HiveJob::script_variables].
    pub fn set_script_variables<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.script_variables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [properties][crate::model::HiveJob::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [jar_file_uris][crate::model::HiveJob::jar_file_uris].
    pub fn set_jar_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jar_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [queries][crate::model::HiveJob::queries].
    ///
    /// Note that all the setters affecting `queries` are mutually
    /// exclusive.
    pub fn set_queries<
        T: std::convert::Into<std::option::Option<crate::model::hive_job::Queries>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.queries = v.into();
        self
    }

    /// The value of [queries][crate::model::HiveJob::queries]
    /// if it holds a `QueryFileUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query_file_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.queries.as_ref().and_then(|v| match v {
            crate::model::hive_job::Queries::QueryFileUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [queries][crate::model::HiveJob::queries]
    /// to hold a `QueryFileUri`.
    ///
    /// Note that all the setters affecting `queries` are
    /// mutually exclusive.
    pub fn set_query_file_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.queries =
            std::option::Option::Some(crate::model::hive_job::Queries::QueryFileUri(v.into()));
        self
    }

    /// The value of [queries][crate::model::HiveJob::queries]
    /// if it holds a `QueryList`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query_list(&self) -> std::option::Option<&std::boxed::Box<crate::model::QueryList>> {
        #[allow(unreachable_patterns)]
        self.queries.as_ref().and_then(|v| match v {
            crate::model::hive_job::Queries::QueryList(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [queries][crate::model::HiveJob::queries]
    /// to hold a `QueryList`.
    ///
    /// Note that all the setters affecting `queries` are
    /// mutually exclusive.
    pub fn set_query_list<T: std::convert::Into<std::boxed::Box<crate::model::QueryList>>>(
        mut self,
        v: T,
    ) -> Self {
        self.queries =
            std::option::Option::Some(crate::model::hive_job::Queries::QueryList(v.into()));
        self
    }
}

impl wkt::message::Message for HiveJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.HiveJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HiveJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query_file_uri,
            __query_list,
            __continue_on_failure,
            __script_variables,
            __properties,
            __jar_file_uris,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HiveJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "queryFileUri" => Ok(__FieldTag::__query_file_uri),
                            "query_file_uri" => Ok(__FieldTag::__query_file_uri),
                            "queryList" => Ok(__FieldTag::__query_list),
                            "query_list" => Ok(__FieldTag::__query_list),
                            "continueOnFailure" => Ok(__FieldTag::__continue_on_failure),
                            "continue_on_failure" => Ok(__FieldTag::__continue_on_failure),
                            "scriptVariables" => Ok(__FieldTag::__script_variables),
                            "script_variables" => Ok(__FieldTag::__script_variables),
                            "properties" => Ok(__FieldTag::__properties),
                            "jarFileUris" => Ok(__FieldTag::__jar_file_uris),
                            "jar_file_uris" => Ok(__FieldTag::__jar_file_uris),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HiveJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HiveJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query_file_uri => {
                            if !fields.insert(__FieldTag::__query_file_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_file_uri",
                                ));
                            }
                            if result.queries.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `queries`, a oneof with full ID .google.cloud.dataproc.v1.HiveJob.query_file_uri, latest field was queryFileUri",
                                ));
                            }
                            result.queries = std::option::Option::Some(
                                crate::model::hive_job::Queries::QueryFileUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__query_list => {
                            if !fields.insert(__FieldTag::__query_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_list",
                                ));
                            }
                            if result.queries.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `queries`, a oneof with full ID .google.cloud.dataproc.v1.HiveJob.query_list, latest field was queryList",
                                ));
                            }
                            result.queries = std::option::Option::Some(
                                crate::model::hive_job::Queries::QueryList(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::QueryList>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__continue_on_failure => {
                            if !fields.insert(__FieldTag::__continue_on_failure) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for continue_on_failure",
                                ));
                            }
                            result.continue_on_failure = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__script_variables => {
                            if !fields.insert(__FieldTag::__script_variables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for script_variables",
                                ));
                            }
                            result.script_variables = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__jar_file_uris => {
                            if !fields.insert(__FieldTag::__jar_file_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jar_file_uris",
                                ));
                            }
                            result.jar_file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HiveJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.query_file_uri() {
            state.serialize_entry("queryFileUri", value)?;
        }
        if let Some(value) = self.query_list() {
            state.serialize_entry("queryList", value)?;
        }
        if !wkt::internal::is_default(&self.continue_on_failure) {
            state.serialize_entry("continueOnFailure", &self.continue_on_failure)?;
        }
        if !self.script_variables.is_empty() {
            state.serialize_entry("scriptVariables", &self.script_variables)?;
        }
        if !self.properties.is_empty() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if !self.jar_file_uris.is_empty() {
            state.serialize_entry("jarFileUris", &self.jar_file_uris)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [HiveJob].
pub mod hive_job {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The sequence of Hive queries to execute, specified as either
    /// an HCFS file URI or a list of queries.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Queries {
        /// The HCFS URI of the script that contains Hive queries.
        QueryFileUri(std::string::String),
        /// A list of queries.
        QueryList(std::boxed::Box<crate::model::QueryList>),
    }
}

/// A Dataproc job for running [Apache Spark
/// SQL](https://spark.apache.org/sql/) queries.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SparkSqlJob {
    /// Optional. Mapping of query variable names to values (equivalent to the
    /// Spark SQL command: SET `name="value";`).
    pub script_variables: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. A mapping of property names to values, used to configure
    /// Spark SQL's SparkConf. Properties that conflict with values set by the
    /// Dataproc API might be overwritten.
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. HCFS URIs of jar files to be added to the Spark CLASSPATH.
    pub jar_file_uris: std::vec::Vec<std::string::String>,

    /// Optional. The runtime log config for job execution.
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Required. The sequence of Spark SQL queries to execute, specified as
    /// either an HCFS file URI or as a list of queries.
    pub queries: std::option::Option<crate::model::spark_sql_job::Queries>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SparkSqlJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [script_variables][crate::model::SparkSqlJob::script_variables].
    pub fn set_script_variables<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.script_variables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [properties][crate::model::SparkSqlJob::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [jar_file_uris][crate::model::SparkSqlJob::jar_file_uris].
    pub fn set_jar_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jar_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [logging_config][crate::model::SparkSqlJob::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::SparkSqlJob::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [queries][crate::model::SparkSqlJob::queries].
    ///
    /// Note that all the setters affecting `queries` are mutually
    /// exclusive.
    pub fn set_queries<
        T: std::convert::Into<std::option::Option<crate::model::spark_sql_job::Queries>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.queries = v.into();
        self
    }

    /// The value of [queries][crate::model::SparkSqlJob::queries]
    /// if it holds a `QueryFileUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query_file_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.queries.as_ref().and_then(|v| match v {
            crate::model::spark_sql_job::Queries::QueryFileUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [queries][crate::model::SparkSqlJob::queries]
    /// to hold a `QueryFileUri`.
    ///
    /// Note that all the setters affecting `queries` are
    /// mutually exclusive.
    pub fn set_query_file_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.queries =
            std::option::Option::Some(crate::model::spark_sql_job::Queries::QueryFileUri(v.into()));
        self
    }

    /// The value of [queries][crate::model::SparkSqlJob::queries]
    /// if it holds a `QueryList`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query_list(&self) -> std::option::Option<&std::boxed::Box<crate::model::QueryList>> {
        #[allow(unreachable_patterns)]
        self.queries.as_ref().and_then(|v| match v {
            crate::model::spark_sql_job::Queries::QueryList(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [queries][crate::model::SparkSqlJob::queries]
    /// to hold a `QueryList`.
    ///
    /// Note that all the setters affecting `queries` are
    /// mutually exclusive.
    pub fn set_query_list<T: std::convert::Into<std::boxed::Box<crate::model::QueryList>>>(
        mut self,
        v: T,
    ) -> Self {
        self.queries =
            std::option::Option::Some(crate::model::spark_sql_job::Queries::QueryList(v.into()));
        self
    }
}

impl wkt::message::Message for SparkSqlJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SparkSqlJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SparkSqlJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query_file_uri,
            __query_list,
            __script_variables,
            __properties,
            __jar_file_uris,
            __logging_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SparkSqlJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "queryFileUri" => Ok(__FieldTag::__query_file_uri),
                            "query_file_uri" => Ok(__FieldTag::__query_file_uri),
                            "queryList" => Ok(__FieldTag::__query_list),
                            "query_list" => Ok(__FieldTag::__query_list),
                            "scriptVariables" => Ok(__FieldTag::__script_variables),
                            "script_variables" => Ok(__FieldTag::__script_variables),
                            "properties" => Ok(__FieldTag::__properties),
                            "jarFileUris" => Ok(__FieldTag::__jar_file_uris),
                            "jar_file_uris" => Ok(__FieldTag::__jar_file_uris),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SparkSqlJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SparkSqlJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query_file_uri => {
                            if !fields.insert(__FieldTag::__query_file_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_file_uri",
                                ));
                            }
                            if result.queries.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `queries`, a oneof with full ID .google.cloud.dataproc.v1.SparkSqlJob.query_file_uri, latest field was queryFileUri",
                                ));
                            }
                            result.queries = std::option::Option::Some(
                                crate::model::spark_sql_job::Queries::QueryFileUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__query_list => {
                            if !fields.insert(__FieldTag::__query_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_list",
                                ));
                            }
                            if result.queries.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `queries`, a oneof with full ID .google.cloud.dataproc.v1.SparkSqlJob.query_list, latest field was queryList",
                                ));
                            }
                            result.queries = std::option::Option::Some(
                                crate::model::spark_sql_job::Queries::QueryList(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::QueryList>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__script_variables => {
                            if !fields.insert(__FieldTag::__script_variables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for script_variables",
                                ));
                            }
                            result.script_variables = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__jar_file_uris => {
                            if !fields.insert(__FieldTag::__jar_file_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jar_file_uris",
                                ));
                            }
                            result.jar_file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SparkSqlJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.query_file_uri() {
            state.serialize_entry("queryFileUri", value)?;
        }
        if let Some(value) = self.query_list() {
            state.serialize_entry("queryList", value)?;
        }
        if !self.script_variables.is_empty() {
            state.serialize_entry("scriptVariables", &self.script_variables)?;
        }
        if !self.properties.is_empty() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if !self.jar_file_uris.is_empty() {
            state.serialize_entry("jarFileUris", &self.jar_file_uris)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SparkSqlJob].
pub mod spark_sql_job {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The sequence of Spark SQL queries to execute, specified as
    /// either an HCFS file URI or as a list of queries.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Queries {
        /// The HCFS URI of the script that contains SQL queries.
        QueryFileUri(std::string::String),
        /// A list of queries.
        QueryList(std::boxed::Box<crate::model::QueryList>),
    }
}

/// A Dataproc job for running [Apache Pig](https://pig.apache.org/)
/// queries on YARN.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PigJob {
    /// Optional. Whether to continue executing queries if a query fails.
    /// The default value is `false`. Setting to `true` can be useful when
    /// executing independent parallel queries.
    pub continue_on_failure: bool,

    /// Optional. Mapping of query variable names to values (equivalent to the Pig
    /// command: `name=[value]`).
    pub script_variables: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. A mapping of property names to values, used to configure Pig.
    /// Properties that conflict with values set by the Dataproc API might be
    /// overwritten. Can include properties set in `/etc/hadoop/conf/*-site.xml`,
    /// /etc/pig/conf/pig.properties, and classes in user code.
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. HCFS URIs of jar files to add to the CLASSPATH of
    /// the Pig Client and Hadoop MapReduce (MR) tasks. Can contain Pig UDFs.
    pub jar_file_uris: std::vec::Vec<std::string::String>,

    /// Optional. The runtime log config for job execution.
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Required. The sequence of Pig queries to execute, specified as an HCFS
    /// file URI or a list of queries.
    pub queries: std::option::Option<crate::model::pig_job::Queries>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PigJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [continue_on_failure][crate::model::PigJob::continue_on_failure].
    pub fn set_continue_on_failure<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.continue_on_failure = v.into();
        self
    }

    /// Sets the value of [script_variables][crate::model::PigJob::script_variables].
    pub fn set_script_variables<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.script_variables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [properties][crate::model::PigJob::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [jar_file_uris][crate::model::PigJob::jar_file_uris].
    pub fn set_jar_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jar_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [logging_config][crate::model::PigJob::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::PigJob::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [queries][crate::model::PigJob::queries].
    ///
    /// Note that all the setters affecting `queries` are mutually
    /// exclusive.
    pub fn set_queries<
        T: std::convert::Into<std::option::Option<crate::model::pig_job::Queries>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.queries = v.into();
        self
    }

    /// The value of [queries][crate::model::PigJob::queries]
    /// if it holds a `QueryFileUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query_file_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.queries.as_ref().and_then(|v| match v {
            crate::model::pig_job::Queries::QueryFileUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [queries][crate::model::PigJob::queries]
    /// to hold a `QueryFileUri`.
    ///
    /// Note that all the setters affecting `queries` are
    /// mutually exclusive.
    pub fn set_query_file_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.queries =
            std::option::Option::Some(crate::model::pig_job::Queries::QueryFileUri(v.into()));
        self
    }

    /// The value of [queries][crate::model::PigJob::queries]
    /// if it holds a `QueryList`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query_list(&self) -> std::option::Option<&std::boxed::Box<crate::model::QueryList>> {
        #[allow(unreachable_patterns)]
        self.queries.as_ref().and_then(|v| match v {
            crate::model::pig_job::Queries::QueryList(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [queries][crate::model::PigJob::queries]
    /// to hold a `QueryList`.
    ///
    /// Note that all the setters affecting `queries` are
    /// mutually exclusive.
    pub fn set_query_list<T: std::convert::Into<std::boxed::Box<crate::model::QueryList>>>(
        mut self,
        v: T,
    ) -> Self {
        self.queries =
            std::option::Option::Some(crate::model::pig_job::Queries::QueryList(v.into()));
        self
    }
}

impl wkt::message::Message for PigJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.PigJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PigJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query_file_uri,
            __query_list,
            __continue_on_failure,
            __script_variables,
            __properties,
            __jar_file_uris,
            __logging_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PigJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "queryFileUri" => Ok(__FieldTag::__query_file_uri),
                            "query_file_uri" => Ok(__FieldTag::__query_file_uri),
                            "queryList" => Ok(__FieldTag::__query_list),
                            "query_list" => Ok(__FieldTag::__query_list),
                            "continueOnFailure" => Ok(__FieldTag::__continue_on_failure),
                            "continue_on_failure" => Ok(__FieldTag::__continue_on_failure),
                            "scriptVariables" => Ok(__FieldTag::__script_variables),
                            "script_variables" => Ok(__FieldTag::__script_variables),
                            "properties" => Ok(__FieldTag::__properties),
                            "jarFileUris" => Ok(__FieldTag::__jar_file_uris),
                            "jar_file_uris" => Ok(__FieldTag::__jar_file_uris),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PigJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PigJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query_file_uri => {
                            if !fields.insert(__FieldTag::__query_file_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_file_uri",
                                ));
                            }
                            if result.queries.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `queries`, a oneof with full ID .google.cloud.dataproc.v1.PigJob.query_file_uri, latest field was queryFileUri",
                                ));
                            }
                            result.queries = std::option::Option::Some(
                                crate::model::pig_job::Queries::QueryFileUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__query_list => {
                            if !fields.insert(__FieldTag::__query_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_list",
                                ));
                            }
                            if result.queries.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `queries`, a oneof with full ID .google.cloud.dataproc.v1.PigJob.query_list, latest field was queryList",
                                ));
                            }
                            result.queries = std::option::Option::Some(
                                crate::model::pig_job::Queries::QueryList(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::QueryList>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__continue_on_failure => {
                            if !fields.insert(__FieldTag::__continue_on_failure) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for continue_on_failure",
                                ));
                            }
                            result.continue_on_failure = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__script_variables => {
                            if !fields.insert(__FieldTag::__script_variables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for script_variables",
                                ));
                            }
                            result.script_variables = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__jar_file_uris => {
                            if !fields.insert(__FieldTag::__jar_file_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jar_file_uris",
                                ));
                            }
                            result.jar_file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PigJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.query_file_uri() {
            state.serialize_entry("queryFileUri", value)?;
        }
        if let Some(value) = self.query_list() {
            state.serialize_entry("queryList", value)?;
        }
        if !wkt::internal::is_default(&self.continue_on_failure) {
            state.serialize_entry("continueOnFailure", &self.continue_on_failure)?;
        }
        if !self.script_variables.is_empty() {
            state.serialize_entry("scriptVariables", &self.script_variables)?;
        }
        if !self.properties.is_empty() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if !self.jar_file_uris.is_empty() {
            state.serialize_entry("jarFileUris", &self.jar_file_uris)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [PigJob].
pub mod pig_job {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The sequence of Pig queries to execute, specified as an HCFS
    /// file URI or a list of queries.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Queries {
        /// The HCFS URI of the script that contains the Pig queries.
        QueryFileUri(std::string::String),
        /// A list of queries.
        QueryList(std::boxed::Box<crate::model::QueryList>),
    }
}

/// A Dataproc job for running
/// [Apache SparkR](https://spark.apache.org/docs/latest/sparkr.html)
/// applications on YARN.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SparkRJob {
    /// Required. The HCFS URI of the main R file to use as the driver.
    /// Must be a .R file.
    pub main_r_file_uri: std::string::String,

    /// Optional. The arguments to pass to the driver.  Do not include arguments,
    /// such as `--conf`, that can be set as job properties, since a collision may
    /// occur that causes an incorrect job submission.
    pub args: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of files to be placed in the working directory of
    /// each executor. Useful for naively parallel tasks.
    pub file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of archives to be extracted into the working directory
    /// of each executor. Supported file types:
    /// .jar, .tar, .tar.gz, .tgz, and .zip.
    pub archive_uris: std::vec::Vec<std::string::String>,

    /// Optional. A mapping of property names to values, used to configure SparkR.
    /// Properties that conflict with values set by the Dataproc API might be
    /// overwritten. Can include properties set in
    /// /etc/spark/conf/spark-defaults.conf and classes in user code.
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The runtime log config for job execution.
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SparkRJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [main_r_file_uri][crate::model::SparkRJob::main_r_file_uri].
    pub fn set_main_r_file_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.main_r_file_uri = v.into();
        self
    }

    /// Sets the value of [args][crate::model::SparkRJob::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_uris][crate::model::SparkRJob::file_uris].
    pub fn set_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [archive_uris][crate::model::SparkRJob::archive_uris].
    pub fn set_archive_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.archive_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [properties][crate::model::SparkRJob::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [logging_config][crate::model::SparkRJob::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::SparkRJob::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SparkRJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SparkRJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SparkRJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __main_r_file_uri,
            __args,
            __file_uris,
            __archive_uris,
            __properties,
            __logging_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SparkRJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mainRFileUri" => Ok(__FieldTag::__main_r_file_uri),
                            "main_r_file_uri" => Ok(__FieldTag::__main_r_file_uri),
                            "args" => Ok(__FieldTag::__args),
                            "fileUris" => Ok(__FieldTag::__file_uris),
                            "file_uris" => Ok(__FieldTag::__file_uris),
                            "archiveUris" => Ok(__FieldTag::__archive_uris),
                            "archive_uris" => Ok(__FieldTag::__archive_uris),
                            "properties" => Ok(__FieldTag::__properties),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SparkRJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SparkRJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__main_r_file_uri => {
                            if !fields.insert(__FieldTag::__main_r_file_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for main_r_file_uri",
                                ));
                            }
                            result.main_r_file_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__args => {
                            if !fields.insert(__FieldTag::__args) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for args",
                                ));
                            }
                            result.args = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__file_uris => {
                            if !fields.insert(__FieldTag::__file_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_uris",
                                ));
                            }
                            result.file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__archive_uris => {
                            if !fields.insert(__FieldTag::__archive_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for archive_uris",
                                ));
                            }
                            result.archive_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SparkRJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.main_r_file_uri.is_empty() {
            state.serialize_entry("mainRFileUri", &self.main_r_file_uri)?;
        }
        if !self.args.is_empty() {
            state.serialize_entry("args", &self.args)?;
        }
        if !self.file_uris.is_empty() {
            state.serialize_entry("fileUris", &self.file_uris)?;
        }
        if !self.archive_uris.is_empty() {
            state.serialize_entry("archiveUris", &self.archive_uris)?;
        }
        if !self.properties.is_empty() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A Dataproc job for running [Presto](https://prestosql.io/) queries.
/// **IMPORTANT**: The [Dataproc Presto Optional
/// Component](https://cloud.google.com/dataproc/docs/concepts/components/presto)
/// must be enabled when the cluster is created to submit a Presto job to the
/// cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PrestoJob {
    /// Optional. Whether to continue executing queries if a query fails.
    /// The default value is `false`. Setting to `true` can be useful when
    /// executing independent parallel queries.
    pub continue_on_failure: bool,

    /// Optional. The format in which query output will be displayed. See the
    /// Presto documentation for supported output formats
    pub output_format: std::string::String,

    /// Optional. Presto client tags to attach to this query
    pub client_tags: std::vec::Vec<std::string::String>,

    /// Optional. A mapping of property names to values. Used to set Presto
    /// [session properties](https://prestodb.io/docs/current/sql/set-session.html)
    /// Equivalent to using the --session flag in the Presto CLI
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The runtime log config for job execution.
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Required. The sequence of Presto queries to execute, specified as
    /// either an HCFS file URI or as a list of queries.
    pub queries: std::option::Option<crate::model::presto_job::Queries>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrestoJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [continue_on_failure][crate::model::PrestoJob::continue_on_failure].
    pub fn set_continue_on_failure<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.continue_on_failure = v.into();
        self
    }

    /// Sets the value of [output_format][crate::model::PrestoJob::output_format].
    pub fn set_output_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output_format = v.into();
        self
    }

    /// Sets the value of [client_tags][crate::model::PrestoJob::client_tags].
    pub fn set_client_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.client_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [properties][crate::model::PrestoJob::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [logging_config][crate::model::PrestoJob::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::PrestoJob::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [queries][crate::model::PrestoJob::queries].
    ///
    /// Note that all the setters affecting `queries` are mutually
    /// exclusive.
    pub fn set_queries<
        T: std::convert::Into<std::option::Option<crate::model::presto_job::Queries>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.queries = v.into();
        self
    }

    /// The value of [queries][crate::model::PrestoJob::queries]
    /// if it holds a `QueryFileUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query_file_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.queries.as_ref().and_then(|v| match v {
            crate::model::presto_job::Queries::QueryFileUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [queries][crate::model::PrestoJob::queries]
    /// to hold a `QueryFileUri`.
    ///
    /// Note that all the setters affecting `queries` are
    /// mutually exclusive.
    pub fn set_query_file_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.queries =
            std::option::Option::Some(crate::model::presto_job::Queries::QueryFileUri(v.into()));
        self
    }

    /// The value of [queries][crate::model::PrestoJob::queries]
    /// if it holds a `QueryList`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query_list(&self) -> std::option::Option<&std::boxed::Box<crate::model::QueryList>> {
        #[allow(unreachable_patterns)]
        self.queries.as_ref().and_then(|v| match v {
            crate::model::presto_job::Queries::QueryList(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [queries][crate::model::PrestoJob::queries]
    /// to hold a `QueryList`.
    ///
    /// Note that all the setters affecting `queries` are
    /// mutually exclusive.
    pub fn set_query_list<T: std::convert::Into<std::boxed::Box<crate::model::QueryList>>>(
        mut self,
        v: T,
    ) -> Self {
        self.queries =
            std::option::Option::Some(crate::model::presto_job::Queries::QueryList(v.into()));
        self
    }
}

impl wkt::message::Message for PrestoJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.PrestoJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PrestoJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query_file_uri,
            __query_list,
            __continue_on_failure,
            __output_format,
            __client_tags,
            __properties,
            __logging_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrestoJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "queryFileUri" => Ok(__FieldTag::__query_file_uri),
                            "query_file_uri" => Ok(__FieldTag::__query_file_uri),
                            "queryList" => Ok(__FieldTag::__query_list),
                            "query_list" => Ok(__FieldTag::__query_list),
                            "continueOnFailure" => Ok(__FieldTag::__continue_on_failure),
                            "continue_on_failure" => Ok(__FieldTag::__continue_on_failure),
                            "outputFormat" => Ok(__FieldTag::__output_format),
                            "output_format" => Ok(__FieldTag::__output_format),
                            "clientTags" => Ok(__FieldTag::__client_tags),
                            "client_tags" => Ok(__FieldTag::__client_tags),
                            "properties" => Ok(__FieldTag::__properties),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PrestoJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrestoJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query_file_uri => {
                            if !fields.insert(__FieldTag::__query_file_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_file_uri",
                                ));
                            }
                            if result.queries.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `queries`, a oneof with full ID .google.cloud.dataproc.v1.PrestoJob.query_file_uri, latest field was queryFileUri",
                                ));
                            }
                            result.queries = std::option::Option::Some(
                                crate::model::presto_job::Queries::QueryFileUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__query_list => {
                            if !fields.insert(__FieldTag::__query_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_list",
                                ));
                            }
                            if result.queries.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `queries`, a oneof with full ID .google.cloud.dataproc.v1.PrestoJob.query_list, latest field was queryList",
                                ));
                            }
                            result.queries = std::option::Option::Some(
                                crate::model::presto_job::Queries::QueryList(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::QueryList>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__continue_on_failure => {
                            if !fields.insert(__FieldTag::__continue_on_failure) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for continue_on_failure",
                                ));
                            }
                            result.continue_on_failure = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__output_format => {
                            if !fields.insert(__FieldTag::__output_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_format",
                                ));
                            }
                            result.output_format = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_tags => {
                            if !fields.insert(__FieldTag::__client_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_tags",
                                ));
                            }
                            result.client_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PrestoJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.query_file_uri() {
            state.serialize_entry("queryFileUri", value)?;
        }
        if let Some(value) = self.query_list() {
            state.serialize_entry("queryList", value)?;
        }
        if !wkt::internal::is_default(&self.continue_on_failure) {
            state.serialize_entry("continueOnFailure", &self.continue_on_failure)?;
        }
        if !self.output_format.is_empty() {
            state.serialize_entry("outputFormat", &self.output_format)?;
        }
        if !self.client_tags.is_empty() {
            state.serialize_entry("clientTags", &self.client_tags)?;
        }
        if !self.properties.is_empty() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [PrestoJob].
pub mod presto_job {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The sequence of Presto queries to execute, specified as
    /// either an HCFS file URI or as a list of queries.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Queries {
        /// The HCFS URI of the script that contains SQL queries.
        QueryFileUri(std::string::String),
        /// A list of queries.
        QueryList(std::boxed::Box<crate::model::QueryList>),
    }
}

/// A Dataproc job for running [Trino](https://trino.io/) queries.
/// **IMPORTANT**: The [Dataproc Trino Optional
/// Component](https://cloud.google.com/dataproc/docs/concepts/components/trino)
/// must be enabled when the cluster is created to submit a Trino job to the
/// cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TrinoJob {
    /// Optional. Whether to continue executing queries if a query fails.
    /// The default value is `false`. Setting to `true` can be useful when
    /// executing independent parallel queries.
    pub continue_on_failure: bool,

    /// Optional. The format in which query output will be displayed. See the
    /// Trino documentation for supported output formats
    pub output_format: std::string::String,

    /// Optional. Trino client tags to attach to this query
    pub client_tags: std::vec::Vec<std::string::String>,

    /// Optional. A mapping of property names to values. Used to set Trino
    /// [session properties](https://trino.io/docs/current/sql/set-session.html)
    /// Equivalent to using the --session flag in the Trino CLI
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The runtime log config for job execution.
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Required. The sequence of Trino queries to execute, specified as
    /// either an HCFS file URI or as a list of queries.
    pub queries: std::option::Option<crate::model::trino_job::Queries>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TrinoJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [continue_on_failure][crate::model::TrinoJob::continue_on_failure].
    pub fn set_continue_on_failure<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.continue_on_failure = v.into();
        self
    }

    /// Sets the value of [output_format][crate::model::TrinoJob::output_format].
    pub fn set_output_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output_format = v.into();
        self
    }

    /// Sets the value of [client_tags][crate::model::TrinoJob::client_tags].
    pub fn set_client_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.client_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [properties][crate::model::TrinoJob::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [logging_config][crate::model::TrinoJob::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::TrinoJob::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [queries][crate::model::TrinoJob::queries].
    ///
    /// Note that all the setters affecting `queries` are mutually
    /// exclusive.
    pub fn set_queries<
        T: std::convert::Into<std::option::Option<crate::model::trino_job::Queries>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.queries = v.into();
        self
    }

    /// The value of [queries][crate::model::TrinoJob::queries]
    /// if it holds a `QueryFileUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query_file_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.queries.as_ref().and_then(|v| match v {
            crate::model::trino_job::Queries::QueryFileUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [queries][crate::model::TrinoJob::queries]
    /// to hold a `QueryFileUri`.
    ///
    /// Note that all the setters affecting `queries` are
    /// mutually exclusive.
    pub fn set_query_file_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.queries =
            std::option::Option::Some(crate::model::trino_job::Queries::QueryFileUri(v.into()));
        self
    }

    /// The value of [queries][crate::model::TrinoJob::queries]
    /// if it holds a `QueryList`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query_list(&self) -> std::option::Option<&std::boxed::Box<crate::model::QueryList>> {
        #[allow(unreachable_patterns)]
        self.queries.as_ref().and_then(|v| match v {
            crate::model::trino_job::Queries::QueryList(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [queries][crate::model::TrinoJob::queries]
    /// to hold a `QueryList`.
    ///
    /// Note that all the setters affecting `queries` are
    /// mutually exclusive.
    pub fn set_query_list<T: std::convert::Into<std::boxed::Box<crate::model::QueryList>>>(
        mut self,
        v: T,
    ) -> Self {
        self.queries =
            std::option::Option::Some(crate::model::trino_job::Queries::QueryList(v.into()));
        self
    }
}

impl wkt::message::Message for TrinoJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.TrinoJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TrinoJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query_file_uri,
            __query_list,
            __continue_on_failure,
            __output_format,
            __client_tags,
            __properties,
            __logging_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TrinoJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "queryFileUri" => Ok(__FieldTag::__query_file_uri),
                            "query_file_uri" => Ok(__FieldTag::__query_file_uri),
                            "queryList" => Ok(__FieldTag::__query_list),
                            "query_list" => Ok(__FieldTag::__query_list),
                            "continueOnFailure" => Ok(__FieldTag::__continue_on_failure),
                            "continue_on_failure" => Ok(__FieldTag::__continue_on_failure),
                            "outputFormat" => Ok(__FieldTag::__output_format),
                            "output_format" => Ok(__FieldTag::__output_format),
                            "clientTags" => Ok(__FieldTag::__client_tags),
                            "client_tags" => Ok(__FieldTag::__client_tags),
                            "properties" => Ok(__FieldTag::__properties),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TrinoJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TrinoJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query_file_uri => {
                            if !fields.insert(__FieldTag::__query_file_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_file_uri",
                                ));
                            }
                            if result.queries.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `queries`, a oneof with full ID .google.cloud.dataproc.v1.TrinoJob.query_file_uri, latest field was queryFileUri",
                                ));
                            }
                            result.queries = std::option::Option::Some(
                                crate::model::trino_job::Queries::QueryFileUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__query_list => {
                            if !fields.insert(__FieldTag::__query_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_list",
                                ));
                            }
                            if result.queries.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `queries`, a oneof with full ID .google.cloud.dataproc.v1.TrinoJob.query_list, latest field was queryList",
                                ));
                            }
                            result.queries = std::option::Option::Some(
                                crate::model::trino_job::Queries::QueryList(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::QueryList>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__continue_on_failure => {
                            if !fields.insert(__FieldTag::__continue_on_failure) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for continue_on_failure",
                                ));
                            }
                            result.continue_on_failure = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__output_format => {
                            if !fields.insert(__FieldTag::__output_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_format",
                                ));
                            }
                            result.output_format = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_tags => {
                            if !fields.insert(__FieldTag::__client_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_tags",
                                ));
                            }
                            result.client_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TrinoJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.query_file_uri() {
            state.serialize_entry("queryFileUri", value)?;
        }
        if let Some(value) = self.query_list() {
            state.serialize_entry("queryList", value)?;
        }
        if !wkt::internal::is_default(&self.continue_on_failure) {
            state.serialize_entry("continueOnFailure", &self.continue_on_failure)?;
        }
        if !self.output_format.is_empty() {
            state.serialize_entry("outputFormat", &self.output_format)?;
        }
        if !self.client_tags.is_empty() {
            state.serialize_entry("clientTags", &self.client_tags)?;
        }
        if !self.properties.is_empty() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TrinoJob].
pub mod trino_job {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The sequence of Trino queries to execute, specified as
    /// either an HCFS file URI or as a list of queries.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Queries {
        /// The HCFS URI of the script that contains SQL queries.
        QueryFileUri(std::string::String),
        /// A list of queries.
        QueryList(std::boxed::Box<crate::model::QueryList>),
    }
}

/// A Dataproc job for running Apache Flink applications on YARN.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FlinkJob {
    /// Optional. The arguments to pass to the driver. Do not include arguments,
    /// such as `--conf`, that can be set as job properties, since a collision
    /// might occur that causes an incorrect job submission.
    pub args: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of jar files to add to the CLASSPATHs of the
    /// Flink driver and tasks.
    pub jar_file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URI of the savepoint, which contains the last saved progress
    /// for starting the current job.
    pub savepoint_uri: std::string::String,

    /// Optional. A mapping of property names to values, used to configure Flink.
    /// Properties that conflict with values set by the Dataproc API might be
    /// overwritten. Can include properties set in
    /// `/etc/flink/conf/flink-defaults.conf` and classes in user code.
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The runtime log config for job execution.
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Required. The specification of the main method to call to drive the job.
    /// Specify either the jar file that contains the main class or the main class
    /// name. To pass both a main jar and a main class in the jar, add the jar to
    /// [jarFileUris][google.cloud.dataproc.v1.FlinkJob.jar_file_uris], and then
    /// specify the main class name in
    /// [mainClass][google.cloud.dataproc.v1.FlinkJob.main_class].
    ///
    /// [google.cloud.dataproc.v1.FlinkJob.jar_file_uris]: crate::model::FlinkJob::jar_file_uris
    /// [google.cloud.dataproc.v1.FlinkJob.main_class]: crate::model::FlinkJob::driver
    pub driver: std::option::Option<crate::model::flink_job::Driver>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FlinkJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [args][crate::model::FlinkJob::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [jar_file_uris][crate::model::FlinkJob::jar_file_uris].
    pub fn set_jar_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jar_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [savepoint_uri][crate::model::FlinkJob::savepoint_uri].
    pub fn set_savepoint_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.savepoint_uri = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::FlinkJob::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [logging_config][crate::model::FlinkJob::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::FlinkJob::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [driver][crate::model::FlinkJob::driver].
    ///
    /// Note that all the setters affecting `driver` are mutually
    /// exclusive.
    pub fn set_driver<
        T: std::convert::Into<std::option::Option<crate::model::flink_job::Driver>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.driver = v.into();
        self
    }

    /// The value of [driver][crate::model::FlinkJob::driver]
    /// if it holds a `MainJarFileUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn main_jar_file_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.driver.as_ref().and_then(|v| match v {
            crate::model::flink_job::Driver::MainJarFileUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [driver][crate::model::FlinkJob::driver]
    /// to hold a `MainJarFileUri`.
    ///
    /// Note that all the setters affecting `driver` are
    /// mutually exclusive.
    pub fn set_main_jar_file_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.driver =
            std::option::Option::Some(crate::model::flink_job::Driver::MainJarFileUri(v.into()));
        self
    }

    /// The value of [driver][crate::model::FlinkJob::driver]
    /// if it holds a `MainClass`, `None` if the field is not set or
    /// holds a different branch.
    pub fn main_class(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.driver.as_ref().and_then(|v| match v {
            crate::model::flink_job::Driver::MainClass(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [driver][crate::model::FlinkJob::driver]
    /// to hold a `MainClass`.
    ///
    /// Note that all the setters affecting `driver` are
    /// mutually exclusive.
    pub fn set_main_class<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.driver =
            std::option::Option::Some(crate::model::flink_job::Driver::MainClass(v.into()));
        self
    }
}

impl wkt::message::Message for FlinkJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.FlinkJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FlinkJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __main_jar_file_uri,
            __main_class,
            __args,
            __jar_file_uris,
            __savepoint_uri,
            __properties,
            __logging_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FlinkJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mainJarFileUri" => Ok(__FieldTag::__main_jar_file_uri),
                            "main_jar_file_uri" => Ok(__FieldTag::__main_jar_file_uri),
                            "mainClass" => Ok(__FieldTag::__main_class),
                            "main_class" => Ok(__FieldTag::__main_class),
                            "args" => Ok(__FieldTag::__args),
                            "jarFileUris" => Ok(__FieldTag::__jar_file_uris),
                            "jar_file_uris" => Ok(__FieldTag::__jar_file_uris),
                            "savepointUri" => Ok(__FieldTag::__savepoint_uri),
                            "savepoint_uri" => Ok(__FieldTag::__savepoint_uri),
                            "properties" => Ok(__FieldTag::__properties),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FlinkJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FlinkJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__main_jar_file_uri => {
                            if !fields.insert(__FieldTag::__main_jar_file_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for main_jar_file_uri",
                                ));
                            }
                            if result.driver.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `driver`, a oneof with full ID .google.cloud.dataproc.v1.FlinkJob.main_jar_file_uri, latest field was mainJarFileUri",
                                ));
                            }
                            result.driver = std::option::Option::Some(
                                crate::model::flink_job::Driver::MainJarFileUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__main_class => {
                            if !fields.insert(__FieldTag::__main_class) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for main_class",
                                ));
                            }
                            if result.driver.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `driver`, a oneof with full ID .google.cloud.dataproc.v1.FlinkJob.main_class, latest field was mainClass",
                                ));
                            }
                            result.driver = std::option::Option::Some(
                                crate::model::flink_job::Driver::MainClass(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__args => {
                            if !fields.insert(__FieldTag::__args) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for args",
                                ));
                            }
                            result.args = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__jar_file_uris => {
                            if !fields.insert(__FieldTag::__jar_file_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jar_file_uris",
                                ));
                            }
                            result.jar_file_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__savepoint_uri => {
                            if !fields.insert(__FieldTag::__savepoint_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for savepoint_uri",
                                ));
                            }
                            result.savepoint_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FlinkJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.main_jar_file_uri() {
            state.serialize_entry("mainJarFileUri", value)?;
        }
        if let Some(value) = self.main_class() {
            state.serialize_entry("mainClass", value)?;
        }
        if !self.args.is_empty() {
            state.serialize_entry("args", &self.args)?;
        }
        if !self.jar_file_uris.is_empty() {
            state.serialize_entry("jarFileUris", &self.jar_file_uris)?;
        }
        if !self.savepoint_uri.is_empty() {
            state.serialize_entry("savepointUri", &self.savepoint_uri)?;
        }
        if !self.properties.is_empty() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [FlinkJob].
pub mod flink_job {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The specification of the main method to call to drive the job.
    /// Specify either the jar file that contains the main class or the main class
    /// name. To pass both a main jar and a main class in the jar, add the jar to
    /// [jarFileUris][google.cloud.dataproc.v1.FlinkJob.jar_file_uris], and then
    /// specify the main class name in
    /// [mainClass][google.cloud.dataproc.v1.FlinkJob.main_class].
    ///
    /// [google.cloud.dataproc.v1.FlinkJob.jar_file_uris]: crate::model::FlinkJob::jar_file_uris
    /// [google.cloud.dataproc.v1.FlinkJob.main_class]: crate::model::FlinkJob::driver
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Driver {
        /// The HCFS URI of the jar file that contains the main class.
        MainJarFileUri(std::string::String),
        /// The name of the driver's main class. The jar file that contains the class
        /// must be in the default CLASSPATH or specified in
        /// [jarFileUris][google.cloud.dataproc.v1.FlinkJob.jar_file_uris].
        ///
        /// [google.cloud.dataproc.v1.FlinkJob.jar_file_uris]: crate::model::FlinkJob::jar_file_uris
        MainClass(std::string::String),
    }
}

/// Dataproc job config.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct JobPlacement {
    /// Required. The name of the cluster where the job will be submitted.
    pub cluster_name: std::string::String,

    /// Output only. A cluster UUID generated by the Dataproc service when
    /// the job is submitted.
    pub cluster_uuid: std::string::String,

    /// Optional. Cluster labels to identify a cluster where the job will be
    /// submitted.
    pub cluster_labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JobPlacement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_name][crate::model::JobPlacement::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [cluster_uuid][crate::model::JobPlacement::cluster_uuid].
    pub fn set_cluster_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uuid = v.into();
        self
    }

    /// Sets the value of [cluster_labels][crate::model::JobPlacement::cluster_labels].
    pub fn set_cluster_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.cluster_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for JobPlacement {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.JobPlacement"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for JobPlacement {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster_name,
            __cluster_uuid,
            __cluster_labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobPlacement")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusterName" => Ok(__FieldTag::__cluster_name),
                            "cluster_name" => Ok(__FieldTag::__cluster_name),
                            "clusterUuid" => Ok(__FieldTag::__cluster_uuid),
                            "cluster_uuid" => Ok(__FieldTag::__cluster_uuid),
                            "clusterLabels" => Ok(__FieldTag::__cluster_labels),
                            "cluster_labels" => Ok(__FieldTag::__cluster_labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = JobPlacement;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobPlacement")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster_name => {
                            if !fields.insert(__FieldTag::__cluster_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_name",
                                ));
                            }
                            result.cluster_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_uuid => {
                            if !fields.insert(__FieldTag::__cluster_uuid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_uuid",
                                ));
                            }
                            result.cluster_uuid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_labels => {
                            if !fields.insert(__FieldTag::__cluster_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_labels",
                                ));
                            }
                            result.cluster_labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for JobPlacement {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cluster_name.is_empty() {
            state.serialize_entry("clusterName", &self.cluster_name)?;
        }
        if !self.cluster_uuid.is_empty() {
            state.serialize_entry("clusterUuid", &self.cluster_uuid)?;
        }
        if !self.cluster_labels.is_empty() {
            state.serialize_entry("clusterLabels", &self.cluster_labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Dataproc job status.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct JobStatus {
    /// Output only. A state message specifying the overall job state.
    pub state: crate::model::job_status::State,

    /// Optional. Output only. Job state details, such as an error
    /// description if the state is `ERROR`.
    pub details: std::string::String,

    /// Output only. The time when this state was entered.
    pub state_start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Additional state information, which includes
    /// status reported by the agent.
    pub substate: crate::model::job_status::Substate,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JobStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::JobStatus::state].
    pub fn set_state<T: std::convert::Into<crate::model::job_status::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [details][crate::model::JobStatus::details].
    pub fn set_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.details = v.into();
        self
    }

    /// Sets the value of [state_start_time][crate::model::JobStatus::state_start_time].
    pub fn set_state_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_start_time][crate::model::JobStatus::state_start_time].
    pub fn set_or_clear_state_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [substate][crate::model::JobStatus::substate].
    pub fn set_substate<T: std::convert::Into<crate::model::job_status::Substate>>(
        mut self,
        v: T,
    ) -> Self {
        self.substate = v.into();
        self
    }
}

impl wkt::message::Message for JobStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.JobStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for JobStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __details,
            __state_start_time,
            __substate,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "details" => Ok(__FieldTag::__details),
                            "stateStartTime" => Ok(__FieldTag::__state_start_time),
                            "state_start_time" => Ok(__FieldTag::__state_start_time),
                            "substate" => Ok(__FieldTag::__substate),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = JobStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::job_status::State>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_start_time => {
                            if !fields.insert(__FieldTag::__state_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_start_time",
                                ));
                            }
                            result.state_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__substate => {
                            if !fields.insert(__FieldTag::__substate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for substate",
                                ));
                            }
                            result.substate = map.next_value::<std::option::Option<crate::model::job_status::Substate>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for JobStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.details.is_empty() {
            state.serialize_entry("details", &self.details)?;
        }
        if self.state_start_time.is_some() {
            state.serialize_entry("stateStartTime", &self.state_start_time)?;
        }
        if !wkt::internal::is_default(&self.substate) {
            state.serialize_entry("substate", &self.substate)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [JobStatus].
pub mod job_status {
    #[allow(unused_imports)]
    use super::*;

    /// The job state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The job state is unknown.
        Unspecified,
        /// The job is pending; it has been submitted, but is not yet running.
        Pending,
        /// Job has been received by the service and completed initial setup;
        /// it will soon be submitted to the cluster.
        SetupDone,
        /// The job is running on the cluster.
        Running,
        /// A CancelJob request has been received, but is pending.
        CancelPending,
        /// Transient in-flight resources have been canceled, and the request to
        /// cancel the running job has been issued to the cluster.
        CancelStarted,
        /// The job cancellation was successful.
        Cancelled,
        /// The job has completed successfully.
        Done,
        /// The job has completed, but encountered an error.
        Error,
        /// Job attempt has failed. The detail field contains failure details for
        /// this attempt.
        ///
        /// Applies to restartable jobs only.
        AttemptFailure,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::SetupDone => std::option::Option::Some(8),
                Self::Running => std::option::Option::Some(2),
                Self::CancelPending => std::option::Option::Some(3),
                Self::CancelStarted => std::option::Option::Some(7),
                Self::Cancelled => std::option::Option::Some(4),
                Self::Done => std::option::Option::Some(5),
                Self::Error => std::option::Option::Some(6),
                Self::AttemptFailure => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::SetupDone => std::option::Option::Some("SETUP_DONE"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::CancelPending => std::option::Option::Some("CANCEL_PENDING"),
                Self::CancelStarted => std::option::Option::Some("CANCEL_STARTED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::AttemptFailure => std::option::Option::Some("ATTEMPT_FAILURE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Running,
                3 => Self::CancelPending,
                4 => Self::Cancelled,
                5 => Self::Done,
                6 => Self::Error,
                7 => Self::CancelStarted,
                8 => Self::SetupDone,
                9 => Self::AttemptFailure,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "SETUP_DONE" => Self::SetupDone,
                "RUNNING" => Self::Running,
                "CANCEL_PENDING" => Self::CancelPending,
                "CANCEL_STARTED" => Self::CancelStarted,
                "CANCELLED" => Self::Cancelled,
                "DONE" => Self::Done,
                "ERROR" => Self::Error,
                "ATTEMPT_FAILURE" => Self::AttemptFailure,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::SetupDone => serializer.serialize_i32(8),
                Self::Running => serializer.serialize_i32(2),
                Self::CancelPending => serializer.serialize_i32(3),
                Self::CancelStarted => serializer.serialize_i32(7),
                Self::Cancelled => serializer.serialize_i32(4),
                Self::Done => serializer.serialize_i32(5),
                Self::Error => serializer.serialize_i32(6),
                Self::AttemptFailure => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataproc.v1.JobStatus.State",
            ))
        }
    }

    /// The job substate.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Substate {
        /// The job substate is unknown.
        Unspecified,
        /// The Job is submitted to the agent.
        ///
        /// Applies to RUNNING state.
        Submitted,
        /// The Job has been received and is awaiting execution (it might be waiting
        /// for a condition to be met). See the "details" field for the reason for
        /// the delay.
        ///
        /// Applies to RUNNING state.
        Queued,
        /// The agent-reported status is out of date, which can be caused by a
        /// loss of communication between the agent and Dataproc. If the
        /// agent does not send a timely update, the job will fail.
        ///
        /// Applies to RUNNING state.
        StaleStatus,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Substate::value] or
        /// [Substate::name].
        UnknownValue(substate::UnknownValue),
    }

    #[doc(hidden)]
    pub mod substate {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Substate {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Submitted => std::option::Option::Some(1),
                Self::Queued => std::option::Option::Some(2),
                Self::StaleStatus => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::Submitted => std::option::Option::Some("SUBMITTED"),
                Self::Queued => std::option::Option::Some("QUEUED"),
                Self::StaleStatus => std::option::Option::Some("STALE_STATUS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Substate {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Substate {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Substate {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Submitted,
                2 => Self::Queued,
                3 => Self::StaleStatus,
                _ => Self::UnknownValue(substate::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Substate {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "SUBMITTED" => Self::Submitted,
                "QUEUED" => Self::Queued,
                "STALE_STATUS" => Self::StaleStatus,
                _ => Self::UnknownValue(substate::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Substate {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Submitted => serializer.serialize_i32(1),
                Self::Queued => serializer.serialize_i32(2),
                Self::StaleStatus => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Substate {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Substate>::new(
                ".google.cloud.dataproc.v1.JobStatus.Substate",
            ))
        }
    }
}

/// Encapsulates the full scoping used to reference a job.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct JobReference {
    /// Optional. The ID of the Google Cloud Platform project that the job belongs
    /// to. If specified, must match the request project ID.
    pub project_id: std::string::String,

    /// Optional. The job ID, which must be unique within the project.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), or hyphens (-). The maximum length is 100 characters.
    ///
    /// If not specified by the caller, the job ID will be provided by the server.
    pub job_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JobReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::JobReference::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::JobReference::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }
}

impl wkt::message::Message for JobReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.JobReference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for JobReference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __job_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobReference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "jobId" => Ok(__FieldTag::__job_id),
                            "job_id" => Ok(__FieldTag::__job_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = JobReference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobReference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_id => {
                            if !fields.insert(__FieldTag::__job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_id",
                                ));
                            }
                            result.job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for JobReference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.job_id.is_empty() {
            state.serialize_entry("jobId", &self.job_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A YARN application created by a job. Application information is a subset of
/// \<code\>org.apache.hadoop.yarn.proto.YarnProtos.ApplicationReportProto\</code\>.
///
/// **Beta Feature**: This report is available for testing purposes only. It may
/// be changed before final release.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct YarnApplication {
    /// Required. The application name.
    pub name: std::string::String,

    /// Required. The application state.
    pub state: crate::model::yarn_application::State,

    /// Required. The numerical progress of the application, from 1 to 100.
    pub progress: f32,

    /// Optional. The HTTP URL of the ApplicationMaster, HistoryServer, or
    /// TimelineServer that provides application-specific information. The URL uses
    /// the internal hostname, and requires a proxy server for resolution and,
    /// possibly, access.
    pub tracking_url: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl YarnApplication {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::YarnApplication::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::YarnApplication::state].
    pub fn set_state<T: std::convert::Into<crate::model::yarn_application::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [progress][crate::model::YarnApplication::progress].
    pub fn set_progress<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.progress = v.into();
        self
    }

    /// Sets the value of [tracking_url][crate::model::YarnApplication::tracking_url].
    pub fn set_tracking_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tracking_url = v.into();
        self
    }
}

impl wkt::message::Message for YarnApplication {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.YarnApplication"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for YarnApplication {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __state,
            __progress,
            __tracking_url,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for YarnApplication")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "state" => Ok(__FieldTag::__state),
                            "progress" => Ok(__FieldTag::__progress),
                            "trackingUrl" => Ok(__FieldTag::__tracking_url),
                            "tracking_url" => Ok(__FieldTag::__tracking_url),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = YarnApplication;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct YarnApplication")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::yarn_application::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__progress => {
                            if !fields.insert(__FieldTag::__progress) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.progress = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__tracking_url => {
                            if !fields.insert(__FieldTag::__tracking_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tracking_url",
                                ));
                            }
                            result.tracking_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for YarnApplication {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.progress) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("progress", &__With(&self.progress))?;
        }
        if !self.tracking_url.is_empty() {
            state.serialize_entry("trackingUrl", &self.tracking_url)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [YarnApplication].
pub mod yarn_application {
    #[allow(unused_imports)]
    use super::*;

    /// The application state, corresponding to
    /// \<code\>YarnProtos.YarnApplicationStateProto\</code\>.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Status is unspecified.
        Unspecified,
        /// Status is NEW.
        New,
        /// Status is NEW_SAVING.
        NewSaving,
        /// Status is SUBMITTED.
        Submitted,
        /// Status is ACCEPTED.
        Accepted,
        /// Status is RUNNING.
        Running,
        /// Status is FINISHED.
        Finished,
        /// Status is FAILED.
        Failed,
        /// Status is KILLED.
        Killed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::New => std::option::Option::Some(1),
                Self::NewSaving => std::option::Option::Some(2),
                Self::Submitted => std::option::Option::Some(3),
                Self::Accepted => std::option::Option::Some(4),
                Self::Running => std::option::Option::Some(5),
                Self::Finished => std::option::Option::Some(6),
                Self::Failed => std::option::Option::Some(7),
                Self::Killed => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::New => std::option::Option::Some("NEW"),
                Self::NewSaving => std::option::Option::Some("NEW_SAVING"),
                Self::Submitted => std::option::Option::Some("SUBMITTED"),
                Self::Accepted => std::option::Option::Some("ACCEPTED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Finished => std::option::Option::Some("FINISHED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Killed => std::option::Option::Some("KILLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::New,
                2 => Self::NewSaving,
                3 => Self::Submitted,
                4 => Self::Accepted,
                5 => Self::Running,
                6 => Self::Finished,
                7 => Self::Failed,
                8 => Self::Killed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "NEW" => Self::New,
                "NEW_SAVING" => Self::NewSaving,
                "SUBMITTED" => Self::Submitted,
                "ACCEPTED" => Self::Accepted,
                "RUNNING" => Self::Running,
                "FINISHED" => Self::Finished,
                "FAILED" => Self::Failed,
                "KILLED" => Self::Killed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::New => serializer.serialize_i32(1),
                Self::NewSaving => serializer.serialize_i32(2),
                Self::Submitted => serializer.serialize_i32(3),
                Self::Accepted => serializer.serialize_i32(4),
                Self::Running => serializer.serialize_i32(5),
                Self::Finished => serializer.serialize_i32(6),
                Self::Failed => serializer.serialize_i32(7),
                Self::Killed => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataproc.v1.YarnApplication.State",
            ))
        }
    }
}

/// A Dataproc job resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Job {
    /// Optional. The fully qualified reference to the job, which can be used to
    /// obtain the equivalent REST path of the job resource. If this property
    /// is not specified when a job is created, the server generates a
    /// \<code\>job_id\</code\>.
    pub reference: std::option::Option<crate::model::JobReference>,

    /// Required. Job information, including how, when, and where to
    /// run the job.
    pub placement: std::option::Option<crate::model::JobPlacement>,

    /// Output only. The job status. Additional application-specific
    /// status information might be contained in the \<code\>type_job\</code\>
    /// and \<code\>yarn_applications\</code\> fields.
    pub status: std::option::Option<crate::model::JobStatus>,

    /// Output only. The previous job status.
    pub status_history: std::vec::Vec<crate::model::JobStatus>,

    /// Output only. The collection of YARN applications spun up by this job.
    ///
    /// **Beta** Feature: This report is available for testing purposes only. It
    /// might be changed before final release.
    pub yarn_applications: std::vec::Vec<crate::model::YarnApplication>,

    /// Output only. A URI pointing to the location of the stdout of the job's
    /// driver program.
    pub driver_output_resource_uri: std::string::String,

    /// Output only. If present, the location of miscellaneous control files
    /// which can be used as part of job setup and handling. If not present,
    /// control files might be placed in the same location as `driver_output_uri`.
    pub driver_control_files_uri: std::string::String,

    /// Optional. The labels to associate with this job.
    /// Label **keys** must contain 1 to 63 characters, and must conform to
    /// [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt).
    /// Label **values** can be empty, but, if present, must contain 1 to 63
    /// characters, and must conform to [RFC
    /// 1035](https://www.ietf.org/rfc/rfc1035.txt). No more than 32 labels can be
    /// associated with a job.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Job scheduling configuration.
    pub scheduling: std::option::Option<crate::model::JobScheduling>,

    /// Output only. A UUID that uniquely identifies a job within the project
    /// over time. This is in contrast to a user-settable reference.job_id that
    /// might be reused over time.
    pub job_uuid: std::string::String,

    /// Output only. Indicates whether the job is completed. If the value is
    /// `false`, the job is still in progress. If `true`, the job is completed, and
    /// `status.state` field will indicate if it was successful, failed,
    /// or cancelled.
    pub done: bool,

    /// Optional. Driver scheduling configuration.
    pub driver_scheduling_config: std::option::Option<crate::model::DriverSchedulingConfig>,

    /// Required. The application/framework-specific portion of the job.
    pub type_job: std::option::Option<crate::model::job::TypeJob>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Job {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reference][crate::model::Job::reference].
    pub fn set_reference<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::JobReference>,
    {
        self.reference = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reference][crate::model::Job::reference].
    pub fn set_or_clear_reference<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::JobReference>,
    {
        self.reference = v.map(|x| x.into());
        self
    }

    /// Sets the value of [placement][crate::model::Job::placement].
    pub fn set_placement<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::JobPlacement>,
    {
        self.placement = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [placement][crate::model::Job::placement].
    pub fn set_or_clear_placement<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::JobPlacement>,
    {
        self.placement = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::Job::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::JobStatus>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::Job::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::JobStatus>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status_history][crate::model::Job::status_history].
    pub fn set_status_history<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::JobStatus>,
    {
        use std::iter::Iterator;
        self.status_history = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [yarn_applications][crate::model::Job::yarn_applications].
    pub fn set_yarn_applications<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::YarnApplication>,
    {
        use std::iter::Iterator;
        self.yarn_applications = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [driver_output_resource_uri][crate::model::Job::driver_output_resource_uri].
    pub fn set_driver_output_resource_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.driver_output_resource_uri = v.into();
        self
    }

    /// Sets the value of [driver_control_files_uri][crate::model::Job::driver_control_files_uri].
    pub fn set_driver_control_files_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.driver_control_files_uri = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Job::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [scheduling][crate::model::Job::scheduling].
    pub fn set_scheduling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::JobScheduling>,
    {
        self.scheduling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scheduling][crate::model::Job::scheduling].
    pub fn set_or_clear_scheduling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::JobScheduling>,
    {
        self.scheduling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [job_uuid][crate::model::Job::job_uuid].
    pub fn set_job_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_uuid = v.into();
        self
    }

    /// Sets the value of [done][crate::model::Job::done].
    pub fn set_done<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.done = v.into();
        self
    }

    /// Sets the value of [driver_scheduling_config][crate::model::Job::driver_scheduling_config].
    pub fn set_driver_scheduling_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DriverSchedulingConfig>,
    {
        self.driver_scheduling_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [driver_scheduling_config][crate::model::Job::driver_scheduling_config].
    pub fn set_or_clear_driver_scheduling_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DriverSchedulingConfig>,
    {
        self.driver_scheduling_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [type_job][crate::model::Job::type_job].
    ///
    /// Note that all the setters affecting `type_job` are mutually
    /// exclusive.
    pub fn set_type_job<T: std::convert::Into<std::option::Option<crate::model::job::TypeJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_job = v.into();
        self
    }

    /// The value of [type_job][crate::model::Job::type_job]
    /// if it holds a `HadoopJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn hadoop_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::HadoopJob>> {
        #[allow(unreachable_patterns)]
        self.type_job.as_ref().and_then(|v| match v {
            crate::model::job::TypeJob::HadoopJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_job][crate::model::Job::type_job]
    /// to hold a `HadoopJob`.
    ///
    /// Note that all the setters affecting `type_job` are
    /// mutually exclusive.
    pub fn set_hadoop_job<T: std::convert::Into<std::boxed::Box<crate::model::HadoopJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_job = std::option::Option::Some(crate::model::job::TypeJob::HadoopJob(v.into()));
        self
    }

    /// The value of [type_job][crate::model::Job::type_job]
    /// if it holds a `SparkJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::SparkJob>> {
        #[allow(unreachable_patterns)]
        self.type_job.as_ref().and_then(|v| match v {
            crate::model::job::TypeJob::SparkJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_job][crate::model::Job::type_job]
    /// to hold a `SparkJob`.
    ///
    /// Note that all the setters affecting `type_job` are
    /// mutually exclusive.
    pub fn set_spark_job<T: std::convert::Into<std::boxed::Box<crate::model::SparkJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_job = std::option::Option::Some(crate::model::job::TypeJob::SparkJob(v.into()));
        self
    }

    /// The value of [type_job][crate::model::Job::type_job]
    /// if it holds a `PysparkJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pyspark_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::PySparkJob>> {
        #[allow(unreachable_patterns)]
        self.type_job.as_ref().and_then(|v| match v {
            crate::model::job::TypeJob::PysparkJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_job][crate::model::Job::type_job]
    /// to hold a `PysparkJob`.
    ///
    /// Note that all the setters affecting `type_job` are
    /// mutually exclusive.
    pub fn set_pyspark_job<T: std::convert::Into<std::boxed::Box<crate::model::PySparkJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_job = std::option::Option::Some(crate::model::job::TypeJob::PysparkJob(v.into()));
        self
    }

    /// The value of [type_job][crate::model::Job::type_job]
    /// if it holds a `HiveJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn hive_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::HiveJob>> {
        #[allow(unreachable_patterns)]
        self.type_job.as_ref().and_then(|v| match v {
            crate::model::job::TypeJob::HiveJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_job][crate::model::Job::type_job]
    /// to hold a `HiveJob`.
    ///
    /// Note that all the setters affecting `type_job` are
    /// mutually exclusive.
    pub fn set_hive_job<T: std::convert::Into<std::boxed::Box<crate::model::HiveJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_job = std::option::Option::Some(crate::model::job::TypeJob::HiveJob(v.into()));
        self
    }

    /// The value of [type_job][crate::model::Job::type_job]
    /// if it holds a `PigJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pig_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::PigJob>> {
        #[allow(unreachable_patterns)]
        self.type_job.as_ref().and_then(|v| match v {
            crate::model::job::TypeJob::PigJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_job][crate::model::Job::type_job]
    /// to hold a `PigJob`.
    ///
    /// Note that all the setters affecting `type_job` are
    /// mutually exclusive.
    pub fn set_pig_job<T: std::convert::Into<std::boxed::Box<crate::model::PigJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_job = std::option::Option::Some(crate::model::job::TypeJob::PigJob(v.into()));
        self
    }

    /// The value of [type_job][crate::model::Job::type_job]
    /// if it holds a `SparkRJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_r_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::SparkRJob>> {
        #[allow(unreachable_patterns)]
        self.type_job.as_ref().and_then(|v| match v {
            crate::model::job::TypeJob::SparkRJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_job][crate::model::Job::type_job]
    /// to hold a `SparkRJob`.
    ///
    /// Note that all the setters affecting `type_job` are
    /// mutually exclusive.
    pub fn set_spark_r_job<T: std::convert::Into<std::boxed::Box<crate::model::SparkRJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_job = std::option::Option::Some(crate::model::job::TypeJob::SparkRJob(v.into()));
        self
    }

    /// The value of [type_job][crate::model::Job::type_job]
    /// if it holds a `SparkSqlJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_sql_job(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SparkSqlJob>> {
        #[allow(unreachable_patterns)]
        self.type_job.as_ref().and_then(|v| match v {
            crate::model::job::TypeJob::SparkSqlJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_job][crate::model::Job::type_job]
    /// to hold a `SparkSqlJob`.
    ///
    /// Note that all the setters affecting `type_job` are
    /// mutually exclusive.
    pub fn set_spark_sql_job<T: std::convert::Into<std::boxed::Box<crate::model::SparkSqlJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_job =
            std::option::Option::Some(crate::model::job::TypeJob::SparkSqlJob(v.into()));
        self
    }

    /// The value of [type_job][crate::model::Job::type_job]
    /// if it holds a `PrestoJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn presto_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::PrestoJob>> {
        #[allow(unreachable_patterns)]
        self.type_job.as_ref().and_then(|v| match v {
            crate::model::job::TypeJob::PrestoJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_job][crate::model::Job::type_job]
    /// to hold a `PrestoJob`.
    ///
    /// Note that all the setters affecting `type_job` are
    /// mutually exclusive.
    pub fn set_presto_job<T: std::convert::Into<std::boxed::Box<crate::model::PrestoJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_job = std::option::Option::Some(crate::model::job::TypeJob::PrestoJob(v.into()));
        self
    }

    /// The value of [type_job][crate::model::Job::type_job]
    /// if it holds a `TrinoJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn trino_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::TrinoJob>> {
        #[allow(unreachable_patterns)]
        self.type_job.as_ref().and_then(|v| match v {
            crate::model::job::TypeJob::TrinoJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_job][crate::model::Job::type_job]
    /// to hold a `TrinoJob`.
    ///
    /// Note that all the setters affecting `type_job` are
    /// mutually exclusive.
    pub fn set_trino_job<T: std::convert::Into<std::boxed::Box<crate::model::TrinoJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_job = std::option::Option::Some(crate::model::job::TypeJob::TrinoJob(v.into()));
        self
    }

    /// The value of [type_job][crate::model::Job::type_job]
    /// if it holds a `FlinkJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn flink_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::FlinkJob>> {
        #[allow(unreachable_patterns)]
        self.type_job.as_ref().and_then(|v| match v {
            crate::model::job::TypeJob::FlinkJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_job][crate::model::Job::type_job]
    /// to hold a `FlinkJob`.
    ///
    /// Note that all the setters affecting `type_job` are
    /// mutually exclusive.
    pub fn set_flink_job<T: std::convert::Into<std::boxed::Box<crate::model::FlinkJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_job = std::option::Option::Some(crate::model::job::TypeJob::FlinkJob(v.into()));
        self
    }
}

impl wkt::message::Message for Job {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.Job"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Job {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __reference,
            __placement,
            __hadoop_job,
            __spark_job,
            __pyspark_job,
            __hive_job,
            __pig_job,
            __spark_r_job,
            __spark_sql_job,
            __presto_job,
            __trino_job,
            __flink_job,
            __status,
            __status_history,
            __yarn_applications,
            __driver_output_resource_uri,
            __driver_control_files_uri,
            __labels,
            __scheduling,
            __job_uuid,
            __done,
            __driver_scheduling_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Job")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "reference" => Ok(__FieldTag::__reference),
                            "placement" => Ok(__FieldTag::__placement),
                            "hadoopJob" => Ok(__FieldTag::__hadoop_job),
                            "hadoop_job" => Ok(__FieldTag::__hadoop_job),
                            "sparkJob" => Ok(__FieldTag::__spark_job),
                            "spark_job" => Ok(__FieldTag::__spark_job),
                            "pysparkJob" => Ok(__FieldTag::__pyspark_job),
                            "pyspark_job" => Ok(__FieldTag::__pyspark_job),
                            "hiveJob" => Ok(__FieldTag::__hive_job),
                            "hive_job" => Ok(__FieldTag::__hive_job),
                            "pigJob" => Ok(__FieldTag::__pig_job),
                            "pig_job" => Ok(__FieldTag::__pig_job),
                            "sparkRJob" => Ok(__FieldTag::__spark_r_job),
                            "spark_r_job" => Ok(__FieldTag::__spark_r_job),
                            "sparkSqlJob" => Ok(__FieldTag::__spark_sql_job),
                            "spark_sql_job" => Ok(__FieldTag::__spark_sql_job),
                            "prestoJob" => Ok(__FieldTag::__presto_job),
                            "presto_job" => Ok(__FieldTag::__presto_job),
                            "trinoJob" => Ok(__FieldTag::__trino_job),
                            "trino_job" => Ok(__FieldTag::__trino_job),
                            "flinkJob" => Ok(__FieldTag::__flink_job),
                            "flink_job" => Ok(__FieldTag::__flink_job),
                            "status" => Ok(__FieldTag::__status),
                            "statusHistory" => Ok(__FieldTag::__status_history),
                            "status_history" => Ok(__FieldTag::__status_history),
                            "yarnApplications" => Ok(__FieldTag::__yarn_applications),
                            "yarn_applications" => Ok(__FieldTag::__yarn_applications),
                            "driverOutputResourceUri" => {
                                Ok(__FieldTag::__driver_output_resource_uri)
                            }
                            "driver_output_resource_uri" => {
                                Ok(__FieldTag::__driver_output_resource_uri)
                            }
                            "driverControlFilesUri" => Ok(__FieldTag::__driver_control_files_uri),
                            "driver_control_files_uri" => {
                                Ok(__FieldTag::__driver_control_files_uri)
                            }
                            "labels" => Ok(__FieldTag::__labels),
                            "scheduling" => Ok(__FieldTag::__scheduling),
                            "jobUuid" => Ok(__FieldTag::__job_uuid),
                            "job_uuid" => Ok(__FieldTag::__job_uuid),
                            "done" => Ok(__FieldTag::__done),
                            "driverSchedulingConfig" => Ok(__FieldTag::__driver_scheduling_config),
                            "driver_scheduling_config" => {
                                Ok(__FieldTag::__driver_scheduling_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Job;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Job")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__reference => {
                            if !fields.insert(__FieldTag::__reference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reference",
                                ));
                            }
                            result.reference = map
                                .next_value::<std::option::Option<crate::model::JobReference>>()?;
                        }
                        __FieldTag::__placement => {
                            if !fields.insert(__FieldTag::__placement) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for placement",
                                ));
                            }
                            result.placement = map
                                .next_value::<std::option::Option<crate::model::JobPlacement>>()?;
                        }
                        __FieldTag::__hadoop_job => {
                            if !fields.insert(__FieldTag::__hadoop_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hadoop_job",
                                ));
                            }
                            if result.type_job.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `type_job`, a oneof with full ID .google.cloud.dataproc.v1.Job.hadoop_job, latest field was hadoopJob",
                                ));
                            }
                            result.type_job =
                                std::option::Option::Some(crate::model::job::TypeJob::HadoopJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::HadoopJob>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__spark_job => {
                            if !fields.insert(__FieldTag::__spark_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark_job",
                                ));
                            }
                            if result.type_job.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `type_job`, a oneof with full ID .google.cloud.dataproc.v1.Job.spark_job, latest field was sparkJob",
                                ));
                            }
                            result.type_job =
                                std::option::Option::Some(crate::model::job::TypeJob::SparkJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SparkJob>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__pyspark_job => {
                            if !fields.insert(__FieldTag::__pyspark_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pyspark_job",
                                ));
                            }
                            if result.type_job.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `type_job`, a oneof with full ID .google.cloud.dataproc.v1.Job.pyspark_job, latest field was pysparkJob",
                                ));
                            }
                            result.type_job =
                                std::option::Option::Some(crate::model::job::TypeJob::PysparkJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PySparkJob>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__hive_job => {
                            if !fields.insert(__FieldTag::__hive_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hive_job",
                                ));
                            }
                            if result.type_job.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `type_job`, a oneof with full ID .google.cloud.dataproc.v1.Job.hive_job, latest field was hiveJob",
                                ));
                            }
                            result.type_job =
                                std::option::Option::Some(
                                    crate::model::job::TypeJob::HiveJob(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::HiveJob>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__pig_job => {
                            if !fields.insert(__FieldTag::__pig_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pig_job",
                                ));
                            }
                            if result.type_job.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `type_job`, a oneof with full ID .google.cloud.dataproc.v1.Job.pig_job, latest field was pigJob",
                                ));
                            }
                            result.type_job =
                                std::option::Option::Some(
                                    crate::model::job::TypeJob::PigJob(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::PigJob>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__spark_r_job => {
                            if !fields.insert(__FieldTag::__spark_r_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark_r_job",
                                ));
                            }
                            if result.type_job.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `type_job`, a oneof with full ID .google.cloud.dataproc.v1.Job.spark_r_job, latest field was sparkRJob",
                                ));
                            }
                            result.type_job =
                                std::option::Option::Some(crate::model::job::TypeJob::SparkRJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SparkRJob>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__spark_sql_job => {
                            if !fields.insert(__FieldTag::__spark_sql_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark_sql_job",
                                ));
                            }
                            if result.type_job.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `type_job`, a oneof with full ID .google.cloud.dataproc.v1.Job.spark_sql_job, latest field was sparkSqlJob",
                                ));
                            }
                            result.type_job =
                                std::option::Option::Some(crate::model::job::TypeJob::SparkSqlJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SparkSqlJob>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__presto_job => {
                            if !fields.insert(__FieldTag::__presto_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for presto_job",
                                ));
                            }
                            if result.type_job.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `type_job`, a oneof with full ID .google.cloud.dataproc.v1.Job.presto_job, latest field was prestoJob",
                                ));
                            }
                            result.type_job =
                                std::option::Option::Some(crate::model::job::TypeJob::PrestoJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PrestoJob>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__trino_job => {
                            if !fields.insert(__FieldTag::__trino_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trino_job",
                                ));
                            }
                            if result.type_job.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `type_job`, a oneof with full ID .google.cloud.dataproc.v1.Job.trino_job, latest field was trinoJob",
                                ));
                            }
                            result.type_job =
                                std::option::Option::Some(crate::model::job::TypeJob::TrinoJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TrinoJob>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__flink_job => {
                            if !fields.insert(__FieldTag::__flink_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flink_job",
                                ));
                            }
                            if result.type_job.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `type_job`, a oneof with full ID .google.cloud.dataproc.v1.Job.flink_job, latest field was flinkJob",
                                ));
                            }
                            result.type_job =
                                std::option::Option::Some(crate::model::job::TypeJob::FlinkJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::FlinkJob>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status =
                                map.next_value::<std::option::Option<crate::model::JobStatus>>()?;
                        }
                        __FieldTag::__status_history => {
                            if !fields.insert(__FieldTag::__status_history) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_history",
                                ));
                            }
                            result.status_history = map.next_value::<std::option::Option<std::vec::Vec<crate::model::JobStatus>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__yarn_applications => {
                            if !fields.insert(__FieldTag::__yarn_applications) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for yarn_applications",
                                ));
                            }
                            result.yarn_applications =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::YarnApplication>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__driver_output_resource_uri => {
                            if !fields.insert(__FieldTag::__driver_output_resource_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for driver_output_resource_uri",
                                ));
                            }
                            result.driver_output_resource_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__driver_control_files_uri => {
                            if !fields.insert(__FieldTag::__driver_control_files_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for driver_control_files_uri",
                                ));
                            }
                            result.driver_control_files_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scheduling => {
                            if !fields.insert(__FieldTag::__scheduling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scheduling",
                                ));
                            }
                            result.scheduling = map
                                .next_value::<std::option::Option<crate::model::JobScheduling>>()?;
                        }
                        __FieldTag::__job_uuid => {
                            if !fields.insert(__FieldTag::__job_uuid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_uuid",
                                ));
                            }
                            result.job_uuid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__done => {
                            if !fields.insert(__FieldTag::__done) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for done",
                                ));
                            }
                            result.done = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__driver_scheduling_config => {
                            if !fields.insert(__FieldTag::__driver_scheduling_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for driver_scheduling_config",
                                ));
                            }
                            result.driver_scheduling_config = map.next_value::<std::option::Option<crate::model::DriverSchedulingConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Job {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.reference.is_some() {
            state.serialize_entry("reference", &self.reference)?;
        }
        if self.placement.is_some() {
            state.serialize_entry("placement", &self.placement)?;
        }
        if let Some(value) = self.hadoop_job() {
            state.serialize_entry("hadoopJob", value)?;
        }
        if let Some(value) = self.spark_job() {
            state.serialize_entry("sparkJob", value)?;
        }
        if let Some(value) = self.pyspark_job() {
            state.serialize_entry("pysparkJob", value)?;
        }
        if let Some(value) = self.hive_job() {
            state.serialize_entry("hiveJob", value)?;
        }
        if let Some(value) = self.pig_job() {
            state.serialize_entry("pigJob", value)?;
        }
        if let Some(value) = self.spark_r_job() {
            state.serialize_entry("sparkRJob", value)?;
        }
        if let Some(value) = self.spark_sql_job() {
            state.serialize_entry("sparkSqlJob", value)?;
        }
        if let Some(value) = self.presto_job() {
            state.serialize_entry("prestoJob", value)?;
        }
        if let Some(value) = self.trino_job() {
            state.serialize_entry("trinoJob", value)?;
        }
        if let Some(value) = self.flink_job() {
            state.serialize_entry("flinkJob", value)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.status_history.is_empty() {
            state.serialize_entry("statusHistory", &self.status_history)?;
        }
        if !self.yarn_applications.is_empty() {
            state.serialize_entry("yarnApplications", &self.yarn_applications)?;
        }
        if !self.driver_output_resource_uri.is_empty() {
            state.serialize_entry("driverOutputResourceUri", &self.driver_output_resource_uri)?;
        }
        if !self.driver_control_files_uri.is_empty() {
            state.serialize_entry("driverControlFilesUri", &self.driver_control_files_uri)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.scheduling.is_some() {
            state.serialize_entry("scheduling", &self.scheduling)?;
        }
        if !self.job_uuid.is_empty() {
            state.serialize_entry("jobUuid", &self.job_uuid)?;
        }
        if !wkt::internal::is_default(&self.done) {
            state.serialize_entry("done", &self.done)?;
        }
        if self.driver_scheduling_config.is_some() {
            state.serialize_entry("driverSchedulingConfig", &self.driver_scheduling_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Job].
pub mod job {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The application/framework-specific portion of the job.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TypeJob {
        /// Optional. Job is a Hadoop job.
        HadoopJob(std::boxed::Box<crate::model::HadoopJob>),
        /// Optional. Job is a Spark job.
        SparkJob(std::boxed::Box<crate::model::SparkJob>),
        /// Optional. Job is a PySpark job.
        PysparkJob(std::boxed::Box<crate::model::PySparkJob>),
        /// Optional. Job is a Hive job.
        HiveJob(std::boxed::Box<crate::model::HiveJob>),
        /// Optional. Job is a Pig job.
        PigJob(std::boxed::Box<crate::model::PigJob>),
        /// Optional. Job is a SparkR job.
        SparkRJob(std::boxed::Box<crate::model::SparkRJob>),
        /// Optional. Job is a SparkSql job.
        SparkSqlJob(std::boxed::Box<crate::model::SparkSqlJob>),
        /// Optional. Job is a Presto job.
        PrestoJob(std::boxed::Box<crate::model::PrestoJob>),
        /// Optional. Job is a Trino job.
        TrinoJob(std::boxed::Box<crate::model::TrinoJob>),
        /// Optional. Job is a Flink job.
        FlinkJob(std::boxed::Box<crate::model::FlinkJob>),
    }
}

/// Driver scheduling configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DriverSchedulingConfig {
    /// Required. The amount of memory in MB the driver is requesting.
    pub memory_mb: i32,

    /// Required. The number of vCPUs the driver is requesting.
    pub vcores: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DriverSchedulingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [memory_mb][crate::model::DriverSchedulingConfig::memory_mb].
    pub fn set_memory_mb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_mb = v.into();
        self
    }

    /// Sets the value of [vcores][crate::model::DriverSchedulingConfig::vcores].
    pub fn set_vcores<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.vcores = v.into();
        self
    }
}

impl wkt::message::Message for DriverSchedulingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DriverSchedulingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DriverSchedulingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __memory_mb,
            __vcores,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DriverSchedulingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "memoryMb" => Ok(__FieldTag::__memory_mb),
                            "memory_mb" => Ok(__FieldTag::__memory_mb),
                            "vcores" => Ok(__FieldTag::__vcores),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DriverSchedulingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DriverSchedulingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__memory_mb => {
                            if !fields.insert(__FieldTag::__memory_mb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_mb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_mb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__vcores => {
                            if !fields.insert(__FieldTag::__vcores) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vcores",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.vcores = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DriverSchedulingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.memory_mb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("memoryMb", &__With(&self.memory_mb))?;
        }
        if !wkt::internal::is_default(&self.vcores) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("vcores", &__With(&self.vcores))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Job scheduling options.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct JobScheduling {
    /// Optional. Maximum number of times per hour a driver can be restarted as
    /// a result of driver exiting with non-zero code before job is
    /// reported failed.
    ///
    /// A job might be reported as thrashing if the driver exits with a non-zero
    /// code four times within a 10-minute window.
    ///
    /// Maximum value is 10.
    ///
    /// **Note:** This restartable job option is not supported in Dataproc
    /// [workflow templates]
    /// (<https://cloud.google.com/dataproc/docs/concepts/workflows/using-workflows#adding_jobs_to_a_template>).
    pub max_failures_per_hour: i32,

    /// Optional. Maximum total number of times a driver can be restarted as a
    /// result of the driver exiting with a non-zero code. After the maximum number
    /// is reached, the job will be reported as failed.
    ///
    /// Maximum value is 240.
    ///
    /// **Note:** Currently, this restartable job option is
    /// not supported in Dataproc
    /// [workflow
    /// templates](https://cloud.google.com/dataproc/docs/concepts/workflows/using-workflows#adding_jobs_to_a_template).
    pub max_failures_total: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JobScheduling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [max_failures_per_hour][crate::model::JobScheduling::max_failures_per_hour].
    pub fn set_max_failures_per_hour<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_failures_per_hour = v.into();
        self
    }

    /// Sets the value of [max_failures_total][crate::model::JobScheduling::max_failures_total].
    pub fn set_max_failures_total<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_failures_total = v.into();
        self
    }
}

impl wkt::message::Message for JobScheduling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.JobScheduling"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for JobScheduling {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __max_failures_per_hour,
            __max_failures_total,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobScheduling")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maxFailuresPerHour" => Ok(__FieldTag::__max_failures_per_hour),
                            "max_failures_per_hour" => Ok(__FieldTag::__max_failures_per_hour),
                            "maxFailuresTotal" => Ok(__FieldTag::__max_failures_total),
                            "max_failures_total" => Ok(__FieldTag::__max_failures_total),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = JobScheduling;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobScheduling")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__max_failures_per_hour => {
                            if !fields.insert(__FieldTag::__max_failures_per_hour) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_failures_per_hour",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_failures_per_hour =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_failures_total => {
                            if !fields.insert(__FieldTag::__max_failures_total) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_failures_total",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_failures_total =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for JobScheduling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.max_failures_per_hour) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxFailuresPerHour", &__With(&self.max_failures_per_hour))?;
        }
        if !wkt::internal::is_default(&self.max_failures_total) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxFailuresTotal", &__With(&self.max_failures_total))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to submit a job.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SubmitJobRequest {
    /// Required. The ID of the Google Cloud Platform project that the job
    /// belongs to.
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    pub region: std::string::String,

    /// Required. The job resource.
    pub job: std::option::Option<crate::model::Job>,

    /// Optional. A unique id used to identify the request. If the server
    /// receives two
    /// [SubmitJobRequest](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.SubmitJobRequest)s
    /// with the same id, then the second request will be ignored and the
    /// first [Job][google.cloud.dataproc.v1.Job] created and stored in the backend
    /// is returned.
    ///
    /// It is recommended to always set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The id must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    ///
    /// [google.cloud.dataproc.v1.Job]: crate::model::Job
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubmitJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SubmitJobRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::SubmitJobRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [job][crate::model::SubmitJobRequest::job].
    pub fn set_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [job][crate::model::SubmitJobRequest::job].
    pub fn set_or_clear_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::SubmitJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for SubmitJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SubmitJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SubmitJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __region,
            __job,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SubmitJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "region" => Ok(__FieldTag::__region),
                            "job" => Ok(__FieldTag::__job),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SubmitJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SubmitJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job => {
                            if !fields.insert(__FieldTag::__job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job",
                                ));
                            }
                            result.job =
                                map.next_value::<std::option::Option<crate::model::Job>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SubmitJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.job.is_some() {
            state.serialize_entry("job", &self.job)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Job Operation metadata.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct JobMetadata {
    /// Output only. The job id.
    pub job_id: std::string::String,

    /// Output only. Most recent job status.
    pub status: std::option::Option<crate::model::JobStatus>,

    /// Output only. Operation type.
    pub operation_type: std::string::String,

    /// Output only. Job submission time.
    pub start_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JobMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job_id][crate::model::JobMetadata::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [status][crate::model::JobMetadata::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::JobStatus>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::JobMetadata::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::JobStatus>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [operation_type][crate::model::JobMetadata::operation_type].
    pub fn set_operation_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_type = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::JobMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::JobMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for JobMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.JobMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for JobMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __job_id,
            __status,
            __operation_type,
            __start_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JobMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobId" => Ok(__FieldTag::__job_id),
                            "job_id" => Ok(__FieldTag::__job_id),
                            "status" => Ok(__FieldTag::__status),
                            "operationType" => Ok(__FieldTag::__operation_type),
                            "operation_type" => Ok(__FieldTag::__operation_type),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = JobMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JobMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__job_id => {
                            if !fields.insert(__FieldTag::__job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_id",
                                ));
                            }
                            result.job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status =
                                map.next_value::<std::option::Option<crate::model::JobStatus>>()?;
                        }
                        __FieldTag::__operation_type => {
                            if !fields.insert(__FieldTag::__operation_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_type",
                                ));
                            }
                            result.operation_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for JobMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.job_id.is_empty() {
            state.serialize_entry("jobId", &self.job_id)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.operation_type.is_empty() {
            state.serialize_entry("operationType", &self.operation_type)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to get the resource representation for a job in a project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetJobRequest {
    /// Required. The ID of the Google Cloud Platform project that the job
    /// belongs to.
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    pub region: std::string::String,

    /// Required. The job ID.
    pub job_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetJobRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::GetJobRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::GetJobRequest::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }
}

impl wkt::message::Message for GetJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GetJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __region,
            __job_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "region" => Ok(__FieldTag::__region),
                            "jobId" => Ok(__FieldTag::__job_id),
                            "job_id" => Ok(__FieldTag::__job_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_id => {
                            if !fields.insert(__FieldTag::__job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_id",
                                ));
                            }
                            result.job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.job_id.is_empty() {
            state.serialize_entry("jobId", &self.job_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to list jobs in a project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListJobsRequest {
    /// Required. The ID of the Google Cloud Platform project that the job
    /// belongs to.
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    pub region: std::string::String,

    /// Optional. The number of results to return in each response.
    pub page_size: i32,

    /// Optional. The page token, returned by a previous call, to request the
    /// next page of results.
    pub page_token: std::string::String,

    /// Optional. If set, the returned jobs list includes only jobs that were
    /// submitted to the named cluster.
    pub cluster_name: std::string::String,

    /// Optional. Specifies enumerated categories of jobs to list.
    /// (default = match ALL jobs).
    ///
    /// If `filter` is provided, `jobStateMatcher` will be ignored.
    pub job_state_matcher: crate::model::list_jobs_request::JobStateMatcher,

    /// Optional. A filter constraining the jobs to list. Filters are
    /// case-sensitive and have the following syntax:
    ///
    /// [field = value] AND [field [= value]] ...
    ///
    /// where **field** is `status.state` or `labels.[KEY]`, and `[KEY]` is a label
    /// key. **value** can be `*` to match all values.
    /// `status.state` can be either `ACTIVE` or `NON_ACTIVE`.
    /// Only the logical `AND` operator is supported; space-separated items are
    /// treated as having an implicit `AND` operator.
    ///
    /// Example filter:
    ///
    /// status.state = ACTIVE AND labels.env = staging AND labels.starred = *
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListJobsRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::ListJobsRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::ListJobsRequest::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [job_state_matcher][crate::model::ListJobsRequest::job_state_matcher].
    pub fn set_job_state_matcher<
        T: std::convert::Into<crate::model::list_jobs_request::JobStateMatcher>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_state_matcher = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __region,
            __page_size,
            __page_token,
            __cluster_name,
            __job_state_matcher,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "region" => Ok(__FieldTag::__region),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "clusterName" => Ok(__FieldTag::__cluster_name),
                            "cluster_name" => Ok(__FieldTag::__cluster_name),
                            "jobStateMatcher" => Ok(__FieldTag::__job_state_matcher),
                            "job_state_matcher" => Ok(__FieldTag::__job_state_matcher),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_name => {
                            if !fields.insert(__FieldTag::__cluster_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_name",
                                ));
                            }
                            result.cluster_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_state_matcher => {
                            if !fields.insert(__FieldTag::__job_state_matcher) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_state_matcher",
                                ));
                            }
                            result.job_state_matcher = map
                                .next_value::<std::option::Option<
                                    crate::model::list_jobs_request::JobStateMatcher,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.cluster_name.is_empty() {
            state.serialize_entry("clusterName", &self.cluster_name)?;
        }
        if !wkt::internal::is_default(&self.job_state_matcher) {
            state.serialize_entry("jobStateMatcher", &self.job_state_matcher)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ListJobsRequest].
pub mod list_jobs_request {
    #[allow(unused_imports)]
    use super::*;

    /// A matcher that specifies categories of job states.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum JobStateMatcher {
        /// Match all jobs, regardless of state.
        All,
        /// Only match jobs in non-terminal states: PENDING, RUNNING, or
        /// CANCEL_PENDING.
        Active,
        /// Only match jobs in terminal states: CANCELLED, DONE, or ERROR.
        NonActive,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [JobStateMatcher::value] or
        /// [JobStateMatcher::name].
        UnknownValue(job_state_matcher::UnknownValue),
    }

    #[doc(hidden)]
    pub mod job_state_matcher {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl JobStateMatcher {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::All => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::NonActive => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::All => std::option::Option::Some("ALL"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::NonActive => std::option::Option::Some("NON_ACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for JobStateMatcher {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for JobStateMatcher {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for JobStateMatcher {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::All,
                1 => Self::Active,
                2 => Self::NonActive,
                _ => Self::UnknownValue(job_state_matcher::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for JobStateMatcher {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ALL" => Self::All,
                "ACTIVE" => Self::Active,
                "NON_ACTIVE" => Self::NonActive,
                _ => Self::UnknownValue(job_state_matcher::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for JobStateMatcher {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::All => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::NonActive => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for JobStateMatcher {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<JobStateMatcher>::new(
                ".google.cloud.dataproc.v1.ListJobsRequest.JobStateMatcher",
            ))
        }
    }
}

/// A request to update a job.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateJobRequest {
    /// Required. The ID of the Google Cloud Platform project that the job
    /// belongs to.
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    pub region: std::string::String,

    /// Required. The job ID.
    pub job_id: std::string::String,

    /// Required. The changes to the job.
    pub job: std::option::Option<crate::model::Job>,

    /// Required. Specifies the path, relative to \<code\>Job\</code\>, of
    /// the field to update. For example, to update the labels of a Job the
    /// \<code\>update_mask\</code\> parameter would be specified as
    /// \<code\>labels\</code\>, and the `PATCH` request body would specify the new
    /// value. \<strong\>Note:\</strong\> Currently, \<code\>labels\</code\> is the only
    /// field that can be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::UpdateJobRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::UpdateJobRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::UpdateJobRequest::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [job][crate::model::UpdateJobRequest::job].
    pub fn set_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [job][crate::model::UpdateJobRequest::job].
    pub fn set_or_clear_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Job>,
    {
        self.job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateJobRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateJobRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.UpdateJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __region,
            __job_id,
            __job,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "region" => Ok(__FieldTag::__region),
                            "jobId" => Ok(__FieldTag::__job_id),
                            "job_id" => Ok(__FieldTag::__job_id),
                            "job" => Ok(__FieldTag::__job),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_id => {
                            if !fields.insert(__FieldTag::__job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_id",
                                ));
                            }
                            result.job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job => {
                            if !fields.insert(__FieldTag::__job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job",
                                ));
                            }
                            result.job =
                                map.next_value::<std::option::Option<crate::model::Job>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.job_id.is_empty() {
            state.serialize_entry("jobId", &self.job_id)?;
        }
        if self.job.is_some() {
            state.serialize_entry("job", &self.job)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A list of jobs in a project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListJobsResponse {
    /// Output only. Jobs list.
    pub jobs: std::vec::Vec<crate::model::Job>,

    /// Optional. This token is included in the response if there are more results
    /// to fetch. To fetch additional results, provide this value as the
    /// `page_token` in a subsequent \<code\>ListJobsRequest\</code\>.
    pub next_page_token: std::string::String,

    /// Output only. List of jobs with
    /// [kms_key][google.cloud.dataproc.v1.EncryptionConfig.kms_key]-encrypted
    /// parameters that could not be decrypted. A response to a `jobs.get` request
    /// may indicate the reason for the decryption failure for a specific job.
    ///
    /// [google.cloud.dataproc.v1.EncryptionConfig.kms_key]: crate::model::EncryptionConfig::kms_key
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [jobs][crate::model::ListJobsResponse::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Job>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListJobsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListJobsResponse {
    type PageItem = crate::model::Job;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __jobs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "jobs" => Ok(__FieldTag::__jobs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__jobs => {
                            if !fields.insert(__FieldTag::__jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jobs",
                                ));
                            }
                            result.jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Job>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.jobs.is_empty() {
            state.serialize_entry("jobs", &self.jobs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to cancel a job.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelJobRequest {
    /// Required. The ID of the Google Cloud Platform project that the job
    /// belongs to.
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    pub region: std::string::String,

    /// Required. The job ID.
    pub job_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::CancelJobRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::CancelJobRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::CancelJobRequest::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }
}

impl wkt::message::Message for CancelJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.CancelJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __region,
            __job_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "region" => Ok(__FieldTag::__region),
                            "jobId" => Ok(__FieldTag::__job_id),
                            "job_id" => Ok(__FieldTag::__job_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_id => {
                            if !fields.insert(__FieldTag::__job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_id",
                                ));
                            }
                            result.job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.job_id.is_empty() {
            state.serialize_entry("jobId", &self.job_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to delete a job.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteJobRequest {
    /// Required. The ID of the Google Cloud Platform project that the job
    /// belongs to.
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    pub region: std::string::String,

    /// Required. The job ID.
    pub job_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DeleteJobRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::DeleteJobRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::DeleteJobRequest::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DeleteJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __region,
            __job_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "region" => Ok(__FieldTag::__region),
                            "jobId" => Ok(__FieldTag::__job_id),
                            "job_id" => Ok(__FieldTag::__job_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region => {
                            if !fields.insert(__FieldTag::__region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region",
                                ));
                            }
                            result.region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__job_id => {
                            if !fields.insert(__FieldTag::__job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_id",
                                ));
                            }
                            result.job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.region.is_empty() {
            state.serialize_entry("region", &self.region)?;
        }
        if !self.job_id.is_empty() {
            state.serialize_entry("jobId", &self.job_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to create a node group.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateNodeGroupRequest {
    /// Required. The parent resource where this node group will be created.
    /// Format: `projects/{project}/regions/{region}/clusters/{cluster}`
    pub parent: std::string::String,

    /// Required. The node group to create.
    pub node_group: std::option::Option<crate::model::NodeGroup>,

    /// Optional. An optional node group ID. Generated if not specified.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). Cannot begin or end with underscore
    /// or hyphen. Must consist of from 3 to 33 characters.
    pub node_group_id: std::string::String,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two
    /// [CreateNodeGroupRequest](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.CreateNodeGroupRequests)
    /// with the same ID, the second request is ignored and the
    /// first [google.longrunning.Operation][google.longrunning.Operation] created
    /// and stored in the backend is returned.
    ///
    /// Recommendation: Set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    ///
    /// [google.longrunning.Operation]: longrunning::model::Operation
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateNodeGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateNodeGroupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [node_group][crate::model::CreateNodeGroupRequest::node_group].
    pub fn set_node_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeGroup>,
    {
        self.node_group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_group][crate::model::CreateNodeGroupRequest::node_group].
    pub fn set_or_clear_node_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeGroup>,
    {
        self.node_group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [node_group_id][crate::model::CreateNodeGroupRequest::node_group_id].
    pub fn set_node_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_group_id = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateNodeGroupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateNodeGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.CreateNodeGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateNodeGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __node_group,
            __node_group_id,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateNodeGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "nodeGroup" => Ok(__FieldTag::__node_group),
                            "node_group" => Ok(__FieldTag::__node_group),
                            "nodeGroupId" => Ok(__FieldTag::__node_group_id),
                            "node_group_id" => Ok(__FieldTag::__node_group_id),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateNodeGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateNodeGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_group => {
                            if !fields.insert(__FieldTag::__node_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_group",
                                ));
                            }
                            result.node_group =
                                map.next_value::<std::option::Option<crate::model::NodeGroup>>()?;
                        }
                        __FieldTag::__node_group_id => {
                            if !fields.insert(__FieldTag::__node_group_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_group_id",
                                ));
                            }
                            result.node_group_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateNodeGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.node_group.is_some() {
            state.serialize_entry("nodeGroup", &self.node_group)?;
        }
        if !self.node_group_id.is_empty() {
            state.serialize_entry("nodeGroupId", &self.node_group_id)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to resize a node group.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ResizeNodeGroupRequest {
    /// Required. The name of the node group to resize.
    /// Format:
    /// `projects/{project}/regions/{region}/clusters/{cluster}/nodeGroups/{nodeGroup}`
    pub name: std::string::String,

    /// Required. The number of running instances for the node group to maintain.
    /// The group adds or removes instances to maintain the number of instances
    /// specified by this parameter.
    pub size: i32,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two
    /// [ResizeNodeGroupRequest](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.ResizeNodeGroupRequests)
    /// with the same ID, the second request is ignored and the
    /// first [google.longrunning.Operation][google.longrunning.Operation] created
    /// and stored in the backend is returned.
    ///
    /// Recommendation: Set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    ///
    /// [google.longrunning.Operation]: longrunning::model::Operation
    pub request_id: std::string::String,

    /// Optional. Timeout for graceful YARN decommissioning. [Graceful
    /// decommissioning]
    /// (<https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/scaling-clusters#graceful_decommissioning>)
    /// allows the removal of nodes from the Compute Engine node group
    /// without interrupting jobs in progress. This timeout specifies how long to
    /// wait for jobs in progress to finish before forcefully removing nodes (and
    /// potentially interrupting jobs). Default timeout is 0 (for forceful
    /// decommission), and the maximum allowed timeout is 1 day. (see JSON
    /// representation of
    /// [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json)).
    ///
    /// Only supported on Dataproc image versions 1.2 and higher.
    pub graceful_decommission_timeout: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResizeNodeGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResizeNodeGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [size][crate::model::ResizeNodeGroupRequest::size].
    pub fn set_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.size = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::ResizeNodeGroupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [graceful_decommission_timeout][crate::model::ResizeNodeGroupRequest::graceful_decommission_timeout].
    pub fn set_graceful_decommission_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.graceful_decommission_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [graceful_decommission_timeout][crate::model::ResizeNodeGroupRequest::graceful_decommission_timeout].
    pub fn set_or_clear_graceful_decommission_timeout<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.graceful_decommission_timeout = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ResizeNodeGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ResizeNodeGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResizeNodeGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __size,
            __request_id,
            __graceful_decommission_timeout,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResizeNodeGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "size" => Ok(__FieldTag::__size),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "gracefulDecommissionTimeout" => {
                                Ok(__FieldTag::__graceful_decommission_timeout)
                            }
                            "graceful_decommission_timeout" => {
                                Ok(__FieldTag::__graceful_decommission_timeout)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResizeNodeGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResizeNodeGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__size => {
                            if !fields.insert(__FieldTag::__size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__graceful_decommission_timeout => {
                            if !fields.insert(__FieldTag::__graceful_decommission_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for graceful_decommission_timeout",
                                ));
                            }
                            result.graceful_decommission_timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResizeNodeGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("size", &__With(&self.size))?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if self.graceful_decommission_timeout.is_some() {
            state.serialize_entry(
                "gracefulDecommissionTimeout",
                &self.graceful_decommission_timeout,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to get a node group .
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetNodeGroupRequest {
    /// Required. The name of the node group to retrieve.
    /// Format:
    /// `projects/{project}/regions/{region}/clusters/{cluster}/nodeGroups/{nodeGroup}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNodeGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNodeGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNodeGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GetNodeGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetNodeGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetNodeGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetNodeGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetNodeGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetNodeGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata describing the Batch operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchOperationMetadata {
    /// Name of the batch for the operation.
    pub batch: std::string::String,

    /// Batch UUID for the operation.
    pub batch_uuid: std::string::String,

    /// The time when the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time when the operation finished.
    pub done_time: std::option::Option<wkt::Timestamp>,

    /// The operation type.
    pub operation_type: crate::model::batch_operation_metadata::BatchOperationType,

    /// Short description of the operation.
    pub description: std::string::String,

    /// Labels associated with the operation.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Warnings encountered during operation execution.
    pub warnings: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [batch][crate::model::BatchOperationMetadata::batch].
    pub fn set_batch<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.batch = v.into();
        self
    }

    /// Sets the value of [batch_uuid][crate::model::BatchOperationMetadata::batch_uuid].
    pub fn set_batch_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.batch_uuid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BatchOperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BatchOperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [done_time][crate::model::BatchOperationMetadata::done_time].
    pub fn set_done_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.done_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [done_time][crate::model::BatchOperationMetadata::done_time].
    pub fn set_or_clear_done_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.done_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [operation_type][crate::model::BatchOperationMetadata::operation_type].
    pub fn set_operation_type<
        T: std::convert::Into<crate::model::batch_operation_metadata::BatchOperationType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation_type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::BatchOperationMetadata::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::BatchOperationMetadata::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [warnings][crate::model::BatchOperationMetadata::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.BatchOperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __batch,
            __batch_uuid,
            __create_time,
            __done_time,
            __operation_type,
            __description,
            __labels,
            __warnings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "batch" => Ok(__FieldTag::__batch),
                            "batchUuid" => Ok(__FieldTag::__batch_uuid),
                            "batch_uuid" => Ok(__FieldTag::__batch_uuid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "doneTime" => Ok(__FieldTag::__done_time),
                            "done_time" => Ok(__FieldTag::__done_time),
                            "operationType" => Ok(__FieldTag::__operation_type),
                            "operation_type" => Ok(__FieldTag::__operation_type),
                            "description" => Ok(__FieldTag::__description),
                            "labels" => Ok(__FieldTag::__labels),
                            "warnings" => Ok(__FieldTag::__warnings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__batch => {
                            if !fields.insert(__FieldTag::__batch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for batch",
                                ));
                            }
                            result.batch = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__batch_uuid => {
                            if !fields.insert(__FieldTag::__batch_uuid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for batch_uuid",
                                ));
                            }
                            result.batch_uuid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__done_time => {
                            if !fields.insert(__FieldTag::__done_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for done_time",
                                ));
                            }
                            result.done_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__operation_type => {
                            if !fields.insert(__FieldTag::__operation_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_type",
                                ));
                            }
                            result.operation_type = map
                                .next_value::<std::option::Option<
                                    crate::model::batch_operation_metadata::BatchOperationType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__warnings => {
                            if !fields.insert(__FieldTag::__warnings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for warnings",
                                ));
                            }
                            result.warnings = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.batch.is_empty() {
            state.serialize_entry("batch", &self.batch)?;
        }
        if !self.batch_uuid.is_empty() {
            state.serialize_entry("batchUuid", &self.batch_uuid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.done_time.is_some() {
            state.serialize_entry("doneTime", &self.done_time)?;
        }
        if !wkt::internal::is_default(&self.operation_type) {
            state.serialize_entry("operationType", &self.operation_type)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.warnings.is_empty() {
            state.serialize_entry("warnings", &self.warnings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BatchOperationMetadata].
pub mod batch_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Operation type for Batch resources
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BatchOperationType {
        /// Batch operation type is unknown.
        Unspecified,
        /// Batch operation type.
        Batch,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BatchOperationType::value] or
        /// [BatchOperationType::name].
        UnknownValue(batch_operation_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod batch_operation_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BatchOperationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Batch => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BATCH_OPERATION_TYPE_UNSPECIFIED"),
                Self::Batch => std::option::Option::Some("BATCH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BatchOperationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BatchOperationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BatchOperationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Batch,
                _ => Self::UnknownValue(batch_operation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BatchOperationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BATCH_OPERATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "BATCH" => Self::Batch,
                _ => Self::UnknownValue(batch_operation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BatchOperationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Batch => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BatchOperationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BatchOperationType>::new(
                ".google.cloud.dataproc.v1.BatchOperationMetadata.BatchOperationType",
            ))
        }
    }
}

/// Metadata describing the Session operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SessionOperationMetadata {
    /// Name of the session for the operation.
    pub session: std::string::String,

    /// Session UUID for the operation.
    pub session_uuid: std::string::String,

    /// The time when the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time when the operation was finished.
    pub done_time: std::option::Option<wkt::Timestamp>,

    /// The operation type.
    pub operation_type: crate::model::session_operation_metadata::SessionOperationType,

    /// Short description of the operation.
    pub description: std::string::String,

    /// Labels associated with the operation.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Warnings encountered during operation execution.
    pub warnings: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SessionOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [session][crate::model::SessionOperationMetadata::session].
    pub fn set_session<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.session = v.into();
        self
    }

    /// Sets the value of [session_uuid][crate::model::SessionOperationMetadata::session_uuid].
    pub fn set_session_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.session_uuid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::SessionOperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::SessionOperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [done_time][crate::model::SessionOperationMetadata::done_time].
    pub fn set_done_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.done_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [done_time][crate::model::SessionOperationMetadata::done_time].
    pub fn set_or_clear_done_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.done_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [operation_type][crate::model::SessionOperationMetadata::operation_type].
    pub fn set_operation_type<
        T: std::convert::Into<crate::model::session_operation_metadata::SessionOperationType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation_type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::SessionOperationMetadata::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::SessionOperationMetadata::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [warnings][crate::model::SessionOperationMetadata::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SessionOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SessionOperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SessionOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session,
            __session_uuid,
            __create_time,
            __done_time,
            __operation_type,
            __description,
            __labels,
            __warnings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SessionOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "session" => Ok(__FieldTag::__session),
                            "sessionUuid" => Ok(__FieldTag::__session_uuid),
                            "session_uuid" => Ok(__FieldTag::__session_uuid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "doneTime" => Ok(__FieldTag::__done_time),
                            "done_time" => Ok(__FieldTag::__done_time),
                            "operationType" => Ok(__FieldTag::__operation_type),
                            "operation_type" => Ok(__FieldTag::__operation_type),
                            "description" => Ok(__FieldTag::__description),
                            "labels" => Ok(__FieldTag::__labels),
                            "warnings" => Ok(__FieldTag::__warnings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SessionOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SessionOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session => {
                            if !fields.insert(__FieldTag::__session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session",
                                ));
                            }
                            result.session = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__session_uuid => {
                            if !fields.insert(__FieldTag::__session_uuid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_uuid",
                                ));
                            }
                            result.session_uuid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__done_time => {
                            if !fields.insert(__FieldTag::__done_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for done_time",
                                ));
                            }
                            result.done_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__operation_type => {
                            if !fields.insert(__FieldTag::__operation_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_type",
                                ));
                            }
                            result.operation_type = map
                                .next_value::<std::option::Option<
                                    crate::model::session_operation_metadata::SessionOperationType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__warnings => {
                            if !fields.insert(__FieldTag::__warnings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for warnings",
                                ));
                            }
                            result.warnings = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SessionOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.session.is_empty() {
            state.serialize_entry("session", &self.session)?;
        }
        if !self.session_uuid.is_empty() {
            state.serialize_entry("sessionUuid", &self.session_uuid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.done_time.is_some() {
            state.serialize_entry("doneTime", &self.done_time)?;
        }
        if !wkt::internal::is_default(&self.operation_type) {
            state.serialize_entry("operationType", &self.operation_type)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.warnings.is_empty() {
            state.serialize_entry("warnings", &self.warnings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SessionOperationMetadata].
pub mod session_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Operation type for Session resources
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SessionOperationType {
        /// Session operation type is unknown.
        Unspecified,
        /// Create Session operation type.
        Create,
        /// Terminate Session operation type.
        Terminate,
        /// Delete Session operation type.
        Delete,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SessionOperationType::value] or
        /// [SessionOperationType::name].
        UnknownValue(session_operation_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod session_operation_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SessionOperationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Create => std::option::Option::Some(1),
                Self::Terminate => std::option::Option::Some(2),
                Self::Delete => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("SESSION_OPERATION_TYPE_UNSPECIFIED")
                }
                Self::Create => std::option::Option::Some("CREATE"),
                Self::Terminate => std::option::Option::Some("TERMINATE"),
                Self::Delete => std::option::Option::Some("DELETE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SessionOperationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SessionOperationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SessionOperationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Create,
                2 => Self::Terminate,
                3 => Self::Delete,
                _ => Self::UnknownValue(session_operation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SessionOperationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SESSION_OPERATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CREATE" => Self::Create,
                "TERMINATE" => Self::Terminate,
                "DELETE" => Self::Delete,
                _ => Self::UnknownValue(session_operation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SessionOperationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Create => serializer.serialize_i32(1),
                Self::Terminate => serializer.serialize_i32(2),
                Self::Delete => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SessionOperationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SessionOperationType>::new(
                ".google.cloud.dataproc.v1.SessionOperationMetadata.SessionOperationType",
            ))
        }
    }
}

/// The status of the operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ClusterOperationStatus {
    /// Output only. A message containing the operation state.
    pub state: crate::model::cluster_operation_status::State,

    /// Output only. A message containing the detailed operation state.
    pub inner_state: std::string::String,

    /// Output only. A message containing any operation metadata details.
    pub details: std::string::String,

    /// Output only. The time this state was entered.
    pub state_start_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterOperationStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::ClusterOperationStatus::state].
    pub fn set_state<T: std::convert::Into<crate::model::cluster_operation_status::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [inner_state][crate::model::ClusterOperationStatus::inner_state].
    pub fn set_inner_state<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.inner_state = v.into();
        self
    }

    /// Sets the value of [details][crate::model::ClusterOperationStatus::details].
    pub fn set_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.details = v.into();
        self
    }

    /// Sets the value of [state_start_time][crate::model::ClusterOperationStatus::state_start_time].
    pub fn set_state_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_start_time][crate::model::ClusterOperationStatus::state_start_time].
    pub fn set_or_clear_state_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_start_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ClusterOperationStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ClusterOperationStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClusterOperationStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __inner_state,
            __details,
            __state_start_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClusterOperationStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "innerState" => Ok(__FieldTag::__inner_state),
                            "inner_state" => Ok(__FieldTag::__inner_state),
                            "details" => Ok(__FieldTag::__details),
                            "stateStartTime" => Ok(__FieldTag::__state_start_time),
                            "state_start_time" => Ok(__FieldTag::__state_start_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClusterOperationStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClusterOperationStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state =
                                map.next_value::<std::option::Option<
                                    crate::model::cluster_operation_status::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__inner_state => {
                            if !fields.insert(__FieldTag::__inner_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inner_state",
                                ));
                            }
                            result.inner_state = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_start_time => {
                            if !fields.insert(__FieldTag::__state_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_start_time",
                                ));
                            }
                            result.state_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ClusterOperationStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.inner_state.is_empty() {
            state.serialize_entry("innerState", &self.inner_state)?;
        }
        if !self.details.is_empty() {
            state.serialize_entry("details", &self.details)?;
        }
        if self.state_start_time.is_some() {
            state.serialize_entry("stateStartTime", &self.state_start_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ClusterOperationStatus].
pub mod cluster_operation_status {
    #[allow(unused_imports)]
    use super::*;

    /// The operation state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unused.
        Unknown,
        /// The operation has been created.
        Pending,
        /// The operation is running.
        Running,
        /// The operation is done; either cancelled or completed.
        Done,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Done => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Pending,
                2 => Self::Running,
                3 => Self::Done,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "PENDING" => Self::Pending,
                "RUNNING" => Self::Running,
                "DONE" => Self::Done,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Done => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataproc.v1.ClusterOperationStatus.State",
            ))
        }
    }
}

/// Metadata describing the operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ClusterOperationMetadata {
    /// Output only. Name of the cluster for the operation.
    pub cluster_name: std::string::String,

    /// Output only. Cluster UUID for the operation.
    pub cluster_uuid: std::string::String,

    /// Output only. Current operation status.
    pub status: std::option::Option<crate::model::ClusterOperationStatus>,

    /// Output only. The previous operation status.
    pub status_history: std::vec::Vec<crate::model::ClusterOperationStatus>,

    /// Output only. The operation type.
    pub operation_type: std::string::String,

    /// Output only. Short description of operation.
    pub description: std::string::String,

    /// Output only. Labels associated with the operation
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Errors encountered during operation execution.
    pub warnings: std::vec::Vec<std::string::String>,

    /// Output only. Child operation ids
    pub child_operation_ids: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_name][crate::model::ClusterOperationMetadata::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [cluster_uuid][crate::model::ClusterOperationMetadata::cluster_uuid].
    pub fn set_cluster_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uuid = v.into();
        self
    }

    /// Sets the value of [status][crate::model::ClusterOperationMetadata::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ClusterOperationStatus>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::ClusterOperationMetadata::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ClusterOperationStatus>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status_history][crate::model::ClusterOperationMetadata::status_history].
    pub fn set_status_history<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClusterOperationStatus>,
    {
        use std::iter::Iterator;
        self.status_history = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [operation_type][crate::model::ClusterOperationMetadata::operation_type].
    pub fn set_operation_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ClusterOperationMetadata::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ClusterOperationMetadata::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [warnings][crate::model::ClusterOperationMetadata::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [child_operation_ids][crate::model::ClusterOperationMetadata::child_operation_ids].
    pub fn set_child_operation_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.child_operation_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ClusterOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ClusterOperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClusterOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster_name,
            __cluster_uuid,
            __status,
            __status_history,
            __operation_type,
            __description,
            __labels,
            __warnings,
            __child_operation_ids,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClusterOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusterName" => Ok(__FieldTag::__cluster_name),
                            "cluster_name" => Ok(__FieldTag::__cluster_name),
                            "clusterUuid" => Ok(__FieldTag::__cluster_uuid),
                            "cluster_uuid" => Ok(__FieldTag::__cluster_uuid),
                            "status" => Ok(__FieldTag::__status),
                            "statusHistory" => Ok(__FieldTag::__status_history),
                            "status_history" => Ok(__FieldTag::__status_history),
                            "operationType" => Ok(__FieldTag::__operation_type),
                            "operation_type" => Ok(__FieldTag::__operation_type),
                            "description" => Ok(__FieldTag::__description),
                            "labels" => Ok(__FieldTag::__labels),
                            "warnings" => Ok(__FieldTag::__warnings),
                            "childOperationIds" => Ok(__FieldTag::__child_operation_ids),
                            "child_operation_ids" => Ok(__FieldTag::__child_operation_ids),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClusterOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClusterOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster_name => {
                            if !fields.insert(__FieldTag::__cluster_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_name",
                                ));
                            }
                            result.cluster_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_uuid => {
                            if !fields.insert(__FieldTag::__cluster_uuid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_uuid",
                                ));
                            }
                            result.cluster_uuid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map.next_value::<std::option::Option<crate::model::ClusterOperationStatus>>()?
                                ;
                        }
                        __FieldTag::__status_history => {
                            if !fields.insert(__FieldTag::__status_history) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_history",
                                ));
                            }
                            result.status_history = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ClusterOperationStatus>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__operation_type => {
                            if !fields.insert(__FieldTag::__operation_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_type",
                                ));
                            }
                            result.operation_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__warnings => {
                            if !fields.insert(__FieldTag::__warnings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for warnings",
                                ));
                            }
                            result.warnings = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__child_operation_ids => {
                            if !fields.insert(__FieldTag::__child_operation_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for child_operation_ids",
                                ));
                            }
                            result.child_operation_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ClusterOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cluster_name.is_empty() {
            state.serialize_entry("clusterName", &self.cluster_name)?;
        }
        if !self.cluster_uuid.is_empty() {
            state.serialize_entry("clusterUuid", &self.cluster_uuid)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.status_history.is_empty() {
            state.serialize_entry("statusHistory", &self.status_history)?;
        }
        if !self.operation_type.is_empty() {
            state.serialize_entry("operationType", &self.operation_type)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.warnings.is_empty() {
            state.serialize_entry("warnings", &self.warnings)?;
        }
        if !self.child_operation_ids.is_empty() {
            state.serialize_entry("childOperationIds", &self.child_operation_ids)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata describing the node group operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NodeGroupOperationMetadata {
    /// Output only. Node group ID for the operation.
    pub node_group_id: std::string::String,

    /// Output only. Cluster UUID associated with the node group operation.
    pub cluster_uuid: std::string::String,

    /// Output only. Current operation status.
    pub status: std::option::Option<crate::model::ClusterOperationStatus>,

    /// Output only. The previous operation status.
    pub status_history: std::vec::Vec<crate::model::ClusterOperationStatus>,

    /// The operation type.
    pub operation_type: crate::model::node_group_operation_metadata::NodeGroupOperationType,

    /// Output only. Short description of operation.
    pub description: std::string::String,

    /// Output only. Labels associated with the operation.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Errors encountered during operation execution.
    pub warnings: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeGroupOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [node_group_id][crate::model::NodeGroupOperationMetadata::node_group_id].
    pub fn set_node_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_group_id = v.into();
        self
    }

    /// Sets the value of [cluster_uuid][crate::model::NodeGroupOperationMetadata::cluster_uuid].
    pub fn set_cluster_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uuid = v.into();
        self
    }

    /// Sets the value of [status][crate::model::NodeGroupOperationMetadata::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ClusterOperationStatus>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::NodeGroupOperationMetadata::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ClusterOperationStatus>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status_history][crate::model::NodeGroupOperationMetadata::status_history].
    pub fn set_status_history<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClusterOperationStatus>,
    {
        use std::iter::Iterator;
        self.status_history = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [operation_type][crate::model::NodeGroupOperationMetadata::operation_type].
    pub fn set_operation_type<
        T: std::convert::Into<crate::model::node_group_operation_metadata::NodeGroupOperationType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation_type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::NodeGroupOperationMetadata::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::NodeGroupOperationMetadata::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [warnings][crate::model::NodeGroupOperationMetadata::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NodeGroupOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.NodeGroupOperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodeGroupOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __node_group_id,
            __cluster_uuid,
            __status,
            __status_history,
            __operation_type,
            __description,
            __labels,
            __warnings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeGroupOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nodeGroupId" => Ok(__FieldTag::__node_group_id),
                            "node_group_id" => Ok(__FieldTag::__node_group_id),
                            "clusterUuid" => Ok(__FieldTag::__cluster_uuid),
                            "cluster_uuid" => Ok(__FieldTag::__cluster_uuid),
                            "status" => Ok(__FieldTag::__status),
                            "statusHistory" => Ok(__FieldTag::__status_history),
                            "status_history" => Ok(__FieldTag::__status_history),
                            "operationType" => Ok(__FieldTag::__operation_type),
                            "operation_type" => Ok(__FieldTag::__operation_type),
                            "description" => Ok(__FieldTag::__description),
                            "labels" => Ok(__FieldTag::__labels),
                            "warnings" => Ok(__FieldTag::__warnings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodeGroupOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeGroupOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__node_group_id => {
                            if !fields.insert(__FieldTag::__node_group_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_group_id",
                                ));
                            }
                            result.node_group_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_uuid => {
                            if !fields.insert(__FieldTag::__cluster_uuid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_uuid",
                                ));
                            }
                            result.cluster_uuid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map.next_value::<std::option::Option<crate::model::ClusterOperationStatus>>()?
                                ;
                        }
                        __FieldTag::__status_history => {
                            if !fields.insert(__FieldTag::__status_history) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_history",
                                ));
                            }
                            result.status_history = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ClusterOperationStatus>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__operation_type => {
                            if !fields.insert(__FieldTag::__operation_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_type",
                                ));
                            }
                            result.operation_type = map.next_value::<std::option::Option<crate::model::node_group_operation_metadata::NodeGroupOperationType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__warnings => {
                            if !fields.insert(__FieldTag::__warnings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for warnings",
                                ));
                            }
                            result.warnings = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodeGroupOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.node_group_id.is_empty() {
            state.serialize_entry("nodeGroupId", &self.node_group_id)?;
        }
        if !self.cluster_uuid.is_empty() {
            state.serialize_entry("clusterUuid", &self.cluster_uuid)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.status_history.is_empty() {
            state.serialize_entry("statusHistory", &self.status_history)?;
        }
        if !wkt::internal::is_default(&self.operation_type) {
            state.serialize_entry("operationType", &self.operation_type)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.warnings.is_empty() {
            state.serialize_entry("warnings", &self.warnings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [NodeGroupOperationMetadata].
pub mod node_group_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Operation type for node group resources.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NodeGroupOperationType {
        /// Node group operation type is unknown.
        Unspecified,
        /// Create node group operation type.
        Create,
        /// Update node group operation type.
        Update,
        /// Delete node group operation type.
        Delete,
        /// Resize node group operation type.
        Resize,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [NodeGroupOperationType::value] or
        /// [NodeGroupOperationType::name].
        UnknownValue(node_group_operation_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod node_group_operation_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl NodeGroupOperationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Create => std::option::Option::Some(1),
                Self::Update => std::option::Option::Some(2),
                Self::Delete => std::option::Option::Some(3),
                Self::Resize => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("NODE_GROUP_OPERATION_TYPE_UNSPECIFIED")
                }
                Self::Create => std::option::Option::Some("CREATE"),
                Self::Update => std::option::Option::Some("UPDATE"),
                Self::Delete => std::option::Option::Some("DELETE"),
                Self::Resize => std::option::Option::Some("RESIZE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for NodeGroupOperationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for NodeGroupOperationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for NodeGroupOperationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Create,
                2 => Self::Update,
                3 => Self::Delete,
                4 => Self::Resize,
                _ => Self::UnknownValue(node_group_operation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for NodeGroupOperationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NODE_GROUP_OPERATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CREATE" => Self::Create,
                "UPDATE" => Self::Update,
                "DELETE" => Self::Delete,
                "RESIZE" => Self::Resize,
                _ => Self::UnknownValue(node_group_operation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for NodeGroupOperationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Create => serializer.serialize_i32(1),
                Self::Update => serializer.serialize_i32(2),
                Self::Delete => serializer.serialize_i32(3),
                Self::Resize => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for NodeGroupOperationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<NodeGroupOperationType>::new(
                ".google.cloud.dataproc.v1.NodeGroupOperationMetadata.NodeGroupOperationType",
            ))
        }
    }
}

/// A request to create a session template.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSessionTemplateRequest {
    /// Required. The parent resource where this session template will be created.
    pub parent: std::string::String,

    /// Required. The session template to create.
    pub session_template: std::option::Option<crate::model::SessionTemplate>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSessionTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSessionTemplateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [session_template][crate::model::CreateSessionTemplateRequest::session_template].
    pub fn set_session_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SessionTemplate>,
    {
        self.session_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [session_template][crate::model::CreateSessionTemplateRequest::session_template].
    pub fn set_or_clear_session_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SessionTemplate>,
    {
        self.session_template = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateSessionTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.CreateSessionTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSessionTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __session_template,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSessionTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "sessionTemplate" => Ok(__FieldTag::__session_template),
                            "session_template" => Ok(__FieldTag::__session_template),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSessionTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSessionTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__session_template => {
                            if !fields.insert(__FieldTag::__session_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_template",
                                ));
                            }
                            result.session_template = map
                                .next_value::<std::option::Option<crate::model::SessionTemplate>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateSessionTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.session_template.is_some() {
            state.serialize_entry("sessionTemplate", &self.session_template)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to update a session template.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSessionTemplateRequest {
    /// Required. The updated session template.
    pub session_template: std::option::Option<crate::model::SessionTemplate>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSessionTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [session_template][crate::model::UpdateSessionTemplateRequest::session_template].
    pub fn set_session_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SessionTemplate>,
    {
        self.session_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [session_template][crate::model::UpdateSessionTemplateRequest::session_template].
    pub fn set_or_clear_session_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SessionTemplate>,
    {
        self.session_template = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateSessionTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.UpdateSessionTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSessionTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session_template,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSessionTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sessionTemplate" => Ok(__FieldTag::__session_template),
                            "session_template" => Ok(__FieldTag::__session_template),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSessionTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSessionTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session_template => {
                            if !fields.insert(__FieldTag::__session_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_template",
                                ));
                            }
                            result.session_template = map
                                .next_value::<std::option::Option<crate::model::SessionTemplate>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateSessionTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.session_template.is_some() {
            state.serialize_entry("sessionTemplate", &self.session_template)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to get the resource representation for a session template.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSessionTemplateRequest {
    /// Required. The name of the session template to retrieve.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSessionTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSessionTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSessionTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GetSessionTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSessionTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSessionTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSessionTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSessionTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSessionTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to list session templates in a project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSessionTemplatesRequest {
    /// Required. The parent that owns this collection of session templates.
    pub parent: std::string::String,

    /// Optional. The maximum number of sessions to return in each response.
    /// The service may return fewer than this value.
    pub page_size: i32,

    /// Optional. A page token received from a previous `ListSessions` call.
    /// Provide this token to retrieve the subsequent page.
    pub page_token: std::string::String,

    /// Optional. A filter for the session templates to return in the response.
    /// Filters are case sensitive and have the following syntax:
    ///
    /// [field = value] AND [field [= value]] ...
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSessionTemplatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSessionTemplatesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSessionTemplatesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSessionTemplatesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSessionTemplatesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListSessionTemplatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListSessionTemplatesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSessionTemplatesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSessionTemplatesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSessionTemplatesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSessionTemplatesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSessionTemplatesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A list of session templates.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSessionTemplatesResponse {
    /// Output only. Session template list
    pub session_templates: std::vec::Vec<crate::model::SessionTemplate>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSessionTemplatesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [session_templates][crate::model::ListSessionTemplatesResponse::session_templates].
    pub fn set_session_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SessionTemplate>,
    {
        use std::iter::Iterator;
        self.session_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSessionTemplatesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSessionTemplatesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListSessionTemplatesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSessionTemplatesResponse {
    type PageItem = crate::model::SessionTemplate;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.session_templates
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSessionTemplatesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session_templates,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSessionTemplatesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sessionTemplates" => Ok(__FieldTag::__session_templates),
                            "session_templates" => Ok(__FieldTag::__session_templates),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSessionTemplatesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSessionTemplatesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session_templates => {
                            if !fields.insert(__FieldTag::__session_templates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_templates",
                                ));
                            }
                            result.session_templates =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SessionTemplate>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSessionTemplatesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.session_templates.is_empty() {
            state.serialize_entry("sessionTemplates", &self.session_templates)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to delete a session template.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSessionTemplateRequest {
    /// Required. The name of the session template resource to delete.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSessionTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSessionTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSessionTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DeleteSessionTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSessionTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSessionTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSessionTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSessionTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteSessionTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A representation of a session template.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SessionTemplate {
    /// Required. The resource name of the session template.
    pub name: std::string::String,

    /// Optional. Brief description of the template.
    pub description: std::string::String,

    /// Output only. The time when the template was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The email address of the user who created the template.
    pub creator: std::string::String,

    /// Optional. Labels to associate with sessions created using this template.
    /// Label **keys** must contain 1 to 63 characters, and must conform to
    /// [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt).
    /// Label **values** can be empty, but, if present, must contain 1 to 63
    /// characters and conform to [RFC
    /// 1035](https://www.ietf.org/rfc/rfc1035.txt). No more than 32 labels can be
    /// associated with a session.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Runtime configuration for session execution.
    pub runtime_config: std::option::Option<crate::model::RuntimeConfig>,

    /// Optional. Environment configuration for session execution.
    pub environment_config: std::option::Option<crate::model::EnvironmentConfig>,

    /// Output only. The time the template was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. A session template UUID (Unique Universal Identifier). The
    /// service generates this value when it creates the session template.
    pub uuid: std::string::String,

    /// The session configuration.
    pub session_config: std::option::Option<crate::model::session_template::SessionConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SessionTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SessionTemplate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::SessionTemplate::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::SessionTemplate::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::SessionTemplate::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creator][crate::model::SessionTemplate::creator].
    pub fn set_creator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.creator = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::SessionTemplate::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [runtime_config][crate::model::SessionTemplate::runtime_config].
    pub fn set_runtime_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RuntimeConfig>,
    {
        self.runtime_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [runtime_config][crate::model::SessionTemplate::runtime_config].
    pub fn set_or_clear_runtime_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RuntimeConfig>,
    {
        self.runtime_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [environment_config][crate::model::SessionTemplate::environment_config].
    pub fn set_environment_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EnvironmentConfig>,
    {
        self.environment_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [environment_config][crate::model::SessionTemplate::environment_config].
    pub fn set_or_clear_environment_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EnvironmentConfig>,
    {
        self.environment_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::SessionTemplate::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::SessionTemplate::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [uuid][crate::model::SessionTemplate::uuid].
    pub fn set_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uuid = v.into();
        self
    }

    /// Sets the value of [session_config][crate::model::SessionTemplate::session_config].
    ///
    /// Note that all the setters affecting `session_config` are mutually
    /// exclusive.
    pub fn set_session_config<
        T: std::convert::Into<std::option::Option<crate::model::session_template::SessionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.session_config = v.into();
        self
    }

    /// The value of [session_config][crate::model::SessionTemplate::session_config]
    /// if it holds a `JupyterSession`, `None` if the field is not set or
    /// holds a different branch.
    pub fn jupyter_session(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::JupyterConfig>> {
        #[allow(unreachable_patterns)]
        self.session_config.as_ref().and_then(|v| match v {
            crate::model::session_template::SessionConfig::JupyterSession(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [session_config][crate::model::SessionTemplate::session_config]
    /// to hold a `JupyterSession`.
    ///
    /// Note that all the setters affecting `session_config` are
    /// mutually exclusive.
    pub fn set_jupyter_session<
        T: std::convert::Into<std::boxed::Box<crate::model::JupyterConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.session_config = std::option::Option::Some(
            crate::model::session_template::SessionConfig::JupyterSession(v.into()),
        );
        self
    }

    /// The value of [session_config][crate::model::SessionTemplate::session_config]
    /// if it holds a `SparkConnectSession`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_connect_session(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SparkConnectConfig>> {
        #[allow(unreachable_patterns)]
        self.session_config.as_ref().and_then(|v| match v {
            crate::model::session_template::SessionConfig::SparkConnectSession(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [session_config][crate::model::SessionTemplate::session_config]
    /// to hold a `SparkConnectSession`.
    ///
    /// Note that all the setters affecting `session_config` are
    /// mutually exclusive.
    pub fn set_spark_connect_session<
        T: std::convert::Into<std::boxed::Box<crate::model::SparkConnectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.session_config = std::option::Option::Some(
            crate::model::session_template::SessionConfig::SparkConnectSession(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SessionTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SessionTemplate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SessionTemplate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __create_time,
            __jupyter_session,
            __spark_connect_session,
            __creator,
            __labels,
            __runtime_config,
            __environment_config,
            __update_time,
            __uuid,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SessionTemplate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "jupyterSession" => Ok(__FieldTag::__jupyter_session),
                            "jupyter_session" => Ok(__FieldTag::__jupyter_session),
                            "sparkConnectSession" => Ok(__FieldTag::__spark_connect_session),
                            "spark_connect_session" => Ok(__FieldTag::__spark_connect_session),
                            "creator" => Ok(__FieldTag::__creator),
                            "labels" => Ok(__FieldTag::__labels),
                            "runtimeConfig" => Ok(__FieldTag::__runtime_config),
                            "runtime_config" => Ok(__FieldTag::__runtime_config),
                            "environmentConfig" => Ok(__FieldTag::__environment_config),
                            "environment_config" => Ok(__FieldTag::__environment_config),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "uuid" => Ok(__FieldTag::__uuid),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SessionTemplate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SessionTemplate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__jupyter_session => {
                            if !fields.insert(__FieldTag::__jupyter_session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jupyter_session",
                                ));
                            }
                            if result.session_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `session_config`, a oneof with full ID .google.cloud.dataproc.v1.SessionTemplate.jupyter_session, latest field was jupyterSession",
                                ));
                            }
                            result.session_config = std::option::Option::Some(
                                crate::model::session_template::SessionConfig::JupyterSession(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::JupyterConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__spark_connect_session => {
                            if !fields.insert(__FieldTag::__spark_connect_session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark_connect_session",
                                ));
                            }
                            if result.session_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `session_config`, a oneof with full ID .google.cloud.dataproc.v1.SessionTemplate.spark_connect_session, latest field was sparkConnectSession",
                                ));
                            }
                            result.session_config = std::option::Option::Some(
                                crate::model::session_template::SessionConfig::SparkConnectSession(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SparkConnectConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__creator => {
                            if !fields.insert(__FieldTag::__creator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creator",
                                ));
                            }
                            result.creator = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__runtime_config => {
                            if !fields.insert(__FieldTag::__runtime_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_config",
                                ));
                            }
                            result.runtime_config = map
                                .next_value::<std::option::Option<crate::model::RuntimeConfig>>()?;
                        }
                        __FieldTag::__environment_config => {
                            if !fields.insert(__FieldTag::__environment_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment_config",
                                ));
                            }
                            result.environment_config = map
                                .next_value::<std::option::Option<crate::model::EnvironmentConfig>>(
                                )?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__uuid => {
                            if !fields.insert(__FieldTag::__uuid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uuid",
                                ));
                            }
                            result.uuid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SessionTemplate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if let Some(value) = self.jupyter_session() {
            state.serialize_entry("jupyterSession", value)?;
        }
        if let Some(value) = self.spark_connect_session() {
            state.serialize_entry("sparkConnectSession", value)?;
        }
        if !self.creator.is_empty() {
            state.serialize_entry("creator", &self.creator)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.runtime_config.is_some() {
            state.serialize_entry("runtimeConfig", &self.runtime_config)?;
        }
        if self.environment_config.is_some() {
            state.serialize_entry("environmentConfig", &self.environment_config)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.uuid.is_empty() {
            state.serialize_entry("uuid", &self.uuid)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SessionTemplate].
pub mod session_template {
    #[allow(unused_imports)]
    use super::*;

    /// The session configuration.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SessionConfig {
        /// Optional. Jupyter session config.
        JupyterSession(std::boxed::Box<crate::model::JupyterConfig>),
        /// Optional. Spark Connect session config.
        SparkConnectSession(std::boxed::Box<crate::model::SparkConnectConfig>),
    }
}

/// A request to create a session.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSessionRequest {
    /// Required. The parent resource where this session will be created.
    pub parent: std::string::String,

    /// Required. The interactive session to create.
    pub session: std::option::Option<crate::model::Session>,

    /// Required. The ID to use for the session, which becomes the final component
    /// of the session's resource name.
    ///
    /// This value must be 4-63 characters. Valid characters
    /// are /[a-z][0-9]-/.
    pub session_id: std::string::String,

    /// Optional. A unique ID used to identify the request. If the service
    /// receives two
    /// [CreateSessionRequests](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.CreateSessionRequest)s
    /// with the same ID, the second request is ignored, and the
    /// first [Session][google.cloud.dataproc.v1.Session] is created and stored in
    /// the backend.
    ///
    /// Recommendation: Set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The value must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    ///
    /// [google.cloud.dataproc.v1.Session]: crate::model::Session
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSessionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [session][crate::model::CreateSessionRequest::session].
    pub fn set_session<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Session>,
    {
        self.session = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [session][crate::model::CreateSessionRequest::session].
    pub fn set_or_clear_session<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Session>,
    {
        self.session = v.map(|x| x.into());
        self
    }

    /// Sets the value of [session_id][crate::model::CreateSessionRequest::session_id].
    pub fn set_session_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.session_id = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateSessionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.CreateSessionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __session,
            __session_id,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "session" => Ok(__FieldTag::__session),
                            "sessionId" => Ok(__FieldTag::__session_id),
                            "session_id" => Ok(__FieldTag::__session_id),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__session => {
                            if !fields.insert(__FieldTag::__session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session",
                                ));
                            }
                            result.session =
                                map.next_value::<std::option::Option<crate::model::Session>>()?;
                        }
                        __FieldTag::__session_id => {
                            if !fields.insert(__FieldTag::__session_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_id",
                                ));
                            }
                            result.session_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.session.is_some() {
            state.serialize_entry("session", &self.session)?;
        }
        if !self.session_id.is_empty() {
            state.serialize_entry("sessionId", &self.session_id)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to get the resource representation for a session.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSessionRequest {
    /// Required. The name of the session to retrieve.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSessionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GetSessionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to list sessions in a project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSessionsRequest {
    /// Required. The parent, which owns this collection of sessions.
    pub parent: std::string::String,

    /// Optional. The maximum number of sessions to return in each response.
    /// The service may return fewer than this value.
    pub page_size: i32,

    /// Optional. A page token received from a previous `ListSessions` call.
    /// Provide this token to retrieve the subsequent page.
    pub page_token: std::string::String,

    /// Optional. A filter for the sessions to return in the response.
    ///
    /// A filter is a logical expression constraining the values of various fields
    /// in each session resource. Filters are case sensitive, and may contain
    /// multiple clauses combined with logical operators (AND, OR).
    /// Supported fields are `session_id`, `session_uuid`, `state`, `create_time`,
    /// and `labels`.
    ///
    /// Example: `state = ACTIVE and create_time < "2023-01-01T00:00:00Z"`
    /// is a filter for sessions in an ACTIVE state that were created before
    /// 2023-01-01. `state = ACTIVE and labels.environment=production` is a filter
    /// for sessions in an ACTIVE state that have a production environment label.
    ///
    /// See <https://google.aip.dev/assets/misc/ebnf-filtering.txt> for a detailed
    /// description of the filter syntax and a list of supported comparators.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSessionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSessionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSessionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSessionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSessionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListSessionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListSessionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSessionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSessionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSessionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSessionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSessionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A list of interactive sessions.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSessionsResponse {
    /// Output only. The sessions from the specified collection.
    pub sessions: std::vec::Vec<crate::model::Session>,

    /// A token, which can be sent as `page_token`, to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSessionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sessions][crate::model::ListSessionsResponse::sessions].
    pub fn set_sessions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Session>,
    {
        use std::iter::Iterator;
        self.sessions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSessionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSessionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListSessionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSessionsResponse {
    type PageItem = crate::model::Session;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.sessions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSessionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sessions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSessionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sessions" => Ok(__FieldTag::__sessions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSessionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSessionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sessions => {
                            if !fields.insert(__FieldTag::__sessions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sessions",
                                ));
                            }
                            result.sessions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Session>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSessionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sessions.is_empty() {
            state.serialize_entry("sessions", &self.sessions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to terminate an interactive session.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TerminateSessionRequest {
    /// Required. The name of the session resource to terminate.
    pub name: std::string::String,

    /// Optional. A unique ID used to identify the request. If the service
    /// receives two
    /// [TerminateSessionRequest](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.TerminateSessionRequest)s
    /// with the same ID, the second request is ignored.
    ///
    /// Recommendation: Set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The value must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TerminateSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TerminateSessionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::TerminateSessionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for TerminateSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.TerminateSessionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TerminateSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TerminateSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TerminateSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TerminateSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TerminateSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to delete a session.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSessionRequest {
    /// Required. The name of the session resource to delete.
    pub name: std::string::String,

    /// Optional. A unique ID used to identify the request. If the service
    /// receives two
    /// [DeleteSessionRequest](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.DeleteSessionRequest)s
    /// with the same ID, the second request is ignored.
    ///
    /// Recommendation: Set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The value must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSessionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteSessionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DeleteSessionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A representation of a session.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Session {
    /// Required. The resource name of the session.
    pub name: std::string::String,

    /// Output only. A session UUID (Unique Universal Identifier). The service
    /// generates this value when it creates the session.
    pub uuid: std::string::String,

    /// Output only. The time when the session was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Runtime information about session execution.
    pub runtime_info: std::option::Option<crate::model::RuntimeInfo>,

    /// Output only. A state of the session.
    pub state: crate::model::session::State,

    /// Output only. Session state details, such as the failure
    /// description if the state is `FAILED`.
    pub state_message: std::string::String,

    /// Output only. The time when the session entered the current state.
    pub state_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The email address of the user who created the session.
    pub creator: std::string::String,

    /// Optional. The labels to associate with the session.
    /// Label **keys** must contain 1 to 63 characters, and must conform to
    /// [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt).
    /// Label **values** may be empty, but, if present, must contain 1 to 63
    /// characters, and must conform to [RFC
    /// 1035](https://www.ietf.org/rfc/rfc1035.txt). No more than 32 labels can be
    /// associated with a session.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Runtime configuration for the session execution.
    pub runtime_config: std::option::Option<crate::model::RuntimeConfig>,

    /// Optional. Environment configuration for the session execution.
    pub environment_config: std::option::Option<crate::model::EnvironmentConfig>,

    /// Optional. The email address of the user who owns the session.
    pub user: std::string::String,

    /// Output only. Historical state information for the session.
    pub state_history: std::vec::Vec<crate::model::session::SessionStateHistory>,

    /// Optional. The session template used by the session.
    ///
    /// Only resource names, including project ID and location, are valid.
    ///
    /// Example:
    ///
    /// * `<https://www.googleapis.com/compute/v1/projects/>[project_id]/locations/[dataproc_region]/sessionTemplates/[template_id]`
    /// * `projects/[project_id]/locations/[dataproc_region]/sessionTemplates/[template_id]`
    ///
    /// The template must be in the same project and Dataproc region as the
    /// session.
    pub session_template: std::string::String,

    /// The session configuration.
    pub session_config: std::option::Option<crate::model::session::SessionConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Session {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Session::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uuid][crate::model::Session::uuid].
    pub fn set_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uuid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Session::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Session::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [runtime_info][crate::model::Session::runtime_info].
    pub fn set_runtime_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RuntimeInfo>,
    {
        self.runtime_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [runtime_info][crate::model::Session::runtime_info].
    pub fn set_or_clear_runtime_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RuntimeInfo>,
    {
        self.runtime_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Session::state].
    pub fn set_state<T: std::convert::Into<crate::model::session::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_message][crate::model::Session::state_message].
    pub fn set_state_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_message = v.into();
        self
    }

    /// Sets the value of [state_time][crate::model::Session::state_time].
    pub fn set_state_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_time][crate::model::Session::state_time].
    pub fn set_or_clear_state_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creator][crate::model::Session::creator].
    pub fn set_creator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.creator = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Session::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [runtime_config][crate::model::Session::runtime_config].
    pub fn set_runtime_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RuntimeConfig>,
    {
        self.runtime_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [runtime_config][crate::model::Session::runtime_config].
    pub fn set_or_clear_runtime_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RuntimeConfig>,
    {
        self.runtime_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [environment_config][crate::model::Session::environment_config].
    pub fn set_environment_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EnvironmentConfig>,
    {
        self.environment_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [environment_config][crate::model::Session::environment_config].
    pub fn set_or_clear_environment_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EnvironmentConfig>,
    {
        self.environment_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user][crate::model::Session::user].
    pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [state_history][crate::model::Session::state_history].
    pub fn set_state_history<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::session::SessionStateHistory>,
    {
        use std::iter::Iterator;
        self.state_history = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [session_template][crate::model::Session::session_template].
    pub fn set_session_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.session_template = v.into();
        self
    }

    /// Sets the value of [session_config][crate::model::Session::session_config].
    ///
    /// Note that all the setters affecting `session_config` are mutually
    /// exclusive.
    pub fn set_session_config<
        T: std::convert::Into<std::option::Option<crate::model::session::SessionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.session_config = v.into();
        self
    }

    /// The value of [session_config][crate::model::Session::session_config]
    /// if it holds a `JupyterSession`, `None` if the field is not set or
    /// holds a different branch.
    pub fn jupyter_session(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::JupyterConfig>> {
        #[allow(unreachable_patterns)]
        self.session_config.as_ref().and_then(|v| match v {
            crate::model::session::SessionConfig::JupyterSession(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [session_config][crate::model::Session::session_config]
    /// to hold a `JupyterSession`.
    ///
    /// Note that all the setters affecting `session_config` are
    /// mutually exclusive.
    pub fn set_jupyter_session<
        T: std::convert::Into<std::boxed::Box<crate::model::JupyterConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.session_config = std::option::Option::Some(
            crate::model::session::SessionConfig::JupyterSession(v.into()),
        );
        self
    }

    /// The value of [session_config][crate::model::Session::session_config]
    /// if it holds a `SparkConnectSession`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_connect_session(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SparkConnectConfig>> {
        #[allow(unreachable_patterns)]
        self.session_config.as_ref().and_then(|v| match v {
            crate::model::session::SessionConfig::SparkConnectSession(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [session_config][crate::model::Session::session_config]
    /// to hold a `SparkConnectSession`.
    ///
    /// Note that all the setters affecting `session_config` are
    /// mutually exclusive.
    pub fn set_spark_connect_session<
        T: std::convert::Into<std::boxed::Box<crate::model::SparkConnectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.session_config = std::option::Option::Some(
            crate::model::session::SessionConfig::SparkConnectSession(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Session {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.Session"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Session {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uuid,
            __create_time,
            __jupyter_session,
            __spark_connect_session,
            __runtime_info,
            __state,
            __state_message,
            __state_time,
            __creator,
            __labels,
            __runtime_config,
            __environment_config,
            __user,
            __state_history,
            __session_template,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Session")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uuid" => Ok(__FieldTag::__uuid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "jupyterSession" => Ok(__FieldTag::__jupyter_session),
                            "jupyter_session" => Ok(__FieldTag::__jupyter_session),
                            "sparkConnectSession" => Ok(__FieldTag::__spark_connect_session),
                            "spark_connect_session" => Ok(__FieldTag::__spark_connect_session),
                            "runtimeInfo" => Ok(__FieldTag::__runtime_info),
                            "runtime_info" => Ok(__FieldTag::__runtime_info),
                            "state" => Ok(__FieldTag::__state),
                            "stateMessage" => Ok(__FieldTag::__state_message),
                            "state_message" => Ok(__FieldTag::__state_message),
                            "stateTime" => Ok(__FieldTag::__state_time),
                            "state_time" => Ok(__FieldTag::__state_time),
                            "creator" => Ok(__FieldTag::__creator),
                            "labels" => Ok(__FieldTag::__labels),
                            "runtimeConfig" => Ok(__FieldTag::__runtime_config),
                            "runtime_config" => Ok(__FieldTag::__runtime_config),
                            "environmentConfig" => Ok(__FieldTag::__environment_config),
                            "environment_config" => Ok(__FieldTag::__environment_config),
                            "user" => Ok(__FieldTag::__user),
                            "stateHistory" => Ok(__FieldTag::__state_history),
                            "state_history" => Ok(__FieldTag::__state_history),
                            "sessionTemplate" => Ok(__FieldTag::__session_template),
                            "session_template" => Ok(__FieldTag::__session_template),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Session;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Session")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uuid => {
                            if !fields.insert(__FieldTag::__uuid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uuid",
                                ));
                            }
                            result.uuid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__jupyter_session => {
                            if !fields.insert(__FieldTag::__jupyter_session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jupyter_session",
                                ));
                            }
                            if result.session_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `session_config`, a oneof with full ID .google.cloud.dataproc.v1.Session.jupyter_session, latest field was jupyterSession",
                                ));
                            }
                            result.session_config = std::option::Option::Some(
                                crate::model::session::SessionConfig::JupyterSession(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::JupyterConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__spark_connect_session => {
                            if !fields.insert(__FieldTag::__spark_connect_session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark_connect_session",
                                ));
                            }
                            if result.session_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `session_config`, a oneof with full ID .google.cloud.dataproc.v1.Session.spark_connect_session, latest field was sparkConnectSession",
                                ));
                            }
                            result.session_config = std::option::Option::Some(
                                crate::model::session::SessionConfig::SparkConnectSession(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SparkConnectConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__runtime_info => {
                            if !fields.insert(__FieldTag::__runtime_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_info",
                                ));
                            }
                            result.runtime_info =
                                map.next_value::<std::option::Option<crate::model::RuntimeInfo>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::session::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_message => {
                            if !fields.insert(__FieldTag::__state_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_message",
                                ));
                            }
                            result.state_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_time => {
                            if !fields.insert(__FieldTag::__state_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_time",
                                ));
                            }
                            result.state_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__creator => {
                            if !fields.insert(__FieldTag::__creator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creator",
                                ));
                            }
                            result.creator = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__runtime_config => {
                            if !fields.insert(__FieldTag::__runtime_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for runtime_config",
                                ));
                            }
                            result.runtime_config = map
                                .next_value::<std::option::Option<crate::model::RuntimeConfig>>()?;
                        }
                        __FieldTag::__environment_config => {
                            if !fields.insert(__FieldTag::__environment_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment_config",
                                ));
                            }
                            result.environment_config = map
                                .next_value::<std::option::Option<crate::model::EnvironmentConfig>>(
                                )?;
                        }
                        __FieldTag::__user => {
                            if !fields.insert(__FieldTag::__user) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user",
                                ));
                            }
                            result.user = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_history => {
                            if !fields.insert(__FieldTag::__state_history) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_history",
                                ));
                            }
                            result.state_history = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::session::SessionStateHistory>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__session_template => {
                            if !fields.insert(__FieldTag::__session_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_template",
                                ));
                            }
                            result.session_template = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Session {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uuid.is_empty() {
            state.serialize_entry("uuid", &self.uuid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if let Some(value) = self.jupyter_session() {
            state.serialize_entry("jupyterSession", value)?;
        }
        if let Some(value) = self.spark_connect_session() {
            state.serialize_entry("sparkConnectSession", value)?;
        }
        if self.runtime_info.is_some() {
            state.serialize_entry("runtimeInfo", &self.runtime_info)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_message.is_empty() {
            state.serialize_entry("stateMessage", &self.state_message)?;
        }
        if self.state_time.is_some() {
            state.serialize_entry("stateTime", &self.state_time)?;
        }
        if !self.creator.is_empty() {
            state.serialize_entry("creator", &self.creator)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.runtime_config.is_some() {
            state.serialize_entry("runtimeConfig", &self.runtime_config)?;
        }
        if self.environment_config.is_some() {
            state.serialize_entry("environmentConfig", &self.environment_config)?;
        }
        if !self.user.is_empty() {
            state.serialize_entry("user", &self.user)?;
        }
        if !self.state_history.is_empty() {
            state.serialize_entry("stateHistory", &self.state_history)?;
        }
        if !self.session_template.is_empty() {
            state.serialize_entry("sessionTemplate", &self.session_template)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Session].
pub mod session {
    #[allow(unused_imports)]
    use super::*;

    /// Historical state information.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SessionStateHistory {
        /// Output only. The state of the session at this point in the session
        /// history.
        pub state: crate::model::session::State,

        /// Output only. Details about the state at this point in the session
        /// history.
        pub state_message: std::string::String,

        /// Output only. The time when the session entered the historical state.
        pub state_start_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SessionStateHistory {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::session::SessionStateHistory::state].
        pub fn set_state<T: std::convert::Into<crate::model::session::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [state_message][crate::model::session::SessionStateHistory::state_message].
        pub fn set_state_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.state_message = v.into();
            self
        }

        /// Sets the value of [state_start_time][crate::model::session::SessionStateHistory::state_start_time].
        pub fn set_state_start_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.state_start_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [state_start_time][crate::model::session::SessionStateHistory::state_start_time].
        pub fn set_or_clear_state_start_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.state_start_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SessionStateHistory {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataproc.v1.Session.SessionStateHistory"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SessionStateHistory {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __state,
                __state_message,
                __state_start_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SessionStateHistory")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "state" => Ok(__FieldTag::__state),
                                "stateMessage" => Ok(__FieldTag::__state_message),
                                "state_message" => Ok(__FieldTag::__state_message),
                                "stateStartTime" => Ok(__FieldTag::__state_start_time),
                                "state_start_time" => Ok(__FieldTag::__state_start_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SessionStateHistory;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SessionStateHistory")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map.next_value::<std::option::Option<crate::model::session::State>>()?.unwrap_or_default();
                            }
                            __FieldTag::__state_message => {
                                if !fields.insert(__FieldTag::__state_message) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state_message",
                                    ));
                                }
                                result.state_message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__state_start_time => {
                                if !fields.insert(__FieldTag::__state_start_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state_start_time",
                                    ));
                                }
                                result.state_start_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SessionStateHistory {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if !self.state_message.is_empty() {
                state.serialize_entry("stateMessage", &self.state_message)?;
            }
            if self.state_start_time.is_some() {
                state.serialize_entry("stateStartTime", &self.state_start_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The session state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The session state is unknown.
        Unspecified,
        /// The session is created prior to running.
        Creating,
        /// The session is running.
        Active,
        /// The session is terminating.
        Terminating,
        /// The session is terminated successfully.
        Terminated,
        /// The session is no longer running due to an error.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Terminating => std::option::Option::Some(3),
                Self::Terminated => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Terminating => std::option::Option::Some("TERMINATING"),
                Self::Terminated => std::option::Option::Some("TERMINATED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Terminating,
                4 => Self::Terminated,
                5 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "TERMINATING" => Self::Terminating,
                "TERMINATED" => Self::Terminated,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Terminating => serializer.serialize_i32(3),
                Self::Terminated => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataproc.v1.Session.State",
            ))
        }
    }

    /// The session configuration.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SessionConfig {
        /// Optional. Jupyter session config.
        JupyterSession(std::boxed::Box<crate::model::JupyterConfig>),
        /// Optional. Spark Connect session config.
        SparkConnectSession(std::boxed::Box<crate::model::SparkConnectConfig>),
    }
}

/// Jupyter configuration for an interactive session.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct JupyterConfig {
    /// Optional. Kernel
    pub kernel: crate::model::jupyter_config::Kernel,

    /// Optional. Display name, shown in the Jupyter kernelspec card.
    pub display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JupyterConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kernel][crate::model::JupyterConfig::kernel].
    pub fn set_kernel<T: std::convert::Into<crate::model::jupyter_config::Kernel>>(
        mut self,
        v: T,
    ) -> Self {
        self.kernel = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::JupyterConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for JupyterConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.JupyterConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for JupyterConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kernel,
            __display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for JupyterConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kernel" => Ok(__FieldTag::__kernel),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = JupyterConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct JupyterConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kernel => {
                            if !fields.insert(__FieldTag::__kernel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kernel",
                                ));
                            }
                            result.kernel = map.next_value::<std::option::Option<crate::model::jupyter_config::Kernel>>()?.unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for JupyterConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.kernel) {
            state.serialize_entry("kernel", &self.kernel)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [JupyterConfig].
pub mod jupyter_config {
    #[allow(unused_imports)]
    use super::*;

    /// Jupyter kernel types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Kernel {
        /// The kernel is unknown.
        Unspecified,
        /// Python kernel.
        Python,
        /// Scala kernel.
        Scala,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Kernel::value] or
        /// [Kernel::name].
        UnknownValue(kernel::UnknownValue),
    }

    #[doc(hidden)]
    pub mod kernel {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Kernel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Python => std::option::Option::Some(1),
                Self::Scala => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("KERNEL_UNSPECIFIED"),
                Self::Python => std::option::Option::Some("PYTHON"),
                Self::Scala => std::option::Option::Some("SCALA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Kernel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Kernel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Kernel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Python,
                2 => Self::Scala,
                _ => Self::UnknownValue(kernel::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Kernel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "KERNEL_UNSPECIFIED" => Self::Unspecified,
                "PYTHON" => Self::Python,
                "SCALA" => Self::Scala,
                _ => Self::UnknownValue(kernel::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Kernel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Python => serializer.serialize_i32(1),
                Self::Scala => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Kernel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Kernel>::new(
                ".google.cloud.dataproc.v1.JupyterConfig.Kernel",
            ))
        }
    }
}

/// Spark Connect configuration for an interactive session.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SparkConnectConfig {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SparkConnectConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SparkConnectConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SparkConnectConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SparkConnectConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SparkConnectConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SparkConnectConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SparkConnectConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SparkConnectConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Runtime configuration for a workload.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RuntimeConfig {
    /// Optional. Version of the batch runtime.
    pub version: std::string::String,

    /// Optional. Optional custom container image for the job runtime environment.
    /// If not specified, a default container image will be used.
    pub container_image: std::string::String,

    /// Optional. A mapping of property names to values, which are used to
    /// configure workload execution.
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Dependency repository configuration.
    pub repository_config: std::option::Option<crate::model::RepositoryConfig>,

    /// Optional. Autotuning configuration of the workload.
    pub autotuning_config: std::option::Option<crate::model::AutotuningConfig>,

    /// Optional. Cohort identifier. Identifies families of the workloads having
    /// the same shape, e.g. daily ETL jobs.
    pub cohort: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RuntimeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::RuntimeConfig::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [container_image][crate::model::RuntimeConfig::container_image].
    pub fn set_container_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.container_image = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::RuntimeConfig::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [repository_config][crate::model::RuntimeConfig::repository_config].
    pub fn set_repository_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RepositoryConfig>,
    {
        self.repository_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [repository_config][crate::model::RuntimeConfig::repository_config].
    pub fn set_or_clear_repository_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RepositoryConfig>,
    {
        self.repository_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [autotuning_config][crate::model::RuntimeConfig::autotuning_config].
    pub fn set_autotuning_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutotuningConfig>,
    {
        self.autotuning_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autotuning_config][crate::model::RuntimeConfig::autotuning_config].
    pub fn set_or_clear_autotuning_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutotuningConfig>,
    {
        self.autotuning_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cohort][crate::model::RuntimeConfig::cohort].
    pub fn set_cohort<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cohort = v.into();
        self
    }
}

impl wkt::message::Message for RuntimeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.RuntimeConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RuntimeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __container_image,
            __properties,
            __repository_config,
            __autotuning_config,
            __cohort,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RuntimeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "containerImage" => Ok(__FieldTag::__container_image),
                            "container_image" => Ok(__FieldTag::__container_image),
                            "properties" => Ok(__FieldTag::__properties),
                            "repositoryConfig" => Ok(__FieldTag::__repository_config),
                            "repository_config" => Ok(__FieldTag::__repository_config),
                            "autotuningConfig" => Ok(__FieldTag::__autotuning_config),
                            "autotuning_config" => Ok(__FieldTag::__autotuning_config),
                            "cohort" => Ok(__FieldTag::__cohort),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RuntimeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RuntimeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__container_image => {
                            if !fields.insert(__FieldTag::__container_image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_image",
                                ));
                            }
                            result.container_image = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repository_config => {
                            if !fields.insert(__FieldTag::__repository_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository_config",
                                ));
                            }
                            result.repository_config = map
                                .next_value::<std::option::Option<crate::model::RepositoryConfig>>(
                                )?;
                        }
                        __FieldTag::__autotuning_config => {
                            if !fields.insert(__FieldTag::__autotuning_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autotuning_config",
                                ));
                            }
                            result.autotuning_config = map
                                .next_value::<std::option::Option<crate::model::AutotuningConfig>>(
                                )?;
                        }
                        __FieldTag::__cohort => {
                            if !fields.insert(__FieldTag::__cohort) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cohort",
                                ));
                            }
                            result.cohort = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RuntimeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.container_image.is_empty() {
            state.serialize_entry("containerImage", &self.container_image)?;
        }
        if !self.properties.is_empty() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if self.repository_config.is_some() {
            state.serialize_entry("repositoryConfig", &self.repository_config)?;
        }
        if self.autotuning_config.is_some() {
            state.serialize_entry("autotuningConfig", &self.autotuning_config)?;
        }
        if !self.cohort.is_empty() {
            state.serialize_entry("cohort", &self.cohort)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Environment configuration for a workload.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EnvironmentConfig {
    /// Optional. Execution configuration for a workload.
    pub execution_config: std::option::Option<crate::model::ExecutionConfig>,

    /// Optional. Peripherals configuration that workload has access to.
    pub peripherals_config: std::option::Option<crate::model::PeripheralsConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnvironmentConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_config][crate::model::EnvironmentConfig::execution_config].
    pub fn set_execution_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExecutionConfig>,
    {
        self.execution_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [execution_config][crate::model::EnvironmentConfig::execution_config].
    pub fn set_or_clear_execution_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExecutionConfig>,
    {
        self.execution_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [peripherals_config][crate::model::EnvironmentConfig::peripherals_config].
    pub fn set_peripherals_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PeripheralsConfig>,
    {
        self.peripherals_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [peripherals_config][crate::model::EnvironmentConfig::peripherals_config].
    pub fn set_or_clear_peripherals_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PeripheralsConfig>,
    {
        self.peripherals_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EnvironmentConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.EnvironmentConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnvironmentConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __execution_config,
            __peripherals_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnvironmentConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "executionConfig" => Ok(__FieldTag::__execution_config),
                            "execution_config" => Ok(__FieldTag::__execution_config),
                            "peripheralsConfig" => Ok(__FieldTag::__peripherals_config),
                            "peripherals_config" => Ok(__FieldTag::__peripherals_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnvironmentConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnvironmentConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__execution_config => {
                            if !fields.insert(__FieldTag::__execution_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for execution_config",
                                ));
                            }
                            result.execution_config = map
                                .next_value::<std::option::Option<crate::model::ExecutionConfig>>(
                                )?;
                        }
                        __FieldTag::__peripherals_config => {
                            if !fields.insert(__FieldTag::__peripherals_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peripherals_config",
                                ));
                            }
                            result.peripherals_config = map
                                .next_value::<std::option::Option<crate::model::PeripheralsConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnvironmentConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.execution_config.is_some() {
            state.serialize_entry("executionConfig", &self.execution_config)?;
        }
        if self.peripherals_config.is_some() {
            state.serialize_entry("peripheralsConfig", &self.peripherals_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Execution configuration for a workload.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExecutionConfig {
    /// Optional. Service account that used to execute workload.
    pub service_account: std::string::String,

    /// Optional. Tags used for network traffic control.
    pub network_tags: std::vec::Vec<std::string::String>,

    /// Optional. The Cloud KMS key to use for encryption.
    pub kms_key: std::string::String,

    /// Optional. Applies to sessions only. The duration to keep the session alive
    /// while it's idling. Exceeding this threshold causes the session to
    /// terminate. This field cannot be set on a batch workload. Minimum value is
    /// 10 minutes; maximum value is 14 days (see JSON representation of
    /// [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json)).
    /// Defaults to 1 hour if not set.
    /// If both `ttl` and `idle_ttl` are specified for an interactive session,
    /// the conditions are treated as `OR` conditions: the workload will be
    /// terminated when it has been idle for `idle_ttl` or when `ttl` has been
    /// exceeded, whichever occurs first.
    pub idle_ttl: std::option::Option<wkt::Duration>,

    /// Optional. The duration after which the workload will be terminated,
    /// specified as the JSON representation for
    /// [Duration](https://protobuf.dev/programming-guides/proto3/#json).
    /// When the workload exceeds this duration, it will be unconditionally
    /// terminated without waiting for ongoing work to finish. If `ttl` is not
    /// specified for a batch workload, the workload will be allowed to run until
    /// it exits naturally (or run forever without exiting). If `ttl` is not
    /// specified for an interactive session, it defaults to 24 hours. If `ttl` is
    /// not specified for a batch that uses 2.1+ runtime version, it defaults to 4
    /// hours. Minimum value is 10 minutes; maximum value is 14 days. If both `ttl`
    /// and `idle_ttl` are specified (for an interactive session), the conditions
    /// are treated as `OR` conditions: the workload will be terminated when it has
    /// been idle for `idle_ttl` or when `ttl` has been exceeded, whichever occurs
    /// first.
    pub ttl: std::option::Option<wkt::Duration>,

    /// Optional. A Cloud Storage bucket used to stage workload dependencies,
    /// config files, and store workload output and other ephemeral data, such as
    /// Spark history files. If you do not specify a staging bucket, Cloud Dataproc
    /// will determine a Cloud Storage location according to the region where your
    /// workload is running, and then create and manage project-level, per-location
    /// staging and temporary buckets.
    /// **This field requires a Cloud Storage bucket name, not a `gs://...` URI to
    /// a Cloud Storage bucket.**
    pub staging_bucket: std::string::String,

    /// Optional. Authentication configuration used to set the default identity for
    /// the workload execution. The config specifies the type of identity
    /// (service account or user) that will be used by workloads to access
    /// resources on the project(s).
    pub authentication_config: std::option::Option<crate::model::AuthenticationConfig>,

    /// Network configuration for workload execution.
    pub network: std::option::Option<crate::model::execution_config::Network>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecutionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_account][crate::model::ExecutionConfig::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [network_tags][crate::model::ExecutionConfig::network_tags].
    pub fn set_network_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.network_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kms_key][crate::model::ExecutionConfig::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }

    /// Sets the value of [idle_ttl][crate::model::ExecutionConfig::idle_ttl].
    pub fn set_idle_ttl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.idle_ttl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [idle_ttl][crate::model::ExecutionConfig::idle_ttl].
    pub fn set_or_clear_idle_ttl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.idle_ttl = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ttl][crate::model::ExecutionConfig::ttl].
    pub fn set_ttl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.ttl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ttl][crate::model::ExecutionConfig::ttl].
    pub fn set_or_clear_ttl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.ttl = v.map(|x| x.into());
        self
    }

    /// Sets the value of [staging_bucket][crate::model::ExecutionConfig::staging_bucket].
    pub fn set_staging_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.staging_bucket = v.into();
        self
    }

    /// Sets the value of [authentication_config][crate::model::ExecutionConfig::authentication_config].
    pub fn set_authentication_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AuthenticationConfig>,
    {
        self.authentication_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authentication_config][crate::model::ExecutionConfig::authentication_config].
    pub fn set_or_clear_authentication_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AuthenticationConfig>,
    {
        self.authentication_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network][crate::model::ExecutionConfig::network].
    ///
    /// Note that all the setters affecting `network` are mutually
    /// exclusive.
    pub fn set_network<
        T: std::convert::Into<std::option::Option<crate::model::execution_config::Network>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network = v.into();
        self
    }

    /// The value of [network][crate::model::ExecutionConfig::network]
    /// if it holds a `NetworkUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn network_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.network.as_ref().and_then(|v| match v {
            crate::model::execution_config::Network::NetworkUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [network][crate::model::ExecutionConfig::network]
    /// to hold a `NetworkUri`.
    ///
    /// Note that all the setters affecting `network` are
    /// mutually exclusive.
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = std::option::Option::Some(
            crate::model::execution_config::Network::NetworkUri(v.into()),
        );
        self
    }

    /// The value of [network][crate::model::ExecutionConfig::network]
    /// if it holds a `SubnetworkUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn subnetwork_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.network.as_ref().and_then(|v| match v {
            crate::model::execution_config::Network::SubnetworkUri(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [network][crate::model::ExecutionConfig::network]
    /// to hold a `SubnetworkUri`.
    ///
    /// Note that all the setters affecting `network` are
    /// mutually exclusive.
    pub fn set_subnetwork_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = std::option::Option::Some(
            crate::model::execution_config::Network::SubnetworkUri(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExecutionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ExecutionConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExecutionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_account,
            __network_uri,
            __subnetwork_uri,
            __network_tags,
            __kms_key,
            __idle_ttl,
            __ttl,
            __staging_bucket,
            __authentication_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExecutionConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "networkUri" => Ok(__FieldTag::__network_uri),
                            "network_uri" => Ok(__FieldTag::__network_uri),
                            "subnetworkUri" => Ok(__FieldTag::__subnetwork_uri),
                            "subnetwork_uri" => Ok(__FieldTag::__subnetwork_uri),
                            "networkTags" => Ok(__FieldTag::__network_tags),
                            "network_tags" => Ok(__FieldTag::__network_tags),
                            "kmsKey" => Ok(__FieldTag::__kms_key),
                            "kms_key" => Ok(__FieldTag::__kms_key),
                            "idleTtl" => Ok(__FieldTag::__idle_ttl),
                            "idle_ttl" => Ok(__FieldTag::__idle_ttl),
                            "ttl" => Ok(__FieldTag::__ttl),
                            "stagingBucket" => Ok(__FieldTag::__staging_bucket),
                            "staging_bucket" => Ok(__FieldTag::__staging_bucket),
                            "authenticationConfig" => Ok(__FieldTag::__authentication_config),
                            "authentication_config" => Ok(__FieldTag::__authentication_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExecutionConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExecutionConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_uri => {
                            if !fields.insert(__FieldTag::__network_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_uri",
                                ));
                            }
                            if result.network.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `network`, a oneof with full ID .google.cloud.dataproc.v1.ExecutionConfig.network_uri, latest field was networkUri",
                                ));
                            }
                            result.network = std::option::Option::Some(
                                crate::model::execution_config::Network::NetworkUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__subnetwork_uri => {
                            if !fields.insert(__FieldTag::__subnetwork_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork_uri",
                                ));
                            }
                            if result.network.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `network`, a oneof with full ID .google.cloud.dataproc.v1.ExecutionConfig.subnetwork_uri, latest field was subnetworkUri",
                                ));
                            }
                            result.network = std::option::Option::Some(
                                crate::model::execution_config::Network::SubnetworkUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__network_tags => {
                            if !fields.insert(__FieldTag::__network_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_tags",
                                ));
                            }
                            result.network_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__kms_key => {
                            if !fields.insert(__FieldTag::__kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key",
                                ));
                            }
                            result.kms_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__idle_ttl => {
                            if !fields.insert(__FieldTag::__idle_ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for idle_ttl",
                                ));
                            }
                            result.idle_ttl =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__ttl => {
                            if !fields.insert(__FieldTag::__ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ttl",
                                ));
                            }
                            result.ttl = map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__staging_bucket => {
                            if !fields.insert(__FieldTag::__staging_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for staging_bucket",
                                ));
                            }
                            result.staging_bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__authentication_config => {
                            if !fields.insert(__FieldTag::__authentication_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authentication_config",
                                ));
                            }
                            result.authentication_config = map.next_value::<std::option::Option<crate::model::AuthenticationConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExecutionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if let Some(value) = self.network_uri() {
            state.serialize_entry("networkUri", value)?;
        }
        if let Some(value) = self.subnetwork_uri() {
            state.serialize_entry("subnetworkUri", value)?;
        }
        if !self.network_tags.is_empty() {
            state.serialize_entry("networkTags", &self.network_tags)?;
        }
        if !self.kms_key.is_empty() {
            state.serialize_entry("kmsKey", &self.kms_key)?;
        }
        if self.idle_ttl.is_some() {
            state.serialize_entry("idleTtl", &self.idle_ttl)?;
        }
        if self.ttl.is_some() {
            state.serialize_entry("ttl", &self.ttl)?;
        }
        if !self.staging_bucket.is_empty() {
            state.serialize_entry("stagingBucket", &self.staging_bucket)?;
        }
        if self.authentication_config.is_some() {
            state.serialize_entry("authenticationConfig", &self.authentication_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExecutionConfig].
pub mod execution_config {
    #[allow(unused_imports)]
    use super::*;

    /// Network configuration for workload execution.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Network {
        /// Optional. Network URI to connect workload to.
        NetworkUri(std::string::String),
        /// Optional. Subnetwork URI to connect workload to.
        SubnetworkUri(std::string::String),
    }
}

/// Spark History Server configuration for the workload.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SparkHistoryServerConfig {
    /// Optional. Resource name of an existing Dataproc Cluster to act as a Spark
    /// History Server for the workload.
    ///
    /// Example:
    ///
    /// * `projects/[project_id]/regions/[region]/clusters/[cluster_name]`
    pub dataproc_cluster: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SparkHistoryServerConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataproc_cluster][crate::model::SparkHistoryServerConfig::dataproc_cluster].
    pub fn set_dataproc_cluster<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataproc_cluster = v.into();
        self
    }
}

impl wkt::message::Message for SparkHistoryServerConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SparkHistoryServerConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SparkHistoryServerConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataproc_cluster,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SparkHistoryServerConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataprocCluster" => Ok(__FieldTag::__dataproc_cluster),
                            "dataproc_cluster" => Ok(__FieldTag::__dataproc_cluster),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SparkHistoryServerConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SparkHistoryServerConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataproc_cluster => {
                            if !fields.insert(__FieldTag::__dataproc_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataproc_cluster",
                                ));
                            }
                            result.dataproc_cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SparkHistoryServerConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dataproc_cluster.is_empty() {
            state.serialize_entry("dataprocCluster", &self.dataproc_cluster)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Auxiliary services configuration for a workload.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PeripheralsConfig {
    /// Optional. Resource name of an existing Dataproc Metastore service.
    ///
    /// Example:
    ///
    /// * `projects/[project_id]/locations/[region]/services/[service_id]`
    pub metastore_service: std::string::String,

    /// Optional. The Spark History Server configuration for the workload.
    pub spark_history_server_config: std::option::Option<crate::model::SparkHistoryServerConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PeripheralsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metastore_service][crate::model::PeripheralsConfig::metastore_service].
    pub fn set_metastore_service<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metastore_service = v.into();
        self
    }

    /// Sets the value of [spark_history_server_config][crate::model::PeripheralsConfig::spark_history_server_config].
    pub fn set_spark_history_server_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SparkHistoryServerConfig>,
    {
        self.spark_history_server_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [spark_history_server_config][crate::model::PeripheralsConfig::spark_history_server_config].
    pub fn set_or_clear_spark_history_server_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SparkHistoryServerConfig>,
    {
        self.spark_history_server_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PeripheralsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.PeripheralsConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PeripheralsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __metastore_service,
            __spark_history_server_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PeripheralsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "metastoreService" => Ok(__FieldTag::__metastore_service),
                            "metastore_service" => Ok(__FieldTag::__metastore_service),
                            "sparkHistoryServerConfig" => {
                                Ok(__FieldTag::__spark_history_server_config)
                            }
                            "spark_history_server_config" => {
                                Ok(__FieldTag::__spark_history_server_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PeripheralsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PeripheralsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__metastore_service => {
                            if !fields.insert(__FieldTag::__metastore_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metastore_service",
                                ));
                            }
                            result.metastore_service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__spark_history_server_config => {
                            if !fields.insert(__FieldTag::__spark_history_server_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark_history_server_config",
                                ));
                            }
                            result.spark_history_server_config = map.next_value::<std::option::Option<crate::model::SparkHistoryServerConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PeripheralsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.metastore_service.is_empty() {
            state.serialize_entry("metastoreService", &self.metastore_service)?;
        }
        if self.spark_history_server_config.is_some() {
            state.serialize_entry(
                "sparkHistoryServerConfig",
                &self.spark_history_server_config,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Runtime information about workload execution.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RuntimeInfo {
    /// Output only. Map of remote access endpoints (such as web interfaces and
    /// APIs) to their URIs.
    pub endpoints: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. A URI pointing to the location of the stdout and stderr of the
    /// workload.
    pub output_uri: std::string::String,

    /// Output only. A URI pointing to the location of the diagnostics tarball.
    pub diagnostic_output_uri: std::string::String,

    /// Output only. Approximate workload resource usage, calculated when
    /// the workload completes (see [Dataproc Serverless pricing]
    /// (<https://cloud.google.com/dataproc-serverless/pricing>)).
    ///
    /// **Note:** This metric calculation may change in the future, for
    /// example, to capture cumulative workload resource
    /// consumption during workload execution (see the
    /// [Dataproc Serverless release notes]
    /// (<https://cloud.google.com/dataproc-serverless/docs/release-notes>)
    /// for announcements, changes, fixes
    /// and other Dataproc developments).
    pub approximate_usage: std::option::Option<crate::model::UsageMetrics>,

    /// Output only. Snapshot of current workload resource usage.
    pub current_usage: std::option::Option<crate::model::UsageSnapshot>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RuntimeInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoints][crate::model::RuntimeInfo::endpoints].
    pub fn set_endpoints<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.endpoints = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [output_uri][crate::model::RuntimeInfo::output_uri].
    pub fn set_output_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output_uri = v.into();
        self
    }

    /// Sets the value of [diagnostic_output_uri][crate::model::RuntimeInfo::diagnostic_output_uri].
    pub fn set_diagnostic_output_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.diagnostic_output_uri = v.into();
        self
    }

    /// Sets the value of [approximate_usage][crate::model::RuntimeInfo::approximate_usage].
    pub fn set_approximate_usage<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UsageMetrics>,
    {
        self.approximate_usage = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [approximate_usage][crate::model::RuntimeInfo::approximate_usage].
    pub fn set_or_clear_approximate_usage<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UsageMetrics>,
    {
        self.approximate_usage = v.map(|x| x.into());
        self
    }

    /// Sets the value of [current_usage][crate::model::RuntimeInfo::current_usage].
    pub fn set_current_usage<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UsageSnapshot>,
    {
        self.current_usage = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [current_usage][crate::model::RuntimeInfo::current_usage].
    pub fn set_or_clear_current_usage<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UsageSnapshot>,
    {
        self.current_usage = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RuntimeInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.RuntimeInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RuntimeInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __endpoints,
            __output_uri,
            __diagnostic_output_uri,
            __approximate_usage,
            __current_usage,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RuntimeInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "endpoints" => Ok(__FieldTag::__endpoints),
                            "outputUri" => Ok(__FieldTag::__output_uri),
                            "output_uri" => Ok(__FieldTag::__output_uri),
                            "diagnosticOutputUri" => Ok(__FieldTag::__diagnostic_output_uri),
                            "diagnostic_output_uri" => Ok(__FieldTag::__diagnostic_output_uri),
                            "approximateUsage" => Ok(__FieldTag::__approximate_usage),
                            "approximate_usage" => Ok(__FieldTag::__approximate_usage),
                            "currentUsage" => Ok(__FieldTag::__current_usage),
                            "current_usage" => Ok(__FieldTag::__current_usage),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RuntimeInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RuntimeInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__endpoints => {
                            if !fields.insert(__FieldTag::__endpoints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoints",
                                ));
                            }
                            result.endpoints = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__output_uri => {
                            if !fields.insert(__FieldTag::__output_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_uri",
                                ));
                            }
                            result.output_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__diagnostic_output_uri => {
                            if !fields.insert(__FieldTag::__diagnostic_output_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for diagnostic_output_uri",
                                ));
                            }
                            result.diagnostic_output_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__approximate_usage => {
                            if !fields.insert(__FieldTag::__approximate_usage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for approximate_usage",
                                ));
                            }
                            result.approximate_usage = map
                                .next_value::<std::option::Option<crate::model::UsageMetrics>>()?;
                        }
                        __FieldTag::__current_usage => {
                            if !fields.insert(__FieldTag::__current_usage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_usage",
                                ));
                            }
                            result.current_usage = map
                                .next_value::<std::option::Option<crate::model::UsageSnapshot>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RuntimeInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.endpoints.is_empty() {
            state.serialize_entry("endpoints", &self.endpoints)?;
        }
        if !self.output_uri.is_empty() {
            state.serialize_entry("outputUri", &self.output_uri)?;
        }
        if !self.diagnostic_output_uri.is_empty() {
            state.serialize_entry("diagnosticOutputUri", &self.diagnostic_output_uri)?;
        }
        if self.approximate_usage.is_some() {
            state.serialize_entry("approximateUsage", &self.approximate_usage)?;
        }
        if self.current_usage.is_some() {
            state.serialize_entry("currentUsage", &self.current_usage)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Usage metrics represent approximate total resources consumed by a workload.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UsageMetrics {
    /// Optional. DCU (Dataproc Compute Units) usage in (`milliDCU` x `seconds`)
    /// (see [Dataproc Serverless pricing]
    /// (<https://cloud.google.com/dataproc-serverless/pricing>)).
    pub milli_dcu_seconds: i64,

    /// Optional. Shuffle storage usage in (`GB` x `seconds`) (see
    /// [Dataproc Serverless pricing]
    /// (<https://cloud.google.com/dataproc-serverless/pricing>)).
    pub shuffle_storage_gb_seconds: i64,

    /// Optional. Accelerator usage in (`milliAccelerator` x `seconds`) (see
    /// [Dataproc Serverless pricing]
    /// (<https://cloud.google.com/dataproc-serverless/pricing>)).
    pub milli_accelerator_seconds: i64,

    /// Optional. Accelerator type being used, if any
    pub accelerator_type: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UsageMetrics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [milli_dcu_seconds][crate::model::UsageMetrics::milli_dcu_seconds].
    pub fn set_milli_dcu_seconds<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.milli_dcu_seconds = v.into();
        self
    }

    /// Sets the value of [shuffle_storage_gb_seconds][crate::model::UsageMetrics::shuffle_storage_gb_seconds].
    pub fn set_shuffle_storage_gb_seconds<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.shuffle_storage_gb_seconds = v.into();
        self
    }

    /// Sets the value of [milli_accelerator_seconds][crate::model::UsageMetrics::milli_accelerator_seconds].
    pub fn set_milli_accelerator_seconds<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.milli_accelerator_seconds = v.into();
        self
    }

    /// Sets the value of [accelerator_type][crate::model::UsageMetrics::accelerator_type].
    pub fn set_accelerator_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.accelerator_type = v.into();
        self
    }
}

impl wkt::message::Message for UsageMetrics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.UsageMetrics"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UsageMetrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __milli_dcu_seconds,
            __shuffle_storage_gb_seconds,
            __milli_accelerator_seconds,
            __accelerator_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UsageMetrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "milliDcuSeconds" => Ok(__FieldTag::__milli_dcu_seconds),
                            "milli_dcu_seconds" => Ok(__FieldTag::__milli_dcu_seconds),
                            "shuffleStorageGbSeconds" => {
                                Ok(__FieldTag::__shuffle_storage_gb_seconds)
                            }
                            "shuffle_storage_gb_seconds" => {
                                Ok(__FieldTag::__shuffle_storage_gb_seconds)
                            }
                            "milliAcceleratorSeconds" => {
                                Ok(__FieldTag::__milli_accelerator_seconds)
                            }
                            "milli_accelerator_seconds" => {
                                Ok(__FieldTag::__milli_accelerator_seconds)
                            }
                            "acceleratorType" => Ok(__FieldTag::__accelerator_type),
                            "accelerator_type" => Ok(__FieldTag::__accelerator_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UsageMetrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UsageMetrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__milli_dcu_seconds => {
                            if !fields.insert(__FieldTag::__milli_dcu_seconds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for milli_dcu_seconds",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.milli_dcu_seconds =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__shuffle_storage_gb_seconds => {
                            if !fields.insert(__FieldTag::__shuffle_storage_gb_seconds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shuffle_storage_gb_seconds",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.shuffle_storage_gb_seconds =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__milli_accelerator_seconds => {
                            if !fields.insert(__FieldTag::__milli_accelerator_seconds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for milli_accelerator_seconds",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.milli_accelerator_seconds =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__accelerator_type => {
                            if !fields.insert(__FieldTag::__accelerator_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accelerator_type",
                                ));
                            }
                            result.accelerator_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UsageMetrics {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.milli_dcu_seconds) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("milliDcuSeconds", &__With(&self.milli_dcu_seconds))?;
        }
        if !wkt::internal::is_default(&self.shuffle_storage_gb_seconds) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "shuffleStorageGbSeconds",
                &__With(&self.shuffle_storage_gb_seconds),
            )?;
        }
        if !wkt::internal::is_default(&self.milli_accelerator_seconds) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "milliAcceleratorSeconds",
                &__With(&self.milli_accelerator_seconds),
            )?;
        }
        if !self.accelerator_type.is_empty() {
            state.serialize_entry("acceleratorType", &self.accelerator_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The usage snapshot represents the resources consumed by a workload at a
/// specified time.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UsageSnapshot {
    /// Optional. Milli (one-thousandth) Dataproc Compute Units (DCUs) (see
    /// [Dataproc Serverless pricing]
    /// (<https://cloud.google.com/dataproc-serverless/pricing>)).
    pub milli_dcu: i64,

    /// Optional. Shuffle Storage in gigabytes (GB). (see [Dataproc Serverless
    /// pricing] (<https://cloud.google.com/dataproc-serverless/pricing>))
    pub shuffle_storage_gb: i64,

    /// Optional. Milli (one-thousandth) Dataproc Compute Units (DCUs) charged at
    /// premium tier (see [Dataproc Serverless pricing]
    /// (<https://cloud.google.com/dataproc-serverless/pricing>)).
    pub milli_dcu_premium: i64,

    /// Optional. Shuffle Storage in gigabytes (GB) charged at premium tier. (see
    /// [Dataproc Serverless pricing]
    /// (<https://cloud.google.com/dataproc-serverless/pricing>))
    pub shuffle_storage_gb_premium: i64,

    /// Optional. Milli (one-thousandth) accelerator. (see [Dataproc
    /// Serverless pricing] (<https://cloud.google.com/dataproc-serverless/pricing>))
    pub milli_accelerator: i64,

    /// Optional. Accelerator type being used, if any
    pub accelerator_type: std::string::String,

    /// Optional. The timestamp of the usage snapshot.
    pub snapshot_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UsageSnapshot {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [milli_dcu][crate::model::UsageSnapshot::milli_dcu].
    pub fn set_milli_dcu<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.milli_dcu = v.into();
        self
    }

    /// Sets the value of [shuffle_storage_gb][crate::model::UsageSnapshot::shuffle_storage_gb].
    pub fn set_shuffle_storage_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.shuffle_storage_gb = v.into();
        self
    }

    /// Sets the value of [milli_dcu_premium][crate::model::UsageSnapshot::milli_dcu_premium].
    pub fn set_milli_dcu_premium<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.milli_dcu_premium = v.into();
        self
    }

    /// Sets the value of [shuffle_storage_gb_premium][crate::model::UsageSnapshot::shuffle_storage_gb_premium].
    pub fn set_shuffle_storage_gb_premium<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.shuffle_storage_gb_premium = v.into();
        self
    }

    /// Sets the value of [milli_accelerator][crate::model::UsageSnapshot::milli_accelerator].
    pub fn set_milli_accelerator<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.milli_accelerator = v.into();
        self
    }

    /// Sets the value of [accelerator_type][crate::model::UsageSnapshot::accelerator_type].
    pub fn set_accelerator_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.accelerator_type = v.into();
        self
    }

    /// Sets the value of [snapshot_time][crate::model::UsageSnapshot::snapshot_time].
    pub fn set_snapshot_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.snapshot_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [snapshot_time][crate::model::UsageSnapshot::snapshot_time].
    pub fn set_or_clear_snapshot_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.snapshot_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UsageSnapshot {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.UsageSnapshot"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UsageSnapshot {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __milli_dcu,
            __shuffle_storage_gb,
            __milli_dcu_premium,
            __shuffle_storage_gb_premium,
            __milli_accelerator,
            __accelerator_type,
            __snapshot_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UsageSnapshot")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "milliDcu" => Ok(__FieldTag::__milli_dcu),
                            "milli_dcu" => Ok(__FieldTag::__milli_dcu),
                            "shuffleStorageGb" => Ok(__FieldTag::__shuffle_storage_gb),
                            "shuffle_storage_gb" => Ok(__FieldTag::__shuffle_storage_gb),
                            "milliDcuPremium" => Ok(__FieldTag::__milli_dcu_premium),
                            "milli_dcu_premium" => Ok(__FieldTag::__milli_dcu_premium),
                            "shuffleStorageGbPremium" => {
                                Ok(__FieldTag::__shuffle_storage_gb_premium)
                            }
                            "shuffle_storage_gb_premium" => {
                                Ok(__FieldTag::__shuffle_storage_gb_premium)
                            }
                            "milliAccelerator" => Ok(__FieldTag::__milli_accelerator),
                            "milli_accelerator" => Ok(__FieldTag::__milli_accelerator),
                            "acceleratorType" => Ok(__FieldTag::__accelerator_type),
                            "accelerator_type" => Ok(__FieldTag::__accelerator_type),
                            "snapshotTime" => Ok(__FieldTag::__snapshot_time),
                            "snapshot_time" => Ok(__FieldTag::__snapshot_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UsageSnapshot;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UsageSnapshot")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__milli_dcu => {
                            if !fields.insert(__FieldTag::__milli_dcu) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for milli_dcu",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.milli_dcu = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__shuffle_storage_gb => {
                            if !fields.insert(__FieldTag::__shuffle_storage_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shuffle_storage_gb",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.shuffle_storage_gb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__milli_dcu_premium => {
                            if !fields.insert(__FieldTag::__milli_dcu_premium) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for milli_dcu_premium",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.milli_dcu_premium =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__shuffle_storage_gb_premium => {
                            if !fields.insert(__FieldTag::__shuffle_storage_gb_premium) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shuffle_storage_gb_premium",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.shuffle_storage_gb_premium =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__milli_accelerator => {
                            if !fields.insert(__FieldTag::__milli_accelerator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for milli_accelerator",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.milli_accelerator =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__accelerator_type => {
                            if !fields.insert(__FieldTag::__accelerator_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accelerator_type",
                                ));
                            }
                            result.accelerator_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__snapshot_time => {
                            if !fields.insert(__FieldTag::__snapshot_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot_time",
                                ));
                            }
                            result.snapshot_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UsageSnapshot {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.milli_dcu) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("milliDcu", &__With(&self.milli_dcu))?;
        }
        if !wkt::internal::is_default(&self.shuffle_storage_gb) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("shuffleStorageGb", &__With(&self.shuffle_storage_gb))?;
        }
        if !wkt::internal::is_default(&self.milli_dcu_premium) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("milliDcuPremium", &__With(&self.milli_dcu_premium))?;
        }
        if !wkt::internal::is_default(&self.shuffle_storage_gb_premium) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "shuffleStorageGbPremium",
                &__With(&self.shuffle_storage_gb_premium),
            )?;
        }
        if !wkt::internal::is_default(&self.milli_accelerator) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("milliAccelerator", &__With(&self.milli_accelerator))?;
        }
        if !self.accelerator_type.is_empty() {
            state.serialize_entry("acceleratorType", &self.accelerator_type)?;
        }
        if self.snapshot_time.is_some() {
            state.serialize_entry("snapshotTime", &self.snapshot_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The cluster's GKE config.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GkeClusterConfig {
    /// Optional. A target GKE cluster to deploy to. It must be in the same project
    /// and region as the Dataproc cluster (the GKE cluster can be zonal or
    /// regional). Format:
    /// 'projects/{project}/locations/{location}/clusters/{cluster_id}'
    pub gke_cluster_target: std::string::String,

    /// Optional. GKE node pools where workloads will be scheduled. At least one
    /// node pool must be assigned the `DEFAULT`
    /// [GkeNodePoolTarget.Role][google.cloud.dataproc.v1.GkeNodePoolTarget.Role].
    /// If a `GkeNodePoolTarget` is not specified, Dataproc constructs a `DEFAULT`
    /// `GkeNodePoolTarget`. Each role can be given to only one
    /// `GkeNodePoolTarget`. All node pools must have the same location settings.
    ///
    /// [google.cloud.dataproc.v1.GkeNodePoolTarget.Role]: crate::model::gke_node_pool_target::Role
    pub node_pool_target: std::vec::Vec<crate::model::GkeNodePoolTarget>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GkeClusterConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gke_cluster_target][crate::model::GkeClusterConfig::gke_cluster_target].
    pub fn set_gke_cluster_target<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.gke_cluster_target = v.into();
        self
    }

    /// Sets the value of [node_pool_target][crate::model::GkeClusterConfig::node_pool_target].
    pub fn set_node_pool_target<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GkeNodePoolTarget>,
    {
        use std::iter::Iterator;
        self.node_pool_target = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GkeClusterConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GkeClusterConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GkeClusterConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gke_cluster_target,
            __node_pool_target,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GkeClusterConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gkeClusterTarget" => Ok(__FieldTag::__gke_cluster_target),
                            "gke_cluster_target" => Ok(__FieldTag::__gke_cluster_target),
                            "nodePoolTarget" => Ok(__FieldTag::__node_pool_target),
                            "node_pool_target" => Ok(__FieldTag::__node_pool_target),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GkeClusterConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GkeClusterConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gke_cluster_target => {
                            if !fields.insert(__FieldTag::__gke_cluster_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_cluster_target",
                                ));
                            }
                            result.gke_cluster_target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool_target => {
                            if !fields.insert(__FieldTag::__node_pool_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_target",
                                ));
                            }
                            result.node_pool_target =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::GkeNodePoolTarget>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GkeClusterConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.gke_cluster_target.is_empty() {
            state.serialize_entry("gkeClusterTarget", &self.gke_cluster_target)?;
        }
        if !self.node_pool_target.is_empty() {
            state.serialize_entry("nodePoolTarget", &self.node_pool_target)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The configuration for running the Dataproc cluster on Kubernetes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct KubernetesClusterConfig {
    /// Optional. A namespace within the Kubernetes cluster to deploy into. If this
    /// namespace does not exist, it is created. If it exists, Dataproc verifies
    /// that another Dataproc VirtualCluster is not installed into it. If not
    /// specified, the name of the Dataproc Cluster is used.
    pub kubernetes_namespace: std::string::String,

    /// Optional. The software configuration for this Dataproc cluster running on
    /// Kubernetes.
    pub kubernetes_software_config: std::option::Option<crate::model::KubernetesSoftwareConfig>,

    pub config: std::option::Option<crate::model::kubernetes_cluster_config::Config>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KubernetesClusterConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kubernetes_namespace][crate::model::KubernetesClusterConfig::kubernetes_namespace].
    pub fn set_kubernetes_namespace<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kubernetes_namespace = v.into();
        self
    }

    /// Sets the value of [kubernetes_software_config][crate::model::KubernetesClusterConfig::kubernetes_software_config].
    pub fn set_kubernetes_software_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::KubernetesSoftwareConfig>,
    {
        self.kubernetes_software_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kubernetes_software_config][crate::model::KubernetesClusterConfig::kubernetes_software_config].
    pub fn set_or_clear_kubernetes_software_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::KubernetesSoftwareConfig>,
    {
        self.kubernetes_software_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [config][crate::model::KubernetesClusterConfig::config].
    ///
    /// Note that all the setters affecting `config` are mutually
    /// exclusive.
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::kubernetes_cluster_config::Config>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// The value of [config][crate::model::KubernetesClusterConfig::config]
    /// if it holds a `GkeClusterConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gke_cluster_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GkeClusterConfig>> {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::kubernetes_cluster_config::Config::GkeClusterConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [config][crate::model::KubernetesClusterConfig::config]
    /// to hold a `GkeClusterConfig`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_gke_cluster_config<
        T: std::convert::Into<std::boxed::Box<crate::model::GkeClusterConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = std::option::Option::Some(
            crate::model::kubernetes_cluster_config::Config::GkeClusterConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for KubernetesClusterConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.KubernetesClusterConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for KubernetesClusterConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kubernetes_namespace,
            __gke_cluster_config,
            __kubernetes_software_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KubernetesClusterConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kubernetesNamespace" => Ok(__FieldTag::__kubernetes_namespace),
                            "kubernetes_namespace" => Ok(__FieldTag::__kubernetes_namespace),
                            "gkeClusterConfig" => Ok(__FieldTag::__gke_cluster_config),
                            "gke_cluster_config" => Ok(__FieldTag::__gke_cluster_config),
                            "kubernetesSoftwareConfig" => {
                                Ok(__FieldTag::__kubernetes_software_config)
                            }
                            "kubernetes_software_config" => {
                                Ok(__FieldTag::__kubernetes_software_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = KubernetesClusterConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KubernetesClusterConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kubernetes_namespace => {
                            if !fields.insert(__FieldTag::__kubernetes_namespace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kubernetes_namespace",
                                ));
                            }
                            result.kubernetes_namespace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gke_cluster_config => {
                            if !fields.insert(__FieldTag::__gke_cluster_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_cluster_config",
                                ));
                            }
                            if result.config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `config`, a oneof with full ID .google.cloud.dataproc.v1.KubernetesClusterConfig.gke_cluster_config, latest field was gkeClusterConfig",
                                ));
                            }
                            result.config = std::option::Option::Some(
                                crate::model::kubernetes_cluster_config::Config::GkeClusterConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GkeClusterConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__kubernetes_software_config => {
                            if !fields.insert(__FieldTag::__kubernetes_software_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kubernetes_software_config",
                                ));
                            }
                            result.kubernetes_software_config = map.next_value::<std::option::Option<crate::model::KubernetesSoftwareConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for KubernetesClusterConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kubernetes_namespace.is_empty() {
            state.serialize_entry("kubernetesNamespace", &self.kubernetes_namespace)?;
        }
        if let Some(value) = self.gke_cluster_config() {
            state.serialize_entry("gkeClusterConfig", value)?;
        }
        if self.kubernetes_software_config.is_some() {
            state.serialize_entry("kubernetesSoftwareConfig", &self.kubernetes_software_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [KubernetesClusterConfig].
pub mod kubernetes_cluster_config {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Config {
        /// Required. The configuration for running the Dataproc cluster on GKE.
        GkeClusterConfig(std::boxed::Box<crate::model::GkeClusterConfig>),
    }
}

/// The software configuration for this Dataproc cluster running on Kubernetes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct KubernetesSoftwareConfig {
    /// The components that should be installed in this Dataproc cluster. The key
    /// must be a string from the KubernetesComponent enumeration. The value is
    /// the version of the software to be installed.
    /// At least one entry must be specified.
    pub component_version: std::collections::HashMap<std::string::String, std::string::String>,

    /// The properties to set on daemon config files.
    ///
    /// Property keys are specified in `prefix:property` format, for example
    /// `spark:spark.kubernetes.container.image`. The following are supported
    /// prefixes and their mappings:
    ///
    /// * spark:  `spark-defaults.conf`
    ///
    /// For more information, see [Cluster
    /// properties](https://cloud.google.com/dataproc/docs/concepts/cluster-properties).
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KubernetesSoftwareConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [component_version][crate::model::KubernetesSoftwareConfig::component_version].
    pub fn set_component_version<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.component_version = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [properties][crate::model::KubernetesSoftwareConfig::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for KubernetesSoftwareConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.KubernetesSoftwareConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for KubernetesSoftwareConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __component_version,
            __properties,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KubernetesSoftwareConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "componentVersion" => Ok(__FieldTag::__component_version),
                            "component_version" => Ok(__FieldTag::__component_version),
                            "properties" => Ok(__FieldTag::__properties),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = KubernetesSoftwareConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KubernetesSoftwareConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__component_version => {
                            if !fields.insert(__FieldTag::__component_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for component_version",
                                ));
                            }
                            result.component_version = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__properties => {
                            if !fields.insert(__FieldTag::__properties) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for properties",
                                ));
                            }
                            result.properties = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for KubernetesSoftwareConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.component_version.is_empty() {
            state.serialize_entry("componentVersion", &self.component_version)?;
        }
        if !self.properties.is_empty() {
            state.serialize_entry("properties", &self.properties)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// GKE node pools that Dataproc workloads run on.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GkeNodePoolTarget {
    /// Required. The target GKE node pool.
    /// Format:
    /// 'projects/{project}/locations/{location}/clusters/{cluster}/nodePools/{node_pool}'
    pub node_pool: std::string::String,

    /// Required. The roles associated with the GKE node pool.
    pub roles: std::vec::Vec<crate::model::gke_node_pool_target::Role>,

    /// Input only. The configuration for the GKE node pool.
    ///
    /// If specified, Dataproc attempts to create a node pool with the
    /// specified shape. If one with the same name already exists, it is
    /// verified against all specified fields. If a field differs, the
    /// virtual cluster creation will fail.
    ///
    /// If omitted, any node pool with the specified name is used. If a
    /// node pool with the specified name does not exist, Dataproc create a
    /// node pool with default values.
    ///
    /// This is an input only field. It will not be returned by the API.
    pub node_pool_config: std::option::Option<crate::model::GkeNodePoolConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GkeNodePoolTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [node_pool][crate::model::GkeNodePoolTarget::node_pool].
    pub fn set_node_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_pool = v.into();
        self
    }

    /// Sets the value of [roles][crate::model::GkeNodePoolTarget::roles].
    pub fn set_roles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::gke_node_pool_target::Role>,
    {
        use std::iter::Iterator;
        self.roles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [node_pool_config][crate::model::GkeNodePoolTarget::node_pool_config].
    pub fn set_node_pool_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GkeNodePoolConfig>,
    {
        self.node_pool_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_pool_config][crate::model::GkeNodePoolTarget::node_pool_config].
    pub fn set_or_clear_node_pool_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GkeNodePoolConfig>,
    {
        self.node_pool_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GkeNodePoolTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GkeNodePoolTarget"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GkeNodePoolTarget {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __node_pool,
            __roles,
            __node_pool_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GkeNodePoolTarget")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nodePool" => Ok(__FieldTag::__node_pool),
                            "node_pool" => Ok(__FieldTag::__node_pool),
                            "roles" => Ok(__FieldTag::__roles),
                            "nodePoolConfig" => Ok(__FieldTag::__node_pool_config),
                            "node_pool_config" => Ok(__FieldTag::__node_pool_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GkeNodePoolTarget;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GkeNodePoolTarget")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__node_pool => {
                            if !fields.insert(__FieldTag::__node_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool",
                                ));
                            }
                            result.node_pool = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__roles => {
                            if !fields.insert(__FieldTag::__roles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for roles",
                                ));
                            }
                            result.roles = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::gke_node_pool_target::Role>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool_config => {
                            if !fields.insert(__FieldTag::__node_pool_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_config",
                                ));
                            }
                            result.node_pool_config = map
                                .next_value::<std::option::Option<crate::model::GkeNodePoolConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GkeNodePoolTarget {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.node_pool.is_empty() {
            state.serialize_entry("nodePool", &self.node_pool)?;
        }
        if !self.roles.is_empty() {
            state.serialize_entry("roles", &self.roles)?;
        }
        if self.node_pool_config.is_some() {
            state.serialize_entry("nodePoolConfig", &self.node_pool_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GkeNodePoolTarget].
pub mod gke_node_pool_target {
    #[allow(unused_imports)]
    use super::*;

    /// `Role` specifies the tasks that will run on the node pool. Roles can be
    /// specific to workloads. Exactly one
    /// [GkeNodePoolTarget][google.cloud.dataproc.v1.GkeNodePoolTarget] within the
    /// virtual cluster must have the `DEFAULT` role, which is used to run all
    /// workloads that are not associated with a node pool.
    ///
    /// [google.cloud.dataproc.v1.GkeNodePoolTarget]: crate::model::GkeNodePoolTarget
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Role {
        /// Role is unspecified.
        Unspecified,
        /// At least one node pool must have the `DEFAULT` role.
        /// Work assigned to a role that is not associated with a node pool
        /// is assigned to the node pool with the `DEFAULT` role. For example,
        /// work assigned to the `CONTROLLER` role will be assigned to the node pool
        /// with the `DEFAULT` role if no node pool has the `CONTROLLER` role.
        Default,
        /// Run work associated with the Dataproc control plane (for example,
        /// controllers and webhooks). Very low resource requirements.
        Controller,
        /// Run work associated with a Spark driver of a job.
        SparkDriver,
        /// Run work associated with a Spark executor of a job.
        SparkExecutor,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Role::value] or
        /// [Role::name].
        UnknownValue(role::UnknownValue),
    }

    #[doc(hidden)]
    pub mod role {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Role {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Default => std::option::Option::Some(1),
                Self::Controller => std::option::Option::Some(2),
                Self::SparkDriver => std::option::Option::Some(3),
                Self::SparkExecutor => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROLE_UNSPECIFIED"),
                Self::Default => std::option::Option::Some("DEFAULT"),
                Self::Controller => std::option::Option::Some("CONTROLLER"),
                Self::SparkDriver => std::option::Option::Some("SPARK_DRIVER"),
                Self::SparkExecutor => std::option::Option::Some("SPARK_EXECUTOR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Role {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Role {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Role {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Default,
                2 => Self::Controller,
                3 => Self::SparkDriver,
                4 => Self::SparkExecutor,
                _ => Self::UnknownValue(role::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Role {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROLE_UNSPECIFIED" => Self::Unspecified,
                "DEFAULT" => Self::Default,
                "CONTROLLER" => Self::Controller,
                "SPARK_DRIVER" => Self::SparkDriver,
                "SPARK_EXECUTOR" => Self::SparkExecutor,
                _ => Self::UnknownValue(role::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Role {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Default => serializer.serialize_i32(1),
                Self::Controller => serializer.serialize_i32(2),
                Self::SparkDriver => serializer.serialize_i32(3),
                Self::SparkExecutor => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Role {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Role>::new(
                ".google.cloud.dataproc.v1.GkeNodePoolTarget.Role",
            ))
        }
    }
}

/// The configuration of a GKE node pool used by a [Dataproc-on-GKE
/// cluster](https://cloud.google.com/dataproc/docs/concepts/jobs/dataproc-gke#create-a-dataproc-on-gke-cluster).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GkeNodePoolConfig {
    /// Optional. The node pool configuration.
    pub config: std::option::Option<crate::model::gke_node_pool_config::GkeNodeConfig>,

    /// Optional. The list of Compute Engine
    /// [zones](https://cloud.google.com/compute/docs/zones#available) where
    /// node pool nodes associated with a Dataproc on GKE virtual cluster
    /// will be located.
    ///
    /// **Note:** All node pools associated with a virtual cluster
    /// must be located in the same region as the virtual cluster, and they must
    /// be located in the same zone within that region.
    ///
    /// If a location is not specified during node pool creation, Dataproc on GKE
    /// will choose the zone.
    pub locations: std::vec::Vec<std::string::String>,

    /// Optional. The autoscaler configuration for this node pool. The autoscaler
    /// is enabled only when a valid configuration is present.
    pub autoscaling:
        std::option::Option<crate::model::gke_node_pool_config::GkeNodePoolAutoscalingConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GkeNodePoolConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config][crate::model::GkeNodePoolConfig::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::gke_node_pool_config::GkeNodeConfig>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::GkeNodePoolConfig::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::gke_node_pool_config::GkeNodeConfig>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [locations][crate::model::GkeNodePoolConfig::locations].
    pub fn set_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [autoscaling][crate::model::GkeNodePoolConfig::autoscaling].
    pub fn set_autoscaling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::gke_node_pool_config::GkeNodePoolAutoscalingConfig>,
    {
        self.autoscaling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autoscaling][crate::model::GkeNodePoolConfig::autoscaling].
    pub fn set_or_clear_autoscaling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::gke_node_pool_config::GkeNodePoolAutoscalingConfig>,
    {
        self.autoscaling = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GkeNodePoolConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GkeNodePoolConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GkeNodePoolConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __config,
            __locations,
            __autoscaling,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GkeNodePoolConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "config" => Ok(__FieldTag::__config),
                            "locations" => Ok(__FieldTag::__locations),
                            "autoscaling" => Ok(__FieldTag::__autoscaling),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GkeNodePoolConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GkeNodePoolConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map.next_value::<std::option::Option<
                                crate::model::gke_node_pool_config::GkeNodeConfig,
                            >>()?;
                        }
                        __FieldTag::__locations => {
                            if !fields.insert(__FieldTag::__locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locations",
                                ));
                            }
                            result.locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__autoscaling => {
                            if !fields.insert(__FieldTag::__autoscaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoscaling",
                                ));
                            }
                            result.autoscaling = map.next_value::<std::option::Option<
                                crate::model::gke_node_pool_config::GkeNodePoolAutoscalingConfig,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GkeNodePoolConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if !self.locations.is_empty() {
            state.serialize_entry("locations", &self.locations)?;
        }
        if self.autoscaling.is_some() {
            state.serialize_entry("autoscaling", &self.autoscaling)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GkeNodePoolConfig].
pub mod gke_node_pool_config {
    #[allow(unused_imports)]
    use super::*;

    /// Parameters that describe cluster nodes.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GkeNodeConfig {
        /// Optional. The name of a Compute Engine [machine
        /// type](https://cloud.google.com/compute/docs/machine-types).
        pub machine_type: std::string::String,

        /// Optional. The number of local SSD disks to attach to the node, which is
        /// limited by the maximum number of disks allowable per zone (see [Adding
        /// Local SSDs](https://cloud.google.com/compute/docs/disks/local-ssd)).
        pub local_ssd_count: i32,

        /// Optional. Whether the nodes are created as legacy [preemptible VM
        /// instances] (<https://cloud.google.com/compute/docs/instances/preemptible>).
        /// Also see
        /// [Spot][google.cloud.dataproc.v1.GkeNodePoolConfig.GkeNodeConfig.spot]
        /// VMs, preemptible VM instances without a maximum lifetime. Legacy and Spot
        /// preemptible nodes cannot be used in a node pool with the `CONTROLLER`
        /// [role]
        /// (/dataproc/docs/reference/rest/v1/projects.regions.clusters#role)
        /// or in the DEFAULT node pool if the CONTROLLER role is not assigned (the
        /// DEFAULT node pool will assume the CONTROLLER role).
        ///
        /// [google.cloud.dataproc.v1.GkeNodePoolConfig.GkeNodeConfig.spot]: crate::model::gke_node_pool_config::GkeNodeConfig::spot
        pub preemptible: bool,

        /// Optional. A list of [hardware
        /// accelerators](https://cloud.google.com/compute/docs/gpus) to attach to
        /// each node.
        pub accelerators:
            std::vec::Vec<crate::model::gke_node_pool_config::GkeNodePoolAcceleratorConfig>,

        /// Optional. [Minimum CPU
        /// platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
        /// to be used by this instance. The instance may be scheduled on the
        /// specified or a newer CPU platform. Specify the friendly names of CPU
        /// platforms, such as "Intel Haswell"` or Intel Sandy Bridge".
        pub min_cpu_platform: std::string::String,

        /// Optional. The [Customer Managed Encryption Key (CMEK)]
        /// (<https://cloud.google.com/kubernetes-engine/docs/how-to/using-cmek>)
        /// used to encrypt the boot disk attached to each node in the node pool.
        /// Specify the key using the following format:
        /// \<code\>projects/\<var\>KEY_PROJECT_ID\</var\>/locations/\<var\>LOCATION\</var\>/keyRings/\<var\>RING_NAME\</var\>/cryptoKeys/\<var\>KEY_NAME\</var\>\</code\>.
        pub boot_disk_kms_key: std::string::String,

        /// Optional. Whether the nodes are created as [Spot VM instances]
        /// (<https://cloud.google.com/compute/docs/instances/spot>).
        /// Spot VMs are the latest update to legacy
        /// [preemptible
        /// VMs][google.cloud.dataproc.v1.GkeNodePoolConfig.GkeNodeConfig.preemptible].
        /// Spot VMs do not have a maximum lifetime. Legacy and Spot preemptible
        /// nodes cannot be used in a node pool with the `CONTROLLER`
        /// [role](/dataproc/docs/reference/rest/v1/projects.regions.clusters#role)
        /// or in the DEFAULT node pool if the CONTROLLER role is not assigned (the
        /// DEFAULT node pool will assume the CONTROLLER role).
        ///
        /// [google.cloud.dataproc.v1.GkeNodePoolConfig.GkeNodeConfig.preemptible]: crate::model::gke_node_pool_config::GkeNodeConfig::preemptible
        pub spot: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GkeNodeConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [machine_type][crate::model::gke_node_pool_config::GkeNodeConfig::machine_type].
        pub fn set_machine_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.machine_type = v.into();
            self
        }

        /// Sets the value of [local_ssd_count][crate::model::gke_node_pool_config::GkeNodeConfig::local_ssd_count].
        pub fn set_local_ssd_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.local_ssd_count = v.into();
            self
        }

        /// Sets the value of [preemptible][crate::model::gke_node_pool_config::GkeNodeConfig::preemptible].
        pub fn set_preemptible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.preemptible = v.into();
            self
        }

        /// Sets the value of [accelerators][crate::model::gke_node_pool_config::GkeNodeConfig::accelerators].
        pub fn set_accelerators<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::gke_node_pool_config::GkeNodePoolAcceleratorConfig>,
        {
            use std::iter::Iterator;
            self.accelerators = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [min_cpu_platform][crate::model::gke_node_pool_config::GkeNodeConfig::min_cpu_platform].
        pub fn set_min_cpu_platform<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.min_cpu_platform = v.into();
            self
        }

        /// Sets the value of [boot_disk_kms_key][crate::model::gke_node_pool_config::GkeNodeConfig::boot_disk_kms_key].
        pub fn set_boot_disk_kms_key<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.boot_disk_kms_key = v.into();
            self
        }

        /// Sets the value of [spot][crate::model::gke_node_pool_config::GkeNodeConfig::spot].
        pub fn set_spot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.spot = v.into();
            self
        }
    }

    impl wkt::message::Message for GkeNodeConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataproc.v1.GkeNodePoolConfig.GkeNodeConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GkeNodeConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __machine_type,
                __local_ssd_count,
                __preemptible,
                __accelerators,
                __min_cpu_platform,
                __boot_disk_kms_key,
                __spot,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GkeNodeConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "machineType" => Ok(__FieldTag::__machine_type),
                                "machine_type" => Ok(__FieldTag::__machine_type),
                                "localSsdCount" => Ok(__FieldTag::__local_ssd_count),
                                "local_ssd_count" => Ok(__FieldTag::__local_ssd_count),
                                "preemptible" => Ok(__FieldTag::__preemptible),
                                "accelerators" => Ok(__FieldTag::__accelerators),
                                "minCpuPlatform" => Ok(__FieldTag::__min_cpu_platform),
                                "min_cpu_platform" => Ok(__FieldTag::__min_cpu_platform),
                                "bootDiskKmsKey" => Ok(__FieldTag::__boot_disk_kms_key),
                                "boot_disk_kms_key" => Ok(__FieldTag::__boot_disk_kms_key),
                                "spot" => Ok(__FieldTag::__spot),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GkeNodeConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GkeNodeConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__machine_type => {
                                if !fields.insert(__FieldTag::__machine_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for machine_type",
                                    ));
                                }
                                result.machine_type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__local_ssd_count => {
                                if !fields.insert(__FieldTag::__local_ssd_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for local_ssd_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.local_ssd_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__preemptible => {
                                if !fields.insert(__FieldTag::__preemptible) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for preemptible",
                                    ));
                                }
                                result.preemptible = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__accelerators => {
                                if !fields.insert(__FieldTag::__accelerators) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for accelerators",
                                    ));
                                }
                                result.accelerators = map.next_value::<std::option::Option<std::vec::Vec<crate::model::gke_node_pool_config::GkeNodePoolAcceleratorConfig>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__min_cpu_platform => {
                                if !fields.insert(__FieldTag::__min_cpu_platform) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min_cpu_platform",
                                    ));
                                }
                                result.min_cpu_platform = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__boot_disk_kms_key => {
                                if !fields.insert(__FieldTag::__boot_disk_kms_key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for boot_disk_kms_key",
                                    ));
                                }
                                result.boot_disk_kms_key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__spot => {
                                if !fields.insert(__FieldTag::__spot) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for spot",
                                    ));
                                }
                                result.spot = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GkeNodeConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.machine_type.is_empty() {
                state.serialize_entry("machineType", &self.machine_type)?;
            }
            if !wkt::internal::is_default(&self.local_ssd_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("localSsdCount", &__With(&self.local_ssd_count))?;
            }
            if !wkt::internal::is_default(&self.preemptible) {
                state.serialize_entry("preemptible", &self.preemptible)?;
            }
            if !self.accelerators.is_empty() {
                state.serialize_entry("accelerators", &self.accelerators)?;
            }
            if !self.min_cpu_platform.is_empty() {
                state.serialize_entry("minCpuPlatform", &self.min_cpu_platform)?;
            }
            if !self.boot_disk_kms_key.is_empty() {
                state.serialize_entry("bootDiskKmsKey", &self.boot_disk_kms_key)?;
            }
            if !wkt::internal::is_default(&self.spot) {
                state.serialize_entry("spot", &self.spot)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A GkeNodeConfigAcceleratorConfig represents a Hardware Accelerator request
    /// for a node pool.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GkeNodePoolAcceleratorConfig {
        /// The number of accelerator cards exposed to an instance.
        pub accelerator_count: i64,

        /// The accelerator type resource namename (see GPUs on Compute Engine).
        pub accelerator_type: std::string::String,

        /// Size of partitions to create on the GPU. Valid values are described in
        /// the NVIDIA [mig user
        /// guide](https://docs.nvidia.com/datacenter/tesla/mig-user-guide/#partitioning).
        pub gpu_partition_size: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GkeNodePoolAcceleratorConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [accelerator_count][crate::model::gke_node_pool_config::GkeNodePoolAcceleratorConfig::accelerator_count].
        pub fn set_accelerator_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.accelerator_count = v.into();
            self
        }

        /// Sets the value of [accelerator_type][crate::model::gke_node_pool_config::GkeNodePoolAcceleratorConfig::accelerator_type].
        pub fn set_accelerator_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.accelerator_type = v.into();
            self
        }

        /// Sets the value of [gpu_partition_size][crate::model::gke_node_pool_config::GkeNodePoolAcceleratorConfig::gpu_partition_size].
        pub fn set_gpu_partition_size<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.gpu_partition_size = v.into();
            self
        }
    }

    impl wkt::message::Message for GkeNodePoolAcceleratorConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataproc.v1.GkeNodePoolConfig.GkeNodePoolAcceleratorConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GkeNodePoolAcceleratorConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __accelerator_count,
                __accelerator_type,
                __gpu_partition_size,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GkeNodePoolAcceleratorConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "acceleratorCount" => Ok(__FieldTag::__accelerator_count),
                                "accelerator_count" => Ok(__FieldTag::__accelerator_count),
                                "acceleratorType" => Ok(__FieldTag::__accelerator_type),
                                "accelerator_type" => Ok(__FieldTag::__accelerator_type),
                                "gpuPartitionSize" => Ok(__FieldTag::__gpu_partition_size),
                                "gpu_partition_size" => Ok(__FieldTag::__gpu_partition_size),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GkeNodePoolAcceleratorConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GkeNodePoolAcceleratorConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__accelerator_count => {
                                if !fields.insert(__FieldTag::__accelerator_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for accelerator_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.accelerator_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__accelerator_type => {
                                if !fields.insert(__FieldTag::__accelerator_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for accelerator_type",
                                    ));
                                }
                                result.accelerator_type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__gpu_partition_size => {
                                if !fields.insert(__FieldTag::__gpu_partition_size) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for gpu_partition_size",
                                    ));
                                }
                                result.gpu_partition_size = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GkeNodePoolAcceleratorConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.accelerator_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("acceleratorCount", &__With(&self.accelerator_count))?;
            }
            if !self.accelerator_type.is_empty() {
                state.serialize_entry("acceleratorType", &self.accelerator_type)?;
            }
            if !self.gpu_partition_size.is_empty() {
                state.serialize_entry("gpuPartitionSize", &self.gpu_partition_size)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// GkeNodePoolAutoscaling contains information the cluster autoscaler needs to
    /// adjust the size of the node pool to the current cluster usage.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GkeNodePoolAutoscalingConfig {
        /// The minimum number of nodes in the node pool. Must be >= 0 and <=
        /// max_node_count.
        pub min_node_count: i32,

        /// The maximum number of nodes in the node pool. Must be >= min_node_count,
        /// and must be > 0.
        /// **Note:** Quota must be sufficient to scale up the cluster.
        pub max_node_count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GkeNodePoolAutoscalingConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [min_node_count][crate::model::gke_node_pool_config::GkeNodePoolAutoscalingConfig::min_node_count].
        pub fn set_min_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.min_node_count = v.into();
            self
        }

        /// Sets the value of [max_node_count][crate::model::gke_node_pool_config::GkeNodePoolAutoscalingConfig::max_node_count].
        pub fn set_max_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_node_count = v.into();
            self
        }
    }

    impl wkt::message::Message for GkeNodePoolAutoscalingConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataproc.v1.GkeNodePoolConfig.GkeNodePoolAutoscalingConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GkeNodePoolAutoscalingConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __min_node_count,
                __max_node_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GkeNodePoolAutoscalingConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "minNodeCount" => Ok(__FieldTag::__min_node_count),
                                "min_node_count" => Ok(__FieldTag::__min_node_count),
                                "maxNodeCount" => Ok(__FieldTag::__max_node_count),
                                "max_node_count" => Ok(__FieldTag::__max_node_count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GkeNodePoolAutoscalingConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GkeNodePoolAutoscalingConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__min_node_count => {
                                if !fields.insert(__FieldTag::__min_node_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min_node_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.min_node_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__max_node_count => {
                                if !fields.insert(__FieldTag::__max_node_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_node_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.max_node_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GkeNodePoolAutoscalingConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.min_node_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("minNodeCount", &__With(&self.min_node_count))?;
            }
            if !wkt::internal::is_default(&self.max_node_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("maxNodeCount", &__With(&self.max_node_count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Authentication configuration for a workload is used to set the default
/// identity for the workload execution.
/// The config specifies the type of identity (service account or user) that
/// will be used by workloads to access resources on the project(s).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AuthenticationConfig {
    /// Optional. Authentication type for the user workload running in containers.
    pub user_workload_authentication_type: crate::model::authentication_config::AuthenticationType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuthenticationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_workload_authentication_type][crate::model::AuthenticationConfig::user_workload_authentication_type].
    pub fn set_user_workload_authentication_type<
        T: std::convert::Into<crate::model::authentication_config::AuthenticationType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_workload_authentication_type = v.into();
        self
    }
}

impl wkt::message::Message for AuthenticationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.AuthenticationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AuthenticationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __user_workload_authentication_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AuthenticationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "userWorkloadAuthenticationType" => {
                                Ok(__FieldTag::__user_workload_authentication_type)
                            }
                            "user_workload_authentication_type" => {
                                Ok(__FieldTag::__user_workload_authentication_type)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AuthenticationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AuthenticationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__user_workload_authentication_type => {
                            if !fields.insert(__FieldTag::__user_workload_authentication_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_workload_authentication_type",
                                ));
                            }
                            result.user_workload_authentication_type = map
                                .next_value::<std::option::Option<
                                    crate::model::authentication_config::AuthenticationType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AuthenticationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.user_workload_authentication_type) {
            state.serialize_entry(
                "userWorkloadAuthenticationType",
                &self.user_workload_authentication_type,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AuthenticationConfig].
pub mod authentication_config {
    #[allow(unused_imports)]
    use super::*;

    /// Authentication types for workload execution.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AuthenticationType {
        /// If AuthenticationType is unspecified then END_USER_CREDENTIALS is used
        /// for 3.0 and newer runtimes, and SERVICE_ACCOUNT is used for older
        /// runtimes.
        Unspecified,
        /// Use service account credentials for authenticating to other services.
        ServiceAccount,
        /// Use OAuth credentials associated with the workload creator/user for
        /// authenticating to other services.
        EndUserCredentials,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AuthenticationType::value] or
        /// [AuthenticationType::name].
        UnknownValue(authentication_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod authentication_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AuthenticationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ServiceAccount => std::option::Option::Some(1),
                Self::EndUserCredentials => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("AUTHENTICATION_TYPE_UNSPECIFIED"),
                Self::ServiceAccount => std::option::Option::Some("SERVICE_ACCOUNT"),
                Self::EndUserCredentials => std::option::Option::Some("END_USER_CREDENTIALS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AuthenticationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AuthenticationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AuthenticationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ServiceAccount,
                2 => Self::EndUserCredentials,
                _ => Self::UnknownValue(authentication_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AuthenticationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AUTHENTICATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SERVICE_ACCOUNT" => Self::ServiceAccount,
                "END_USER_CREDENTIALS" => Self::EndUserCredentials,
                _ => Self::UnknownValue(authentication_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AuthenticationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ServiceAccount => serializer.serialize_i32(1),
                Self::EndUserCredentials => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AuthenticationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AuthenticationType>::new(
                ".google.cloud.dataproc.v1.AuthenticationConfig.AuthenticationType",
            ))
        }
    }
}

/// Autotuning configuration of the workload.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AutotuningConfig {
    /// Optional. Scenarios for which tunings are applied.
    pub scenarios: std::vec::Vec<crate::model::autotuning_config::Scenario>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutotuningConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scenarios][crate::model::AutotuningConfig::scenarios].
    pub fn set_scenarios<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::autotuning_config::Scenario>,
    {
        use std::iter::Iterator;
        self.scenarios = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AutotuningConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.AutotuningConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutotuningConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __scenarios,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutotuningConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scenarios" => Ok(__FieldTag::__scenarios),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutotuningConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutotuningConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__scenarios => {
                            if !fields.insert(__FieldTag::__scenarios) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scenarios",
                                ));
                            }
                            result.scenarios = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::autotuning_config::Scenario>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutotuningConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.scenarios.is_empty() {
            state.serialize_entry("scenarios", &self.scenarios)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AutotuningConfig].
pub mod autotuning_config {
    #[allow(unused_imports)]
    use super::*;

    /// Scenario represents a specific goal that autotuning will attempt to achieve
    /// by modifying workloads.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scenario {
        /// Default value.
        Unspecified,
        /// Scaling recommendations such as initialExecutors.
        Scaling,
        /// Adding hints for potential relation broadcasts.
        BroadcastHashJoin,
        /// Memory management for workloads.
        Memory,
        /// No autotuning.
        None,
        /// Automatic selection of scenarios.
        Auto,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Scenario::value] or
        /// [Scenario::name].
        UnknownValue(scenario::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scenario {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Scenario {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Scaling => std::option::Option::Some(2),
                Self::BroadcastHashJoin => std::option::Option::Some(3),
                Self::Memory => std::option::Option::Some(4),
                Self::None => std::option::Option::Some(5),
                Self::Auto => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCENARIO_UNSPECIFIED"),
                Self::Scaling => std::option::Option::Some("SCALING"),
                Self::BroadcastHashJoin => std::option::Option::Some("BROADCAST_HASH_JOIN"),
                Self::Memory => std::option::Option::Some("MEMORY"),
                Self::None => std::option::Option::Some("NONE"),
                Self::Auto => std::option::Option::Some("AUTO"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Scenario {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Scenario {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Scenario {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::Scaling,
                3 => Self::BroadcastHashJoin,
                4 => Self::Memory,
                5 => Self::None,
                6 => Self::Auto,
                _ => Self::UnknownValue(scenario::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Scenario {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCENARIO_UNSPECIFIED" => Self::Unspecified,
                "SCALING" => Self::Scaling,
                "BROADCAST_HASH_JOIN" => Self::BroadcastHashJoin,
                "MEMORY" => Self::Memory,
                "NONE" => Self::None,
                "AUTO" => Self::Auto,
                _ => Self::UnknownValue(scenario::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Scenario {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Scaling => serializer.serialize_i32(2),
                Self::BroadcastHashJoin => serializer.serialize_i32(3),
                Self::Memory => serializer.serialize_i32(4),
                Self::None => serializer.serialize_i32(5),
                Self::Auto => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Scenario {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scenario>::new(
                ".google.cloud.dataproc.v1.AutotuningConfig.Scenario",
            ))
        }
    }
}

/// Configuration for dependency repositories
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RepositoryConfig {
    /// Optional. Configuration for PyPi repository.
    pub pypi_repository_config: std::option::Option<crate::model::PyPiRepositoryConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepositoryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pypi_repository_config][crate::model::RepositoryConfig::pypi_repository_config].
    pub fn set_pypi_repository_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PyPiRepositoryConfig>,
    {
        self.pypi_repository_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pypi_repository_config][crate::model::RepositoryConfig::pypi_repository_config].
    pub fn set_or_clear_pypi_repository_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PyPiRepositoryConfig>,
    {
        self.pypi_repository_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RepositoryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.RepositoryConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RepositoryConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pypi_repository_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RepositoryConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pypiRepositoryConfig" => Ok(__FieldTag::__pypi_repository_config),
                            "pypi_repository_config" => Ok(__FieldTag::__pypi_repository_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RepositoryConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RepositoryConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pypi_repository_config => {
                            if !fields.insert(__FieldTag::__pypi_repository_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pypi_repository_config",
                                ));
                            }
                            result.pypi_repository_config = map.next_value::<std::option::Option<crate::model::PyPiRepositoryConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RepositoryConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.pypi_repository_config.is_some() {
            state.serialize_entry("pypiRepositoryConfig", &self.pypi_repository_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for PyPi repository
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PyPiRepositoryConfig {
    /// Optional. PyPi repository address
    pub pypi_repository: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PyPiRepositoryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pypi_repository][crate::model::PyPiRepositoryConfig::pypi_repository].
    pub fn set_pypi_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pypi_repository = v.into();
        self
    }
}

impl wkt::message::Message for PyPiRepositoryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.PyPiRepositoryConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PyPiRepositoryConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pypi_repository,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PyPiRepositoryConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pypiRepository" => Ok(__FieldTag::__pypi_repository),
                            "pypi_repository" => Ok(__FieldTag::__pypi_repository),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PyPiRepositoryConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PyPiRepositoryConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pypi_repository => {
                            if !fields.insert(__FieldTag::__pypi_repository) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pypi_repository",
                                ));
                            }
                            result.pypi_repository = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PyPiRepositoryConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.pypi_repository.is_empty() {
            state.serialize_entry("pypiRepository", &self.pypi_repository)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A Dataproc workflow template resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WorkflowTemplate {
    pub id: std::string::String,

    /// Output only. The resource name of the workflow template, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.workflowTemplates`, the resource name of the
    ///   template has the following format:
    ///   `projects/{project_id}/regions/{region}/workflowTemplates/{template_id}`
    ///
    /// * For `projects.locations.workflowTemplates`, the resource name of the
    ///   template has the following format:
    ///   `projects/{project_id}/locations/{location}/workflowTemplates/{template_id}`
    ///
    pub name: std::string::String,

    /// Optional. Used to perform a consistent read-modify-write.
    ///
    /// This field should be left blank for a `CreateWorkflowTemplate` request. It
    /// is required for an `UpdateWorkflowTemplate` request, and must match the
    /// current server version. A typical update template flow would fetch the
    /// current template with a `GetWorkflowTemplate` request, which will return
    /// the current template with the `version` field filled in with the
    /// current server version. The user updates other fields in the template,
    /// then returns it as part of the `UpdateWorkflowTemplate` request.
    pub version: i32,

    /// Output only. The time template was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time template was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The labels to associate with this template. These labels
    /// will be propagated to all jobs and clusters created by the workflow
    /// instance.
    ///
    /// Label **keys** must contain 1 to 63 characters, and must conform to
    /// [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt).
    ///
    /// Label **values** may be empty, but, if present, must contain 1 to 63
    /// characters, and must conform to
    /// [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt).
    ///
    /// No more than 32 labels can be associated with a template.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. WorkflowTemplate scheduling information.
    pub placement: std::option::Option<crate::model::WorkflowTemplatePlacement>,

    /// Required. The Directed Acyclic Graph of Jobs to submit.
    pub jobs: std::vec::Vec<crate::model::OrderedJob>,

    /// Optional. Template parameters whose values are substituted into the
    /// template. Values for parameters must be provided when the template is
    /// instantiated.
    pub parameters: std::vec::Vec<crate::model::TemplateParameter>,

    /// Optional. Timeout duration for the DAG of jobs, expressed in seconds (see
    /// [JSON representation of
    /// duration](https://developers.google.com/protocol-buffers/docs/proto3#json)).
    /// The timeout duration must be from 10 minutes ("600s") to 24 hours
    /// ("86400s"). The timer begins when the first job is submitted. If the
    /// workflow is running at the end of the timeout period, any remaining jobs
    /// are cancelled, the workflow is ended, and if the workflow was running on a
    /// [managed
    /// cluster](/dataproc/docs/concepts/workflows/using-workflows#configuring_or_selecting_a_cluster),
    /// the cluster is deleted.
    pub dag_timeout: std::option::Option<wkt::Duration>,

    /// Optional. Encryption settings for encrypting workflow template job
    /// arguments.
    pub encryption_config: std::option::Option<crate::model::workflow_template::EncryptionConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkflowTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::WorkflowTemplate::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::WorkflowTemplate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::WorkflowTemplate::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::WorkflowTemplate::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::WorkflowTemplate::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::WorkflowTemplate::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::WorkflowTemplate::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::WorkflowTemplate::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [placement][crate::model::WorkflowTemplate::placement].
    pub fn set_placement<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkflowTemplatePlacement>,
    {
        self.placement = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [placement][crate::model::WorkflowTemplate::placement].
    pub fn set_or_clear_placement<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkflowTemplatePlacement>,
    {
        self.placement = v.map(|x| x.into());
        self
    }

    /// Sets the value of [jobs][crate::model::WorkflowTemplate::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OrderedJob>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [parameters][crate::model::WorkflowTemplate::parameters].
    pub fn set_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TemplateParameter>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dag_timeout][crate::model::WorkflowTemplate::dag_timeout].
    pub fn set_dag_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.dag_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dag_timeout][crate::model::WorkflowTemplate::dag_timeout].
    pub fn set_or_clear_dag_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.dag_timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption_config][crate::model::WorkflowTemplate::encryption_config].
    pub fn set_encryption_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::workflow_template::EncryptionConfig>,
    {
        self.encryption_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_config][crate::model::WorkflowTemplate::encryption_config].
    pub fn set_or_clear_encryption_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::workflow_template::EncryptionConfig>,
    {
        self.encryption_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for WorkflowTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.WorkflowTemplate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WorkflowTemplate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __name,
            __version,
            __create_time,
            __update_time,
            __labels,
            __placement,
            __jobs,
            __parameters,
            __dag_timeout,
            __encryption_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkflowTemplate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "name" => Ok(__FieldTag::__name),
                            "version" => Ok(__FieldTag::__version),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "placement" => Ok(__FieldTag::__placement),
                            "jobs" => Ok(__FieldTag::__jobs),
                            "parameters" => Ok(__FieldTag::__parameters),
                            "dagTimeout" => Ok(__FieldTag::__dag_timeout),
                            "dag_timeout" => Ok(__FieldTag::__dag_timeout),
                            "encryptionConfig" => Ok(__FieldTag::__encryption_config),
                            "encryption_config" => Ok(__FieldTag::__encryption_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WorkflowTemplate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkflowTemplate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.version = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__placement => {
                            if !fields.insert(__FieldTag::__placement) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for placement",
                                ));
                            }
                            result.placement = map.next_value::<std::option::Option<crate::model::WorkflowTemplatePlacement>>()?
                                ;
                        }
                        __FieldTag::__jobs => {
                            if !fields.insert(__FieldTag::__jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jobs",
                                ));
                            }
                            result.jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::OrderedJob>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TemplateParameter>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dag_timeout => {
                            if !fields.insert(__FieldTag::__dag_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dag_timeout",
                                ));
                            }
                            result.dag_timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__encryption_config => {
                            if !fields.insert(__FieldTag::__encryption_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_config",
                                ));
                            }
                            result.encryption_config = map.next_value::<std::option::Option<
                                crate::model::workflow_template::EncryptionConfig,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WorkflowTemplate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.version) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("version", &__With(&self.version))?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.placement.is_some() {
            state.serialize_entry("placement", &self.placement)?;
        }
        if !self.jobs.is_empty() {
            state.serialize_entry("jobs", &self.jobs)?;
        }
        if !self.parameters.is_empty() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if self.dag_timeout.is_some() {
            state.serialize_entry("dagTimeout", &self.dag_timeout)?;
        }
        if self.encryption_config.is_some() {
            state.serialize_entry("encryptionConfig", &self.encryption_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [WorkflowTemplate].
pub mod workflow_template {
    #[allow(unused_imports)]
    use super::*;

    /// Encryption settings for encrypting workflow template job arguments.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct EncryptionConfig {
        /// Optional. The Cloud KMS key name to use for encrypting
        /// workflow template job arguments.
        ///
        /// When this this key is provided, the following workflow template
        /// [job arguments]
        /// (<https://cloud.google.com/dataproc/docs/concepts/workflows/use-workflows#adding_jobs_to_a_template>),
        /// if present, are
        /// [CMEK
        /// encrypted](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/customer-managed-encryption#use_cmek_with_workflow_template_data):
        ///
        /// * [FlinkJob
        ///   args](https://cloud.google.com/dataproc/docs/reference/rest/v1/FlinkJob)
        /// * [HadoopJob
        ///   args](https://cloud.google.com/dataproc/docs/reference/rest/v1/HadoopJob)
        /// * [SparkJob
        ///   args](https://cloud.google.com/dataproc/docs/reference/rest/v1/SparkJob)
        /// * [SparkRJob
        ///   args](https://cloud.google.com/dataproc/docs/reference/rest/v1/SparkRJob)
        /// * [PySparkJob
        ///   args](https://cloud.google.com/dataproc/docs/reference/rest/v1/PySparkJob)
        /// * [SparkSqlJob](https://cloud.google.com/dataproc/docs/reference/rest/v1/SparkSqlJob)
        ///   scriptVariables and queryList.queries
        /// * [HiveJob](https://cloud.google.com/dataproc/docs/reference/rest/v1/HiveJob)
        ///   scriptVariables and queryList.queries
        /// * [PigJob](https://cloud.google.com/dataproc/docs/reference/rest/v1/PigJob)
        ///   scriptVariables and queryList.queries
        /// * [PrestoJob](https://cloud.google.com/dataproc/docs/reference/rest/v1/PrestoJob)
        ///   scriptVariables and queryList.queries
        pub kms_key: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl EncryptionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kms_key][crate::model::workflow_template::EncryptionConfig::kms_key].
        pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.kms_key = v.into();
            self
        }
    }

    impl wkt::message::Message for EncryptionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataproc.v1.WorkflowTemplate.EncryptionConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for EncryptionConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __kms_key,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for EncryptionConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "kmsKey" => Ok(__FieldTag::__kms_key),
                                "kms_key" => Ok(__FieldTag::__kms_key),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = EncryptionConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct EncryptionConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__kms_key => {
                                if !fields.insert(__FieldTag::__kms_key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for kms_key",
                                    ));
                                }
                                result.kms_key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for EncryptionConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.kms_key.is_empty() {
                state.serialize_entry("kmsKey", &self.kms_key)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Specifies workflow execution target.
///
/// Either `managed_cluster` or `cluster_selector` is required.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WorkflowTemplatePlacement {
    /// Required. Specifies where workflow executes; either on a managed
    /// cluster or an existing cluster chosen by labels.
    pub placement: std::option::Option<crate::model::workflow_template_placement::Placement>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkflowTemplatePlacement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [placement][crate::model::WorkflowTemplatePlacement::placement].
    ///
    /// Note that all the setters affecting `placement` are mutually
    /// exclusive.
    pub fn set_placement<
        T: std::convert::Into<
                std::option::Option<crate::model::workflow_template_placement::Placement>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.placement = v.into();
        self
    }

    /// The value of [placement][crate::model::WorkflowTemplatePlacement::placement]
    /// if it holds a `ManagedCluster`, `None` if the field is not set or
    /// holds a different branch.
    pub fn managed_cluster(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ManagedCluster>> {
        #[allow(unreachable_patterns)]
        self.placement.as_ref().and_then(|v| match v {
            crate::model::workflow_template_placement::Placement::ManagedCluster(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [placement][crate::model::WorkflowTemplatePlacement::placement]
    /// to hold a `ManagedCluster`.
    ///
    /// Note that all the setters affecting `placement` are
    /// mutually exclusive.
    pub fn set_managed_cluster<
        T: std::convert::Into<std::boxed::Box<crate::model::ManagedCluster>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.placement = std::option::Option::Some(
            crate::model::workflow_template_placement::Placement::ManagedCluster(v.into()),
        );
        self
    }

    /// The value of [placement][crate::model::WorkflowTemplatePlacement::placement]
    /// if it holds a `ClusterSelector`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cluster_selector(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ClusterSelector>> {
        #[allow(unreachable_patterns)]
        self.placement.as_ref().and_then(|v| match v {
            crate::model::workflow_template_placement::Placement::ClusterSelector(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [placement][crate::model::WorkflowTemplatePlacement::placement]
    /// to hold a `ClusterSelector`.
    ///
    /// Note that all the setters affecting `placement` are
    /// mutually exclusive.
    pub fn set_cluster_selector<
        T: std::convert::Into<std::boxed::Box<crate::model::ClusterSelector>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.placement = std::option::Option::Some(
            crate::model::workflow_template_placement::Placement::ClusterSelector(v.into()),
        );
        self
    }
}

impl wkt::message::Message for WorkflowTemplatePlacement {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.WorkflowTemplatePlacement"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WorkflowTemplatePlacement {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __managed_cluster,
            __cluster_selector,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkflowTemplatePlacement")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "managedCluster" => Ok(__FieldTag::__managed_cluster),
                            "managed_cluster" => Ok(__FieldTag::__managed_cluster),
                            "clusterSelector" => Ok(__FieldTag::__cluster_selector),
                            "cluster_selector" => Ok(__FieldTag::__cluster_selector),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WorkflowTemplatePlacement;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkflowTemplatePlacement")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__managed_cluster => {
                            if !fields.insert(__FieldTag::__managed_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for managed_cluster",
                                ));
                            }
                            if result.placement.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `placement`, a oneof with full ID .google.cloud.dataproc.v1.WorkflowTemplatePlacement.managed_cluster, latest field was managedCluster",
                                ));
                            }
                            result.placement = std::option::Option::Some(
                                crate::model::workflow_template_placement::Placement::ManagedCluster(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ManagedCluster>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__cluster_selector => {
                            if !fields.insert(__FieldTag::__cluster_selector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_selector",
                                ));
                            }
                            if result.placement.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `placement`, a oneof with full ID .google.cloud.dataproc.v1.WorkflowTemplatePlacement.cluster_selector, latest field was clusterSelector",
                                ));
                            }
                            result.placement = std::option::Option::Some(
                                crate::model::workflow_template_placement::Placement::ClusterSelector(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ClusterSelector>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WorkflowTemplatePlacement {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.managed_cluster() {
            state.serialize_entry("managedCluster", value)?;
        }
        if let Some(value) = self.cluster_selector() {
            state.serialize_entry("clusterSelector", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [WorkflowTemplatePlacement].
pub mod workflow_template_placement {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Specifies where workflow executes; either on a managed
    /// cluster or an existing cluster chosen by labels.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Placement {
        /// A cluster that is managed by the workflow.
        ManagedCluster(std::boxed::Box<crate::model::ManagedCluster>),
        /// Optional. A selector that chooses target cluster for jobs based
        /// on metadata.
        ///
        /// The selector is evaluated at the time each job is submitted.
        ClusterSelector(std::boxed::Box<crate::model::ClusterSelector>),
    }
}

/// Cluster that is managed by the workflow.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ManagedCluster {
    /// Required. The cluster name prefix. A unique cluster name will be formed by
    /// appending a random suffix.
    ///
    /// The name must contain only lower-case letters (a-z), numbers (0-9),
    /// and hyphens (-). Must begin with a letter. Cannot begin or end with
    /// hyphen. Must consist of between 2 and 35 characters.
    pub cluster_name: std::string::String,

    /// Required. The cluster configuration.
    pub config: std::option::Option<crate::model::ClusterConfig>,

    /// Optional. The labels to associate with this cluster.
    ///
    /// Label keys must be between 1 and 63 characters long, and must conform to
    /// the following PCRE regular expression:
    /// [\p{Ll}\p{Lo}][\p{Ll}\p{Lo}\p{N}_-]{0,62}
    ///
    /// Label values must be between 1 and 63 characters long, and must conform to
    /// the following PCRE regular expression: [\p{Ll}\p{Lo}\p{N}_-]{0,63}
    ///
    /// No more than 32 labels can be associated with a given cluster.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManagedCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_name][crate::model::ManagedCluster::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [config][crate::model::ManagedCluster::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ClusterConfig>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::ManagedCluster::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ClusterConfig>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::ManagedCluster::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ManagedCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ManagedCluster"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ManagedCluster {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster_name,
            __config,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ManagedCluster")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusterName" => Ok(__FieldTag::__cluster_name),
                            "cluster_name" => Ok(__FieldTag::__cluster_name),
                            "config" => Ok(__FieldTag::__config),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ManagedCluster;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagedCluster")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster_name => {
                            if !fields.insert(__FieldTag::__cluster_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_name",
                                ));
                            }
                            result.cluster_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map
                                .next_value::<std::option::Option<crate::model::ClusterConfig>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ManagedCluster {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cluster_name.is_empty() {
            state.serialize_entry("clusterName", &self.cluster_name)?;
        }
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A selector that chooses target cluster for jobs based on metadata.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ClusterSelector {
    /// Optional. The zone where workflow process executes. This parameter does not
    /// affect the selection of the cluster.
    ///
    /// If unspecified, the zone of the first cluster matching the selector
    /// is used.
    pub zone: std::string::String,

    /// Required. The cluster labels. Cluster must have all labels
    /// to match.
    pub cluster_labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterSelector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [zone][crate::model::ClusterSelector::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_labels][crate::model::ClusterSelector::cluster_labels].
    pub fn set_cluster_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.cluster_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ClusterSelector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ClusterSelector"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClusterSelector {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __zone,
            __cluster_labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClusterSelector")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterLabels" => Ok(__FieldTag::__cluster_labels),
                            "cluster_labels" => Ok(__FieldTag::__cluster_labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClusterSelector;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClusterSelector")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_labels => {
                            if !fields.insert(__FieldTag::__cluster_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_labels",
                                ));
                            }
                            result.cluster_labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ClusterSelector {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_labels.is_empty() {
            state.serialize_entry("clusterLabels", &self.cluster_labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A job executed by the workflow.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OrderedJob {
    /// Required. The step id. The id must be unique among all jobs
    /// within the template.
    ///
    /// The step id is used as prefix for job id, as job
    /// `goog-dataproc-workflow-step-id` label, and in
    /// [prerequisiteStepIds][google.cloud.dataproc.v1.OrderedJob.prerequisite_step_ids]
    /// field from other steps.
    ///
    /// The id must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). Cannot begin or end with underscore
    /// or hyphen. Must consist of between 3 and 50 characters.
    ///
    /// [google.cloud.dataproc.v1.OrderedJob.prerequisite_step_ids]: crate::model::OrderedJob::prerequisite_step_ids
    pub step_id: std::string::String,

    /// Optional. The labels to associate with this job.
    ///
    /// Label keys must be between 1 and 63 characters long, and must conform to
    /// the following regular expression:
    /// [\p{Ll}\p{Lo}][\p{Ll}\p{Lo}\p{N}_-]{0,62}
    ///
    /// Label values must be between 1 and 63 characters long, and must conform to
    /// the following regular expression: [\p{Ll}\p{Lo}\p{N}_-]{0,63}
    ///
    /// No more than 32 labels can be associated with a given job.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Job scheduling configuration.
    pub scheduling: std::option::Option<crate::model::JobScheduling>,

    /// Optional. The optional list of prerequisite job step_ids.
    /// If not specified, the job will start at the beginning of workflow.
    pub prerequisite_step_ids: std::vec::Vec<std::string::String>,

    /// Required. The job definition.
    pub job_type: std::option::Option<crate::model::ordered_job::JobType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OrderedJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [step_id][crate::model::OrderedJob::step_id].
    pub fn set_step_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.step_id = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::OrderedJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [scheduling][crate::model::OrderedJob::scheduling].
    pub fn set_scheduling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::JobScheduling>,
    {
        self.scheduling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scheduling][crate::model::OrderedJob::scheduling].
    pub fn set_or_clear_scheduling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::JobScheduling>,
    {
        self.scheduling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [prerequisite_step_ids][crate::model::OrderedJob::prerequisite_step_ids].
    pub fn set_prerequisite_step_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.prerequisite_step_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [job_type][crate::model::OrderedJob::job_type].
    ///
    /// Note that all the setters affecting `job_type` are mutually
    /// exclusive.
    pub fn set_job_type<
        T: std::convert::Into<std::option::Option<crate::model::ordered_job::JobType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_type = v.into();
        self
    }

    /// The value of [job_type][crate::model::OrderedJob::job_type]
    /// if it holds a `HadoopJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn hadoop_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::HadoopJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::ordered_job::JobType::HadoopJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::OrderedJob::job_type]
    /// to hold a `HadoopJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_hadoop_job<T: std::convert::Into<std::boxed::Box<crate::model::HadoopJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::ordered_job::JobType::HadoopJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::OrderedJob::job_type]
    /// if it holds a `SparkJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::SparkJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::ordered_job::JobType::SparkJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::OrderedJob::job_type]
    /// to hold a `SparkJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_spark_job<T: std::convert::Into<std::boxed::Box<crate::model::SparkJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::ordered_job::JobType::SparkJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::OrderedJob::job_type]
    /// if it holds a `PysparkJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pyspark_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::PySparkJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::ordered_job::JobType::PysparkJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::OrderedJob::job_type]
    /// to hold a `PysparkJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_pyspark_job<T: std::convert::Into<std::boxed::Box<crate::model::PySparkJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::ordered_job::JobType::PysparkJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::OrderedJob::job_type]
    /// if it holds a `HiveJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn hive_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::HiveJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::ordered_job::JobType::HiveJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::OrderedJob::job_type]
    /// to hold a `HiveJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_hive_job<T: std::convert::Into<std::boxed::Box<crate::model::HiveJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::ordered_job::JobType::HiveJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::OrderedJob::job_type]
    /// if it holds a `PigJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pig_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::PigJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::ordered_job::JobType::PigJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::OrderedJob::job_type]
    /// to hold a `PigJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_pig_job<T: std::convert::Into<std::boxed::Box<crate::model::PigJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::ordered_job::JobType::PigJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::OrderedJob::job_type]
    /// if it holds a `SparkRJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_r_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::SparkRJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::ordered_job::JobType::SparkRJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::OrderedJob::job_type]
    /// to hold a `SparkRJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_spark_r_job<T: std::convert::Into<std::boxed::Box<crate::model::SparkRJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::ordered_job::JobType::SparkRJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::OrderedJob::job_type]
    /// if it holds a `SparkSqlJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_sql_job(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SparkSqlJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::ordered_job::JobType::SparkSqlJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::OrderedJob::job_type]
    /// to hold a `SparkSqlJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_spark_sql_job<T: std::convert::Into<std::boxed::Box<crate::model::SparkSqlJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::ordered_job::JobType::SparkSqlJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::OrderedJob::job_type]
    /// if it holds a `PrestoJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn presto_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::PrestoJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::ordered_job::JobType::PrestoJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::OrderedJob::job_type]
    /// to hold a `PrestoJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_presto_job<T: std::convert::Into<std::boxed::Box<crate::model::PrestoJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::ordered_job::JobType::PrestoJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::OrderedJob::job_type]
    /// if it holds a `TrinoJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn trino_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::TrinoJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::ordered_job::JobType::TrinoJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::OrderedJob::job_type]
    /// to hold a `TrinoJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_trino_job<T: std::convert::Into<std::boxed::Box<crate::model::TrinoJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::ordered_job::JobType::TrinoJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::OrderedJob::job_type]
    /// if it holds a `FlinkJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn flink_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::FlinkJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::ordered_job::JobType::FlinkJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::OrderedJob::job_type]
    /// to hold a `FlinkJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_flink_job<T: std::convert::Into<std::boxed::Box<crate::model::FlinkJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::ordered_job::JobType::FlinkJob(v.into()));
        self
    }
}

impl wkt::message::Message for OrderedJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.OrderedJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OrderedJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __step_id,
            __hadoop_job,
            __spark_job,
            __pyspark_job,
            __hive_job,
            __pig_job,
            __spark_r_job,
            __spark_sql_job,
            __presto_job,
            __trino_job,
            __flink_job,
            __labels,
            __scheduling,
            __prerequisite_step_ids,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OrderedJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "stepId" => Ok(__FieldTag::__step_id),
                            "step_id" => Ok(__FieldTag::__step_id),
                            "hadoopJob" => Ok(__FieldTag::__hadoop_job),
                            "hadoop_job" => Ok(__FieldTag::__hadoop_job),
                            "sparkJob" => Ok(__FieldTag::__spark_job),
                            "spark_job" => Ok(__FieldTag::__spark_job),
                            "pysparkJob" => Ok(__FieldTag::__pyspark_job),
                            "pyspark_job" => Ok(__FieldTag::__pyspark_job),
                            "hiveJob" => Ok(__FieldTag::__hive_job),
                            "hive_job" => Ok(__FieldTag::__hive_job),
                            "pigJob" => Ok(__FieldTag::__pig_job),
                            "pig_job" => Ok(__FieldTag::__pig_job),
                            "sparkRJob" => Ok(__FieldTag::__spark_r_job),
                            "spark_r_job" => Ok(__FieldTag::__spark_r_job),
                            "sparkSqlJob" => Ok(__FieldTag::__spark_sql_job),
                            "spark_sql_job" => Ok(__FieldTag::__spark_sql_job),
                            "prestoJob" => Ok(__FieldTag::__presto_job),
                            "presto_job" => Ok(__FieldTag::__presto_job),
                            "trinoJob" => Ok(__FieldTag::__trino_job),
                            "trino_job" => Ok(__FieldTag::__trino_job),
                            "flinkJob" => Ok(__FieldTag::__flink_job),
                            "flink_job" => Ok(__FieldTag::__flink_job),
                            "labels" => Ok(__FieldTag::__labels),
                            "scheduling" => Ok(__FieldTag::__scheduling),
                            "prerequisiteStepIds" => Ok(__FieldTag::__prerequisite_step_ids),
                            "prerequisite_step_ids" => Ok(__FieldTag::__prerequisite_step_ids),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OrderedJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OrderedJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__step_id => {
                            if !fields.insert(__FieldTag::__step_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for step_id",
                                ));
                            }
                            result.step_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hadoop_job => {
                            if !fields.insert(__FieldTag::__hadoop_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hadoop_job",
                                ));
                            }
                            if result.job_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_type`, a oneof with full ID .google.cloud.dataproc.v1.OrderedJob.hadoop_job, latest field was hadoopJob",
                                ));
                            }
                            result.job_type = std::option::Option::Some(
                                crate::model::ordered_job::JobType::HadoopJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::HadoopJob>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__spark_job => {
                            if !fields.insert(__FieldTag::__spark_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark_job",
                                ));
                            }
                            if result.job_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_type`, a oneof with full ID .google.cloud.dataproc.v1.OrderedJob.spark_job, latest field was sparkJob",
                                ));
                            }
                            result.job_type = std::option::Option::Some(
                                crate::model::ordered_job::JobType::SparkJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SparkJob>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__pyspark_job => {
                            if !fields.insert(__FieldTag::__pyspark_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pyspark_job",
                                ));
                            }
                            if result.job_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_type`, a oneof with full ID .google.cloud.dataproc.v1.OrderedJob.pyspark_job, latest field was pysparkJob",
                                ));
                            }
                            result.job_type = std::option::Option::Some(
                                crate::model::ordered_job::JobType::PysparkJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PySparkJob>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__hive_job => {
                            if !fields.insert(__FieldTag::__hive_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hive_job",
                                ));
                            }
                            if result.job_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_type`, a oneof with full ID .google.cloud.dataproc.v1.OrderedJob.hive_job, latest field was hiveJob",
                                ));
                            }
                            result.job_type =
                                std::option::Option::Some(
                                    crate::model::ordered_job::JobType::HiveJob(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::HiveJob>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__pig_job => {
                            if !fields.insert(__FieldTag::__pig_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pig_job",
                                ));
                            }
                            if result.job_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_type`, a oneof with full ID .google.cloud.dataproc.v1.OrderedJob.pig_job, latest field was pigJob",
                                ));
                            }
                            result.job_type =
                                std::option::Option::Some(
                                    crate::model::ordered_job::JobType::PigJob(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::PigJob>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__spark_r_job => {
                            if !fields.insert(__FieldTag::__spark_r_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark_r_job",
                                ));
                            }
                            if result.job_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_type`, a oneof with full ID .google.cloud.dataproc.v1.OrderedJob.spark_r_job, latest field was sparkRJob",
                                ));
                            }
                            result.job_type = std::option::Option::Some(
                                crate::model::ordered_job::JobType::SparkRJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SparkRJob>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__spark_sql_job => {
                            if !fields.insert(__FieldTag::__spark_sql_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spark_sql_job",
                                ));
                            }
                            if result.job_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_type`, a oneof with full ID .google.cloud.dataproc.v1.OrderedJob.spark_sql_job, latest field was sparkSqlJob",
                                ));
                            }
                            result.job_type = std::option::Option::Some(
                                crate::model::ordered_job::JobType::SparkSqlJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SparkSqlJob>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__presto_job => {
                            if !fields.insert(__FieldTag::__presto_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for presto_job",
                                ));
                            }
                            if result.job_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_type`, a oneof with full ID .google.cloud.dataproc.v1.OrderedJob.presto_job, latest field was prestoJob",
                                ));
                            }
                            result.job_type = std::option::Option::Some(
                                crate::model::ordered_job::JobType::PrestoJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PrestoJob>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__trino_job => {
                            if !fields.insert(__FieldTag::__trino_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trino_job",
                                ));
                            }
                            if result.job_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_type`, a oneof with full ID .google.cloud.dataproc.v1.OrderedJob.trino_job, latest field was trinoJob",
                                ));
                            }
                            result.job_type = std::option::Option::Some(
                                crate::model::ordered_job::JobType::TrinoJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TrinoJob>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__flink_job => {
                            if !fields.insert(__FieldTag::__flink_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flink_job",
                                ));
                            }
                            if result.job_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `job_type`, a oneof with full ID .google.cloud.dataproc.v1.OrderedJob.flink_job, latest field was flinkJob",
                                ));
                            }
                            result.job_type = std::option::Option::Some(
                                crate::model::ordered_job::JobType::FlinkJob(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::FlinkJob>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scheduling => {
                            if !fields.insert(__FieldTag::__scheduling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scheduling",
                                ));
                            }
                            result.scheduling = map
                                .next_value::<std::option::Option<crate::model::JobScheduling>>()?;
                        }
                        __FieldTag::__prerequisite_step_ids => {
                            if !fields.insert(__FieldTag::__prerequisite_step_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for prerequisite_step_ids",
                                ));
                            }
                            result.prerequisite_step_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OrderedJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.step_id.is_empty() {
            state.serialize_entry("stepId", &self.step_id)?;
        }
        if let Some(value) = self.hadoop_job() {
            state.serialize_entry("hadoopJob", value)?;
        }
        if let Some(value) = self.spark_job() {
            state.serialize_entry("sparkJob", value)?;
        }
        if let Some(value) = self.pyspark_job() {
            state.serialize_entry("pysparkJob", value)?;
        }
        if let Some(value) = self.hive_job() {
            state.serialize_entry("hiveJob", value)?;
        }
        if let Some(value) = self.pig_job() {
            state.serialize_entry("pigJob", value)?;
        }
        if let Some(value) = self.spark_r_job() {
            state.serialize_entry("sparkRJob", value)?;
        }
        if let Some(value) = self.spark_sql_job() {
            state.serialize_entry("sparkSqlJob", value)?;
        }
        if let Some(value) = self.presto_job() {
            state.serialize_entry("prestoJob", value)?;
        }
        if let Some(value) = self.trino_job() {
            state.serialize_entry("trinoJob", value)?;
        }
        if let Some(value) = self.flink_job() {
            state.serialize_entry("flinkJob", value)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.scheduling.is_some() {
            state.serialize_entry("scheduling", &self.scheduling)?;
        }
        if !self.prerequisite_step_ids.is_empty() {
            state.serialize_entry("prerequisiteStepIds", &self.prerequisite_step_ids)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [OrderedJob].
pub mod ordered_job {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The job definition.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum JobType {
        /// Optional. Job is a Hadoop job.
        HadoopJob(std::boxed::Box<crate::model::HadoopJob>),
        /// Optional. Job is a Spark job.
        SparkJob(std::boxed::Box<crate::model::SparkJob>),
        /// Optional. Job is a PySpark job.
        PysparkJob(std::boxed::Box<crate::model::PySparkJob>),
        /// Optional. Job is a Hive job.
        HiveJob(std::boxed::Box<crate::model::HiveJob>),
        /// Optional. Job is a Pig job.
        PigJob(std::boxed::Box<crate::model::PigJob>),
        /// Optional. Job is a SparkR job.
        SparkRJob(std::boxed::Box<crate::model::SparkRJob>),
        /// Optional. Job is a SparkSql job.
        SparkSqlJob(std::boxed::Box<crate::model::SparkSqlJob>),
        /// Optional. Job is a Presto job.
        PrestoJob(std::boxed::Box<crate::model::PrestoJob>),
        /// Optional. Job is a Trino job.
        TrinoJob(std::boxed::Box<crate::model::TrinoJob>),
        /// Optional. Job is a Flink job.
        FlinkJob(std::boxed::Box<crate::model::FlinkJob>),
    }
}

/// A configurable parameter that replaces one or more fields in the template.
/// Parameterizable fields:
///
/// - Labels
/// - File uris
/// - Job properties
/// - Job arguments
/// - Script variables
/// - Main class (in HadoopJob and SparkJob)
/// - Zone (in ClusterSelector)
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TemplateParameter {
    /// Required. Parameter name.
    /// The parameter name is used as the key, and paired with the
    /// parameter value, which are passed to the template when the template
    /// is instantiated.
    /// The name must contain only capital letters (A-Z), numbers (0-9), and
    /// underscores (_), and must not start with a number. The maximum length is
    /// 40 characters.
    pub name: std::string::String,

    /// Required. Paths to all fields that the parameter replaces.
    /// A field is allowed to appear in at most one parameter's list of field
    /// paths.
    ///
    /// A field path is similar in syntax to a
    /// [google.protobuf.FieldMask][google.protobuf.FieldMask]. For example, a
    /// field path that references the zone field of a workflow template's cluster
    /// selector would be specified as `placement.clusterSelector.zone`.
    ///
    /// Also, field paths can reference fields using the following syntax:
    ///
    /// * Values in maps can be referenced by key:
    ///
    ///   * labels['key']
    ///   * placement.clusterSelector.clusterLabels['key']
    ///   * placement.managedCluster.labels['key']
    ///   * placement.clusterSelector.clusterLabels['key']
    ///   * jobs['step-id'].labels['key']
    /// * Jobs in the jobs list can be referenced by step-id:
    ///
    ///   * jobs['step-id'].hadoopJob.mainJarFileUri
    ///   * jobs['step-id'].hiveJob.queryFileUri
    ///   * jobs['step-id'].pySparkJob.mainPythonFileUri
    ///   * jobs['step-id'].hadoopJob.jarFileUris[0]
    ///   * jobs['step-id'].hadoopJob.archiveUris[0]
    ///   * jobs['step-id'].hadoopJob.fileUris[0]
    ///   * jobs['step-id'].pySparkJob.pythonFileUris[0]
    /// * Items in repeated fields can be referenced by a zero-based index:
    ///
    ///   * jobs['step-id'].sparkJob.args[0]
    /// * Other examples:
    ///
    ///   * jobs['step-id'].hadoopJob.properties['key']
    ///   * jobs['step-id'].hadoopJob.args[0]
    ///   * jobs['step-id'].hiveJob.scriptVariables['key']
    ///   * jobs['step-id'].hadoopJob.mainJarFileUri
    ///   * placement.clusterSelector.zone
    ///
    /// It may not be possible to parameterize maps and repeated fields in their
    /// entirety since only individual map values and individual items in repeated
    /// fields can be referenced. For example, the following field paths are
    /// invalid:
    ///
    /// - placement.clusterSelector.clusterLabels
    /// - jobs['step-id'].sparkJob.args
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    pub fields: std::vec::Vec<std::string::String>,

    /// Optional. Brief description of the parameter.
    /// Must not exceed 1024 characters.
    pub description: std::string::String,

    /// Optional. Validation rules to be applied to this parameter's value.
    pub validation: std::option::Option<crate::model::ParameterValidation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TemplateParameter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TemplateParameter::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::TemplateParameter::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [description][crate::model::TemplateParameter::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [validation][crate::model::TemplateParameter::validation].
    pub fn set_validation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ParameterValidation>,
    {
        self.validation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [validation][crate::model::TemplateParameter::validation].
    pub fn set_or_clear_validation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ParameterValidation>,
    {
        self.validation = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TemplateParameter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.TemplateParameter"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TemplateParameter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __fields,
            __description,
            __validation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TemplateParameter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "fields" => Ok(__FieldTag::__fields),
                            "description" => Ok(__FieldTag::__description),
                            "validation" => Ok(__FieldTag::__validation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TemplateParameter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TemplateParameter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fields => {
                            if !fields.insert(__FieldTag::__fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fields",
                                ));
                            }
                            result.fields = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validation => {
                            if !fields.insert(__FieldTag::__validation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validation",
                                ));
                            }
                            result.validation = map.next_value::<std::option::Option<crate::model::ParameterValidation>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TemplateParameter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.fields.is_empty() {
            state.serialize_entry("fields", &self.fields)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.validation.is_some() {
            state.serialize_entry("validation", &self.validation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration for parameter validation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ParameterValidation {
    /// Required. The type of validation to be performed.
    pub validation_type: std::option::Option<crate::model::parameter_validation::ValidationType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ParameterValidation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [validation_type][crate::model::ParameterValidation::validation_type].
    ///
    /// Note that all the setters affecting `validation_type` are mutually
    /// exclusive.
    pub fn set_validation_type<
        T: std::convert::Into<std::option::Option<crate::model::parameter_validation::ValidationType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.validation_type = v.into();
        self
    }

    /// The value of [validation_type][crate::model::ParameterValidation::validation_type]
    /// if it holds a `Regex`, `None` if the field is not set or
    /// holds a different branch.
    pub fn regex(&self) -> std::option::Option<&std::boxed::Box<crate::model::RegexValidation>> {
        #[allow(unreachable_patterns)]
        self.validation_type.as_ref().and_then(|v| match v {
            crate::model::parameter_validation::ValidationType::Regex(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [validation_type][crate::model::ParameterValidation::validation_type]
    /// to hold a `Regex`.
    ///
    /// Note that all the setters affecting `validation_type` are
    /// mutually exclusive.
    pub fn set_regex<T: std::convert::Into<std::boxed::Box<crate::model::RegexValidation>>>(
        mut self,
        v: T,
    ) -> Self {
        self.validation_type = std::option::Option::Some(
            crate::model::parameter_validation::ValidationType::Regex(v.into()),
        );
        self
    }

    /// The value of [validation_type][crate::model::ParameterValidation::validation_type]
    /// if it holds a `Values`, `None` if the field is not set or
    /// holds a different branch.
    pub fn values(&self) -> std::option::Option<&std::boxed::Box<crate::model::ValueValidation>> {
        #[allow(unreachable_patterns)]
        self.validation_type.as_ref().and_then(|v| match v {
            crate::model::parameter_validation::ValidationType::Values(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [validation_type][crate::model::ParameterValidation::validation_type]
    /// to hold a `Values`.
    ///
    /// Note that all the setters affecting `validation_type` are
    /// mutually exclusive.
    pub fn set_values<T: std::convert::Into<std::boxed::Box<crate::model::ValueValidation>>>(
        mut self,
        v: T,
    ) -> Self {
        self.validation_type = std::option::Option::Some(
            crate::model::parameter_validation::ValidationType::Values(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ParameterValidation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ParameterValidation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ParameterValidation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __regex,
            __values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ParameterValidation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "regex" => Ok(__FieldTag::__regex),
                            "values" => Ok(__FieldTag::__values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ParameterValidation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ParameterValidation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__regex => {
                            if !fields.insert(__FieldTag::__regex) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for regex",
                                ));
                            }
                            if result.validation_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `validation_type`, a oneof with full ID .google.cloud.dataproc.v1.ParameterValidation.regex, latest field was regex",
                                ));
                            }
                            result.validation_type = std::option::Option::Some(
                                crate::model::parameter_validation::ValidationType::Regex(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RegexValidation>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__values => {
                            if !fields.insert(__FieldTag::__values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for values",
                                ));
                            }
                            if result.validation_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `validation_type`, a oneof with full ID .google.cloud.dataproc.v1.ParameterValidation.values, latest field was values",
                                ));
                            }
                            result.validation_type = std::option::Option::Some(
                                crate::model::parameter_validation::ValidationType::Values(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ValueValidation>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ParameterValidation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.regex() {
            state.serialize_entry("regex", value)?;
        }
        if let Some(value) = self.values() {
            state.serialize_entry("values", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ParameterValidation].
pub mod parameter_validation {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The type of validation to be performed.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ValidationType {
        /// Validation based on regular expressions.
        Regex(std::boxed::Box<crate::model::RegexValidation>),
        /// Validation based on a list of allowed values.
        Values(std::boxed::Box<crate::model::ValueValidation>),
    }
}

/// Validation based on regular expressions.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RegexValidation {
    /// Required. RE2 regular expressions used to validate the parameter's value.
    /// The value must match the regex in its entirety (substring
    /// matches are not sufficient).
    pub regexes: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RegexValidation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [regexes][crate::model::RegexValidation::regexes].
    pub fn set_regexes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.regexes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RegexValidation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.RegexValidation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RegexValidation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __regexes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RegexValidation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "regexes" => Ok(__FieldTag::__regexes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RegexValidation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RegexValidation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__regexes => {
                            if !fields.insert(__FieldTag::__regexes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for regexes",
                                ));
                            }
                            result.regexes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RegexValidation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.regexes.is_empty() {
            state.serialize_entry("regexes", &self.regexes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Validation based on a list of allowed values.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ValueValidation {
    /// Required. List of allowed values for the parameter.
    pub values: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValueValidation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::ValueValidation::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ValueValidation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ValueValidation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ValueValidation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ValueValidation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "values" => Ok(__FieldTag::__values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ValueValidation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValueValidation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__values => {
                            if !fields.insert(__FieldTag::__values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for values",
                                ));
                            }
                            result.values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ValueValidation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.values.is_empty() {
            state.serialize_entry("values", &self.values)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A Dataproc workflow template resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WorkflowMetadata {
    /// Output only. The resource name of the workflow template as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.workflowTemplates`, the resource name of the
    ///   template has the following format:
    ///   `projects/{project_id}/regions/{region}/workflowTemplates/{template_id}`
    ///
    /// * For `projects.locations.workflowTemplates`, the resource name of the
    ///   template has the following format:
    ///   `projects/{project_id}/locations/{location}/workflowTemplates/{template_id}`
    ///
    pub template: std::string::String,

    /// Output only. The version of template at the time of
    /// workflow instantiation.
    pub version: i32,

    /// Output only. The create cluster operation metadata.
    pub create_cluster: std::option::Option<crate::model::ClusterOperation>,

    /// Output only. The workflow graph.
    pub graph: std::option::Option<crate::model::WorkflowGraph>,

    /// Output only. The delete cluster operation metadata.
    pub delete_cluster: std::option::Option<crate::model::ClusterOperation>,

    /// Output only. The workflow state.
    pub state: crate::model::workflow_metadata::State,

    /// Output only. The name of the target cluster.
    pub cluster_name: std::string::String,

    /// Map from parameter names to values that were used for those parameters.
    pub parameters: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Workflow start time.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Workflow end time.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The UUID of target cluster.
    pub cluster_uuid: std::string::String,

    /// Output only. The timeout duration for the DAG of jobs, expressed in seconds
    /// (see [JSON representation of
    /// duration](https://developers.google.com/protocol-buffers/docs/proto3#json)).
    pub dag_timeout: std::option::Option<wkt::Duration>,

    /// Output only. DAG start time, only set for workflows with
    /// [dag_timeout][google.cloud.dataproc.v1.WorkflowMetadata.dag_timeout] when
    /// DAG begins.
    ///
    /// [google.cloud.dataproc.v1.WorkflowMetadata.dag_timeout]: crate::model::WorkflowMetadata::dag_timeout
    pub dag_start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. DAG end time, only set for workflows with
    /// [dag_timeout][google.cloud.dataproc.v1.WorkflowMetadata.dag_timeout] when
    /// DAG ends.
    ///
    /// [google.cloud.dataproc.v1.WorkflowMetadata.dag_timeout]: crate::model::WorkflowMetadata::dag_timeout
    pub dag_end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkflowMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [template][crate::model::WorkflowMetadata::template].
    pub fn set_template<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.template = v.into();
        self
    }

    /// Sets the value of [version][crate::model::WorkflowMetadata::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [create_cluster][crate::model::WorkflowMetadata::create_cluster].
    pub fn set_create_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ClusterOperation>,
    {
        self.create_cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_cluster][crate::model::WorkflowMetadata::create_cluster].
    pub fn set_or_clear_create_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ClusterOperation>,
    {
        self.create_cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [graph][crate::model::WorkflowMetadata::graph].
    pub fn set_graph<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkflowGraph>,
    {
        self.graph = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [graph][crate::model::WorkflowMetadata::graph].
    pub fn set_or_clear_graph<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkflowGraph>,
    {
        self.graph = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_cluster][crate::model::WorkflowMetadata::delete_cluster].
    pub fn set_delete_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ClusterOperation>,
    {
        self.delete_cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_cluster][crate::model::WorkflowMetadata::delete_cluster].
    pub fn set_or_clear_delete_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ClusterOperation>,
    {
        self.delete_cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::WorkflowMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::workflow_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::WorkflowMetadata::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::WorkflowMetadata::parameters].
    pub fn set_parameters<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [start_time][crate::model::WorkflowMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::WorkflowMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::WorkflowMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::WorkflowMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cluster_uuid][crate::model::WorkflowMetadata::cluster_uuid].
    pub fn set_cluster_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uuid = v.into();
        self
    }

    /// Sets the value of [dag_timeout][crate::model::WorkflowMetadata::dag_timeout].
    pub fn set_dag_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.dag_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dag_timeout][crate::model::WorkflowMetadata::dag_timeout].
    pub fn set_or_clear_dag_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.dag_timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dag_start_time][crate::model::WorkflowMetadata::dag_start_time].
    pub fn set_dag_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.dag_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dag_start_time][crate::model::WorkflowMetadata::dag_start_time].
    pub fn set_or_clear_dag_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.dag_start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dag_end_time][crate::model::WorkflowMetadata::dag_end_time].
    pub fn set_dag_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.dag_end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dag_end_time][crate::model::WorkflowMetadata::dag_end_time].
    pub fn set_or_clear_dag_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.dag_end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for WorkflowMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.WorkflowMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WorkflowMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __template,
            __version,
            __create_cluster,
            __graph,
            __delete_cluster,
            __state,
            __cluster_name,
            __parameters,
            __start_time,
            __end_time,
            __cluster_uuid,
            __dag_timeout,
            __dag_start_time,
            __dag_end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkflowMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "template" => Ok(__FieldTag::__template),
                            "version" => Ok(__FieldTag::__version),
                            "createCluster" => Ok(__FieldTag::__create_cluster),
                            "create_cluster" => Ok(__FieldTag::__create_cluster),
                            "graph" => Ok(__FieldTag::__graph),
                            "deleteCluster" => Ok(__FieldTag::__delete_cluster),
                            "delete_cluster" => Ok(__FieldTag::__delete_cluster),
                            "state" => Ok(__FieldTag::__state),
                            "clusterName" => Ok(__FieldTag::__cluster_name),
                            "cluster_name" => Ok(__FieldTag::__cluster_name),
                            "parameters" => Ok(__FieldTag::__parameters),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "clusterUuid" => Ok(__FieldTag::__cluster_uuid),
                            "cluster_uuid" => Ok(__FieldTag::__cluster_uuid),
                            "dagTimeout" => Ok(__FieldTag::__dag_timeout),
                            "dag_timeout" => Ok(__FieldTag::__dag_timeout),
                            "dagStartTime" => Ok(__FieldTag::__dag_start_time),
                            "dag_start_time" => Ok(__FieldTag::__dag_start_time),
                            "dagEndTime" => Ok(__FieldTag::__dag_end_time),
                            "dag_end_time" => Ok(__FieldTag::__dag_end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WorkflowMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkflowMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__template => {
                            if !fields.insert(__FieldTag::__template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for template",
                                ));
                            }
                            result.template = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.version = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__create_cluster => {
                            if !fields.insert(__FieldTag::__create_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_cluster",
                                ));
                            }
                            result.create_cluster = map
                                .next_value::<std::option::Option<crate::model::ClusterOperation>>(
                                )?;
                        }
                        __FieldTag::__graph => {
                            if !fields.insert(__FieldTag::__graph) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for graph",
                                ));
                            }
                            result.graph = map
                                .next_value::<std::option::Option<crate::model::WorkflowGraph>>()?;
                        }
                        __FieldTag::__delete_cluster => {
                            if !fields.insert(__FieldTag::__delete_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_cluster",
                                ));
                            }
                            result.delete_cluster = map
                                .next_value::<std::option::Option<crate::model::ClusterOperation>>(
                                )?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::workflow_metadata::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cluster_name => {
                            if !fields.insert(__FieldTag::__cluster_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_name",
                                ));
                            }
                            result.cluster_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__cluster_uuid => {
                            if !fields.insert(__FieldTag::__cluster_uuid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_uuid",
                                ));
                            }
                            result.cluster_uuid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dag_timeout => {
                            if !fields.insert(__FieldTag::__dag_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dag_timeout",
                                ));
                            }
                            result.dag_timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__dag_start_time => {
                            if !fields.insert(__FieldTag::__dag_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dag_start_time",
                                ));
                            }
                            result.dag_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__dag_end_time => {
                            if !fields.insert(__FieldTag::__dag_end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dag_end_time",
                                ));
                            }
                            result.dag_end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WorkflowMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.template.is_empty() {
            state.serialize_entry("template", &self.template)?;
        }
        if !wkt::internal::is_default(&self.version) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("version", &__With(&self.version))?;
        }
        if self.create_cluster.is_some() {
            state.serialize_entry("createCluster", &self.create_cluster)?;
        }
        if self.graph.is_some() {
            state.serialize_entry("graph", &self.graph)?;
        }
        if self.delete_cluster.is_some() {
            state.serialize_entry("deleteCluster", &self.delete_cluster)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.cluster_name.is_empty() {
            state.serialize_entry("clusterName", &self.cluster_name)?;
        }
        if !self.parameters.is_empty() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.cluster_uuid.is_empty() {
            state.serialize_entry("clusterUuid", &self.cluster_uuid)?;
        }
        if self.dag_timeout.is_some() {
            state.serialize_entry("dagTimeout", &self.dag_timeout)?;
        }
        if self.dag_start_time.is_some() {
            state.serialize_entry("dagStartTime", &self.dag_start_time)?;
        }
        if self.dag_end_time.is_some() {
            state.serialize_entry("dagEndTime", &self.dag_end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [WorkflowMetadata].
pub mod workflow_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// The operation state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unused.
        Unknown,
        /// The operation has been created.
        Pending,
        /// The operation is running.
        Running,
        /// The operation is done; either cancelled or completed.
        Done,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Done => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Pending,
                2 => Self::Running,
                3 => Self::Done,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "PENDING" => Self::Pending,
                "RUNNING" => Self::Running,
                "DONE" => Self::Done,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Done => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataproc.v1.WorkflowMetadata.State",
            ))
        }
    }
}

/// The cluster operation triggered by a workflow.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ClusterOperation {
    /// Output only. The id of the cluster operation.
    pub operation_id: std::string::String,

    /// Output only. Error, if operation failed.
    pub error: std::string::String,

    /// Output only. Indicates the operation is done.
    pub done: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterOperation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation_id][crate::model::ClusterOperation::operation_id].
    pub fn set_operation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_id = v.into();
        self
    }

    /// Sets the value of [error][crate::model::ClusterOperation::error].
    pub fn set_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [done][crate::model::ClusterOperation::done].
    pub fn set_done<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.done = v.into();
        self
    }
}

impl wkt::message::Message for ClusterOperation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ClusterOperation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClusterOperation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __operation_id,
            __error,
            __done,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClusterOperation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "operationId" => Ok(__FieldTag::__operation_id),
                            "operation_id" => Ok(__FieldTag::__operation_id),
                            "error" => Ok(__FieldTag::__error),
                            "done" => Ok(__FieldTag::__done),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClusterOperation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClusterOperation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__operation_id => {
                            if !fields.insert(__FieldTag::__operation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_id",
                                ));
                            }
                            result.operation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__done => {
                            if !fields.insert(__FieldTag::__done) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for done",
                                ));
                            }
                            result.done = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ClusterOperation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.operation_id.is_empty() {
            state.serialize_entry("operationId", &self.operation_id)?;
        }
        if !self.error.is_empty() {
            state.serialize_entry("error", &self.error)?;
        }
        if !wkt::internal::is_default(&self.done) {
            state.serialize_entry("done", &self.done)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The workflow graph.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WorkflowGraph {
    /// Output only. The workflow nodes.
    pub nodes: std::vec::Vec<crate::model::WorkflowNode>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkflowGraph {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [nodes][crate::model::WorkflowGraph::nodes].
    pub fn set_nodes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WorkflowNode>,
    {
        use std::iter::Iterator;
        self.nodes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for WorkflowGraph {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.WorkflowGraph"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WorkflowGraph {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __nodes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkflowGraph")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nodes" => Ok(__FieldTag::__nodes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WorkflowGraph;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkflowGraph")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__nodes => {
                            if !fields.insert(__FieldTag::__nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nodes",
                                ));
                            }
                            result.nodes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::WorkflowNode>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WorkflowGraph {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.nodes.is_empty() {
            state.serialize_entry("nodes", &self.nodes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The workflow node.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WorkflowNode {
    /// Output only. The name of the node.
    pub step_id: std::string::String,

    /// Output only. Node's prerequisite nodes.
    pub prerequisite_step_ids: std::vec::Vec<std::string::String>,

    /// Output only. The job id; populated after the node enters RUNNING state.
    pub job_id: std::string::String,

    /// Output only. The node state.
    pub state: crate::model::workflow_node::NodeState,

    /// Output only. The error detail.
    pub error: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkflowNode {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [step_id][crate::model::WorkflowNode::step_id].
    pub fn set_step_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.step_id = v.into();
        self
    }

    /// Sets the value of [prerequisite_step_ids][crate::model::WorkflowNode::prerequisite_step_ids].
    pub fn set_prerequisite_step_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.prerequisite_step_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [job_id][crate::model::WorkflowNode::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::WorkflowNode::state].
    pub fn set_state<T: std::convert::Into<crate::model::workflow_node::NodeState>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::WorkflowNode::error].
    pub fn set_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error = v.into();
        self
    }
}

impl wkt::message::Message for WorkflowNode {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.WorkflowNode"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WorkflowNode {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __step_id,
            __prerequisite_step_ids,
            __job_id,
            __state,
            __error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkflowNode")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "stepId" => Ok(__FieldTag::__step_id),
                            "step_id" => Ok(__FieldTag::__step_id),
                            "prerequisiteStepIds" => Ok(__FieldTag::__prerequisite_step_ids),
                            "prerequisite_step_ids" => Ok(__FieldTag::__prerequisite_step_ids),
                            "jobId" => Ok(__FieldTag::__job_id),
                            "job_id" => Ok(__FieldTag::__job_id),
                            "state" => Ok(__FieldTag::__state),
                            "error" => Ok(__FieldTag::__error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WorkflowNode;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkflowNode")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__step_id => {
                            if !fields.insert(__FieldTag::__step_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for step_id",
                                ));
                            }
                            result.step_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__prerequisite_step_ids => {
                            if !fields.insert(__FieldTag::__prerequisite_step_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for prerequisite_step_ids",
                                ));
                            }
                            result.prerequisite_step_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__job_id => {
                            if !fields.insert(__FieldTag::__job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for job_id",
                                ));
                            }
                            result.job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::workflow_node::NodeState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WorkflowNode {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.step_id.is_empty() {
            state.serialize_entry("stepId", &self.step_id)?;
        }
        if !self.prerequisite_step_ids.is_empty() {
            state.serialize_entry("prerequisiteStepIds", &self.prerequisite_step_ids)?;
        }
        if !self.job_id.is_empty() {
            state.serialize_entry("jobId", &self.job_id)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.error.is_empty() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [WorkflowNode].
pub mod workflow_node {
    #[allow(unused_imports)]
    use super::*;

    /// The workflow node state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NodeState {
        /// State is unspecified.
        Unspecified,
        /// The node is awaiting prerequisite node to finish.
        Blocked,
        /// The node is runnable but not running.
        Runnable,
        /// The node is running.
        Running,
        /// The node completed successfully.
        Completed,
        /// The node failed. A node can be marked FAILED because
        /// its ancestor or peer failed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [NodeState::value] or
        /// [NodeState::name].
        UnknownValue(node_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod node_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl NodeState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Blocked => std::option::Option::Some(1),
                Self::Runnable => std::option::Option::Some(2),
                Self::Running => std::option::Option::Some(3),
                Self::Completed => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("NODE_STATE_UNSPECIFIED"),
                Self::Blocked => std::option::Option::Some("BLOCKED"),
                Self::Runnable => std::option::Option::Some("RUNNABLE"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Completed => std::option::Option::Some("COMPLETED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for NodeState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for NodeState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for NodeState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Blocked,
                2 => Self::Runnable,
                3 => Self::Running,
                4 => Self::Completed,
                5 => Self::Failed,
                _ => Self::UnknownValue(node_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for NodeState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NODE_STATE_UNSPECIFIED" => Self::Unspecified,
                "BLOCKED" => Self::Blocked,
                "RUNNABLE" => Self::Runnable,
                "RUNNING" => Self::Running,
                "COMPLETED" => Self::Completed,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(node_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for NodeState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Blocked => serializer.serialize_i32(1),
                Self::Runnable => serializer.serialize_i32(2),
                Self::Running => serializer.serialize_i32(3),
                Self::Completed => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for NodeState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<NodeState>::new(
                ".google.cloud.dataproc.v1.WorkflowNode.NodeState",
            ))
        }
    }
}

/// A request to create a workflow template.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateWorkflowTemplateRequest {
    /// Required. The resource name of the region or location, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.workflowTemplates.create`, the resource name of the
    ///   region has the following format:
    ///   `projects/{project_id}/regions/{region}`
    ///
    /// * For `projects.locations.workflowTemplates.create`, the resource name of
    ///   the location has the following format:
    ///   `projects/{project_id}/locations/{location}`
    ///
    pub parent: std::string::String,

    /// Required. The Dataproc workflow template to create.
    pub template: std::option::Option<crate::model::WorkflowTemplate>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateWorkflowTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateWorkflowTemplateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [template][crate::model::CreateWorkflowTemplateRequest::template].
    pub fn set_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkflowTemplate>,
    {
        self.template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [template][crate::model::CreateWorkflowTemplateRequest::template].
    pub fn set_or_clear_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkflowTemplate>,
    {
        self.template = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateWorkflowTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.CreateWorkflowTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateWorkflowTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __template,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateWorkflowTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "template" => Ok(__FieldTag::__template),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateWorkflowTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateWorkflowTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__template => {
                            if !fields.insert(__FieldTag::__template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for template",
                                ));
                            }
                            result.template = map
                                .next_value::<std::option::Option<crate::model::WorkflowTemplate>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateWorkflowTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.template.is_some() {
            state.serialize_entry("template", &self.template)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to fetch a workflow template.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetWorkflowTemplateRequest {
    /// Required. The resource name of the workflow template, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.workflowTemplates.get`, the resource name of the
    ///   template has the following format:
    ///   `projects/{project_id}/regions/{region}/workflowTemplates/{template_id}`
    ///
    /// * For `projects.locations.workflowTemplates.get`, the resource name of the
    ///   template has the following format:
    ///   `projects/{project_id}/locations/{location}/workflowTemplates/{template_id}`
    ///
    pub name: std::string::String,

    /// Optional. The version of workflow template to retrieve. Only previously
    /// instantiated versions can be retrieved.
    ///
    /// If unspecified, retrieves the current version.
    pub version: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetWorkflowTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetWorkflowTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::GetWorkflowTemplateRequest::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for GetWorkflowTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GetWorkflowTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetWorkflowTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetWorkflowTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetWorkflowTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetWorkflowTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.version = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetWorkflowTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.version) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("version", &__With(&self.version))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to instantiate a workflow template.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstantiateWorkflowTemplateRequest {
    /// Required. The resource name of the workflow template, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.workflowTemplates.instantiate`, the resource name
    ///   of the template has the following format:
    ///   `projects/{project_id}/regions/{region}/workflowTemplates/{template_id}`
    ///
    /// * For `projects.locations.workflowTemplates.instantiate`, the resource name
    ///   of the template has the following format:
    ///   `projects/{project_id}/locations/{location}/workflowTemplates/{template_id}`
    ///
    pub name: std::string::String,

    /// Optional. The version of workflow template to instantiate. If specified,
    /// the workflow will be instantiated only if the current version of
    /// the workflow template has the supplied version.
    ///
    /// This option cannot be used to instantiate a previous version of
    /// workflow template.
    pub version: i32,

    /// Optional. A tag that prevents multiple concurrent workflow
    /// instances with the same tag from running. This mitigates risk of
    /// concurrent instances started due to retries.
    ///
    /// It is recommended to always set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The tag must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    pub request_id: std::string::String,

    /// Optional. Map from parameter names to values that should be used for those
    /// parameters. Values may not exceed 1000 characters.
    pub parameters: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstantiateWorkflowTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InstantiateWorkflowTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::InstantiateWorkflowTemplateRequest::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::InstantiateWorkflowTemplateRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::InstantiateWorkflowTemplateRequest::parameters].
    pub fn set_parameters<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for InstantiateWorkflowTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.InstantiateWorkflowTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstantiateWorkflowTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __version,
            __request_id,
            __parameters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstantiateWorkflowTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "version" => Ok(__FieldTag::__version),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "parameters" => Ok(__FieldTag::__parameters),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstantiateWorkflowTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstantiateWorkflowTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.version = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstantiateWorkflowTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.version) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("version", &__With(&self.version))?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self.parameters.is_empty() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to instantiate an inline workflow template.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstantiateInlineWorkflowTemplateRequest {
    /// Required. The resource name of the region or location, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.workflowTemplates,instantiateinline`, the resource
    ///   name of the region has the following format:
    ///   `projects/{project_id}/regions/{region}`
    ///
    /// * For `projects.locations.workflowTemplates.instantiateinline`, the
    ///   resource name of the location has the following format:
    ///   `projects/{project_id}/locations/{location}`
    ///
    pub parent: std::string::String,

    /// Required. The workflow template to instantiate.
    pub template: std::option::Option<crate::model::WorkflowTemplate>,

    /// Optional. A tag that prevents multiple concurrent workflow
    /// instances with the same tag from running. This mitigates risk of
    /// concurrent instances started due to retries.
    ///
    /// It is recommended to always set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The tag must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstantiateInlineWorkflowTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::InstantiateInlineWorkflowTemplateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [template][crate::model::InstantiateInlineWorkflowTemplateRequest::template].
    pub fn set_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkflowTemplate>,
    {
        self.template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [template][crate::model::InstantiateInlineWorkflowTemplateRequest::template].
    pub fn set_or_clear_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkflowTemplate>,
    {
        self.template = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::InstantiateInlineWorkflowTemplateRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for InstantiateInlineWorkflowTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.InstantiateInlineWorkflowTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstantiateInlineWorkflowTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __template,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for InstantiateInlineWorkflowTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "template" => Ok(__FieldTag::__template),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstantiateInlineWorkflowTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstantiateInlineWorkflowTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__template => {
                            if !fields.insert(__FieldTag::__template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for template",
                                ));
                            }
                            result.template = map
                                .next_value::<std::option::Option<crate::model::WorkflowTemplate>>(
                                )?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstantiateInlineWorkflowTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.template.is_some() {
            state.serialize_entry("template", &self.template)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to update a workflow template.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateWorkflowTemplateRequest {
    /// Required. The updated workflow template.
    ///
    /// The `template.version` field must match the current version.
    pub template: std::option::Option<crate::model::WorkflowTemplate>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateWorkflowTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [template][crate::model::UpdateWorkflowTemplateRequest::template].
    pub fn set_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkflowTemplate>,
    {
        self.template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [template][crate::model::UpdateWorkflowTemplateRequest::template].
    pub fn set_or_clear_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkflowTemplate>,
    {
        self.template = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateWorkflowTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.UpdateWorkflowTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateWorkflowTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __template,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateWorkflowTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "template" => Ok(__FieldTag::__template),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateWorkflowTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateWorkflowTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__template => {
                            if !fields.insert(__FieldTag::__template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for template",
                                ));
                            }
                            result.template = map
                                .next_value::<std::option::Option<crate::model::WorkflowTemplate>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateWorkflowTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.template.is_some() {
            state.serialize_entry("template", &self.template)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to list workflow templates in a project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListWorkflowTemplatesRequest {
    /// Required. The resource name of the region or location, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.workflowTemplates,list`, the resource
    ///   name of the region has the following format:
    ///   `projects/{project_id}/regions/{region}`
    ///
    /// * For `projects.locations.workflowTemplates.list`, the
    ///   resource name of the location has the following format:
    ///   `projects/{project_id}/locations/{location}`
    ///
    pub parent: std::string::String,

    /// Optional. The maximum number of results to return in each response.
    pub page_size: i32,

    /// Optional. The page token, returned by a previous call, to request the
    /// next page of results.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkflowTemplatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListWorkflowTemplatesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListWorkflowTemplatesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListWorkflowTemplatesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListWorkflowTemplatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListWorkflowTemplatesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListWorkflowTemplatesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWorkflowTemplatesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListWorkflowTemplatesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWorkflowTemplatesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListWorkflowTemplatesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A response to a request to list workflow templates in a project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListWorkflowTemplatesResponse {
    /// Output only. WorkflowTemplates list.
    pub templates: std::vec::Vec<crate::model::WorkflowTemplate>,

    /// Output only. This token is included in the response if there are more
    /// results to fetch. To fetch additional results, provide this value as the
    /// page_token in a subsequent \<code\>ListWorkflowTemplatesRequest\</code\>.
    pub next_page_token: std::string::String,

    /// Output only. List of workflow templates that could not be included in the
    /// response. Attempting to get one of these resources may indicate why it was
    /// not included in the list response.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkflowTemplatesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [templates][crate::model::ListWorkflowTemplatesResponse::templates].
    pub fn set_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WorkflowTemplate>,
    {
        use std::iter::Iterator;
        self.templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListWorkflowTemplatesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListWorkflowTemplatesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListWorkflowTemplatesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListWorkflowTemplatesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListWorkflowTemplatesResponse {
    type PageItem = crate::model::WorkflowTemplate;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.templates
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListWorkflowTemplatesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __templates,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWorkflowTemplatesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "templates" => Ok(__FieldTag::__templates),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListWorkflowTemplatesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWorkflowTemplatesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__templates => {
                            if !fields.insert(__FieldTag::__templates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for templates",
                                ));
                            }
                            result.templates =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::WorkflowTemplate>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListWorkflowTemplatesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.templates.is_empty() {
            state.serialize_entry("templates", &self.templates)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A request to delete a workflow template.
///
/// Currently started workflows will remain running.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteWorkflowTemplateRequest {
    /// Required. The resource name of the workflow template, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.workflowTemplates.delete`, the resource name
    ///   of the template has the following format:
    ///   `projects/{project_id}/regions/{region}/workflowTemplates/{template_id}`
    ///
    /// * For `projects.locations.workflowTemplates.instantiate`, the resource name
    ///   of the template has the following format:
    ///   `projects/{project_id}/locations/{location}/workflowTemplates/{template_id}`
    ///
    pub name: std::string::String,

    /// Optional. The version of workflow template to delete. If specified,
    /// will only delete the template if the current server version matches
    /// specified version.
    pub version: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteWorkflowTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteWorkflowTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::DeleteWorkflowTemplateRequest::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for DeleteWorkflowTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DeleteWorkflowTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteWorkflowTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteWorkflowTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteWorkflowTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteWorkflowTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.version = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteWorkflowTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.version) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("version", &__With(&self.version))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Cluster components that can be activated.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Component {
    /// Unspecified component. Specifying this will cause Cluster creation to fail.
    Unspecified,
    /// The Anaconda component is no longer supported or applicable to
    /// [supported Dataproc on Compute Engine image versions]
    /// (<https://cloud.google.com/dataproc/docs/concepts/versioning/dataproc-version-clusters#supported-dataproc-image-versions>).
    /// It cannot be activated on clusters created with supported Dataproc on
    /// Compute Engine image versions.
    Anaconda,
    /// Delta Lake.
    Delta,
    /// Docker
    Docker,
    /// The Druid query engine. (alpha)
    Druid,
    /// Flink
    Flink,
    /// HBase. (beta)
    Hbase,
    /// The Hive Web HCatalog (the REST service for accessing HCatalog).
    HiveWebhcat,
    /// Hudi.
    Hudi,
    /// Iceberg.
    Iceberg,
    /// The Jupyter Notebook.
    Jupyter,
    /// The Pig component.
    Pig,
    /// The Presto query engine.
    Presto,
    /// The Trino query engine.
    Trino,
    /// The Ranger service.
    Ranger,
    /// The Solr service.
    Solr,
    /// The Zeppelin notebook.
    Zeppelin,
    /// The Zookeeper service.
    Zookeeper,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Component::value] or
    /// [Component::name].
    UnknownValue(component::UnknownValue),
}

#[doc(hidden)]
pub mod component {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Component {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Anaconda => std::option::Option::Some(5),
            Self::Delta => std::option::Option::Some(20),
            Self::Docker => std::option::Option::Some(13),
            Self::Druid => std::option::Option::Some(9),
            Self::Flink => std::option::Option::Some(14),
            Self::Hbase => std::option::Option::Some(11),
            Self::HiveWebhcat => std::option::Option::Some(3),
            Self::Hudi => std::option::Option::Some(18),
            Self::Iceberg => std::option::Option::Some(19),
            Self::Jupyter => std::option::Option::Some(1),
            Self::Pig => std::option::Option::Some(21),
            Self::Presto => std::option::Option::Some(6),
            Self::Trino => std::option::Option::Some(17),
            Self::Ranger => std::option::Option::Some(12),
            Self::Solr => std::option::Option::Some(10),
            Self::Zeppelin => std::option::Option::Some(4),
            Self::Zookeeper => std::option::Option::Some(8),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("COMPONENT_UNSPECIFIED"),
            Self::Anaconda => std::option::Option::Some("ANACONDA"),
            Self::Delta => std::option::Option::Some("DELTA"),
            Self::Docker => std::option::Option::Some("DOCKER"),
            Self::Druid => std::option::Option::Some("DRUID"),
            Self::Flink => std::option::Option::Some("FLINK"),
            Self::Hbase => std::option::Option::Some("HBASE"),
            Self::HiveWebhcat => std::option::Option::Some("HIVE_WEBHCAT"),
            Self::Hudi => std::option::Option::Some("HUDI"),
            Self::Iceberg => std::option::Option::Some("ICEBERG"),
            Self::Jupyter => std::option::Option::Some("JUPYTER"),
            Self::Pig => std::option::Option::Some("PIG"),
            Self::Presto => std::option::Option::Some("PRESTO"),
            Self::Trino => std::option::Option::Some("TRINO"),
            Self::Ranger => std::option::Option::Some("RANGER"),
            Self::Solr => std::option::Option::Some("SOLR"),
            Self::Zeppelin => std::option::Option::Some("ZEPPELIN"),
            Self::Zookeeper => std::option::Option::Some("ZOOKEEPER"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Component {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Component {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Component {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Jupyter,
            3 => Self::HiveWebhcat,
            4 => Self::Zeppelin,
            5 => Self::Anaconda,
            6 => Self::Presto,
            8 => Self::Zookeeper,
            9 => Self::Druid,
            10 => Self::Solr,
            11 => Self::Hbase,
            12 => Self::Ranger,
            13 => Self::Docker,
            14 => Self::Flink,
            17 => Self::Trino,
            18 => Self::Hudi,
            19 => Self::Iceberg,
            20 => Self::Delta,
            21 => Self::Pig,
            _ => Self::UnknownValue(component::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Component {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COMPONENT_UNSPECIFIED" => Self::Unspecified,
            "ANACONDA" => Self::Anaconda,
            "DELTA" => Self::Delta,
            "DOCKER" => Self::Docker,
            "DRUID" => Self::Druid,
            "FLINK" => Self::Flink,
            "HBASE" => Self::Hbase,
            "HIVE_WEBHCAT" => Self::HiveWebhcat,
            "HUDI" => Self::Hudi,
            "ICEBERG" => Self::Iceberg,
            "JUPYTER" => Self::Jupyter,
            "PIG" => Self::Pig,
            "PRESTO" => Self::Presto,
            "TRINO" => Self::Trino,
            "RANGER" => Self::Ranger,
            "SOLR" => Self::Solr,
            "ZEPPELIN" => Self::Zeppelin,
            "ZOOKEEPER" => Self::Zookeeper,
            _ => Self::UnknownValue(component::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Component {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Anaconda => serializer.serialize_i32(5),
            Self::Delta => serializer.serialize_i32(20),
            Self::Docker => serializer.serialize_i32(13),
            Self::Druid => serializer.serialize_i32(9),
            Self::Flink => serializer.serialize_i32(14),
            Self::Hbase => serializer.serialize_i32(11),
            Self::HiveWebhcat => serializer.serialize_i32(3),
            Self::Hudi => serializer.serialize_i32(18),
            Self::Iceberg => serializer.serialize_i32(19),
            Self::Jupyter => serializer.serialize_i32(1),
            Self::Pig => serializer.serialize_i32(21),
            Self::Presto => serializer.serialize_i32(6),
            Self::Trino => serializer.serialize_i32(17),
            Self::Ranger => serializer.serialize_i32(12),
            Self::Solr => serializer.serialize_i32(10),
            Self::Zeppelin => serializer.serialize_i32(4),
            Self::Zookeeper => serializer.serialize_i32(8),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Component {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Component>::new(
            ".google.cloud.dataproc.v1.Component",
        ))
    }
}

/// Actions in response to failure of a resource associated with a cluster.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum FailureAction {
    /// When FailureAction is unspecified, failure action defaults to NO_ACTION.
    Unspecified,
    /// Take no action on failure to create a cluster resource. NO_ACTION is the
    /// default.
    NoAction,
    /// Delete the failed cluster resource.
    Delete,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [FailureAction::value] or
    /// [FailureAction::name].
    UnknownValue(failure_action::UnknownValue),
}

#[doc(hidden)]
pub mod failure_action {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl FailureAction {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::NoAction => std::option::Option::Some(1),
            Self::Delete => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("FAILURE_ACTION_UNSPECIFIED"),
            Self::NoAction => std::option::Option::Some("NO_ACTION"),
            Self::Delete => std::option::Option::Some("DELETE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for FailureAction {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for FailureAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for FailureAction {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::NoAction,
            2 => Self::Delete,
            _ => Self::UnknownValue(failure_action::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for FailureAction {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "FAILURE_ACTION_UNSPECIFIED" => Self::Unspecified,
            "NO_ACTION" => Self::NoAction,
            "DELETE" => Self::Delete,
            _ => Self::UnknownValue(failure_action::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for FailureAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::NoAction => serializer.serialize_i32(1),
            Self::Delete => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for FailureAction {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<FailureAction>::new(
            ".google.cloud.dataproc.v1.FailureAction",
        ))
    }
}
