// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate iam_v1;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Describes an autoscaling policy for Dataproc cluster autoscaler.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutoscalingPolicy {
    /// Required. The policy id.
    ///
    /// The id must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). Cannot begin or end with underscore
    /// or hyphen. Must consist of between 3 and 50 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Output only. The "resource name" of the autoscaling policy, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.autoscalingPolicies`, the resource name of the
    ///   policy has the following format:
    ///   `projects/{project_id}/regions/{region}/autoscalingPolicies/{policy_id}`
    ///
    /// * For `projects.locations.autoscalingPolicies`, the resource name of the
    ///   policy has the following format:
    ///   `projects/{project_id}/locations/{location}/autoscalingPolicies/{policy_id}`
    ///
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Describes how the autoscaler will operate for primary workers.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub worker_config: std::option::Option<crate::model::InstanceGroupAutoscalingPolicyConfig>,

    /// Optional. Describes how the autoscaler will operate for secondary workers.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub secondary_worker_config:
        std::option::Option<crate::model::InstanceGroupAutoscalingPolicyConfig>,

    /// Optional. The labels to associate with this autoscaling policy.
    /// Label **keys** must contain 1 to 63 characters, and must conform to
    /// [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt).
    /// Label **values** may be empty, but, if present, must contain 1 to 63
    /// characters, and must conform to [RFC
    /// 1035](https://www.ietf.org/rfc/rfc1035.txt). No more than 32 labels can be
    /// associated with an autoscaling policy.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Autoscaling algorithm for policy.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub algorithm: std::option::Option<crate::model::autoscaling_policy::Algorithm>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoscalingPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::AutoscalingPolicy::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::AutoscalingPolicy::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [worker_config][crate::model::AutoscalingPolicy::worker_config].
    pub fn set_worker_config<
        T: std::convert::Into<std::option::Option<crate::model::InstanceGroupAutoscalingPolicyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.worker_config = v.into();
        self
    }

    /// Sets the value of [secondary_worker_config][crate::model::AutoscalingPolicy::secondary_worker_config].
    pub fn set_secondary_worker_config<
        T: std::convert::Into<std::option::Option<crate::model::InstanceGroupAutoscalingPolicyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.secondary_worker_config = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::AutoscalingPolicy::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [algorithm][crate::model::AutoscalingPolicy::algorithm].
    ///
    /// Note that all the setters affecting `algorithm` are mutually
    /// exclusive.
    pub fn set_algorithm<
        T: std::convert::Into<std::option::Option<crate::model::autoscaling_policy::Algorithm>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.algorithm = v.into();
        self
    }

    /// The value of [algorithm][crate::model::AutoscalingPolicy::algorithm]
    /// if it holds a `BasicAlgorithm`, `None` if the field is not set or
    /// holds a different branch.
    pub fn basic_algorithm(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BasicAutoscalingAlgorithm>> {
        #[allow(unreachable_patterns)]
        self.algorithm.as_ref().and_then(|v| match v {
            crate::model::autoscaling_policy::Algorithm::BasicAlgorithm(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [algorithm][crate::model::AutoscalingPolicy::algorithm]
    /// to hold a `BasicAlgorithm`.
    ///
    /// Note that all the setters affecting `algorithm` are
    /// mutually exclusive.
    pub fn set_basic_algorithm<
        T: std::convert::Into<std::boxed::Box<crate::model::BasicAutoscalingAlgorithm>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.algorithm = std::option::Option::Some(
            crate::model::autoscaling_policy::Algorithm::BasicAlgorithm(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AutoscalingPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.AutoscalingPolicy"
    }
}

/// Defines additional types related to [AutoscalingPolicy].
pub mod autoscaling_policy {
    #[allow(unused_imports)]
    use super::*;

    /// Autoscaling algorithm for policy.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Algorithm {
        BasicAlgorithm(std::boxed::Box<crate::model::BasicAutoscalingAlgorithm>),
    }
}

/// Basic algorithm for autoscaling.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BasicAutoscalingAlgorithm {
    /// Optional. Duration between scaling events. A scaling period starts after
    /// the update operation from the previous event has completed.
    ///
    /// Bounds: [2m, 1d]. Default: 2m.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cooldown_period: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::basic_autoscaling_algorithm::Config>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BasicAutoscalingAlgorithm {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cooldown_period][crate::model::BasicAutoscalingAlgorithm::cooldown_period].
    pub fn set_cooldown_period<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cooldown_period = v.into();
        self
    }

    /// Sets the value of [config][crate::model::BasicAutoscalingAlgorithm::config].
    ///
    /// Note that all the setters affecting `config` are mutually
    /// exclusive.
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::basic_autoscaling_algorithm::Config>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// The value of [config][crate::model::BasicAutoscalingAlgorithm::config]
    /// if it holds a `YarnConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn yarn_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BasicYarnAutoscalingConfig>> {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::basic_autoscaling_algorithm::Config::YarnConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [config][crate::model::BasicAutoscalingAlgorithm::config]
    /// to hold a `YarnConfig`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_yarn_config<
        T: std::convert::Into<std::boxed::Box<crate::model::BasicYarnAutoscalingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = std::option::Option::Some(
            crate::model::basic_autoscaling_algorithm::Config::YarnConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BasicAutoscalingAlgorithm {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.BasicAutoscalingAlgorithm"
    }
}

/// Defines additional types related to [BasicAutoscalingAlgorithm].
pub mod basic_autoscaling_algorithm {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Config {
        /// Required. YARN autoscaling configuration.
        YarnConfig(std::boxed::Box<crate::model::BasicYarnAutoscalingConfig>),
    }
}

/// Basic autoscaling configurations for YARN.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BasicYarnAutoscalingConfig {
    /// Required. Timeout for YARN graceful decommissioning of Node Managers.
    /// Specifies the duration to wait for jobs to complete before forcefully
    /// removing workers (and potentially interrupting jobs). Only applicable to
    /// downscaling operations.
    ///
    /// Bounds: [0s, 1d].
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub graceful_decommission_timeout: std::option::Option<wkt::Duration>,

    /// Required. Fraction of average YARN pending memory in the last cooldown
    /// period for which to add workers. A scale-up factor of 1.0 will result in
    /// scaling up so that there is no pending memory remaining after the update
    /// (more aggressive scaling). A scale-up factor closer to 0 will result in a
    /// smaller magnitude of scaling up (less aggressive scaling). See [How
    /// autoscaling
    /// works](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/autoscaling#how_autoscaling_works)
    /// for more information.
    ///
    /// Bounds: [0.0, 1.0].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub scale_up_factor: f64,

    /// Required. Fraction of average YARN pending memory in the last cooldown
    /// period for which to remove workers. A scale-down factor of 1 will result in
    /// scaling down so that there is no available memory remaining after the
    /// update (more aggressive scaling). A scale-down factor of 0 disables
    /// removing workers, which can be beneficial for autoscaling a single job.
    /// See [How autoscaling
    /// works](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/autoscaling#how_autoscaling_works)
    /// for more information.
    ///
    /// Bounds: [0.0, 1.0].
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub scale_down_factor: f64,

    /// Optional. Minimum scale-up threshold as a fraction of total cluster size
    /// before scaling occurs. For example, in a 20-worker cluster, a threshold of
    /// 0.1 means the autoscaler must recommend at least a 2-worker scale-up for
    /// the cluster to scale. A threshold of 0 means the autoscaler will scale up
    /// on any recommended change.
    ///
    /// Bounds: [0.0, 1.0]. Default: 0.0.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub scale_up_min_worker_fraction: f64,

    /// Optional. Minimum scale-down threshold as a fraction of total cluster size
    /// before scaling occurs. For example, in a 20-worker cluster, a threshold of
    /// 0.1 means the autoscaler must recommend at least a 2 worker scale-down for
    /// the cluster to scale. A threshold of 0 means the autoscaler will scale down
    /// on any recommended change.
    ///
    /// Bounds: [0.0, 1.0]. Default: 0.0.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F64")]
    pub scale_down_min_worker_fraction: f64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BasicYarnAutoscalingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [graceful_decommission_timeout][crate::model::BasicYarnAutoscalingConfig::graceful_decommission_timeout].
    pub fn set_graceful_decommission_timeout<
        T: std::convert::Into<std::option::Option<wkt::Duration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.graceful_decommission_timeout = v.into();
        self
    }

    /// Sets the value of [scale_up_factor][crate::model::BasicYarnAutoscalingConfig::scale_up_factor].
    pub fn set_scale_up_factor<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.scale_up_factor = v.into();
        self
    }

    /// Sets the value of [scale_down_factor][crate::model::BasicYarnAutoscalingConfig::scale_down_factor].
    pub fn set_scale_down_factor<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.scale_down_factor = v.into();
        self
    }

    /// Sets the value of [scale_up_min_worker_fraction][crate::model::BasicYarnAutoscalingConfig::scale_up_min_worker_fraction].
    pub fn set_scale_up_min_worker_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.scale_up_min_worker_fraction = v.into();
        self
    }

    /// Sets the value of [scale_down_min_worker_fraction][crate::model::BasicYarnAutoscalingConfig::scale_down_min_worker_fraction].
    pub fn set_scale_down_min_worker_fraction<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.scale_down_min_worker_fraction = v.into();
        self
    }
}

impl wkt::message::Message for BasicYarnAutoscalingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.BasicYarnAutoscalingConfig"
    }
}

/// Configuration for the size bounds of an instance group, including its
/// proportional size to other groups.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstanceGroupAutoscalingPolicyConfig {
    /// Optional. Minimum number of instances for this group.
    ///
    /// Primary workers - Bounds: [2, max_instances]. Default: 2.
    /// Secondary workers - Bounds: [0, max_instances]. Default: 0.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub min_instances: i32,

    /// Required. Maximum number of instances for this group. Required for primary
    /// workers. Note that by default, clusters will not use secondary workers.
    /// Required for secondary workers if the minimum secondary instances is set.
    ///
    /// Primary workers - Bounds: [min_instances, ).
    /// Secondary workers - Bounds: [min_instances, ). Default: 0.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_instances: i32,

    /// Optional. Weight for the instance group, which is used to determine the
    /// fraction of total workers in the cluster from this instance group.
    /// For example, if primary workers have weight 2, and secondary workers have
    /// weight 1, the cluster will have approximately 2 primary workers for each
    /// secondary worker.
    ///
    /// The cluster may not reach the specified balance if constrained
    /// by min/max bounds or other autoscaling settings. For example, if
    /// `max_instances` for secondary workers is 0, then only primary workers will
    /// be added. The cluster can also be out of balance when created.
    ///
    /// If weight is not set on any instance group, the cluster will default to
    /// equal weight for all groups: the cluster will attempt to maintain an equal
    /// number of workers in each group within the configured size bounds for each
    /// group. If weight is set for one group only, the cluster will default to
    /// zero weight on the unset group. For example if weight is set only on
    /// primary workers, the cluster will use primary workers only and no
    /// secondary workers.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub weight: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstanceGroupAutoscalingPolicyConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_instances][crate::model::InstanceGroupAutoscalingPolicyConfig::min_instances].
    pub fn set_min_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_instances = v.into();
        self
    }

    /// Sets the value of [max_instances][crate::model::InstanceGroupAutoscalingPolicyConfig::max_instances].
    pub fn set_max_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_instances = v.into();
        self
    }

    /// Sets the value of [weight][crate::model::InstanceGroupAutoscalingPolicyConfig::weight].
    pub fn set_weight<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.weight = v.into();
        self
    }
}

impl wkt::message::Message for InstanceGroupAutoscalingPolicyConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.InstanceGroupAutoscalingPolicyConfig"
    }
}

/// A request to create an autoscaling policy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAutoscalingPolicyRequest {
    /// Required. The "resource name" of the region or location, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.autoscalingPolicies.create`, the resource name
    ///   of the region has the following format:
    ///   `projects/{project_id}/regions/{region}`
    ///
    /// * For `projects.locations.autoscalingPolicies.create`, the resource name
    ///   of the location has the following format:
    ///   `projects/{project_id}/locations/{location}`
    ///
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The autoscaling policy to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub policy: std::option::Option<crate::model::AutoscalingPolicy>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAutoscalingPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAutoscalingPolicyRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [policy][crate::model::CreateAutoscalingPolicyRequest::policy].
    pub fn set_policy<
        T: std::convert::Into<std::option::Option<crate::model::AutoscalingPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.policy = v.into();
        self
    }
}

impl wkt::message::Message for CreateAutoscalingPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.CreateAutoscalingPolicyRequest"
    }
}

/// A request to fetch an autoscaling policy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAutoscalingPolicyRequest {
    /// Required. The "resource name" of the autoscaling policy, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.autoscalingPolicies.get`, the resource name
    ///   of the policy has the following format:
    ///   `projects/{project_id}/regions/{region}/autoscalingPolicies/{policy_id}`
    ///
    /// * For `projects.locations.autoscalingPolicies.get`, the resource name
    ///   of the policy has the following format:
    ///   `projects/{project_id}/locations/{location}/autoscalingPolicies/{policy_id}`
    ///
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAutoscalingPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAutoscalingPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAutoscalingPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GetAutoscalingPolicyRequest"
    }
}

/// A request to update an autoscaling policy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateAutoscalingPolicyRequest {
    /// Required. The updated autoscaling policy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub policy: std::option::Option<crate::model::AutoscalingPolicy>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAutoscalingPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy][crate::model::UpdateAutoscalingPolicyRequest::policy].
    pub fn set_policy<
        T: std::convert::Into<std::option::Option<crate::model::AutoscalingPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.policy = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAutoscalingPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.UpdateAutoscalingPolicyRequest"
    }
}

/// A request to delete an autoscaling policy.
///
/// Autoscaling policies in use by one or more clusters will not be deleted.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAutoscalingPolicyRequest {
    /// Required. The "resource name" of the autoscaling policy, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.autoscalingPolicies.delete`, the resource name
    ///   of the policy has the following format:
    ///   `projects/{project_id}/regions/{region}/autoscalingPolicies/{policy_id}`
    ///
    /// * For `projects.locations.autoscalingPolicies.delete`, the resource name
    ///   of the policy has the following format:
    ///   `projects/{project_id}/locations/{location}/autoscalingPolicies/{policy_id}`
    ///
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAutoscalingPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAutoscalingPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAutoscalingPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DeleteAutoscalingPolicyRequest"
    }
}

/// A request to list autoscaling policies in a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAutoscalingPoliciesRequest {
    /// Required. The "resource name" of the region or location, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.autoscalingPolicies.list`, the resource name
    ///   of the region has the following format:
    ///   `projects/{project_id}/regions/{region}`
    ///
    /// * For `projects.locations.autoscalingPolicies.list`, the resource name
    ///   of the location has the following format:
    ///   `projects/{project_id}/locations/{location}`
    ///
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of results to return in each response.
    /// Must be less than or equal to 1000. Defaults to 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The page token, returned by a previous call, to request the
    /// next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutoscalingPoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAutoscalingPoliciesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAutoscalingPoliciesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAutoscalingPoliciesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutoscalingPoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListAutoscalingPoliciesRequest"
    }
}

/// A response to a request to list autoscaling policies in a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAutoscalingPoliciesResponse {
    /// Output only. Autoscaling policies list.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub policies: std::vec::Vec<crate::model::AutoscalingPolicy>,

    /// Output only. This token is included in the response if there are more
    /// results to fetch.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAutoscalingPoliciesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policies][crate::model::ListAutoscalingPoliciesResponse::policies].
    pub fn set_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutoscalingPolicy>,
    {
        use std::iter::Iterator;
        self.policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAutoscalingPoliciesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAutoscalingPoliciesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListAutoscalingPoliciesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAutoscalingPoliciesResponse {
    type PageItem = crate::model::AutoscalingPolicy;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.policies
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A request to create a batch workload.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBatchRequest {
    /// Required. The parent resource where this batch will be created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The batch to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub batch: std::option::Option<crate::model::Batch>,

    /// Optional. The ID to use for the batch, which will become the final
    /// component of the batch's resource name.
    ///
    /// This value must be 4-63 characters. Valid characters are `/[a-z][0-9]-/`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub batch_id: std::string::String,

    /// Optional. A unique ID used to identify the request. If the service
    /// receives two
    /// [CreateBatchRequest](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.CreateBatchRequest)s
    /// with the same request_id, the second request is ignored and the
    /// Operation that corresponds to the first Batch created and stored
    /// in the backend is returned.
    ///
    /// Recommendation: Set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The value must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBatchRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBatchRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [batch][crate::model::CreateBatchRequest::batch].
    pub fn set_batch<T: std::convert::Into<std::option::Option<crate::model::Batch>>>(
        mut self,
        v: T,
    ) -> Self {
        self.batch = v.into();
        self
    }

    /// Sets the value of [batch_id][crate::model::CreateBatchRequest::batch_id].
    pub fn set_batch_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.batch_id = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateBatchRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateBatchRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.CreateBatchRequest"
    }
}

/// A request to get the resource representation for a batch workload.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBatchRequest {
    /// Required. The fully qualified name of the batch to retrieve
    /// in the format
    /// "projects/PROJECT_ID/locations/DATAPROC_REGION/batches/BATCH_ID"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBatchRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBatchRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBatchRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GetBatchRequest"
    }
}

/// A request to list batch workloads in a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBatchesRequest {
    /// Required. The parent, which owns this collection of batches.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of batches to return in each response.
    /// The service may return fewer than this value.
    /// The default page size is 20; the maximum page size is 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. A page token received from a previous `ListBatches` call.
    /// Provide this token to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. A filter for the batches to return in the response.
    ///
    /// A filter is a logical expression constraining the values of various fields
    /// in each batch resource. Filters are case sensitive, and may contain
    /// multiple clauses combined with logical operators (AND/OR).
    /// Supported fields are `batch_id`, `batch_uuid`, `state`, and `create_time`.
    ///
    /// e.g. `state = RUNNING and create_time < "2023-01-01T00:00:00Z"`
    /// filters for batches in state RUNNING that were created before 2023-01-01
    ///
    /// See <https://google.aip.dev/assets/misc/ebnf-filtering.txt> for a detailed
    /// description of the filter syntax and a list of supported comparisons.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Field(s) on which to sort the list of batches.
    ///
    /// Currently the only supported sort orders are unspecified (empty) and
    /// `create_time desc` to sort by most recently created batches first.
    ///
    /// See <https://google.aip.dev/132#ordering> for more details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBatchesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBatchesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBatchesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBatchesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBatchesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBatchesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListBatchesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListBatchesRequest"
    }
}

/// A list of batch workloads.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBatchesResponse {
    /// The batches from the specified collection.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub batches: std::vec::Vec<crate::model::Batch>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Output only. List of Batches that could not be included in the response.
    /// Attempting to get one of these resources may indicate why it was not
    /// included in the list response.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBatchesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [batches][crate::model::ListBatchesResponse::batches].
    pub fn set_batches<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Batch>,
    {
        use std::iter::Iterator;
        self.batches = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBatchesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBatchesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBatchesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListBatchesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBatchesResponse {
    type PageItem = crate::model::Batch;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.batches
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A request to delete a batch workload.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBatchRequest {
    /// Required. The fully qualified name of the batch to retrieve
    /// in the format
    /// "projects/PROJECT_ID/locations/DATAPROC_REGION/batches/BATCH_ID"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBatchRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBatchRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBatchRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DeleteBatchRequest"
    }
}

/// A representation of a batch workload in the service.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Batch {
    /// Output only. The resource name of the batch.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. A batch UUID (Unique Universal Identifier). The service
    /// generates this value when it creates the batch.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uuid: std::string::String,

    /// Output only. The time when the batch was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Runtime information about batch execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub runtime_info: std::option::Option<crate::model::RuntimeInfo>,

    /// Output only. The state of the batch.
    pub state: crate::model::batch::State,

    /// Output only. Batch state details, such as a failure
    /// description if the state is `FAILED`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub state_message: std::string::String,

    /// Output only. The time when the batch entered a current state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub state_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The email address of the user who created the batch.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub creator: std::string::String,

    /// Optional. The labels to associate with this batch.
    /// Label **keys** must contain 1 to 63 characters, and must conform to
    /// [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt).
    /// Label **values** may be empty, but, if present, must contain 1 to 63
    /// characters, and must conform to [RFC
    /// 1035](https://www.ietf.org/rfc/rfc1035.txt). No more than 32 labels can be
    /// associated with a batch.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Runtime configuration for the batch execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub runtime_config: std::option::Option<crate::model::RuntimeConfig>,

    /// Optional. Environment configuration for the batch execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub environment_config: std::option::Option<crate::model::EnvironmentConfig>,

    /// Output only. The resource name of the operation associated with this batch.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub operation: std::string::String,

    /// Output only. Historical state information for the batch.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub state_history: std::vec::Vec<crate::model::batch::StateHistory>,

    /// The application/framework-specific portion of the batch configuration.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub batch_config: std::option::Option<crate::model::batch::BatchConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Batch {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Batch::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uuid][crate::model::Batch::uuid].
    pub fn set_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uuid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Batch::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [runtime_info][crate::model::Batch::runtime_info].
    pub fn set_runtime_info<
        T: std::convert::Into<std::option::Option<crate::model::RuntimeInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_info = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Batch::state].
    pub fn set_state<T: std::convert::Into<crate::model::batch::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_message][crate::model::Batch::state_message].
    pub fn set_state_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_message = v.into();
        self
    }

    /// Sets the value of [state_time][crate::model::Batch::state_time].
    pub fn set_state_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.state_time = v.into();
        self
    }

    /// Sets the value of [creator][crate::model::Batch::creator].
    pub fn set_creator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.creator = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Batch::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [runtime_config][crate::model::Batch::runtime_config].
    pub fn set_runtime_config<
        T: std::convert::Into<std::option::Option<crate::model::RuntimeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_config = v.into();
        self
    }

    /// Sets the value of [environment_config][crate::model::Batch::environment_config].
    pub fn set_environment_config<
        T: std::convert::Into<std::option::Option<crate::model::EnvironmentConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.environment_config = v.into();
        self
    }

    /// Sets the value of [operation][crate::model::Batch::operation].
    pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation = v.into();
        self
    }

    /// Sets the value of [state_history][crate::model::Batch::state_history].
    pub fn set_state_history<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::batch::StateHistory>,
    {
        use std::iter::Iterator;
        self.state_history = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [batch_config][crate::model::Batch::batch_config].
    ///
    /// Note that all the setters affecting `batch_config` are mutually
    /// exclusive.
    pub fn set_batch_config<
        T: std::convert::Into<std::option::Option<crate::model::batch::BatchConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.batch_config = v.into();
        self
    }

    /// The value of [batch_config][crate::model::Batch::batch_config]
    /// if it holds a `PysparkBatch`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pyspark_batch(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PySparkBatch>> {
        #[allow(unreachable_patterns)]
        self.batch_config.as_ref().and_then(|v| match v {
            crate::model::batch::BatchConfig::PysparkBatch(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [batch_config][crate::model::Batch::batch_config]
    /// to hold a `PysparkBatch`.
    ///
    /// Note that all the setters affecting `batch_config` are
    /// mutually exclusive.
    pub fn set_pyspark_batch<T: std::convert::Into<std::boxed::Box<crate::model::PySparkBatch>>>(
        mut self,
        v: T,
    ) -> Self {
        self.batch_config =
            std::option::Option::Some(crate::model::batch::BatchConfig::PysparkBatch(v.into()));
        self
    }

    /// The value of [batch_config][crate::model::Batch::batch_config]
    /// if it holds a `SparkBatch`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_batch(&self) -> std::option::Option<&std::boxed::Box<crate::model::SparkBatch>> {
        #[allow(unreachable_patterns)]
        self.batch_config.as_ref().and_then(|v| match v {
            crate::model::batch::BatchConfig::SparkBatch(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [batch_config][crate::model::Batch::batch_config]
    /// to hold a `SparkBatch`.
    ///
    /// Note that all the setters affecting `batch_config` are
    /// mutually exclusive.
    pub fn set_spark_batch<T: std::convert::Into<std::boxed::Box<crate::model::SparkBatch>>>(
        mut self,
        v: T,
    ) -> Self {
        self.batch_config =
            std::option::Option::Some(crate::model::batch::BatchConfig::SparkBatch(v.into()));
        self
    }

    /// The value of [batch_config][crate::model::Batch::batch_config]
    /// if it holds a `SparkRBatch`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_r_batch(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SparkRBatch>> {
        #[allow(unreachable_patterns)]
        self.batch_config.as_ref().and_then(|v| match v {
            crate::model::batch::BatchConfig::SparkRBatch(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [batch_config][crate::model::Batch::batch_config]
    /// to hold a `SparkRBatch`.
    ///
    /// Note that all the setters affecting `batch_config` are
    /// mutually exclusive.
    pub fn set_spark_r_batch<T: std::convert::Into<std::boxed::Box<crate::model::SparkRBatch>>>(
        mut self,
        v: T,
    ) -> Self {
        self.batch_config =
            std::option::Option::Some(crate::model::batch::BatchConfig::SparkRBatch(v.into()));
        self
    }

    /// The value of [batch_config][crate::model::Batch::batch_config]
    /// if it holds a `SparkSqlBatch`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_sql_batch(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SparkSqlBatch>> {
        #[allow(unreachable_patterns)]
        self.batch_config.as_ref().and_then(|v| match v {
            crate::model::batch::BatchConfig::SparkSqlBatch(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [batch_config][crate::model::Batch::batch_config]
    /// to hold a `SparkSqlBatch`.
    ///
    /// Note that all the setters affecting `batch_config` are
    /// mutually exclusive.
    pub fn set_spark_sql_batch<
        T: std::convert::Into<std::boxed::Box<crate::model::SparkSqlBatch>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.batch_config =
            std::option::Option::Some(crate::model::batch::BatchConfig::SparkSqlBatch(v.into()));
        self
    }
}

impl wkt::message::Message for Batch {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.Batch"
    }
}

/// Defines additional types related to [Batch].
pub mod batch {
    #[allow(unused_imports)]
    use super::*;

    /// Historical state information.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct StateHistory {
        /// Output only. The state of the batch at this point in history.
        pub state: crate::model::batch::State,

        /// Output only. Details about the state at this point in history.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub state_message: std::string::String,

        /// Output only. The time when the batch entered the historical state.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub state_start_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StateHistory {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::batch::StateHistory::state].
        pub fn set_state<T: std::convert::Into<crate::model::batch::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [state_message][crate::model::batch::StateHistory::state_message].
        pub fn set_state_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.state_message = v.into();
            self
        }

        /// Sets the value of [state_start_time][crate::model::batch::StateHistory::state_start_time].
        pub fn set_state_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.state_start_time = v.into();
            self
        }
    }

    impl wkt::message::Message for StateHistory {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataproc.v1.Batch.StateHistory"
        }
    }

    /// The batch state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The batch state is unknown.
        Unspecified,
        /// The batch is created before running.
        Pending,
        /// The batch is running.
        Running,
        /// The batch is cancelling.
        Cancelling,
        /// The batch cancellation was successful.
        Cancelled,
        /// The batch completed successfully.
        Succeeded,
        /// The batch is no longer running due to an error.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Cancelling => std::option::Option::Some(3),
                Self::Cancelled => std::option::Option::Some(4),
                Self::Succeeded => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Running,
                3 => Self::Cancelling,
                4 => Self::Cancelled,
                5 => Self::Succeeded,
                6 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "RUNNING" => Self::Running,
                "CANCELLING" => Self::Cancelling,
                "CANCELLED" => Self::Cancelled,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Cancelling => serializer.serialize_i32(3),
                Self::Cancelled => serializer.serialize_i32(4),
                Self::Succeeded => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataproc.v1.Batch.State",
            ))
        }
    }

    /// The application/framework-specific portion of the batch configuration.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum BatchConfig {
        /// Optional. PySpark batch config.
        PysparkBatch(std::boxed::Box<crate::model::PySparkBatch>),
        /// Optional. Spark batch config.
        SparkBatch(std::boxed::Box<crate::model::SparkBatch>),
        /// Optional. SparkR batch config.
        SparkRBatch(std::boxed::Box<crate::model::SparkRBatch>),
        /// Optional. SparkSql batch config.
        SparkSqlBatch(std::boxed::Box<crate::model::SparkSqlBatch>),
    }
}

/// A configuration for running an
/// [Apache
/// PySpark](https://spark.apache.org/docs/latest/api/python/getting_started/quickstart.html)
/// batch workload.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PySparkBatch {
    /// Required. The HCFS URI of the main Python file to use as the Spark driver.
    /// Must be a .py file.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub main_python_file_uri: std::string::String,

    /// Optional. The arguments to pass to the driver. Do not include arguments
    /// that can be set as batch properties, such as `--conf`, since a collision
    /// can occur that causes an incorrect batch submission.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub args: std::vec::Vec<std::string::String>,

    /// Optional. HCFS file URIs of Python files to pass to the PySpark
    /// framework. Supported file types: `.py`, `.egg`, and `.zip`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub python_file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of jar files to add to the classpath of the
    /// Spark driver and tasks.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jar_file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of files to be placed in the working directory of
    /// each executor.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of archives to be extracted into the working directory
    /// of each executor. Supported file types:
    /// `.jar`, `.tar`, `.tar.gz`, `.tgz`, and `.zip`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub archive_uris: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PySparkBatch {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [main_python_file_uri][crate::model::PySparkBatch::main_python_file_uri].
    pub fn set_main_python_file_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.main_python_file_uri = v.into();
        self
    }

    /// Sets the value of [args][crate::model::PySparkBatch::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [python_file_uris][crate::model::PySparkBatch::python_file_uris].
    pub fn set_python_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.python_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [jar_file_uris][crate::model::PySparkBatch::jar_file_uris].
    pub fn set_jar_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jar_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_uris][crate::model::PySparkBatch::file_uris].
    pub fn set_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [archive_uris][crate::model::PySparkBatch::archive_uris].
    pub fn set_archive_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.archive_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PySparkBatch {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.PySparkBatch"
    }
}

/// A configuration for running an [Apache Spark](https://spark.apache.org/)
/// batch workload.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SparkBatch {
    /// Optional. The arguments to pass to the driver. Do not include arguments
    /// that can be set as batch properties, such as `--conf`, since a collision
    /// can occur that causes an incorrect batch submission.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub args: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of jar files to add to the classpath of the
    /// Spark driver and tasks.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jar_file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of files to be placed in the working directory of
    /// each executor.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of archives to be extracted into the working directory
    /// of each executor. Supported file types:
    /// `.jar`, `.tar`, `.tar.gz`, `.tgz`, and `.zip`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub archive_uris: std::vec::Vec<std::string::String>,

    /// The specification of the main method to call to drive the Spark
    /// workload. Specify either the jar file that contains the main class or the
    /// main class name. To pass both a main jar and a main class in that jar, add
    /// the jar to `jar_file_uris`, and then specify the main class
    /// name in `main_class`.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub driver: std::option::Option<crate::model::spark_batch::Driver>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SparkBatch {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [args][crate::model::SparkBatch::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [jar_file_uris][crate::model::SparkBatch::jar_file_uris].
    pub fn set_jar_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jar_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_uris][crate::model::SparkBatch::file_uris].
    pub fn set_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [archive_uris][crate::model::SparkBatch::archive_uris].
    pub fn set_archive_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.archive_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [driver][crate::model::SparkBatch::driver].
    ///
    /// Note that all the setters affecting `driver` are mutually
    /// exclusive.
    pub fn set_driver<
        T: std::convert::Into<std::option::Option<crate::model::spark_batch::Driver>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.driver = v.into();
        self
    }

    /// The value of [driver][crate::model::SparkBatch::driver]
    /// if it holds a `MainJarFileUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn main_jar_file_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.driver.as_ref().and_then(|v| match v {
            crate::model::spark_batch::Driver::MainJarFileUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [driver][crate::model::SparkBatch::driver]
    /// to hold a `MainJarFileUri`.
    ///
    /// Note that all the setters affecting `driver` are
    /// mutually exclusive.
    pub fn set_main_jar_file_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.driver =
            std::option::Option::Some(crate::model::spark_batch::Driver::MainJarFileUri(v.into()));
        self
    }

    /// The value of [driver][crate::model::SparkBatch::driver]
    /// if it holds a `MainClass`, `None` if the field is not set or
    /// holds a different branch.
    pub fn main_class(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.driver.as_ref().and_then(|v| match v {
            crate::model::spark_batch::Driver::MainClass(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [driver][crate::model::SparkBatch::driver]
    /// to hold a `MainClass`.
    ///
    /// Note that all the setters affecting `driver` are
    /// mutually exclusive.
    pub fn set_main_class<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.driver =
            std::option::Option::Some(crate::model::spark_batch::Driver::MainClass(v.into()));
        self
    }
}

impl wkt::message::Message for SparkBatch {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SparkBatch"
    }
}

/// Defines additional types related to [SparkBatch].
pub mod spark_batch {
    #[allow(unused_imports)]
    use super::*;

    /// The specification of the main method to call to drive the Spark
    /// workload. Specify either the jar file that contains the main class or the
    /// main class name. To pass both a main jar and a main class in that jar, add
    /// the jar to `jar_file_uris`, and then specify the main class
    /// name in `main_class`.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Driver {
        /// Optional. The HCFS URI of the jar file that contains the main class.
        MainJarFileUri(std::string::String),
        /// Optional. The name of the driver main class. The jar file that contains
        /// the class must be in the classpath or specified in `jar_file_uris`.
        MainClass(std::string::String),
    }
}

/// A configuration for running an
/// [Apache SparkR](https://spark.apache.org/docs/latest/sparkr.html)
/// batch workload.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SparkRBatch {
    /// Required. The HCFS URI of the main R file to use as the driver.
    /// Must be a `.R` or `.r` file.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub main_r_file_uri: std::string::String,

    /// Optional. The arguments to pass to the Spark driver. Do not include
    /// arguments that can be set as batch properties, such as `--conf`, since a
    /// collision can occur that causes an incorrect batch submission.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub args: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of files to be placed in the working directory of
    /// each executor.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of archives to be extracted into the working directory
    /// of each executor. Supported file types:
    /// `.jar`, `.tar`, `.tar.gz`, `.tgz`, and `.zip`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub archive_uris: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SparkRBatch {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [main_r_file_uri][crate::model::SparkRBatch::main_r_file_uri].
    pub fn set_main_r_file_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.main_r_file_uri = v.into();
        self
    }

    /// Sets the value of [args][crate::model::SparkRBatch::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_uris][crate::model::SparkRBatch::file_uris].
    pub fn set_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [archive_uris][crate::model::SparkRBatch::archive_uris].
    pub fn set_archive_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.archive_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SparkRBatch {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SparkRBatch"
    }
}

/// A configuration for running
/// [Apache Spark SQL](https://spark.apache.org/sql/) queries as a batch
/// workload.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SparkSqlBatch {
    /// Required. The HCFS URI of the script that contains Spark SQL queries to
    /// execute.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query_file_uri: std::string::String,

    /// Optional. Mapping of query variable names to values (equivalent to the
    /// Spark SQL command: `SET name="value";`).
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub query_variables: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. HCFS URIs of jar files to be added to the Spark CLASSPATH.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jar_file_uris: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SparkSqlBatch {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query_file_uri][crate::model::SparkSqlBatch::query_file_uri].
    pub fn set_query_file_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query_file_uri = v.into();
        self
    }

    /// Sets the value of [query_variables][crate::model::SparkSqlBatch::query_variables].
    pub fn set_query_variables<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.query_variables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [jar_file_uris][crate::model::SparkSqlBatch::jar_file_uris].
    pub fn set_jar_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jar_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SparkSqlBatch {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SparkSqlBatch"
    }
}

/// Describes the identifying information, config, and status of
/// a Dataproc cluster
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Cluster {
    /// Required. The Google Cloud Platform project ID that the cluster belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The cluster name, which must be unique within a project.
    /// The name must start with a lowercase letter, and can contain
    /// up to 51 lowercase letters, numbers, and hyphens. It cannot end
    /// with a hyphen. The name of a deleted cluster can be reused.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_name: std::string::String,

    /// Optional. The cluster config for a cluster of Compute Engine Instances.
    /// Note that Dataproc may set default values, and values may change
    /// when clusters are updated.
    ///
    /// Exactly one of ClusterConfig or VirtualClusterConfig must be specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::ClusterConfig>,

    /// Optional. The virtual cluster config is used when creating a Dataproc
    /// cluster that does not directly control the underlying compute resources,
    /// for example, when creating a [Dataproc-on-GKE
    /// cluster](https://cloud.google.com/dataproc/docs/guides/dpgke/dataproc-gke-overview).
    /// Dataproc may set default values, and values may change when
    /// clusters are updated. Exactly one of
    /// [config][google.cloud.dataproc.v1.Cluster.config] or
    /// [virtual_cluster_config][google.cloud.dataproc.v1.Cluster.virtual_cluster_config]
    /// must be specified.
    ///
    /// [google.cloud.dataproc.v1.Cluster.config]: crate::model::Cluster::config
    /// [google.cloud.dataproc.v1.Cluster.virtual_cluster_config]: crate::model::Cluster::virtual_cluster_config
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub virtual_cluster_config: std::option::Option<crate::model::VirtualClusterConfig>,

    /// Optional. The labels to associate with this cluster.
    /// Label **keys** must contain 1 to 63 characters, and must conform to
    /// [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt).
    /// Label **values** may be empty, but, if present, must contain 1 to 63
    /// characters, and must conform to [RFC
    /// 1035](https://www.ietf.org/rfc/rfc1035.txt). No more than 32 labels can be
    /// associated with a cluster.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Cluster status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<crate::model::ClusterStatus>,

    /// Output only. The previous cluster status.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub status_history: std::vec::Vec<crate::model::ClusterStatus>,

    /// Output only. A cluster UUID (Unique Universal Identifier). Dataproc
    /// generates this value when it creates the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_uuid: std::string::String,

    /// Output only. Contains cluster daemon metrics such as HDFS and YARN stats.
    ///
    /// **Beta Feature**: This report is available for testing purposes only. It
    /// may be changed before final release.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metrics: std::option::Option<crate::model::ClusterMetrics>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Cluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::Cluster::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::Cluster::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [config][crate::model::Cluster::config].
    pub fn set_config<T: std::convert::Into<std::option::Option<crate::model::ClusterConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [virtual_cluster_config][crate::model::Cluster::virtual_cluster_config].
    pub fn set_virtual_cluster_config<
        T: std::convert::Into<std::option::Option<crate::model::VirtualClusterConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.virtual_cluster_config = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Cluster::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [status][crate::model::Cluster::status].
    pub fn set_status<T: std::convert::Into<std::option::Option<crate::model::ClusterStatus>>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [status_history][crate::model::Cluster::status_history].
    pub fn set_status_history<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClusterStatus>,
    {
        use std::iter::Iterator;
        self.status_history = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cluster_uuid][crate::model::Cluster::cluster_uuid].
    pub fn set_cluster_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uuid = v.into();
        self
    }

    /// Sets the value of [metrics][crate::model::Cluster::metrics].
    pub fn set_metrics<T: std::convert::Into<std::option::Option<crate::model::ClusterMetrics>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metrics = v.into();
        self
    }
}

impl wkt::message::Message for Cluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.Cluster"
    }
}

/// The cluster config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClusterConfig {
    /// Optional. A Cloud Storage bucket used to stage job
    /// dependencies, config files, and job driver console output.
    /// If you do not specify a staging bucket, Cloud
    /// Dataproc will determine a Cloud Storage location (US,
    /// ASIA, or EU) for your cluster's staging bucket according to the
    /// Compute Engine zone where your cluster is deployed, and then create
    /// and manage this project-level, per-location bucket (see
    /// [Dataproc staging and temp
    /// buckets](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/staging-bucket)).
    /// **This field requires a Cloud Storage bucket name, not a `gs://...` URI to
    /// a Cloud Storage bucket.**
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub config_bucket: std::string::String,

    /// Optional. A Cloud Storage bucket used to store ephemeral cluster and jobs
    /// data, such as Spark and MapReduce history files. If you do not specify a
    /// temp bucket, Dataproc will determine a Cloud Storage location (US, ASIA, or
    /// EU) for your cluster's temp bucket according to the Compute Engine zone
    /// where your cluster is deployed, and then create and manage this
    /// project-level, per-location bucket. The default bucket has a TTL of 90
    /// days, but you can use any TTL (or none) if you specify a bucket (see
    /// [Dataproc staging and temp
    /// buckets](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/staging-bucket)).
    /// **This field requires a Cloud Storage bucket name, not a `gs://...` URI to
    /// a Cloud Storage bucket.**
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub temp_bucket: std::string::String,

    /// Optional. The shared Compute Engine config settings for
    /// all instances in a cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gce_cluster_config: std::option::Option<crate::model::GceClusterConfig>,

    /// Optional. The Compute Engine config settings for
    /// the cluster's master instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub master_config: std::option::Option<crate::model::InstanceGroupConfig>,

    /// Optional. The Compute Engine config settings for
    /// the cluster's worker instances.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub worker_config: std::option::Option<crate::model::InstanceGroupConfig>,

    /// Optional. The Compute Engine config settings for
    /// a cluster's secondary worker instances
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub secondary_worker_config: std::option::Option<crate::model::InstanceGroupConfig>,

    /// Optional. The config settings for cluster software.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub software_config: std::option::Option<crate::model::SoftwareConfig>,

    /// Optional. Commands to execute on each node after config is
    /// completed. By default, executables are run on master and all worker nodes.
    /// You can test a node's `role` metadata to run an executable on
    /// a master or worker node, as shown below using `curl` (you can also use
    /// `wget`):
    ///
    /// ```norust
    /// ROLE=$(curl -H Metadata-Flavor:Google
    /// http://metadata/computeMetadata/v1/instance/attributes/dataproc-role)
    /// if [[ "${ROLE}" == 'Master' ]]; then
    ///   ... master specific actions ...
    /// else
    ///   ... worker specific actions ...
    /// fi
    /// ```
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub initialization_actions: std::vec::Vec<crate::model::NodeInitializationAction>,

    /// Optional. Encryption settings for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_config: std::option::Option<crate::model::EncryptionConfig>,

    /// Optional. Autoscaling config for the policy associated with the cluster.
    /// Cluster does not autoscale if this field is unset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub autoscaling_config: std::option::Option<crate::model::AutoscalingConfig>,

    /// Optional. Security settings for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub security_config: std::option::Option<crate::model::SecurityConfig>,

    /// Optional. Lifecycle setting for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub lifecycle_config: std::option::Option<crate::model::LifecycleConfig>,

    /// Optional. Port/endpoint configuration for this cluster
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub endpoint_config: std::option::Option<crate::model::EndpointConfig>,

    /// Optional. Metastore configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metastore_config: std::option::Option<crate::model::MetastoreConfig>,

    /// Optional. The config for Dataproc metrics.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataproc_metric_config: std::option::Option<crate::model::DataprocMetricConfig>,

    /// Optional. The node group settings.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub auxiliary_node_groups: std::vec::Vec<crate::model::AuxiliaryNodeGroup>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config_bucket][crate::model::ClusterConfig::config_bucket].
    pub fn set_config_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.config_bucket = v.into();
        self
    }

    /// Sets the value of [temp_bucket][crate::model::ClusterConfig::temp_bucket].
    pub fn set_temp_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.temp_bucket = v.into();
        self
    }

    /// Sets the value of [gce_cluster_config][crate::model::ClusterConfig::gce_cluster_config].
    pub fn set_gce_cluster_config<
        T: std::convert::Into<std::option::Option<crate::model::GceClusterConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gce_cluster_config = v.into();
        self
    }

    /// Sets the value of [master_config][crate::model::ClusterConfig::master_config].
    pub fn set_master_config<
        T: std::convert::Into<std::option::Option<crate::model::InstanceGroupConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.master_config = v.into();
        self
    }

    /// Sets the value of [worker_config][crate::model::ClusterConfig::worker_config].
    pub fn set_worker_config<
        T: std::convert::Into<std::option::Option<crate::model::InstanceGroupConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.worker_config = v.into();
        self
    }

    /// Sets the value of [secondary_worker_config][crate::model::ClusterConfig::secondary_worker_config].
    pub fn set_secondary_worker_config<
        T: std::convert::Into<std::option::Option<crate::model::InstanceGroupConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.secondary_worker_config = v.into();
        self
    }

    /// Sets the value of [software_config][crate::model::ClusterConfig::software_config].
    pub fn set_software_config<
        T: std::convert::Into<std::option::Option<crate::model::SoftwareConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.software_config = v.into();
        self
    }

    /// Sets the value of [initialization_actions][crate::model::ClusterConfig::initialization_actions].
    pub fn set_initialization_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NodeInitializationAction>,
    {
        use std::iter::Iterator;
        self.initialization_actions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [encryption_config][crate::model::ClusterConfig::encryption_config].
    pub fn set_encryption_config<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_config = v.into();
        self
    }

    /// Sets the value of [autoscaling_config][crate::model::ClusterConfig::autoscaling_config].
    pub fn set_autoscaling_config<
        T: std::convert::Into<std::option::Option<crate::model::AutoscalingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.autoscaling_config = v.into();
        self
    }

    /// Sets the value of [security_config][crate::model::ClusterConfig::security_config].
    pub fn set_security_config<
        T: std::convert::Into<std::option::Option<crate::model::SecurityConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.security_config = v.into();
        self
    }

    /// Sets the value of [lifecycle_config][crate::model::ClusterConfig::lifecycle_config].
    pub fn set_lifecycle_config<
        T: std::convert::Into<std::option::Option<crate::model::LifecycleConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_config = v.into();
        self
    }

    /// Sets the value of [endpoint_config][crate::model::ClusterConfig::endpoint_config].
    pub fn set_endpoint_config<
        T: std::convert::Into<std::option::Option<crate::model::EndpointConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.endpoint_config = v.into();
        self
    }

    /// Sets the value of [metastore_config][crate::model::ClusterConfig::metastore_config].
    pub fn set_metastore_config<
        T: std::convert::Into<std::option::Option<crate::model::MetastoreConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metastore_config = v.into();
        self
    }

    /// Sets the value of [dataproc_metric_config][crate::model::ClusterConfig::dataproc_metric_config].
    pub fn set_dataproc_metric_config<
        T: std::convert::Into<std::option::Option<crate::model::DataprocMetricConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataproc_metric_config = v.into();
        self
    }

    /// Sets the value of [auxiliary_node_groups][crate::model::ClusterConfig::auxiliary_node_groups].
    pub fn set_auxiliary_node_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AuxiliaryNodeGroup>,
    {
        use std::iter::Iterator;
        self.auxiliary_node_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ClusterConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ClusterConfig"
    }
}

/// The Dataproc cluster config for a cluster that does not directly control the
/// underlying compute resources, such as a [Dataproc-on-GKE
/// cluster](https://cloud.google.com/dataproc/docs/guides/dpgke/dataproc-gke-overview).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VirtualClusterConfig {
    /// Optional. A Cloud Storage bucket used to stage job
    /// dependencies, config files, and job driver console output.
    /// If you do not specify a staging bucket, Cloud
    /// Dataproc will determine a Cloud Storage location (US,
    /// ASIA, or EU) for your cluster's staging bucket according to the
    /// Compute Engine zone where your cluster is deployed, and then create
    /// and manage this project-level, per-location bucket (see
    /// [Dataproc staging and temp
    /// buckets](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/staging-bucket)).
    /// **This field requires a Cloud Storage bucket name, not a `gs://...` URI to
    /// a Cloud Storage bucket.**
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub staging_bucket: std::string::String,

    /// Optional. Configuration of auxiliary services used by this cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub auxiliary_services_config: std::option::Option<crate::model::AuxiliaryServicesConfig>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub infrastructure_config:
        std::option::Option<crate::model::virtual_cluster_config::InfrastructureConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VirtualClusterConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [staging_bucket][crate::model::VirtualClusterConfig::staging_bucket].
    pub fn set_staging_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.staging_bucket = v.into();
        self
    }

    /// Sets the value of [auxiliary_services_config][crate::model::VirtualClusterConfig::auxiliary_services_config].
    pub fn set_auxiliary_services_config<
        T: std::convert::Into<std::option::Option<crate::model::AuxiliaryServicesConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.auxiliary_services_config = v.into();
        self
    }

    /// Sets the value of [infrastructure_config][crate::model::VirtualClusterConfig::infrastructure_config].
    ///
    /// Note that all the setters affecting `infrastructure_config` are mutually
    /// exclusive.
    pub fn set_infrastructure_config<
        T: std::convert::Into<
                std::option::Option<crate::model::virtual_cluster_config::InfrastructureConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.infrastructure_config = v.into();
        self
    }

    /// The value of [infrastructure_config][crate::model::VirtualClusterConfig::infrastructure_config]
    /// if it holds a `KubernetesClusterConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn kubernetes_cluster_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::KubernetesClusterConfig>> {
        #[allow(unreachable_patterns)]
        self.infrastructure_config.as_ref().and_then(|v| match v {
            crate::model::virtual_cluster_config::InfrastructureConfig::KubernetesClusterConfig(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [infrastructure_config][crate::model::VirtualClusterConfig::infrastructure_config]
    /// to hold a `KubernetesClusterConfig`.
    ///
    /// Note that all the setters affecting `infrastructure_config` are
    /// mutually exclusive.
    pub fn set_kubernetes_cluster_config<
        T: std::convert::Into<std::boxed::Box<crate::model::KubernetesClusterConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.infrastructure_config = std::option::Option::Some(
            crate::model::virtual_cluster_config::InfrastructureConfig::KubernetesClusterConfig(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for VirtualClusterConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.VirtualClusterConfig"
    }
}

/// Defines additional types related to [VirtualClusterConfig].
pub mod virtual_cluster_config {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum InfrastructureConfig {
        /// Required. The configuration for running the Dataproc cluster on
        /// Kubernetes.
        KubernetesClusterConfig(std::boxed::Box<crate::model::KubernetesClusterConfig>),
    }
}

/// Auxiliary services configuration for a Cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AuxiliaryServicesConfig {
    /// Optional. The Hive Metastore configuration for this workload.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metastore_config: std::option::Option<crate::model::MetastoreConfig>,

    /// Optional. The Spark History Server configuration for the workload.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub spark_history_server_config: std::option::Option<crate::model::SparkHistoryServerConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuxiliaryServicesConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metastore_config][crate::model::AuxiliaryServicesConfig::metastore_config].
    pub fn set_metastore_config<
        T: std::convert::Into<std::option::Option<crate::model::MetastoreConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metastore_config = v.into();
        self
    }

    /// Sets the value of [spark_history_server_config][crate::model::AuxiliaryServicesConfig::spark_history_server_config].
    pub fn set_spark_history_server_config<
        T: std::convert::Into<std::option::Option<crate::model::SparkHistoryServerConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spark_history_server_config = v.into();
        self
    }
}

impl wkt::message::Message for AuxiliaryServicesConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.AuxiliaryServicesConfig"
    }
}

/// Endpoint config for this cluster
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EndpointConfig {
    /// Output only. The map of port descriptions to URLs. Will only be populated
    /// if enable_http_port_access is true.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub http_ports: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. If true, enable http access to specific ports on the cluster
    /// from external sources. Defaults to false.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_http_port_access: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EndpointConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [http_ports][crate::model::EndpointConfig::http_ports].
    pub fn set_http_ports<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.http_ports = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [enable_http_port_access][crate::model::EndpointConfig::enable_http_port_access].
    pub fn set_enable_http_port_access<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_http_port_access = v.into();
        self
    }
}

impl wkt::message::Message for EndpointConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.EndpointConfig"
    }
}

/// Autoscaling Policy config associated with the cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutoscalingConfig {
    /// Optional. The autoscaling policy used by the cluster.
    ///
    /// Only resource names including projectid and location (region) are valid.
    /// Examples:
    ///
    /// * `<https://www.googleapis.com/compute/v1/projects/>[project_id]/locations/[dataproc_region]/autoscalingPolicies/[policy_id]`
    /// * `projects/[project_id]/locations/[dataproc_region]/autoscalingPolicies/[policy_id]`
    ///
    /// Note that the policy must be in the same project and Dataproc region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub policy_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoscalingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy_uri][crate::model::AutoscalingConfig::policy_uri].
    pub fn set_policy_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy_uri = v.into();
        self
    }
}

impl wkt::message::Message for AutoscalingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.AutoscalingConfig"
    }
}

/// Encryption settings for the cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EncryptionConfig {
    /// Optional. The Cloud KMS key resource name to use for persistent disk
    /// encryption for all instances in the cluster. See [Use CMEK with cluster
    /// data]
    /// (<https://cloud.google.com//dataproc/docs/concepts/configuring-clusters/customer-managed-encryption#use_cmek_with_cluster_data>)
    /// for more information.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gce_pd_kms_key_name: std::string::String,

    /// Optional. The Cloud KMS key resource name to use for cluster persistent
    /// disk and job argument encryption. See [Use CMEK with cluster data]
    /// (<https://cloud.google.com//dataproc/docs/concepts/configuring-clusters/customer-managed-encryption#use_cmek_with_cluster_data>)
    /// for more information.
    ///
    /// When this key resource name is provided, the following job arguments of
    /// the following job types submitted to the cluster are encrypted using CMEK:
    ///
    /// * [FlinkJob
    ///   args](https://cloud.google.com/dataproc/docs/reference/rest/v1/FlinkJob)
    /// * [HadoopJob
    ///   args](https://cloud.google.com/dataproc/docs/reference/rest/v1/HadoopJob)
    /// * [SparkJob
    ///   args](https://cloud.google.com/dataproc/docs/reference/rest/v1/SparkJob)
    /// * [SparkRJob
    ///   args](https://cloud.google.com/dataproc/docs/reference/rest/v1/SparkRJob)
    /// * [PySparkJob
    ///   args](https://cloud.google.com/dataproc/docs/reference/rest/v1/PySparkJob)
    /// * [SparkSqlJob](https://cloud.google.com/dataproc/docs/reference/rest/v1/SparkSqlJob)
    ///   scriptVariables and queryList.queries
    /// * [HiveJob](https://cloud.google.com/dataproc/docs/reference/rest/v1/HiveJob)
    ///   scriptVariables and queryList.queries
    /// * [PigJob](https://cloud.google.com/dataproc/docs/reference/rest/v1/PigJob)
    ///   scriptVariables and queryList.queries
    /// * [PrestoJob](https://cloud.google.com/dataproc/docs/reference/rest/v1/PrestoJob)
    ///   scriptVariables and queryList.queries
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EncryptionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gce_pd_kms_key_name][crate::model::EncryptionConfig::gce_pd_kms_key_name].
    pub fn set_gce_pd_kms_key_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.gce_pd_kms_key_name = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::EncryptionConfig::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }
}

impl wkt::message::Message for EncryptionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.EncryptionConfig"
    }
}

/// Common config settings for resources of Compute Engine cluster
/// instances, applicable to all instances in the cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GceClusterConfig {
    /// Optional. The Compute Engine zone where the Dataproc cluster will be
    /// located. If omitted, the service will pick a zone in the cluster's Compute
    /// Engine region. On a get request, zone will always be present.
    ///
    /// A full URL, partial URI, or short name are valid. Examples:
    ///
    /// * `<https://www.googleapis.com/compute/v1/projects/>[project_id]/zones/[zone]`
    /// * `projects/[project_id]/zones/[zone]`
    /// * `[zone]`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub zone_uri: std::string::String,

    /// Optional. The Compute Engine network to be used for machine
    /// communications. Cannot be specified with subnetwork_uri. If neither
    /// `network_uri` nor `subnetwork_uri` is specified, the "default" network of
    /// the project is used, if it exists. Cannot be a "Custom Subnet Network" (see
    /// [Using Subnetworks](https://cloud.google.com/compute/docs/subnetworks) for
    /// more information).
    ///
    /// A full URL, partial URI, or short name are valid. Examples:
    ///
    /// * `<https://www.googleapis.com/compute/v1/projects/>[project_id]/global/networks/default`
    /// * `projects/[project_id]/global/networks/default`
    /// * `default`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network_uri: std::string::String,

    /// Optional. The Compute Engine subnetwork to be used for machine
    /// communications. Cannot be specified with network_uri.
    ///
    /// A full URL, partial URI, or short name are valid. Examples:
    ///
    /// * `<https://www.googleapis.com/compute/v1/projects/>[project_id]/regions/[region]/subnetworks/sub0`
    /// * `projects/[project_id]/regions/[region]/subnetworks/sub0`
    /// * `sub0`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnetwork_uri: std::string::String,

    /// Optional. This setting applies to subnetwork-enabled networks. It is set to
    /// `true` by default in clusters created with image versions 2.2.x.
    ///
    /// When set to `true`:
    ///
    /// * All cluster VMs have internal IP addresses.
    /// * [Google Private Access]
    ///   (<https://cloud.google.com/vpc/docs/private-google-access>)
    ///   must be enabled to access Dataproc and other Google Cloud APIs.
    /// * Off-cluster dependencies must be configured to be accessible
    ///   without external IP addresses.
    ///
    /// When set to `false`:
    ///
    /// * Cluster VMs are not restricted to internal IP addresses.
    /// * Ephemeral external IP addresses are assigned to each cluster VM.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub internal_ip_only: std::option::Option<bool>,

    /// Optional. The type of IPv6 access for a cluster.
    pub private_ipv6_google_access: crate::model::gce_cluster_config::PrivateIpv6GoogleAccess,

    /// Optional. The [Dataproc service
    /// account](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/service-accounts#service_accounts_in_dataproc)
    /// (also see [VM Data Plane
    /// identity](https://cloud.google.com/dataproc/docs/concepts/iam/dataproc-principals#vm_service_account_data_plane_identity))
    /// used by Dataproc cluster VM instances to access Google Cloud Platform
    /// services.
    ///
    /// If not specified, the
    /// [Compute Engine default service
    /// account](https://cloud.google.com/compute/docs/access/service-accounts#default_service_account)
    /// is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// Optional. The URIs of service account scopes to be included in
    /// Compute Engine instances. The following base set of scopes is always
    /// included:
    ///
    /// * <https://www.googleapis.com/auth/cloud.useraccounts.readonly>
    /// * <https://www.googleapis.com/auth/devstorage.read_write>
    /// * <https://www.googleapis.com/auth/logging.write>
    ///
    /// If no scopes are specified, the following defaults are also provided:
    ///
    /// * <https://www.googleapis.com/auth/bigquery>
    /// * <https://www.googleapis.com/auth/bigtable.admin.table>
    /// * <https://www.googleapis.com/auth/bigtable.data>
    /// * <https://www.googleapis.com/auth/devstorage.full_control>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub service_account_scopes: std::vec::Vec<std::string::String>,

    /// The Compute Engine network tags to add to all instances (see [Tagging
    /// instances](https://cloud.google.com/vpc/docs/add-remove-network-tags)).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tags: std::vec::Vec<std::string::String>,

    /// Optional. The Compute Engine metadata entries to add to all instances (see
    /// [Project and instance
    /// metadata](https://cloud.google.com/compute/docs/storing-retrieving-metadata#project_and_instance_metadata)).
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Reservation Affinity for consuming Zonal reservation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reservation_affinity: std::option::Option<crate::model::ReservationAffinity>,

    /// Optional. Node Group Affinity for sole-tenant clusters.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub node_group_affinity: std::option::Option<crate::model::NodeGroupAffinity>,

    /// Optional. Shielded Instance Config for clusters using [Compute Engine
    /// Shielded
    /// VMs](https://cloud.google.com/security/shielded-cloud/shielded-vm).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub shielded_instance_config: std::option::Option<crate::model::ShieldedInstanceConfig>,

    /// Optional. Confidential Instance Config for clusters using [Confidential
    /// VMs](https://cloud.google.com/compute/confidential-vm/docs).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub confidential_instance_config: std::option::Option<crate::model::ConfidentialInstanceConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GceClusterConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [zone_uri][crate::model::GceClusterConfig::zone_uri].
    pub fn set_zone_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone_uri = v.into();
        self
    }

    /// Sets the value of [network_uri][crate::model::GceClusterConfig::network_uri].
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network_uri = v.into();
        self
    }

    /// Sets the value of [subnetwork_uri][crate::model::GceClusterConfig::subnetwork_uri].
    pub fn set_subnetwork_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork_uri = v.into();
        self
    }

    /// Sets the value of [internal_ip_only][crate::model::GceClusterConfig::internal_ip_only].
    pub fn set_internal_ip_only<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.internal_ip_only = v.into();
        self
    }

    /// Sets the value of [private_ipv6_google_access][crate::model::GceClusterConfig::private_ipv6_google_access].
    pub fn set_private_ipv6_google_access<
        T: std::convert::Into<crate::model::gce_cluster_config::PrivateIpv6GoogleAccess>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_ipv6_google_access = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::GceClusterConfig::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [service_account_scopes][crate::model::GceClusterConfig::service_account_scopes].
    pub fn set_service_account_scopes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.service_account_scopes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tags][crate::model::GceClusterConfig::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metadata][crate::model::GceClusterConfig::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [reservation_affinity][crate::model::GceClusterConfig::reservation_affinity].
    pub fn set_reservation_affinity<
        T: std::convert::Into<std::option::Option<crate::model::ReservationAffinity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reservation_affinity = v.into();
        self
    }

    /// Sets the value of [node_group_affinity][crate::model::GceClusterConfig::node_group_affinity].
    pub fn set_node_group_affinity<
        T: std::convert::Into<std::option::Option<crate::model::NodeGroupAffinity>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.node_group_affinity = v.into();
        self
    }

    /// Sets the value of [shielded_instance_config][crate::model::GceClusterConfig::shielded_instance_config].
    pub fn set_shielded_instance_config<
        T: std::convert::Into<std::option::Option<crate::model::ShieldedInstanceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.shielded_instance_config = v.into();
        self
    }

    /// Sets the value of [confidential_instance_config][crate::model::GceClusterConfig::confidential_instance_config].
    pub fn set_confidential_instance_config<
        T: std::convert::Into<std::option::Option<crate::model::ConfidentialInstanceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.confidential_instance_config = v.into();
        self
    }
}

impl wkt::message::Message for GceClusterConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GceClusterConfig"
    }
}

/// Defines additional types related to [GceClusterConfig].
pub mod gce_cluster_config {
    #[allow(unused_imports)]
    use super::*;

    /// `PrivateIpv6GoogleAccess` controls whether and how Dataproc cluster nodes
    /// can communicate with Google Services through gRPC over IPv6.
    /// These values are directly mapped to corresponding values in the
    /// [Compute Engine Instance
    /// fields](https://cloud.google.com/compute/docs/reference/rest/v1/instances).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PrivateIpv6GoogleAccess {
        /// If unspecified, Compute Engine default behavior will apply, which
        /// is the same as
        /// [INHERIT_FROM_SUBNETWORK][google.cloud.dataproc.v1.GceClusterConfig.PrivateIpv6GoogleAccess.INHERIT_FROM_SUBNETWORK].
        ///
        /// [google.cloud.dataproc.v1.GceClusterConfig.PrivateIpv6GoogleAccess.INHERIT_FROM_SUBNETWORK]: crate::model::gce_cluster_config::PrivateIpv6GoogleAccess::InheritFromSubnetwork
        Unspecified,
        /// Private access to and from Google Services configuration
        /// inherited from the subnetwork configuration. This is the
        /// default Compute Engine behavior.
        InheritFromSubnetwork,
        /// Enables outbound private IPv6 access to Google Services from the Dataproc
        /// cluster.
        Outbound,
        /// Enables bidirectional private IPv6 access between Google Services and the
        /// Dataproc cluster.
        Bidirectional,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PrivateIpv6GoogleAccess::value] or
        /// [PrivateIpv6GoogleAccess::name].
        UnknownValue(private_ipv_6_google_access::UnknownValue),
    }

    #[doc(hidden)]
    pub mod private_ipv_6_google_access {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PrivateIpv6GoogleAccess {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InheritFromSubnetwork => std::option::Option::Some(1),
                Self::Outbound => std::option::Option::Some(2),
                Self::Bidirectional => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED")
                }
                Self::InheritFromSubnetwork => std::option::Option::Some("INHERIT_FROM_SUBNETWORK"),
                Self::Outbound => std::option::Option::Some("OUTBOUND"),
                Self::Bidirectional => std::option::Option::Some("BIDIRECTIONAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PrivateIpv6GoogleAccess {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PrivateIpv6GoogleAccess {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PrivateIpv6GoogleAccess {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InheritFromSubnetwork,
                2 => Self::Outbound,
                3 => Self::Bidirectional,
                _ => Self::UnknownValue(private_ipv_6_google_access::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PrivateIpv6GoogleAccess {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED" => Self::Unspecified,
                "INHERIT_FROM_SUBNETWORK" => Self::InheritFromSubnetwork,
                "OUTBOUND" => Self::Outbound,
                "BIDIRECTIONAL" => Self::Bidirectional,
                _ => Self::UnknownValue(private_ipv_6_google_access::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PrivateIpv6GoogleAccess {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InheritFromSubnetwork => serializer.serialize_i32(1),
                Self::Outbound => serializer.serialize_i32(2),
                Self::Bidirectional => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PrivateIpv6GoogleAccess {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<PrivateIpv6GoogleAccess>::new(
                    ".google.cloud.dataproc.v1.GceClusterConfig.PrivateIpv6GoogleAccess",
                ),
            )
        }
    }
}

/// Node Group Affinity for clusters using sole-tenant node groups.
/// **The Dataproc `NodeGroupAffinity` resource is not related to the
/// Dataproc [NodeGroup][google.cloud.dataproc.v1.NodeGroup] resource.**
///
/// [google.cloud.dataproc.v1.NodeGroup]: crate::model::NodeGroup
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodeGroupAffinity {
    /// Required. The URI of a
    /// sole-tenant [node group
    /// resource](https://cloud.google.com/compute/docs/reference/rest/v1/nodeGroups)
    /// that the cluster will be created on.
    ///
    /// A full URL, partial URI, or node group name are valid. Examples:
    ///
    /// * `<https://www.googleapis.com/compute/v1/projects/>[project_id]/zones/[zone]/nodeGroups/node-group-1`
    /// * `projects/[project_id]/zones/[zone]/nodeGroups/node-group-1`
    /// * `node-group-1`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub node_group_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeGroupAffinity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [node_group_uri][crate::model::NodeGroupAffinity::node_group_uri].
    pub fn set_node_group_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_group_uri = v.into();
        self
    }
}

impl wkt::message::Message for NodeGroupAffinity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.NodeGroupAffinity"
    }
}

/// Shielded Instance Config for clusters using [Compute Engine Shielded
/// VMs](https://cloud.google.com/security/shielded-cloud/shielded-vm).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ShieldedInstanceConfig {
    /// Optional. Defines whether instances have Secure Boot enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_secure_boot: std::option::Option<bool>,

    /// Optional. Defines whether instances have the vTPM enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_vtpm: std::option::Option<bool>,

    /// Optional. Defines whether instances have integrity monitoring enabled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_integrity_monitoring: std::option::Option<bool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ShieldedInstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_secure_boot][crate::model::ShieldedInstanceConfig::enable_secure_boot].
    pub fn set_enable_secure_boot<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_secure_boot = v.into();
        self
    }

    /// Sets the value of [enable_vtpm][crate::model::ShieldedInstanceConfig::enable_vtpm].
    pub fn set_enable_vtpm<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_vtpm = v.into();
        self
    }

    /// Sets the value of [enable_integrity_monitoring][crate::model::ShieldedInstanceConfig::enable_integrity_monitoring].
    pub fn set_enable_integrity_monitoring<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_integrity_monitoring = v.into();
        self
    }
}

impl wkt::message::Message for ShieldedInstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ShieldedInstanceConfig"
    }
}

/// Confidential Instance Config for clusters using [Confidential
/// VMs](https://cloud.google.com/compute/confidential-vm/docs)
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConfidentialInstanceConfig {
    /// Optional. Defines whether the instance should have confidential compute
    /// enabled.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_confidential_compute: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfidentialInstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_confidential_compute][crate::model::ConfidentialInstanceConfig::enable_confidential_compute].
    pub fn set_enable_confidential_compute<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_confidential_compute = v.into();
        self
    }
}

impl wkt::message::Message for ConfidentialInstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ConfidentialInstanceConfig"
    }
}

/// The config settings for Compute Engine resources in
/// an instance group, such as a master or worker group.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstanceGroupConfig {
    /// Optional. The number of VM instances in the instance group.
    /// For [HA
    /// cluster](/dataproc/docs/concepts/configuring-clusters/high-availability)
    /// [master_config](#FIELDS.master_config) groups, **must be set to 3**.
    /// For standard cluster [master_config](#FIELDS.master_config) groups,
    /// **must be set to 1**.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub num_instances: i32,

    /// Output only. The list of instance names. Dataproc derives the names
    /// from `cluster_name`, `num_instances`, and the instance group.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instance_names: std::vec::Vec<std::string::String>,

    /// Output only. List of references to Compute Engine instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instance_references: std::vec::Vec<crate::model::InstanceReference>,

    /// Optional. The Compute Engine image resource used for cluster instances.
    ///
    /// The URI can represent an image or image family.
    ///
    /// Image examples:
    ///
    /// * `<https://www.googleapis.com/compute/v1/projects/>[project_id]/global/images/[image-id]`
    /// * `projects/[project_id]/global/images/[image-id]`
    /// * `image-id`
    ///
    /// Image family examples. Dataproc will use the most recent
    /// image from the family:
    ///
    /// * `<https://www.googleapis.com/compute/v1/projects/>[project_id]/global/images/family/[custom-image-family-name]`
    /// * `projects/[project_id]/global/images/family/[custom-image-family-name]`
    ///
    /// If the URI is unspecified, it will be inferred from
    /// `SoftwareConfig.image_version` or the system default.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image_uri: std::string::String,

    /// Optional. The Compute Engine machine type used for cluster instances.
    ///
    /// A full URL, partial URI, or short name are valid. Examples:
    ///
    /// * `<https://www.googleapis.com/compute/v1/projects/>[project_id]/zones/[zone]/machineTypes/n1-standard-2`
    /// * `projects/[project_id]/zones/[zone]/machineTypes/n1-standard-2`
    /// * `n1-standard-2`
    ///
    /// **Auto Zone Exception**: If you are using the Dataproc
    /// [Auto Zone
    /// Placement](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/auto-zone#using_auto_zone_placement)
    /// feature, you must use the short name of the machine type
    /// resource, for example, `n1-standard-2`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub machine_type_uri: std::string::String,

    /// Optional. Disk option config settings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub disk_config: std::option::Option<crate::model::DiskConfig>,

    /// Output only. Specifies that this instance group contains preemptible
    /// instances.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub is_preemptible: bool,

    /// Optional. Specifies the preemptibility of the instance group.
    ///
    /// The default value for master and worker groups is
    /// `NON_PREEMPTIBLE`. This default cannot be changed.
    ///
    /// The default value for secondary instances is
    /// `PREEMPTIBLE`.
    pub preemptibility: crate::model::instance_group_config::Preemptibility,

    /// Output only. The config for Compute Engine Instance Group
    /// Manager that manages this group.
    /// This is only used for preemptible instance groups.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub managed_group_config: std::option::Option<crate::model::ManagedGroupConfig>,

    /// Optional. The Compute Engine accelerator configuration for these
    /// instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub accelerators: std::vec::Vec<crate::model::AcceleratorConfig>,

    /// Optional. Specifies the minimum cpu platform for the Instance Group.
    /// See [Dataproc -> Minimum CPU
    /// Platform](https://cloud.google.com/dataproc/docs/concepts/compute/dataproc-min-cpu).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub min_cpu_platform: std::string::String,

    /// Optional. The minimum number of primary worker instances to create.
    /// If `min_num_instances` is set, cluster creation will succeed if
    /// the number of primary workers created is at least equal to the
    /// `min_num_instances` number.
    ///
    /// Example: Cluster creation request with `num_instances` = `5` and
    /// `min_num_instances` = `3`:
    ///
    /// * If 4 VMs are created and 1 instance fails,
    ///   the failed VM is deleted. The cluster is
    ///   resized to 4 instances and placed in a `RUNNING` state.
    /// * If 2 instances are created and 3 instances fail,
    ///   the cluster in placed in an `ERROR` state. The failed VMs
    ///   are not deleted.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub min_num_instances: i32,

    /// Optional. Instance flexibility Policy allowing a mixture of VM shapes and
    /// provisioning models.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance_flexibility_policy: std::option::Option<crate::model::InstanceFlexibilityPolicy>,

    /// Optional. Configuration to handle the startup of instances during cluster
    /// create and update process.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub startup_config: std::option::Option<crate::model::StartupConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstanceGroupConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [num_instances][crate::model::InstanceGroupConfig::num_instances].
    pub fn set_num_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.num_instances = v.into();
        self
    }

    /// Sets the value of [instance_names][crate::model::InstanceGroupConfig::instance_names].
    pub fn set_instance_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instance_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [instance_references][crate::model::InstanceGroupConfig::instance_references].
    pub fn set_instance_references<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceReference>,
    {
        use std::iter::Iterator;
        self.instance_references = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [image_uri][crate::model::InstanceGroupConfig::image_uri].
    pub fn set_image_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_uri = v.into();
        self
    }

    /// Sets the value of [machine_type_uri][crate::model::InstanceGroupConfig::machine_type_uri].
    pub fn set_machine_type_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_type_uri = v.into();
        self
    }

    /// Sets the value of [disk_config][crate::model::InstanceGroupConfig::disk_config].
    pub fn set_disk_config<T: std::convert::Into<std::option::Option<crate::model::DiskConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.disk_config = v.into();
        self
    }

    /// Sets the value of [is_preemptible][crate::model::InstanceGroupConfig::is_preemptible].
    pub fn set_is_preemptible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_preemptible = v.into();
        self
    }

    /// Sets the value of [preemptibility][crate::model::InstanceGroupConfig::preemptibility].
    pub fn set_preemptibility<
        T: std::convert::Into<crate::model::instance_group_config::Preemptibility>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.preemptibility = v.into();
        self
    }

    /// Sets the value of [managed_group_config][crate::model::InstanceGroupConfig::managed_group_config].
    pub fn set_managed_group_config<
        T: std::convert::Into<std::option::Option<crate::model::ManagedGroupConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.managed_group_config = v.into();
        self
    }

    /// Sets the value of [accelerators][crate::model::InstanceGroupConfig::accelerators].
    pub fn set_accelerators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AcceleratorConfig>,
    {
        use std::iter::Iterator;
        self.accelerators = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [min_cpu_platform][crate::model::InstanceGroupConfig::min_cpu_platform].
    pub fn set_min_cpu_platform<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.min_cpu_platform = v.into();
        self
    }

    /// Sets the value of [min_num_instances][crate::model::InstanceGroupConfig::min_num_instances].
    pub fn set_min_num_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_num_instances = v.into();
        self
    }

    /// Sets the value of [instance_flexibility_policy][crate::model::InstanceGroupConfig::instance_flexibility_policy].
    pub fn set_instance_flexibility_policy<
        T: std::convert::Into<std::option::Option<crate::model::InstanceFlexibilityPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instance_flexibility_policy = v.into();
        self
    }

    /// Sets the value of [startup_config][crate::model::InstanceGroupConfig::startup_config].
    pub fn set_startup_config<
        T: std::convert::Into<std::option::Option<crate::model::StartupConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.startup_config = v.into();
        self
    }
}

impl wkt::message::Message for InstanceGroupConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.InstanceGroupConfig"
    }
}

/// Defines additional types related to [InstanceGroupConfig].
pub mod instance_group_config {
    #[allow(unused_imports)]
    use super::*;

    /// Controls the use of preemptible instances within the group.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Preemptibility {
        /// Preemptibility is unspecified, the system will choose the
        /// appropriate setting for each instance group.
        Unspecified,
        /// Instances are non-preemptible.
        ///
        /// This option is allowed for all instance groups and is the only valid
        /// value for Master and Worker instance groups.
        NonPreemptible,
        /// Instances are [preemptible]
        /// (<https://cloud.google.com/compute/docs/instances/preemptible>).
        ///
        /// This option is allowed only for [secondary worker]
        /// (<https://cloud.google.com/dataproc/docs/concepts/compute/secondary-vms>)
        /// groups.
        Preemptible,
        /// Instances are [Spot VMs]
        /// (<https://cloud.google.com/compute/docs/instances/spot>).
        ///
        /// This option is allowed only for [secondary worker]
        /// (<https://cloud.google.com/dataproc/docs/concepts/compute/secondary-vms>)
        /// groups. Spot VMs are the latest version of [preemptible VMs]
        /// (<https://cloud.google.com/compute/docs/instances/preemptible>), and
        /// provide additional features.
        Spot,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Preemptibility::value] or
        /// [Preemptibility::name].
        UnknownValue(preemptibility::UnknownValue),
    }

    #[doc(hidden)]
    pub mod preemptibility {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Preemptibility {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NonPreemptible => std::option::Option::Some(1),
                Self::Preemptible => std::option::Option::Some(2),
                Self::Spot => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PREEMPTIBILITY_UNSPECIFIED"),
                Self::NonPreemptible => std::option::Option::Some("NON_PREEMPTIBLE"),
                Self::Preemptible => std::option::Option::Some("PREEMPTIBLE"),
                Self::Spot => std::option::Option::Some("SPOT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Preemptibility {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Preemptibility {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Preemptibility {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NonPreemptible,
                2 => Self::Preemptible,
                3 => Self::Spot,
                _ => Self::UnknownValue(preemptibility::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Preemptibility {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PREEMPTIBILITY_UNSPECIFIED" => Self::Unspecified,
                "NON_PREEMPTIBLE" => Self::NonPreemptible,
                "PREEMPTIBLE" => Self::Preemptible,
                "SPOT" => Self::Spot,
                _ => Self::UnknownValue(preemptibility::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Preemptibility {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NonPreemptible => serializer.serialize_i32(1),
                Self::Preemptible => serializer.serialize_i32(2),
                Self::Spot => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Preemptibility {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Preemptibility>::new(
                ".google.cloud.dataproc.v1.InstanceGroupConfig.Preemptibility",
            ))
        }
    }
}

/// Configuration to handle the startup of instances during cluster create and
/// update process.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartupConfig {
    /// Optional. The config setting to enable cluster creation/ updation to be
    /// successful only after required_registration_fraction of instances are up
    /// and running. This configuration is applicable to only secondary workers for
    /// now. The cluster will fail if required_registration_fraction of instances
    /// are not available. This will include instance creation, agent registration,
    /// and service registration (if enabled).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::F64>")]
    pub required_registration_fraction: std::option::Option<f64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartupConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [required_registration_fraction][crate::model::StartupConfig::required_registration_fraction].
    pub fn set_required_registration_fraction<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.required_registration_fraction = v.into();
        self
    }
}

impl wkt::message::Message for StartupConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.StartupConfig"
    }
}

/// A reference to a Compute Engine instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstanceReference {
    /// The user-friendly name of the Compute Engine instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_name: std::string::String,

    /// The unique identifier of the Compute Engine instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_id: std::string::String,

    /// The public RSA key used for sharing data with this instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub public_key: std::string::String,

    /// The public ECIES key used for sharing data with this instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub public_ecies_key: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstanceReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_name][crate::model::InstanceReference::instance_name].
    pub fn set_instance_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_name = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::InstanceReference::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [public_key][crate::model::InstanceReference::public_key].
    pub fn set_public_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_key = v.into();
        self
    }

    /// Sets the value of [public_ecies_key][crate::model::InstanceReference::public_ecies_key].
    pub fn set_public_ecies_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.public_ecies_key = v.into();
        self
    }
}

impl wkt::message::Message for InstanceReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.InstanceReference"
    }
}

/// Specifies the resources used to actively manage an instance group.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ManagedGroupConfig {
    /// Output only. The name of the Instance Template used for the Managed
    /// Instance Group.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_template_name: std::string::String,

    /// Output only. The name of the Instance Group Manager for this group.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_group_manager_name: std::string::String,

    /// Output only. The partial URI to the instance group manager for this group.
    /// E.g. projects/my-project/regions/us-central1/instanceGroupManagers/my-igm.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_group_manager_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManagedGroupConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_template_name][crate::model::ManagedGroupConfig::instance_template_name].
    pub fn set_instance_template_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_template_name = v.into();
        self
    }

    /// Sets the value of [instance_group_manager_name][crate::model::ManagedGroupConfig::instance_group_manager_name].
    pub fn set_instance_group_manager_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_group_manager_name = v.into();
        self
    }

    /// Sets the value of [instance_group_manager_uri][crate::model::ManagedGroupConfig::instance_group_manager_uri].
    pub fn set_instance_group_manager_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance_group_manager_uri = v.into();
        self
    }
}

impl wkt::message::Message for ManagedGroupConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ManagedGroupConfig"
    }
}

/// Instance flexibility Policy allowing a mixture of VM shapes and provisioning
/// models.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstanceFlexibilityPolicy {
    /// Optional. Defines how the Group selects the provisioning model to ensure
    /// required reliability.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub provisioning_model_mix:
        std::option::Option<crate::model::instance_flexibility_policy::ProvisioningModelMix>,

    /// Optional. List of instance selection options that the group will use when
    /// creating new VMs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instance_selection_list:
        std::vec::Vec<crate::model::instance_flexibility_policy::InstanceSelection>,

    /// Output only. A list of instance selection results in the group.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instance_selection_results:
        std::vec::Vec<crate::model::instance_flexibility_policy::InstanceSelectionResult>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstanceFlexibilityPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [provisioning_model_mix][crate::model::InstanceFlexibilityPolicy::provisioning_model_mix].
    pub fn set_provisioning_model_mix<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::instance_flexibility_policy::ProvisioningModelMix,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.provisioning_model_mix = v.into();
        self
    }

    /// Sets the value of [instance_selection_list][crate::model::InstanceFlexibilityPolicy::instance_selection_list].
    pub fn set_instance_selection_list<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::instance_flexibility_policy::InstanceSelection>,
    {
        use std::iter::Iterator;
        self.instance_selection_list = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [instance_selection_results][crate::model::InstanceFlexibilityPolicy::instance_selection_results].
    pub fn set_instance_selection_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::instance_flexibility_policy::InstanceSelectionResult>,
    {
        use std::iter::Iterator;
        self.instance_selection_results = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for InstanceFlexibilityPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.InstanceFlexibilityPolicy"
    }
}

/// Defines additional types related to [InstanceFlexibilityPolicy].
pub mod instance_flexibility_policy {
    #[allow(unused_imports)]
    use super::*;

    /// Defines how Dataproc should create VMs with a mixture of provisioning
    /// models.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ProvisioningModelMix {
        /// Optional. The base capacity that will always use Standard VMs to avoid
        /// risk of more preemption than the minimum capacity you need. Dataproc will
        /// create only standard VMs until it reaches standard_capacity_base, then it
        /// will start using standard_capacity_percent_above_base to mix Spot with
        /// Standard VMs. eg. If 15 instances are requested and
        /// standard_capacity_base is 5, Dataproc will create 5 standard VMs and then
        /// start mixing spot and standard VMs for remaining 10 instances.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub standard_capacity_base: std::option::Option<i32>,

        /// Optional. The percentage of target capacity that should use Standard VM.
        /// The remaining percentage will use Spot VMs. The percentage applies only
        /// to the capacity above standard_capacity_base. eg. If 15 instances are
        /// requested and standard_capacity_base is 5 and
        /// standard_capacity_percent_above_base is 30, Dataproc will create 5
        /// standard VMs and then start mixing spot and standard VMs for remaining 10
        /// instances. The mix will be 30% standard and 70% spot.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub standard_capacity_percent_above_base: std::option::Option<i32>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ProvisioningModelMix {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [standard_capacity_base][crate::model::instance_flexibility_policy::ProvisioningModelMix::standard_capacity_base].
        pub fn set_standard_capacity_base<T: std::convert::Into<std::option::Option<i32>>>(
            mut self,
            v: T,
        ) -> Self {
            self.standard_capacity_base = v.into();
            self
        }

        /// Sets the value of [standard_capacity_percent_above_base][crate::model::instance_flexibility_policy::ProvisioningModelMix::standard_capacity_percent_above_base].
        pub fn set_standard_capacity_percent_above_base<
            T: std::convert::Into<std::option::Option<i32>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.standard_capacity_percent_above_base = v.into();
            self
        }
    }

    impl wkt::message::Message for ProvisioningModelMix {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataproc.v1.InstanceFlexibilityPolicy.ProvisioningModelMix"
        }
    }

    /// Defines machines types and a rank to which the machines types belong.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InstanceSelection {
        /// Optional. Full machine-type names, e.g. "n1-standard-16".
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub machine_types: std::vec::Vec<std::string::String>,

        /// Optional. Preference of this instance selection. Lower number means
        /// higher preference. Dataproc will first try to create a VM based on the
        /// machine-type with priority rank and fallback to next rank based on
        /// availability. Machine types and instance selections with the same
        /// priority have the same preference.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub rank: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InstanceSelection {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [machine_types][crate::model::instance_flexibility_policy::InstanceSelection::machine_types].
        pub fn set_machine_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.machine_types = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [rank][crate::model::instance_flexibility_policy::InstanceSelection::rank].
        pub fn set_rank<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.rank = v.into();
            self
        }
    }

    impl wkt::message::Message for InstanceSelection {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataproc.v1.InstanceFlexibilityPolicy.InstanceSelection"
        }
    }

    /// Defines a mapping from machine types to the number of VMs that are created
    /// with each machine type.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct InstanceSelectionResult {
        /// Output only. Full machine-type names, e.g. "n1-standard-16".
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub machine_type: std::option::Option<std::string::String>,

        /// Output only. Number of VM provisioned with the machine_type.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub vm_count: std::option::Option<i32>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl InstanceSelectionResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [machine_type][crate::model::instance_flexibility_policy::InstanceSelectionResult::machine_type].
        pub fn set_machine_type<T: std::convert::Into<std::option::Option<std::string::String>>>(
            mut self,
            v: T,
        ) -> Self {
            self.machine_type = v.into();
            self
        }

        /// Sets the value of [vm_count][crate::model::instance_flexibility_policy::InstanceSelectionResult::vm_count].
        pub fn set_vm_count<T: std::convert::Into<std::option::Option<i32>>>(
            mut self,
            v: T,
        ) -> Self {
            self.vm_count = v.into();
            self
        }
    }

    impl wkt::message::Message for InstanceSelectionResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataproc.v1.InstanceFlexibilityPolicy.InstanceSelectionResult"
        }
    }
}

/// Specifies the type and number of accelerator cards attached to the instances
/// of an instance. See [GPUs on Compute
/// Engine](https://cloud.google.com/compute/docs/gpus/).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AcceleratorConfig {
    /// Full URL, partial URI, or short name of the accelerator type resource to
    /// expose to this instance. See
    /// [Compute Engine
    /// AcceleratorTypes](https://cloud.google.com/compute/docs/reference/v1/acceleratorTypes).
    ///
    /// Examples:
    ///
    /// * `<https://www.googleapis.com/compute/v1/projects/>[project_id]/zones/[zone]/acceleratorTypes/nvidia-tesla-t4`
    /// * `projects/[project_id]/zones/[zone]/acceleratorTypes/nvidia-tesla-t4`
    /// * `nvidia-tesla-t4`
    ///
    /// **Auto Zone Exception**: If you are using the Dataproc
    /// [Auto Zone
    /// Placement](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/auto-zone#using_auto_zone_placement)
    /// feature, you must use the short name of the accelerator type
    /// resource, for example, `nvidia-tesla-t4`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub accelerator_type_uri: std::string::String,

    /// The number of the accelerator cards of this type exposed to this instance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub accelerator_count: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AcceleratorConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [accelerator_type_uri][crate::model::AcceleratorConfig::accelerator_type_uri].
    pub fn set_accelerator_type_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.accelerator_type_uri = v.into();
        self
    }

    /// Sets the value of [accelerator_count][crate::model::AcceleratorConfig::accelerator_count].
    pub fn set_accelerator_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.accelerator_count = v.into();
        self
    }
}

impl wkt::message::Message for AcceleratorConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.AcceleratorConfig"
    }
}

/// Specifies the config of disk options for a group of VM instances.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiskConfig {
    /// Optional. Type of the boot disk (default is "pd-standard").
    /// Valid values: "pd-balanced" (Persistent Disk Balanced Solid State Drive),
    /// "pd-ssd" (Persistent Disk Solid State Drive),
    /// or "pd-standard" (Persistent Disk Hard Disk Drive).
    /// See [Disk types](https://cloud.google.com/compute/docs/disks#disk-types).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub boot_disk_type: std::string::String,

    /// Optional. Size in GB of the boot disk (default is 500GB).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub boot_disk_size_gb: i32,

    /// Optional. Number of attached SSDs, from 0 to 8 (default is 0).
    /// If SSDs are not attached, the boot disk is used to store runtime logs and
    /// [HDFS](https://hadoop.apache.org/docs/r1.2.1/hdfs_user_guide.html) data.
    /// If one or more SSDs are attached, this runtime bulk
    /// data is spread across them, and the boot disk contains only basic
    /// config and installed binaries.
    ///
    /// Note: Local SSD options may vary by machine type and number of vCPUs
    /// selected.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub num_local_ssds: i32,

    /// Optional. Interface type of local SSDs (default is "scsi").
    /// Valid values: "scsi" (Small Computer System Interface),
    /// "nvme" (Non-Volatile Memory Express).
    /// See [local SSD
    /// performance](https://cloud.google.com/compute/docs/disks/local-ssd#performance).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub local_ssd_interface: std::string::String,

    /// Optional. Indicates how many IOPS to provision for the disk. This sets the
    /// number of I/O operations per second that the disk can handle. Note: This
    /// field is only supported if boot_disk_type is hyperdisk-balanced.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub boot_disk_provisioned_iops: std::option::Option<i64>,

    /// Optional. Indicates how much throughput to provision for the disk. This
    /// sets the number of throughput mb per second that the disk can handle.
    /// Values must be greater than or equal to 1. Note: This field is only
    /// supported if boot_disk_type is hyperdisk-balanced.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub boot_disk_provisioned_throughput: std::option::Option<i64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiskConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [boot_disk_type][crate::model::DiskConfig::boot_disk_type].
    pub fn set_boot_disk_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.boot_disk_type = v.into();
        self
    }

    /// Sets the value of [boot_disk_size_gb][crate::model::DiskConfig::boot_disk_size_gb].
    pub fn set_boot_disk_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.boot_disk_size_gb = v.into();
        self
    }

    /// Sets the value of [num_local_ssds][crate::model::DiskConfig::num_local_ssds].
    pub fn set_num_local_ssds<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.num_local_ssds = v.into();
        self
    }

    /// Sets the value of [local_ssd_interface][crate::model::DiskConfig::local_ssd_interface].
    pub fn set_local_ssd_interface<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.local_ssd_interface = v.into();
        self
    }

    /// Sets the value of [boot_disk_provisioned_iops][crate::model::DiskConfig::boot_disk_provisioned_iops].
    pub fn set_boot_disk_provisioned_iops<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.boot_disk_provisioned_iops = v.into();
        self
    }

    /// Sets the value of [boot_disk_provisioned_throughput][crate::model::DiskConfig::boot_disk_provisioned_throughput].
    pub fn set_boot_disk_provisioned_throughput<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.boot_disk_provisioned_throughput = v.into();
        self
    }
}

impl wkt::message::Message for DiskConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DiskConfig"
    }
}

/// Node group identification and configuration information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AuxiliaryNodeGroup {
    /// Required. Node group configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub node_group: std::option::Option<crate::model::NodeGroup>,

    /// Optional. A node group ID. Generated if not specified.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). Cannot begin or end with underscore
    /// or hyphen. Must consist of from 3 to 33 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub node_group_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuxiliaryNodeGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [node_group][crate::model::AuxiliaryNodeGroup::node_group].
    pub fn set_node_group<T: std::convert::Into<std::option::Option<crate::model::NodeGroup>>>(
        mut self,
        v: T,
    ) -> Self {
        self.node_group = v.into();
        self
    }

    /// Sets the value of [node_group_id][crate::model::AuxiliaryNodeGroup::node_group_id].
    pub fn set_node_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_group_id = v.into();
        self
    }
}

impl wkt::message::Message for AuxiliaryNodeGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.AuxiliaryNodeGroup"
    }
}

/// Dataproc Node Group.
/// **The Dataproc `NodeGroup` resource is not related to the
/// Dataproc [NodeGroupAffinity][google.cloud.dataproc.v1.NodeGroupAffinity]
/// resource.**
///
/// [google.cloud.dataproc.v1.NodeGroupAffinity]: crate::model::NodeGroupAffinity
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodeGroup {
    /// The Node group [resource name](https://aip.dev/122).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Node group roles.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub roles: std::vec::Vec<crate::model::node_group::Role>,

    /// Optional. The node group instance group configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub node_group_config: std::option::Option<crate::model::InstanceGroupConfig>,

    /// Optional. Node group labels.
    ///
    /// * Label **keys** must consist of from 1 to 63 characters and conform to
    ///   [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt).
    /// * Label **values** can be empty. If specified, they must consist of from
    ///   1 to 63 characters and conform to [RFC 1035]
    ///   (<https://www.ietf.org/rfc/rfc1035.txt>).
    /// * The node group must have no more than 32 labels.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NodeGroup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [roles][crate::model::NodeGroup::roles].
    pub fn set_roles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::node_group::Role>,
    {
        use std::iter::Iterator;
        self.roles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [node_group_config][crate::model::NodeGroup::node_group_config].
    pub fn set_node_group_config<
        T: std::convert::Into<std::option::Option<crate::model::InstanceGroupConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.node_group_config = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::NodeGroup::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for NodeGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.NodeGroup"
    }
}

/// Defines additional types related to [NodeGroup].
pub mod node_group {
    #[allow(unused_imports)]
    use super::*;

    /// Node pool roles.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Role {
        /// Required unspecified role.
        Unspecified,
        /// Job drivers run on the node pool.
        Driver,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Role::value] or
        /// [Role::name].
        UnknownValue(role::UnknownValue),
    }

    #[doc(hidden)]
    pub mod role {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Role {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Driver => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROLE_UNSPECIFIED"),
                Self::Driver => std::option::Option::Some("DRIVER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Role {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Role {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Role {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Driver,
                _ => Self::UnknownValue(role::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Role {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROLE_UNSPECIFIED" => Self::Unspecified,
                "DRIVER" => Self::Driver,
                _ => Self::UnknownValue(role::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Role {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Driver => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Role {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Role>::new(
                ".google.cloud.dataproc.v1.NodeGroup.Role",
            ))
        }
    }
}

/// Specifies an executable to run on a fully configured node and a
/// timeout period for executable completion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodeInitializationAction {
    /// Required. Cloud Storage URI of executable file.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub executable_file: std::string::String,

    /// Optional. Amount of time executable has to complete. Default is
    /// 10 minutes (see JSON representation of
    /// [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json)).
    ///
    /// Cluster creation fails with an explanatory error message (the
    /// name of the executable that caused the error and the exceeded timeout
    /// period) if the executable is not completed at end of the timeout period.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execution_timeout: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeInitializationAction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [executable_file][crate::model::NodeInitializationAction::executable_file].
    pub fn set_executable_file<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.executable_file = v.into();
        self
    }

    /// Sets the value of [execution_timeout][crate::model::NodeInitializationAction::execution_timeout].
    pub fn set_execution_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_timeout = v.into();
        self
    }
}

impl wkt::message::Message for NodeInitializationAction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.NodeInitializationAction"
    }
}

/// The status of a cluster and its instances.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClusterStatus {
    /// Output only. The cluster's state.
    pub state: crate::model::cluster_status::State,

    /// Optional. Output only. Details of cluster's state.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub detail: std::string::String,

    /// Output only. Time when this state was entered (see JSON representation of
    /// [Timestamp](https://developers.google.com/protocol-buffers/docs/proto3#json)).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub state_start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Additional state information that includes
    /// status reported by the agent.
    pub substate: crate::model::cluster_status::Substate,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::ClusterStatus::state].
    pub fn set_state<T: std::convert::Into<crate::model::cluster_status::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [detail][crate::model::ClusterStatus::detail].
    pub fn set_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.detail = v.into();
        self
    }

    /// Sets the value of [state_start_time][crate::model::ClusterStatus::state_start_time].
    pub fn set_state_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.state_start_time = v.into();
        self
    }

    /// Sets the value of [substate][crate::model::ClusterStatus::substate].
    pub fn set_substate<T: std::convert::Into<crate::model::cluster_status::Substate>>(
        mut self,
        v: T,
    ) -> Self {
        self.substate = v.into();
        self
    }
}

impl wkt::message::Message for ClusterStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ClusterStatus"
    }
}

/// Defines additional types related to [ClusterStatus].
pub mod cluster_status {
    #[allow(unused_imports)]
    use super::*;

    /// The cluster state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The cluster state is unknown.
        Unknown,
        /// The cluster is being created and set up. It is not ready for use.
        Creating,
        /// The cluster is currently running and healthy. It is ready for use.
        ///
        /// **Note:** The cluster state changes from "creating" to "running" status
        /// after the master node(s), first two primary worker nodes (and the last
        /// primary worker node if primary workers > 2) are running.
        Running,
        /// The cluster encountered an error. It is not ready for use.
        Error,
        /// The cluster has encountered an error while being updated. Jobs can
        /// be submitted to the cluster, but the cluster cannot be updated.
        ErrorDueToUpdate,
        /// The cluster is being deleted. It cannot be used.
        Deleting,
        /// The cluster is being updated. It continues to accept and process jobs.
        Updating,
        /// The cluster is being stopped. It cannot be used.
        Stopping,
        /// The cluster is currently stopped. It is not ready for use.
        Stopped,
        /// The cluster is being started. It is not ready for use.
        Starting,
        /// The cluster is being repaired. It is not ready for use.
        Repairing,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Error => std::option::Option::Some(3),
                Self::ErrorDueToUpdate => std::option::Option::Some(9),
                Self::Deleting => std::option::Option::Some(4),
                Self::Updating => std::option::Option::Some(5),
                Self::Stopping => std::option::Option::Some(6),
                Self::Stopped => std::option::Option::Some(7),
                Self::Starting => std::option::Option::Some(8),
                Self::Repairing => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::ErrorDueToUpdate => std::option::Option::Some("ERROR_DUE_TO_UPDATE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::Starting => std::option::Option::Some("STARTING"),
                Self::Repairing => std::option::Option::Some("REPAIRING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Creating,
                2 => Self::Running,
                3 => Self::Error,
                4 => Self::Deleting,
                5 => Self::Updating,
                6 => Self::Stopping,
                7 => Self::Stopped,
                8 => Self::Starting,
                9 => Self::ErrorDueToUpdate,
                10 => Self::Repairing,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "CREATING" => Self::Creating,
                "RUNNING" => Self::Running,
                "ERROR" => Self::Error,
                "ERROR_DUE_TO_UPDATE" => Self::ErrorDueToUpdate,
                "DELETING" => Self::Deleting,
                "UPDATING" => Self::Updating,
                "STOPPING" => Self::Stopping,
                "STOPPED" => Self::Stopped,
                "STARTING" => Self::Starting,
                "REPAIRING" => Self::Repairing,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Error => serializer.serialize_i32(3),
                Self::ErrorDueToUpdate => serializer.serialize_i32(9),
                Self::Deleting => serializer.serialize_i32(4),
                Self::Updating => serializer.serialize_i32(5),
                Self::Stopping => serializer.serialize_i32(6),
                Self::Stopped => serializer.serialize_i32(7),
                Self::Starting => serializer.serialize_i32(8),
                Self::Repairing => serializer.serialize_i32(10),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataproc.v1.ClusterStatus.State",
            ))
        }
    }

    /// The cluster substate.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Substate {
        /// The cluster substate is unknown.
        Unspecified,
        /// The cluster is known to be in an unhealthy state
        /// (for example, critical daemons are not running or HDFS capacity is
        /// exhausted).
        ///
        /// Applies to RUNNING state.
        Unhealthy,
        /// The agent-reported status is out of date (may occur if
        /// Dataproc loses communication with Agent).
        ///
        /// Applies to RUNNING state.
        StaleStatus,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Substate::value] or
        /// [Substate::name].
        UnknownValue(substate::UnknownValue),
    }

    #[doc(hidden)]
    pub mod substate {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Substate {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Unhealthy => std::option::Option::Some(1),
                Self::StaleStatus => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::Unhealthy => std::option::Option::Some("UNHEALTHY"),
                Self::StaleStatus => std::option::Option::Some("STALE_STATUS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Substate {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Substate {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Substate {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Unhealthy,
                2 => Self::StaleStatus,
                _ => Self::UnknownValue(substate::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Substate {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "UNHEALTHY" => Self::Unhealthy,
                "STALE_STATUS" => Self::StaleStatus,
                _ => Self::UnknownValue(substate::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Substate {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Unhealthy => serializer.serialize_i32(1),
                Self::StaleStatus => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Substate {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Substate>::new(
                ".google.cloud.dataproc.v1.ClusterStatus.Substate",
            ))
        }
    }
}

/// Security related configuration, including encryption, Kerberos, etc.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecurityConfig {
    /// Optional. Kerberos related configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub kerberos_config: std::option::Option<crate::model::KerberosConfig>,

    /// Optional. Identity related configuration, including service account based
    /// secure multi-tenancy user mappings.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub identity_config: std::option::Option<crate::model::IdentityConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecurityConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kerberos_config][crate::model::SecurityConfig::kerberos_config].
    pub fn set_kerberos_config<
        T: std::convert::Into<std::option::Option<crate::model::KerberosConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.kerberos_config = v.into();
        self
    }

    /// Sets the value of [identity_config][crate::model::SecurityConfig::identity_config].
    pub fn set_identity_config<
        T: std::convert::Into<std::option::Option<crate::model::IdentityConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.identity_config = v.into();
        self
    }
}

impl wkt::message::Message for SecurityConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SecurityConfig"
    }
}

/// Specifies Kerberos related configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct KerberosConfig {
    /// Optional. Flag to indicate whether to Kerberize the cluster (default:
    /// false). Set this field to true to enable Kerberos on a cluster.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub enable_kerberos: bool,

    /// Optional. The Cloud Storage URI of a KMS encrypted file containing the root
    /// principal password.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub root_principal_password_uri: std::string::String,

    /// Optional. The URI of the KMS key used to encrypt sensitive
    /// files.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_uri: std::string::String,

    /// Optional. The Cloud Storage URI of the keystore file used for SSL
    /// encryption. If not provided, Dataproc will provide a self-signed
    /// certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub keystore_uri: std::string::String,

    /// Optional. The Cloud Storage URI of the truststore file used for SSL
    /// encryption. If not provided, Dataproc will provide a self-signed
    /// certificate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub truststore_uri: std::string::String,

    /// Optional. The Cloud Storage URI of a KMS encrypted file containing the
    /// password to the user provided keystore. For the self-signed certificate,
    /// this password is generated by Dataproc.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub keystore_password_uri: std::string::String,

    /// Optional. The Cloud Storage URI of a KMS encrypted file containing the
    /// password to the user provided key. For the self-signed certificate, this
    /// password is generated by Dataproc.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key_password_uri: std::string::String,

    /// Optional. The Cloud Storage URI of a KMS encrypted file containing the
    /// password to the user provided truststore. For the self-signed certificate,
    /// this password is generated by Dataproc.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub truststore_password_uri: std::string::String,

    /// Optional. The remote realm the Dataproc on-cluster KDC will trust, should
    /// the user enable cross realm trust.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cross_realm_trust_realm: std::string::String,

    /// Optional. The KDC (IP or hostname) for the remote trusted realm in a cross
    /// realm trust relationship.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cross_realm_trust_kdc: std::string::String,

    /// Optional. The admin server (IP or hostname) for the remote trusted realm in
    /// a cross realm trust relationship.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cross_realm_trust_admin_server: std::string::String,

    /// Optional. The Cloud Storage URI of a KMS encrypted file containing the
    /// shared password between the on-cluster Kerberos realm and the remote
    /// trusted realm, in a cross realm trust relationship.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cross_realm_trust_shared_password_uri: std::string::String,

    /// Optional. The Cloud Storage URI of a KMS encrypted file containing the
    /// master key of the KDC database.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kdc_db_key_uri: std::string::String,

    /// Optional. The lifetime of the ticket granting ticket, in hours.
    /// If not specified, or user specifies 0, then default value 10
    /// will be used.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub tgt_lifetime_hours: i32,

    /// Optional. The name of the on-cluster Kerberos realm.
    /// If not specified, the uppercased domain of hostnames will be the realm.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub realm: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KerberosConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_kerberos][crate::model::KerberosConfig::enable_kerberos].
    pub fn set_enable_kerberos<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_kerberos = v.into();
        self
    }

    /// Sets the value of [root_principal_password_uri][crate::model::KerberosConfig::root_principal_password_uri].
    pub fn set_root_principal_password_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.root_principal_password_uri = v.into();
        self
    }

    /// Sets the value of [kms_key_uri][crate::model::KerberosConfig::kms_key_uri].
    pub fn set_kms_key_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_uri = v.into();
        self
    }

    /// Sets the value of [keystore_uri][crate::model::KerberosConfig::keystore_uri].
    pub fn set_keystore_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.keystore_uri = v.into();
        self
    }

    /// Sets the value of [truststore_uri][crate::model::KerberosConfig::truststore_uri].
    pub fn set_truststore_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.truststore_uri = v.into();
        self
    }

    /// Sets the value of [keystore_password_uri][crate::model::KerberosConfig::keystore_password_uri].
    pub fn set_keystore_password_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.keystore_password_uri = v.into();
        self
    }

    /// Sets the value of [key_password_uri][crate::model::KerberosConfig::key_password_uri].
    pub fn set_key_password_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.key_password_uri = v.into();
        self
    }

    /// Sets the value of [truststore_password_uri][crate::model::KerberosConfig::truststore_password_uri].
    pub fn set_truststore_password_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.truststore_password_uri = v.into();
        self
    }

    /// Sets the value of [cross_realm_trust_realm][crate::model::KerberosConfig::cross_realm_trust_realm].
    pub fn set_cross_realm_trust_realm<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cross_realm_trust_realm = v.into();
        self
    }

    /// Sets the value of [cross_realm_trust_kdc][crate::model::KerberosConfig::cross_realm_trust_kdc].
    pub fn set_cross_realm_trust_kdc<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cross_realm_trust_kdc = v.into();
        self
    }

    /// Sets the value of [cross_realm_trust_admin_server][crate::model::KerberosConfig::cross_realm_trust_admin_server].
    pub fn set_cross_realm_trust_admin_server<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cross_realm_trust_admin_server = v.into();
        self
    }

    /// Sets the value of [cross_realm_trust_shared_password_uri][crate::model::KerberosConfig::cross_realm_trust_shared_password_uri].
    pub fn set_cross_realm_trust_shared_password_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cross_realm_trust_shared_password_uri = v.into();
        self
    }

    /// Sets the value of [kdc_db_key_uri][crate::model::KerberosConfig::kdc_db_key_uri].
    pub fn set_kdc_db_key_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kdc_db_key_uri = v.into();
        self
    }

    /// Sets the value of [tgt_lifetime_hours][crate::model::KerberosConfig::tgt_lifetime_hours].
    pub fn set_tgt_lifetime_hours<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.tgt_lifetime_hours = v.into();
        self
    }

    /// Sets the value of [realm][crate::model::KerberosConfig::realm].
    pub fn set_realm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.realm = v.into();
        self
    }
}

impl wkt::message::Message for KerberosConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.KerberosConfig"
    }
}

/// Identity related configuration, including service account based
/// secure multi-tenancy user mappings.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct IdentityConfig {
    /// Required. Map of user to service account.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub user_service_account_mapping:
        std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IdentityConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_service_account_mapping][crate::model::IdentityConfig::user_service_account_mapping].
    pub fn set_user_service_account_mapping<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.user_service_account_mapping =
            v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for IdentityConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.IdentityConfig"
    }
}

/// Specifies the selection and config of software inside the cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SoftwareConfig {
    /// Optional. The version of software inside the cluster. It must be one of the
    /// supported [Dataproc
    /// Versions](https://cloud.google.com/dataproc/docs/concepts/versioning/dataproc-versions#supported-dataproc-image-versions),
    /// such as "1.2" (including a subminor version, such as "1.2.29"), or the
    /// ["preview"
    /// version](https://cloud.google.com/dataproc/docs/concepts/versioning/dataproc-versions#other_versions).
    /// If unspecified, it defaults to the latest Debian version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub image_version: std::string::String,

    /// Optional. The properties to set on daemon config files.
    ///
    /// Property keys are specified in `prefix:property` format, for example
    /// `core:hadoop.tmp.dir`. The following are supported prefixes
    /// and their mappings:
    ///
    /// * capacity-scheduler: `capacity-scheduler.xml`
    /// * core:   `core-site.xml`
    /// * distcp: `distcp-default.xml`
    /// * hdfs:   `hdfs-site.xml`
    /// * hive:   `hive-site.xml`
    /// * mapred: `mapred-site.xml`
    /// * pig:    `pig.properties`
    /// * spark:  `spark-defaults.conf`
    /// * yarn:   `yarn-site.xml`
    ///
    /// For more information, see [Cluster
    /// properties](https://cloud.google.com/dataproc/docs/concepts/cluster-properties).
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The set of components to activate on the cluster.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub optional_components: std::vec::Vec<crate::model::Component>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SoftwareConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image_version][crate::model::SoftwareConfig::image_version].
    pub fn set_image_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_version = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::SoftwareConfig::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [optional_components][crate::model::SoftwareConfig::optional_components].
    pub fn set_optional_components<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Component>,
    {
        use std::iter::Iterator;
        self.optional_components = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SoftwareConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SoftwareConfig"
    }
}

/// Specifies the cluster auto-delete schedule configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LifecycleConfig {
    /// Optional. The duration to keep the cluster alive while idling (when no jobs
    /// are running). Passing this threshold will cause the cluster to be
    /// deleted. Minimum value is 5 minutes; maximum value is 14 days (see JSON
    /// representation of
    /// [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json)).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub idle_delete_ttl: std::option::Option<wkt::Duration>,

    /// Output only. The time when cluster became idle (most recent job finished)
    /// and became eligible for deletion due to idleness (see JSON representation
    /// of
    /// [Timestamp](https://developers.google.com/protocol-buffers/docs/proto3#json)).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub idle_start_time: std::option::Option<wkt::Timestamp>,

    /// Either the exact time the cluster should be deleted at or
    /// the cluster maximum age.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub ttl: std::option::Option<crate::model::lifecycle_config::Ttl>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LifecycleConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [idle_delete_ttl][crate::model::LifecycleConfig::idle_delete_ttl].
    pub fn set_idle_delete_ttl<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.idle_delete_ttl = v.into();
        self
    }

    /// Sets the value of [idle_start_time][crate::model::LifecycleConfig::idle_start_time].
    pub fn set_idle_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.idle_start_time = v.into();
        self
    }

    /// Sets the value of [ttl][crate::model::LifecycleConfig::ttl].
    ///
    /// Note that all the setters affecting `ttl` are mutually
    /// exclusive.
    pub fn set_ttl<
        T: std::convert::Into<std::option::Option<crate::model::lifecycle_config::Ttl>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ttl = v.into();
        self
    }

    /// The value of [ttl][crate::model::LifecycleConfig::ttl]
    /// if it holds a `AutoDeleteTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn auto_delete_time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.ttl.as_ref().and_then(|v| match v {
            crate::model::lifecycle_config::Ttl::AutoDeleteTime(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [ttl][crate::model::LifecycleConfig::ttl]
    /// to hold a `AutoDeleteTime`.
    ///
    /// Note that all the setters affecting `ttl` are
    /// mutually exclusive.
    pub fn set_auto_delete_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ttl = std::option::Option::Some(crate::model::lifecycle_config::Ttl::AutoDeleteTime(
            v.into(),
        ));
        self
    }

    /// The value of [ttl][crate::model::LifecycleConfig::ttl]
    /// if it holds a `AutoDeleteTtl`, `None` if the field is not set or
    /// holds a different branch.
    pub fn auto_delete_ttl(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.ttl.as_ref().and_then(|v| match v {
            crate::model::lifecycle_config::Ttl::AutoDeleteTtl(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [ttl][crate::model::LifecycleConfig::ttl]
    /// to hold a `AutoDeleteTtl`.
    ///
    /// Note that all the setters affecting `ttl` are
    /// mutually exclusive.
    pub fn set_auto_delete_ttl<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ttl =
            std::option::Option::Some(crate::model::lifecycle_config::Ttl::AutoDeleteTtl(v.into()));
        self
    }
}

impl wkt::message::Message for LifecycleConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.LifecycleConfig"
    }
}

/// Defines additional types related to [LifecycleConfig].
pub mod lifecycle_config {
    #[allow(unused_imports)]
    use super::*;

    /// Either the exact time the cluster should be deleted at or
    /// the cluster maximum age.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Ttl {
        /// Optional. The time when cluster will be auto-deleted (see JSON
        /// representation of
        /// [Timestamp](https://developers.google.com/protocol-buffers/docs/proto3#json)).
        AutoDeleteTime(std::boxed::Box<wkt::Timestamp>),
        /// Optional. The lifetime duration of cluster. The cluster will be
        /// auto-deleted at the end of this period. Minimum value is 10 minutes;
        /// maximum value is 14 days (see JSON representation of
        /// [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json)).
        AutoDeleteTtl(std::boxed::Box<wkt::Duration>),
    }
}

/// Specifies a Metastore configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MetastoreConfig {
    /// Required. Resource name of an existing Dataproc Metastore service.
    ///
    /// Example:
    ///
    /// * `projects/[project_id]/locations/[dataproc_region]/services/[service-name]`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataproc_metastore_service: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MetastoreConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataproc_metastore_service][crate::model::MetastoreConfig::dataproc_metastore_service].
    pub fn set_dataproc_metastore_service<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataproc_metastore_service = v.into();
        self
    }
}

impl wkt::message::Message for MetastoreConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.MetastoreConfig"
    }
}

/// Contains cluster daemon metrics, such as HDFS and YARN stats.
///
/// **Beta Feature**: This report is available for testing purposes only. It may
/// be changed before final release.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClusterMetrics {
    /// The HDFS metrics.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "std::collections::HashMap<_, serde_with::DisplayFromStr>")]
    pub hdfs_metrics: std::collections::HashMap<std::string::String, i64>,

    /// YARN metrics.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "std::collections::HashMap<_, serde_with::DisplayFromStr>")]
    pub yarn_metrics: std::collections::HashMap<std::string::String, i64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterMetrics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hdfs_metrics][crate::model::ClusterMetrics::hdfs_metrics].
    pub fn set_hdfs_metrics<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.hdfs_metrics = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [yarn_metrics][crate::model::ClusterMetrics::yarn_metrics].
    pub fn set_yarn_metrics<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.yarn_metrics = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ClusterMetrics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ClusterMetrics"
    }
}

/// Dataproc metric config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataprocMetricConfig {
    /// Required. Metrics sources to enable.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub metrics: std::vec::Vec<crate::model::dataproc_metric_config::Metric>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataprocMetricConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metrics][crate::model::DataprocMetricConfig::metrics].
    pub fn set_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::dataproc_metric_config::Metric>,
    {
        use std::iter::Iterator;
        self.metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DataprocMetricConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DataprocMetricConfig"
    }
}

/// Defines additional types related to [DataprocMetricConfig].
pub mod dataproc_metric_config {
    #[allow(unused_imports)]
    use super::*;

    /// A Dataproc custom metric.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Metric {
        /// Required. A standard set of metrics is collected unless `metricOverrides`
        /// are specified for the metric source (see [Custom metrics]
        /// (<https://cloud.google.com/dataproc/docs/guides/dataproc-metrics#custom_metrics>)
        /// for more information).
        pub metric_source: crate::model::dataproc_metric_config::MetricSource,

        /// Optional. Specify one or more [Custom metrics]
        /// (<https://cloud.google.com/dataproc/docs/guides/dataproc-metrics#custom_metrics>)
        /// to collect for the metric course (for the `SPARK` metric source (any
        /// [Spark metric]
        /// (<https://spark.apache.org/docs/latest/monitoring.html#metrics>) can be
        /// specified).
        ///
        /// Provide metrics in the following format:
        /// \<code\>\<var\>METRIC_SOURCE\</var\>:\<var\>INSTANCE\</var\>:\<var\>GROUP\</var\>:\<var\>METRIC\</var\>\</code\>
        /// Use camelcase as appropriate.
        ///
        /// Examples:
        ///
        /// ```norust
        /// yarn:ResourceManager:QueueMetrics:AppsCompleted
        /// spark:driver:DAGScheduler:job.allJobs
        /// sparkHistoryServer:JVM:Memory:NonHeapMemoryUsage.committed
        /// hiveserver2:JVM:Memory:NonHeapMemoryUsage.used
        /// ```
        ///
        /// Notes:
        ///
        /// * Only the specified overridden metrics are collected for the
        ///   metric source. For example, if one or more `spark:executive` metrics
        ///   are listed as metric overrides, other `SPARK` metrics are not
        ///   collected. The collection of the metrics for other enabled custom
        ///   metric sources is unaffected. For example, if both `SPARK` andd `YARN`
        ///   metric sources are enabled, and overrides are provided for Spark
        ///   metrics only, all YARN metrics are collected.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub metric_overrides: std::vec::Vec<std::string::String>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Metric {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [metric_source][crate::model::dataproc_metric_config::Metric::metric_source].
        pub fn set_metric_source<
            T: std::convert::Into<crate::model::dataproc_metric_config::MetricSource>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.metric_source = v.into();
            self
        }

        /// Sets the value of [metric_overrides][crate::model::dataproc_metric_config::Metric::metric_overrides].
        pub fn set_metric_overrides<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.metric_overrides = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Metric {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataproc.v1.DataprocMetricConfig.Metric"
        }
    }

    /// A source for the collection of Dataproc custom metrics (see [Custom
    /// metrics]
    /// (<https://cloud.google.com//dataproc/docs/guides/dataproc-metrics#custom_metrics>)).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MetricSource {
        /// Required unspecified metric source.
        Unspecified,
        /// Monitoring agent metrics. If this source is enabled,
        /// Dataproc enables the monitoring agent in Compute Engine,
        /// and collects monitoring agent metrics, which are published
        /// with an `agent.googleapis.com` prefix.
        MonitoringAgentDefaults,
        /// HDFS metric source.
        Hdfs,
        /// Spark metric source.
        Spark,
        /// YARN metric source.
        Yarn,
        /// Spark History Server metric source.
        SparkHistoryServer,
        /// Hiveserver2 metric source.
        Hiveserver2,
        /// hivemetastore metric source
        Hivemetastore,
        /// flink metric source
        Flink,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MetricSource::value] or
        /// [MetricSource::name].
        UnknownValue(metric_source::UnknownValue),
    }

    #[doc(hidden)]
    pub mod metric_source {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MetricSource {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::MonitoringAgentDefaults => std::option::Option::Some(1),
                Self::Hdfs => std::option::Option::Some(2),
                Self::Spark => std::option::Option::Some(3),
                Self::Yarn => std::option::Option::Some(4),
                Self::SparkHistoryServer => std::option::Option::Some(5),
                Self::Hiveserver2 => std::option::Option::Some(6),
                Self::Hivemetastore => std::option::Option::Some(7),
                Self::Flink => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("METRIC_SOURCE_UNSPECIFIED"),
                Self::MonitoringAgentDefaults => {
                    std::option::Option::Some("MONITORING_AGENT_DEFAULTS")
                }
                Self::Hdfs => std::option::Option::Some("HDFS"),
                Self::Spark => std::option::Option::Some("SPARK"),
                Self::Yarn => std::option::Option::Some("YARN"),
                Self::SparkHistoryServer => std::option::Option::Some("SPARK_HISTORY_SERVER"),
                Self::Hiveserver2 => std::option::Option::Some("HIVESERVER2"),
                Self::Hivemetastore => std::option::Option::Some("HIVEMETASTORE"),
                Self::Flink => std::option::Option::Some("FLINK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MetricSource {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MetricSource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MetricSource {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::MonitoringAgentDefaults,
                2 => Self::Hdfs,
                3 => Self::Spark,
                4 => Self::Yarn,
                5 => Self::SparkHistoryServer,
                6 => Self::Hiveserver2,
                7 => Self::Hivemetastore,
                8 => Self::Flink,
                _ => Self::UnknownValue(metric_source::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MetricSource {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "METRIC_SOURCE_UNSPECIFIED" => Self::Unspecified,
                "MONITORING_AGENT_DEFAULTS" => Self::MonitoringAgentDefaults,
                "HDFS" => Self::Hdfs,
                "SPARK" => Self::Spark,
                "YARN" => Self::Yarn,
                "SPARK_HISTORY_SERVER" => Self::SparkHistoryServer,
                "HIVESERVER2" => Self::Hiveserver2,
                "HIVEMETASTORE" => Self::Hivemetastore,
                "FLINK" => Self::Flink,
                _ => Self::UnknownValue(metric_source::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MetricSource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::MonitoringAgentDefaults => serializer.serialize_i32(1),
                Self::Hdfs => serializer.serialize_i32(2),
                Self::Spark => serializer.serialize_i32(3),
                Self::Yarn => serializer.serialize_i32(4),
                Self::SparkHistoryServer => serializer.serialize_i32(5),
                Self::Hiveserver2 => serializer.serialize_i32(6),
                Self::Hivemetastore => serializer.serialize_i32(7),
                Self::Flink => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MetricSource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MetricSource>::new(
                ".google.cloud.dataproc.v1.DataprocMetricConfig.MetricSource",
            ))
        }
    }
}

/// A request to create a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateClusterRequest {
    /// Required. The ID of the Google Cloud Platform project that the cluster
    /// belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// Required. The cluster to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two
    /// [CreateClusterRequest](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.CreateClusterRequest)s
    /// with the same id, then the second request will be ignored and the
    /// first [google.longrunning.Operation][google.longrunning.Operation] created
    /// and stored in the backend is returned.
    ///
    /// It is recommended to always set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    ///
    /// [google.longrunning.Operation]: longrunning::model::Operation
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. Failure action when primary worker creation fails.
    pub action_on_failed_primary_workers: crate::model::FailureAction,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::CreateClusterRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::CreateClusterRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_cluster<T: std::convert::Into<std::option::Option<crate::model::Cluster>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [action_on_failed_primary_workers][crate::model::CreateClusterRequest::action_on_failed_primary_workers].
    pub fn set_action_on_failed_primary_workers<
        T: std::convert::Into<crate::model::FailureAction>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action_on_failed_primary_workers = v.into();
        self
    }
}

impl wkt::message::Message for CreateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.CreateClusterRequest"
    }
}

/// A request to update a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateClusterRequest {
    /// Required. The ID of the Google Cloud Platform project the
    /// cluster belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// Required. The cluster name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_name: std::string::String,

    /// Required. The changes to the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Optional. Timeout for graceful YARN decommissioning. Graceful
    /// decommissioning allows removing nodes from the cluster without
    /// interrupting jobs in progress. Timeout specifies how long to wait for jobs
    /// in progress to finish before forcefully removing nodes (and potentially
    /// interrupting jobs). Default timeout is 0 (for forceful decommission), and
    /// the maximum allowed timeout is 1 day. (see JSON representation of
    /// [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json)).
    ///
    /// Only supported on Dataproc image versions 1.2 and higher.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub graceful_decommission_timeout: std::option::Option<wkt::Duration>,

    /// Required. Specifies the path, relative to `Cluster`, of
    /// the field to update. For example, to change the number of workers
    /// in a cluster to 5, the `update_mask` parameter would be
    /// specified as `config.worker_config.num_instances`,
    /// and the `PATCH` request body would specify the new value, as follows:
    ///
    /// ```norust
    /// {
    ///   "config":{
    ///     "workerConfig":{
    ///       "numInstances":"5"
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// Similarly, to change the number of preemptible workers in a cluster to 5,
    /// the `update_mask` parameter would be
    /// `config.secondary_worker_config.num_instances`, and the `PATCH` request
    /// body would be set as follows:
    ///
    /// ```norust
    /// {
    ///   "config":{
    ///     "secondaryWorkerConfig":{
    ///       "numInstances":"5"
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// \<strong\>Note:\</strong\> Currently, only the following fields can be updated:
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. A unique ID used to identify the request. If the server
    /// receives two
    /// [UpdateClusterRequest](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.UpdateClusterRequest)s
    /// with the same id, then the second request will be ignored and the
    /// first [google.longrunning.Operation][google.longrunning.Operation] created
    /// and stored in the backend is returned.
    ///
    /// It is recommended to always set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    ///
    /// [google.longrunning.Operation]: longrunning::model::Operation
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::UpdateClusterRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::UpdateClusterRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::UpdateClusterRequest::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::UpdateClusterRequest::cluster].
    pub fn set_cluster<T: std::convert::Into<std::option::Option<crate::model::Cluster>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [graceful_decommission_timeout][crate::model::UpdateClusterRequest::graceful_decommission_timeout].
    pub fn set_graceful_decommission_timeout<
        T: std::convert::Into<std::option::Option<wkt::Duration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.graceful_decommission_timeout = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateClusterRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.UpdateClusterRequest"
    }
}

/// A request to stop a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopClusterRequest {
    /// Required. The ID of the Google Cloud Platform project the
    /// cluster belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// Required. The cluster name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_name: std::string::String,

    /// Optional. Specifying the `cluster_uuid` means the RPC will fail
    /// (with error NOT_FOUND) if a cluster with the specified UUID does not exist.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_uuid: std::string::String,

    /// Optional. A unique ID used to identify the request. If the server
    /// receives two
    /// [StopClusterRequest](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.StopClusterRequest)s
    /// with the same id, then the second request will be ignored and the
    /// first [google.longrunning.Operation][google.longrunning.Operation] created
    /// and stored in the backend is returned.
    ///
    /// Recommendation: Set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    ///
    /// [google.longrunning.Operation]: longrunning::model::Operation
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::StopClusterRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::StopClusterRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::StopClusterRequest::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [cluster_uuid][crate::model::StopClusterRequest::cluster_uuid].
    pub fn set_cluster_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uuid = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::StopClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for StopClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.StopClusterRequest"
    }
}

/// A request to start a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartClusterRequest {
    /// Required. The ID of the Google Cloud Platform project the
    /// cluster belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// Required. The cluster name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_name: std::string::String,

    /// Optional. Specifying the `cluster_uuid` means the RPC will fail
    /// (with error NOT_FOUND) if a cluster with the specified UUID does not exist.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_uuid: std::string::String,

    /// Optional. A unique ID used to identify the request. If the server
    /// receives two
    /// [StartClusterRequest](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.StartClusterRequest)s
    /// with the same id, then the second request will be ignored and the
    /// first [google.longrunning.Operation][google.longrunning.Operation] created
    /// and stored in the backend is returned.
    ///
    /// Recommendation: Set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    ///
    /// [google.longrunning.Operation]: longrunning::model::Operation
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::StartClusterRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::StartClusterRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::StartClusterRequest::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [cluster_uuid][crate::model::StartClusterRequest::cluster_uuid].
    pub fn set_cluster_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uuid = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::StartClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for StartClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.StartClusterRequest"
    }
}

/// A request to delete a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteClusterRequest {
    /// Required. The ID of the Google Cloud Platform project that the cluster
    /// belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// Required. The cluster name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_name: std::string::String,

    /// Optional. Specifying the `cluster_uuid` means the RPC should fail
    /// (with error NOT_FOUND) if cluster with specified UUID does not exist.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_uuid: std::string::String,

    /// Optional. A unique ID used to identify the request. If the server
    /// receives two
    /// [DeleteClusterRequest](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.DeleteClusterRequest)s
    /// with the same id, then the second request will be ignored and the
    /// first [google.longrunning.Operation][google.longrunning.Operation] created
    /// and stored in the backend is returned.
    ///
    /// It is recommended to always set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    ///
    /// [google.longrunning.Operation]: longrunning::model::Operation
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DeleteClusterRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::DeleteClusterRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::DeleteClusterRequest::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [cluster_uuid][crate::model::DeleteClusterRequest::cluster_uuid].
    pub fn set_cluster_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uuid = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DeleteClusterRequest"
    }
}

/// Request to get the resource representation for a cluster in a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetClusterRequest {
    /// Required. The ID of the Google Cloud Platform project that the cluster
    /// belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// Required. The cluster name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetClusterRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::GetClusterRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::GetClusterRequest::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }
}

impl wkt::message::Message for GetClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GetClusterRequest"
    }
}

/// A request to list the clusters in a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListClustersRequest {
    /// Required. The ID of the Google Cloud Platform project that the cluster
    /// belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// Optional. A filter constraining the clusters to list. Filters are
    /// case-sensitive and have the following syntax:
    ///
    /// field = value [AND [field = value]] ...
    ///
    /// where **field** is one of `status.state`, `clusterName`, or `labels.[KEY]`,
    /// and `[KEY]` is a label key. **value** can be `*` to match all values.
    /// `status.state` can be one of the following: `ACTIVE`, `INACTIVE`,
    /// `CREATING`, `RUNNING`, `ERROR`, `DELETING`, `UPDATING`, `STOPPING`, or
    /// `STOPPED`. `ACTIVE` contains the `CREATING`, `UPDATING`, and `RUNNING`
    /// states. `INACTIVE` contains the `DELETING`, `ERROR`, `STOPPING`, and
    /// `STOPPED` states. `clusterName` is the name of the cluster provided at
    /// creation time. Only the logical `AND` operator is supported;
    /// space-separated items are treated as having an implicit `AND` operator.
    ///
    /// Example filter:
    ///
    /// status.state = ACTIVE AND clusterName = mycluster
    /// AND labels.env = staging AND labels.starred = *
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. The standard List page size.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The standard List page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListClustersRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::ListClustersRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListClustersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListClustersRequest"
    }
}

/// The list of all clusters in a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListClustersResponse {
    /// Output only. The clusters in the project.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub clusters: std::vec::Vec<crate::model::Cluster>,

    /// Output only. This token is included in the response if there are more
    /// results to fetch. To fetch additional results, provide this value as the
    /// `page_token` in a subsequent `ListClustersRequest`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [clusters][crate::model::ListClustersResponse::clusters].
    pub fn set_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Cluster>,
    {
        use std::iter::Iterator;
        self.clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListClustersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListClustersResponse {
    type PageItem = crate::model::Cluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.clusters
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A request to collect cluster diagnostic information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiagnoseClusterRequest {
    /// Required. The ID of the Google Cloud Platform project that the cluster
    /// belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// Required. The cluster name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_name: std::string::String,

    /// Optional. (Optional) The output Cloud Storage directory for the diagnostic
    /// tarball. If not specified, a task-specific directory in the cluster's
    /// staging bucket will be used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tarball_gcs_dir: std::string::String,

    /// Optional. (Optional) The access type to the diagnostic tarball. If not
    /// specified, falls back to default access of the bucket
    pub tarball_access: crate::model::diagnose_cluster_request::TarballAccess,

    /// Optional. Time interval in which diagnosis should be carried out on the
    /// cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub diagnosis_interval: std::option::Option<gtype::model::Interval>,

    /// Optional. Specifies a list of jobs on which diagnosis is to be performed.
    /// Format: projects/{project}/regions/{region}/jobs/{job}
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jobs: std::vec::Vec<std::string::String>,

    /// Optional. Specifies a list of yarn applications on which diagnosis is to be
    /// performed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub yarn_application_ids: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiagnoseClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DiagnoseClusterRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::DiagnoseClusterRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::DiagnoseClusterRequest::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [tarball_gcs_dir][crate::model::DiagnoseClusterRequest::tarball_gcs_dir].
    pub fn set_tarball_gcs_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tarball_gcs_dir = v.into();
        self
    }

    /// Sets the value of [tarball_access][crate::model::DiagnoseClusterRequest::tarball_access].
    pub fn set_tarball_access<
        T: std::convert::Into<crate::model::diagnose_cluster_request::TarballAccess>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tarball_access = v.into();
        self
    }

    /// Sets the value of [diagnosis_interval][crate::model::DiagnoseClusterRequest::diagnosis_interval].
    pub fn set_diagnosis_interval<
        T: std::convert::Into<std::option::Option<gtype::model::Interval>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.diagnosis_interval = v.into();
        self
    }

    /// Sets the value of [jobs][crate::model::DiagnoseClusterRequest::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [yarn_application_ids][crate::model::DiagnoseClusterRequest::yarn_application_ids].
    pub fn set_yarn_application_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.yarn_application_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DiagnoseClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DiagnoseClusterRequest"
    }
}

/// Defines additional types related to [DiagnoseClusterRequest].
pub mod diagnose_cluster_request {
    #[allow(unused_imports)]
    use super::*;

    /// Defines who has access to the diagnostic tarball
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TarballAccess {
        /// Tarball Access unspecified. Falls back to default access of the bucket
        Unspecified,
        /// Google Cloud Support group has read access to the
        /// diagnostic tarball
        GoogleCloudSupport,
        /// Google Cloud Dataproc Diagnose service account has read access to the
        /// diagnostic tarball
        GoogleDataprocDiagnose,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TarballAccess::value] or
        /// [TarballAccess::name].
        UnknownValue(tarball_access::UnknownValue),
    }

    #[doc(hidden)]
    pub mod tarball_access {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TarballAccess {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GoogleCloudSupport => std::option::Option::Some(1),
                Self::GoogleDataprocDiagnose => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TARBALL_ACCESS_UNSPECIFIED"),
                Self::GoogleCloudSupport => std::option::Option::Some("GOOGLE_CLOUD_SUPPORT"),
                Self::GoogleDataprocDiagnose => {
                    std::option::Option::Some("GOOGLE_DATAPROC_DIAGNOSE")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TarballAccess {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TarballAccess {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TarballAccess {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GoogleCloudSupport,
                2 => Self::GoogleDataprocDiagnose,
                _ => Self::UnknownValue(tarball_access::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TarballAccess {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TARBALL_ACCESS_UNSPECIFIED" => Self::Unspecified,
                "GOOGLE_CLOUD_SUPPORT" => Self::GoogleCloudSupport,
                "GOOGLE_DATAPROC_DIAGNOSE" => Self::GoogleDataprocDiagnose,
                _ => Self::UnknownValue(tarball_access::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TarballAccess {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GoogleCloudSupport => serializer.serialize_i32(1),
                Self::GoogleDataprocDiagnose => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TarballAccess {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TarballAccess>::new(
                ".google.cloud.dataproc.v1.DiagnoseClusterRequest.TarballAccess",
            ))
        }
    }
}

/// The location of diagnostic output.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiagnoseClusterResults {
    /// Output only. The Cloud Storage URI of the diagnostic output.
    /// The output report is a plain text file with a summary of collected
    /// diagnostics.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiagnoseClusterResults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_uri][crate::model::DiagnoseClusterResults::output_uri].
    pub fn set_output_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output_uri = v.into();
        self
    }
}

impl wkt::message::Message for DiagnoseClusterResults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DiagnoseClusterResults"
    }
}

/// Reservation Affinity for consuming Zonal reservation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReservationAffinity {
    /// Optional. Type of reservation to consume
    pub consume_reservation_type: crate::model::reservation_affinity::Type,

    /// Optional. Corresponds to the label key of reservation resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key: std::string::String,

    /// Optional. Corresponds to the label values of reservation resource.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReservationAffinity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [consume_reservation_type][crate::model::ReservationAffinity::consume_reservation_type].
    pub fn set_consume_reservation_type<
        T: std::convert::Into<crate::model::reservation_affinity::Type>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.consume_reservation_type = v.into();
        self
    }

    /// Sets the value of [key][crate::model::ReservationAffinity::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [values][crate::model::ReservationAffinity::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReservationAffinity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ReservationAffinity"
    }
}

/// Defines additional types related to [ReservationAffinity].
pub mod reservation_affinity {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates whether to consume capacity from an reservation or not.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        Unspecified,
        /// Do not consume from any allocated capacity.
        NoReservation,
        /// Consume any reservation available.
        AnyReservation,
        /// Must consume from a specific reservation. Must specify key value fields
        /// for specifying the reservations.
        SpecificReservation,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NoReservation => std::option::Option::Some(1),
                Self::AnyReservation => std::option::Option::Some(2),
                Self::SpecificReservation => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::NoReservation => std::option::Option::Some("NO_RESERVATION"),
                Self::AnyReservation => std::option::Option::Some("ANY_RESERVATION"),
                Self::SpecificReservation => std::option::Option::Some("SPECIFIC_RESERVATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NoReservation,
                2 => Self::AnyReservation,
                3 => Self::SpecificReservation,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "NO_RESERVATION" => Self::NoReservation,
                "ANY_RESERVATION" => Self::AnyReservation,
                "SPECIFIC_RESERVATION" => Self::SpecificReservation,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NoReservation => serializer.serialize_i32(1),
                Self::AnyReservation => serializer.serialize_i32(2),
                Self::SpecificReservation => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.dataproc.v1.ReservationAffinity.Type",
            ))
        }
    }
}

/// The runtime logging config of the job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LoggingConfig {
    /// The per-package log levels for the driver. This can include
    /// "root" package name to configure rootLogger.
    /// Examples:
    ///
    /// - 'com.google = FATAL'
    /// - 'root = INFO'
    /// - 'org.apache = DEBUG'
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub driver_log_levels:
        std::collections::HashMap<std::string::String, crate::model::logging_config::Level>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LoggingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [driver_log_levels][crate::model::LoggingConfig::driver_log_levels].
    pub fn set_driver_log_levels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::logging_config::Level>,
    {
        use std::iter::Iterator;
        self.driver_log_levels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for LoggingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.LoggingConfig"
    }
}

/// Defines additional types related to [LoggingConfig].
pub mod logging_config {
    #[allow(unused_imports)]
    use super::*;

    /// The Log4j level for job execution. When running an
    /// [Apache Hive](https://hive.apache.org/) job, Cloud
    /// Dataproc configures the Hive client to an equivalent verbosity level.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Level {
        /// Level is unspecified. Use default level for log4j.
        Unspecified,
        /// Use ALL level for log4j.
        All,
        /// Use TRACE level for log4j.
        Trace,
        /// Use DEBUG level for log4j.
        Debug,
        /// Use INFO level for log4j.
        Info,
        /// Use WARN level for log4j.
        Warn,
        /// Use ERROR level for log4j.
        Error,
        /// Use FATAL level for log4j.
        Fatal,
        /// Turn off log4j.
        Off,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Level::value] or
        /// [Level::name].
        UnknownValue(level::UnknownValue),
    }

    #[doc(hidden)]
    pub mod level {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Level {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::All => std::option::Option::Some(1),
                Self::Trace => std::option::Option::Some(2),
                Self::Debug => std::option::Option::Some(3),
                Self::Info => std::option::Option::Some(4),
                Self::Warn => std::option::Option::Some(5),
                Self::Error => std::option::Option::Some(6),
                Self::Fatal => std::option::Option::Some(7),
                Self::Off => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LEVEL_UNSPECIFIED"),
                Self::All => std::option::Option::Some("ALL"),
                Self::Trace => std::option::Option::Some("TRACE"),
                Self::Debug => std::option::Option::Some("DEBUG"),
                Self::Info => std::option::Option::Some("INFO"),
                Self::Warn => std::option::Option::Some("WARN"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Fatal => std::option::Option::Some("FATAL"),
                Self::Off => std::option::Option::Some("OFF"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Level {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Level {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Level {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::All,
                2 => Self::Trace,
                3 => Self::Debug,
                4 => Self::Info,
                5 => Self::Warn,
                6 => Self::Error,
                7 => Self::Fatal,
                8 => Self::Off,
                _ => Self::UnknownValue(level::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Level {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LEVEL_UNSPECIFIED" => Self::Unspecified,
                "ALL" => Self::All,
                "TRACE" => Self::Trace,
                "DEBUG" => Self::Debug,
                "INFO" => Self::Info,
                "WARN" => Self::Warn,
                "ERROR" => Self::Error,
                "FATAL" => Self::Fatal,
                "OFF" => Self::Off,
                _ => Self::UnknownValue(level::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Level {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::All => serializer.serialize_i32(1),
                Self::Trace => serializer.serialize_i32(2),
                Self::Debug => serializer.serialize_i32(3),
                Self::Info => serializer.serialize_i32(4),
                Self::Warn => serializer.serialize_i32(5),
                Self::Error => serializer.serialize_i32(6),
                Self::Fatal => serializer.serialize_i32(7),
                Self::Off => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Level {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Level>::new(
                ".google.cloud.dataproc.v1.LoggingConfig.Level",
            ))
        }
    }
}

/// A Dataproc job for running
/// [Apache Hadoop
/// MapReduce](https://hadoop.apache.org/docs/current/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html)
/// jobs on [Apache Hadoop
/// YARN](https://hadoop.apache.org/docs/r2.7.1/hadoop-yarn/hadoop-yarn-site/YARN.html).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HadoopJob {
    /// Optional. The arguments to pass to the driver. Do not
    /// include arguments, such as `-libjars` or `-Dfoo=bar`, that can be set as
    /// job properties, since a collision might occur that causes an incorrect job
    /// submission.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub args: std::vec::Vec<std::string::String>,

    /// Optional. Jar file URIs to add to the CLASSPATHs of the
    /// Hadoop driver and tasks.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jar_file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS (Hadoop Compatible Filesystem) URIs of files to be copied
    /// to the working directory of Hadoop drivers and distributed tasks. Useful
    /// for naively parallel tasks.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of archives to be extracted in the working directory of
    /// Hadoop drivers and tasks. Supported file types:
    /// .jar, .tar, .tar.gz, .tgz, or .zip.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub archive_uris: std::vec::Vec<std::string::String>,

    /// Optional. A mapping of property names to values, used to configure Hadoop.
    /// Properties that conflict with values set by the Dataproc API might be
    /// overwritten. Can include properties set in `/etc/hadoop/conf/*-site` and
    /// classes in user code.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The runtime log config for job execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Required. Indicates the location of the driver's main class. Specify
    /// either the jar file that contains the main class or the main class name.
    /// To specify both, add the jar file to `jar_file_uris`, and then specify
    /// the main class name in this property.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub driver: std::option::Option<crate::model::hadoop_job::Driver>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HadoopJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [args][crate::model::HadoopJob::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [jar_file_uris][crate::model::HadoopJob::jar_file_uris].
    pub fn set_jar_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jar_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_uris][crate::model::HadoopJob::file_uris].
    pub fn set_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [archive_uris][crate::model::HadoopJob::archive_uris].
    pub fn set_archive_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.archive_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [properties][crate::model::HadoopJob::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [logging_config][crate::model::HadoopJob::logging_config].
    pub fn set_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::LoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logging_config = v.into();
        self
    }

    /// Sets the value of [driver][crate::model::HadoopJob::driver].
    ///
    /// Note that all the setters affecting `driver` are mutually
    /// exclusive.
    pub fn set_driver<
        T: std::convert::Into<std::option::Option<crate::model::hadoop_job::Driver>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.driver = v.into();
        self
    }

    /// The value of [driver][crate::model::HadoopJob::driver]
    /// if it holds a `MainJarFileUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn main_jar_file_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.driver.as_ref().and_then(|v| match v {
            crate::model::hadoop_job::Driver::MainJarFileUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [driver][crate::model::HadoopJob::driver]
    /// to hold a `MainJarFileUri`.
    ///
    /// Note that all the setters affecting `driver` are
    /// mutually exclusive.
    pub fn set_main_jar_file_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.driver =
            std::option::Option::Some(crate::model::hadoop_job::Driver::MainJarFileUri(v.into()));
        self
    }

    /// The value of [driver][crate::model::HadoopJob::driver]
    /// if it holds a `MainClass`, `None` if the field is not set or
    /// holds a different branch.
    pub fn main_class(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.driver.as_ref().and_then(|v| match v {
            crate::model::hadoop_job::Driver::MainClass(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [driver][crate::model::HadoopJob::driver]
    /// to hold a `MainClass`.
    ///
    /// Note that all the setters affecting `driver` are
    /// mutually exclusive.
    pub fn set_main_class<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.driver =
            std::option::Option::Some(crate::model::hadoop_job::Driver::MainClass(v.into()));
        self
    }
}

impl wkt::message::Message for HadoopJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.HadoopJob"
    }
}

/// Defines additional types related to [HadoopJob].
pub mod hadoop_job {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Indicates the location of the driver's main class. Specify
    /// either the jar file that contains the main class or the main class name.
    /// To specify both, add the jar file to `jar_file_uris`, and then specify
    /// the main class name in this property.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Driver {
        /// The HCFS URI of the jar file containing the main class.
        /// Examples:
        /// 'gs://foo-bucket/analytics-binaries/extract-useful-metrics-mr.jar'
        /// 'hdfs:/tmp/test-samples/custom-wordcount.jar'
        /// 'file:///home/usr/lib/hadoop-mapreduce/hadoop-mapreduce-examples.jar'
        MainJarFileUri(std::string::String),
        /// The name of the driver's main class. The jar file containing the class
        /// must be in the default CLASSPATH or specified in `jar_file_uris`.
        MainClass(std::string::String),
    }
}

/// A Dataproc job for running [Apache Spark](https://spark.apache.org/)
/// applications on YARN.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SparkJob {
    /// Optional. The arguments to pass to the driver. Do not include arguments,
    /// such as `--conf`, that can be set as job properties, since a collision may
    /// occur that causes an incorrect job submission.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub args: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of jar files to add to the CLASSPATHs of the
    /// Spark driver and tasks.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jar_file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of files to be placed in the working directory of
    /// each executor. Useful for naively parallel tasks.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of archives to be extracted into the working directory
    /// of each executor. Supported file types:
    /// .jar, .tar, .tar.gz, .tgz, and .zip.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub archive_uris: std::vec::Vec<std::string::String>,

    /// Optional. A mapping of property names to values, used to configure Spark.
    /// Properties that conflict with values set by the Dataproc API might be
    /// overwritten. Can include properties set in
    /// /etc/spark/conf/spark-defaults.conf and classes in user code.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The runtime log config for job execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Required. The specification of the main method to call to drive the job.
    /// Specify either the jar file that contains the main class or the main class
    /// name. To pass both a main jar and a main class in that jar, add the jar to
    /// [jarFileUris][google.cloud.dataproc.v1.SparkJob.jar_file_uris], and then
    /// specify the main class name in
    /// [mainClass][google.cloud.dataproc.v1.SparkJob.main_class].
    ///
    /// [google.cloud.dataproc.v1.SparkJob.jar_file_uris]: crate::model::SparkJob::jar_file_uris
    /// [google.cloud.dataproc.v1.SparkJob.main_class]: crate::model::SparkJob::driver
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub driver: std::option::Option<crate::model::spark_job::Driver>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SparkJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [args][crate::model::SparkJob::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [jar_file_uris][crate::model::SparkJob::jar_file_uris].
    pub fn set_jar_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jar_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_uris][crate::model::SparkJob::file_uris].
    pub fn set_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [archive_uris][crate::model::SparkJob::archive_uris].
    pub fn set_archive_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.archive_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [properties][crate::model::SparkJob::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [logging_config][crate::model::SparkJob::logging_config].
    pub fn set_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::LoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logging_config = v.into();
        self
    }

    /// Sets the value of [driver][crate::model::SparkJob::driver].
    ///
    /// Note that all the setters affecting `driver` are mutually
    /// exclusive.
    pub fn set_driver<
        T: std::convert::Into<std::option::Option<crate::model::spark_job::Driver>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.driver = v.into();
        self
    }

    /// The value of [driver][crate::model::SparkJob::driver]
    /// if it holds a `MainJarFileUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn main_jar_file_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.driver.as_ref().and_then(|v| match v {
            crate::model::spark_job::Driver::MainJarFileUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [driver][crate::model::SparkJob::driver]
    /// to hold a `MainJarFileUri`.
    ///
    /// Note that all the setters affecting `driver` are
    /// mutually exclusive.
    pub fn set_main_jar_file_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.driver =
            std::option::Option::Some(crate::model::spark_job::Driver::MainJarFileUri(v.into()));
        self
    }

    /// The value of [driver][crate::model::SparkJob::driver]
    /// if it holds a `MainClass`, `None` if the field is not set or
    /// holds a different branch.
    pub fn main_class(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.driver.as_ref().and_then(|v| match v {
            crate::model::spark_job::Driver::MainClass(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [driver][crate::model::SparkJob::driver]
    /// to hold a `MainClass`.
    ///
    /// Note that all the setters affecting `driver` are
    /// mutually exclusive.
    pub fn set_main_class<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.driver =
            std::option::Option::Some(crate::model::spark_job::Driver::MainClass(v.into()));
        self
    }
}

impl wkt::message::Message for SparkJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SparkJob"
    }
}

/// Defines additional types related to [SparkJob].
pub mod spark_job {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The specification of the main method to call to drive the job.
    /// Specify either the jar file that contains the main class or the main class
    /// name. To pass both a main jar and a main class in that jar, add the jar to
    /// [jarFileUris][google.cloud.dataproc.v1.SparkJob.jar_file_uris], and then
    /// specify the main class name in
    /// [mainClass][google.cloud.dataproc.v1.SparkJob.main_class].
    ///
    /// [google.cloud.dataproc.v1.SparkJob.jar_file_uris]: crate::model::SparkJob::jar_file_uris
    /// [google.cloud.dataproc.v1.SparkJob.main_class]: crate::model::SparkJob::driver
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Driver {
        /// The HCFS URI of the jar file that contains the main class.
        MainJarFileUri(std::string::String),
        /// The name of the driver's main class. The jar file that contains the class
        /// must be in the default CLASSPATH or specified in
        /// SparkJob.jar_file_uris.
        MainClass(std::string::String),
    }
}

/// A Dataproc job for running
/// [Apache
/// PySpark](https://spark.apache.org/docs/0.9.0/python-programming-guide.html)
/// applications on YARN.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PySparkJob {
    /// Required. The HCFS URI of the main Python file to use as the driver. Must
    /// be a .py file.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub main_python_file_uri: std::string::String,

    /// Optional. The arguments to pass to the driver.  Do not include arguments,
    /// such as `--conf`, that can be set as job properties, since a collision may
    /// occur that causes an incorrect job submission.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub args: std::vec::Vec<std::string::String>,

    /// Optional. HCFS file URIs of Python files to pass to the PySpark
    /// framework. Supported file types: .py, .egg, and .zip.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub python_file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of jar files to add to the CLASSPATHs of the
    /// Python driver and tasks.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jar_file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of files to be placed in the working directory of
    /// each executor. Useful for naively parallel tasks.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of archives to be extracted into the working directory
    /// of each executor. Supported file types:
    /// .jar, .tar, .tar.gz, .tgz, and .zip.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub archive_uris: std::vec::Vec<std::string::String>,

    /// Optional. A mapping of property names to values, used to configure PySpark.
    /// Properties that conflict with values set by the Dataproc API might be
    /// overwritten. Can include properties set in
    /// /etc/spark/conf/spark-defaults.conf and classes in user code.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The runtime log config for job execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PySparkJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [main_python_file_uri][crate::model::PySparkJob::main_python_file_uri].
    pub fn set_main_python_file_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.main_python_file_uri = v.into();
        self
    }

    /// Sets the value of [args][crate::model::PySparkJob::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [python_file_uris][crate::model::PySparkJob::python_file_uris].
    pub fn set_python_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.python_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [jar_file_uris][crate::model::PySparkJob::jar_file_uris].
    pub fn set_jar_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jar_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_uris][crate::model::PySparkJob::file_uris].
    pub fn set_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [archive_uris][crate::model::PySparkJob::archive_uris].
    pub fn set_archive_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.archive_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [properties][crate::model::PySparkJob::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [logging_config][crate::model::PySparkJob::logging_config].
    pub fn set_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::LoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logging_config = v.into();
        self
    }
}

impl wkt::message::Message for PySparkJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.PySparkJob"
    }
}

/// A list of queries to run on a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QueryList {
    /// Required. The queries to execute. You do not need to end a query expression
    /// with a semicolon. Multiple queries can be specified in one
    /// string by separating each with a semicolon. Here is an example of a
    /// Dataproc API snippet that uses a QueryList to specify a HiveJob:
    ///
    /// ```norust
    /// "hiveJob": {
    ///   "queryList": {
    ///     "queries": [
    ///       "query1",
    ///       "query2",
    ///       "query3;query4",
    ///     ]
    ///   }
    /// }
    /// ```
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub queries: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [queries][crate::model::QueryList::queries].
    pub fn set_queries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.queries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for QueryList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.QueryList"
    }
}

/// A Dataproc job for running [Apache Hive](https://hive.apache.org/)
/// queries on YARN.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HiveJob {
    /// Optional. Whether to continue executing queries if a query fails.
    /// The default value is `false`. Setting to `true` can be useful when
    /// executing independent parallel queries.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub continue_on_failure: bool,

    /// Optional. Mapping of query variable names to values (equivalent to the
    /// Hive command: `SET name="value";`).
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub script_variables: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. A mapping of property names and values, used to configure Hive.
    /// Properties that conflict with values set by the Dataproc API might be
    /// overwritten. Can include properties set in `/etc/hadoop/conf/*-site.xml`,
    /// /etc/hive/conf/hive-site.xml, and classes in user code.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. HCFS URIs of jar files to add to the CLASSPATH of the
    /// Hive server and Hadoop MapReduce (MR) tasks. Can contain Hive SerDes
    /// and UDFs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jar_file_uris: std::vec::Vec<std::string::String>,

    /// Required. The sequence of Hive queries to execute, specified as either
    /// an HCFS file URI or a list of queries.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub queries: std::option::Option<crate::model::hive_job::Queries>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HiveJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [continue_on_failure][crate::model::HiveJob::continue_on_failure].
    pub fn set_continue_on_failure<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.continue_on_failure = v.into();
        self
    }

    /// Sets the value of [script_variables][crate::model::HiveJob::script_variables].
    pub fn set_script_variables<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.script_variables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [properties][crate::model::HiveJob::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [jar_file_uris][crate::model::HiveJob::jar_file_uris].
    pub fn set_jar_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jar_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [queries][crate::model::HiveJob::queries].
    ///
    /// Note that all the setters affecting `queries` are mutually
    /// exclusive.
    pub fn set_queries<
        T: std::convert::Into<std::option::Option<crate::model::hive_job::Queries>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.queries = v.into();
        self
    }

    /// The value of [queries][crate::model::HiveJob::queries]
    /// if it holds a `QueryFileUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query_file_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.queries.as_ref().and_then(|v| match v {
            crate::model::hive_job::Queries::QueryFileUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [queries][crate::model::HiveJob::queries]
    /// to hold a `QueryFileUri`.
    ///
    /// Note that all the setters affecting `queries` are
    /// mutually exclusive.
    pub fn set_query_file_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.queries =
            std::option::Option::Some(crate::model::hive_job::Queries::QueryFileUri(v.into()));
        self
    }

    /// The value of [queries][crate::model::HiveJob::queries]
    /// if it holds a `QueryList`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query_list(&self) -> std::option::Option<&std::boxed::Box<crate::model::QueryList>> {
        #[allow(unreachable_patterns)]
        self.queries.as_ref().and_then(|v| match v {
            crate::model::hive_job::Queries::QueryList(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [queries][crate::model::HiveJob::queries]
    /// to hold a `QueryList`.
    ///
    /// Note that all the setters affecting `queries` are
    /// mutually exclusive.
    pub fn set_query_list<T: std::convert::Into<std::boxed::Box<crate::model::QueryList>>>(
        mut self,
        v: T,
    ) -> Self {
        self.queries =
            std::option::Option::Some(crate::model::hive_job::Queries::QueryList(v.into()));
        self
    }
}

impl wkt::message::Message for HiveJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.HiveJob"
    }
}

/// Defines additional types related to [HiveJob].
pub mod hive_job {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The sequence of Hive queries to execute, specified as either
    /// an HCFS file URI or a list of queries.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Queries {
        /// The HCFS URI of the script that contains Hive queries.
        QueryFileUri(std::string::String),
        /// A list of queries.
        QueryList(std::boxed::Box<crate::model::QueryList>),
    }
}

/// A Dataproc job for running [Apache Spark
/// SQL](https://spark.apache.org/sql/) queries.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SparkSqlJob {
    /// Optional. Mapping of query variable names to values (equivalent to the
    /// Spark SQL command: SET `name="value";`).
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub script_variables: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. A mapping of property names to values, used to configure
    /// Spark SQL's SparkConf. Properties that conflict with values set by the
    /// Dataproc API might be overwritten.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. HCFS URIs of jar files to be added to the Spark CLASSPATH.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jar_file_uris: std::vec::Vec<std::string::String>,

    /// Optional. The runtime log config for job execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Required. The sequence of Spark SQL queries to execute, specified as
    /// either an HCFS file URI or as a list of queries.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub queries: std::option::Option<crate::model::spark_sql_job::Queries>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SparkSqlJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [script_variables][crate::model::SparkSqlJob::script_variables].
    pub fn set_script_variables<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.script_variables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [properties][crate::model::SparkSqlJob::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [jar_file_uris][crate::model::SparkSqlJob::jar_file_uris].
    pub fn set_jar_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jar_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [logging_config][crate::model::SparkSqlJob::logging_config].
    pub fn set_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::LoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logging_config = v.into();
        self
    }

    /// Sets the value of [queries][crate::model::SparkSqlJob::queries].
    ///
    /// Note that all the setters affecting `queries` are mutually
    /// exclusive.
    pub fn set_queries<
        T: std::convert::Into<std::option::Option<crate::model::spark_sql_job::Queries>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.queries = v.into();
        self
    }

    /// The value of [queries][crate::model::SparkSqlJob::queries]
    /// if it holds a `QueryFileUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query_file_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.queries.as_ref().and_then(|v| match v {
            crate::model::spark_sql_job::Queries::QueryFileUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [queries][crate::model::SparkSqlJob::queries]
    /// to hold a `QueryFileUri`.
    ///
    /// Note that all the setters affecting `queries` are
    /// mutually exclusive.
    pub fn set_query_file_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.queries =
            std::option::Option::Some(crate::model::spark_sql_job::Queries::QueryFileUri(v.into()));
        self
    }

    /// The value of [queries][crate::model::SparkSqlJob::queries]
    /// if it holds a `QueryList`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query_list(&self) -> std::option::Option<&std::boxed::Box<crate::model::QueryList>> {
        #[allow(unreachable_patterns)]
        self.queries.as_ref().and_then(|v| match v {
            crate::model::spark_sql_job::Queries::QueryList(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [queries][crate::model::SparkSqlJob::queries]
    /// to hold a `QueryList`.
    ///
    /// Note that all the setters affecting `queries` are
    /// mutually exclusive.
    pub fn set_query_list<T: std::convert::Into<std::boxed::Box<crate::model::QueryList>>>(
        mut self,
        v: T,
    ) -> Self {
        self.queries =
            std::option::Option::Some(crate::model::spark_sql_job::Queries::QueryList(v.into()));
        self
    }
}

impl wkt::message::Message for SparkSqlJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SparkSqlJob"
    }
}

/// Defines additional types related to [SparkSqlJob].
pub mod spark_sql_job {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The sequence of Spark SQL queries to execute, specified as
    /// either an HCFS file URI or as a list of queries.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Queries {
        /// The HCFS URI of the script that contains SQL queries.
        QueryFileUri(std::string::String),
        /// A list of queries.
        QueryList(std::boxed::Box<crate::model::QueryList>),
    }
}

/// A Dataproc job for running [Apache Pig](https://pig.apache.org/)
/// queries on YARN.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PigJob {
    /// Optional. Whether to continue executing queries if a query fails.
    /// The default value is `false`. Setting to `true` can be useful when
    /// executing independent parallel queries.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub continue_on_failure: bool,

    /// Optional. Mapping of query variable names to values (equivalent to the Pig
    /// command: `name=[value]`).
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub script_variables: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. A mapping of property names to values, used to configure Pig.
    /// Properties that conflict with values set by the Dataproc API might be
    /// overwritten. Can include properties set in `/etc/hadoop/conf/*-site.xml`,
    /// /etc/pig/conf/pig.properties, and classes in user code.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. HCFS URIs of jar files to add to the CLASSPATH of
    /// the Pig Client and Hadoop MapReduce (MR) tasks. Can contain Pig UDFs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jar_file_uris: std::vec::Vec<std::string::String>,

    /// Optional. The runtime log config for job execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Required. The sequence of Pig queries to execute, specified as an HCFS
    /// file URI or a list of queries.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub queries: std::option::Option<crate::model::pig_job::Queries>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PigJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [continue_on_failure][crate::model::PigJob::continue_on_failure].
    pub fn set_continue_on_failure<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.continue_on_failure = v.into();
        self
    }

    /// Sets the value of [script_variables][crate::model::PigJob::script_variables].
    pub fn set_script_variables<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.script_variables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [properties][crate::model::PigJob::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [jar_file_uris][crate::model::PigJob::jar_file_uris].
    pub fn set_jar_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jar_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [logging_config][crate::model::PigJob::logging_config].
    pub fn set_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::LoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logging_config = v.into();
        self
    }

    /// Sets the value of [queries][crate::model::PigJob::queries].
    ///
    /// Note that all the setters affecting `queries` are mutually
    /// exclusive.
    pub fn set_queries<
        T: std::convert::Into<std::option::Option<crate::model::pig_job::Queries>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.queries = v.into();
        self
    }

    /// The value of [queries][crate::model::PigJob::queries]
    /// if it holds a `QueryFileUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query_file_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.queries.as_ref().and_then(|v| match v {
            crate::model::pig_job::Queries::QueryFileUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [queries][crate::model::PigJob::queries]
    /// to hold a `QueryFileUri`.
    ///
    /// Note that all the setters affecting `queries` are
    /// mutually exclusive.
    pub fn set_query_file_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.queries =
            std::option::Option::Some(crate::model::pig_job::Queries::QueryFileUri(v.into()));
        self
    }

    /// The value of [queries][crate::model::PigJob::queries]
    /// if it holds a `QueryList`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query_list(&self) -> std::option::Option<&std::boxed::Box<crate::model::QueryList>> {
        #[allow(unreachable_patterns)]
        self.queries.as_ref().and_then(|v| match v {
            crate::model::pig_job::Queries::QueryList(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [queries][crate::model::PigJob::queries]
    /// to hold a `QueryList`.
    ///
    /// Note that all the setters affecting `queries` are
    /// mutually exclusive.
    pub fn set_query_list<T: std::convert::Into<std::boxed::Box<crate::model::QueryList>>>(
        mut self,
        v: T,
    ) -> Self {
        self.queries =
            std::option::Option::Some(crate::model::pig_job::Queries::QueryList(v.into()));
        self
    }
}

impl wkt::message::Message for PigJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.PigJob"
    }
}

/// Defines additional types related to [PigJob].
pub mod pig_job {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The sequence of Pig queries to execute, specified as an HCFS
    /// file URI or a list of queries.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Queries {
        /// The HCFS URI of the script that contains the Pig queries.
        QueryFileUri(std::string::String),
        /// A list of queries.
        QueryList(std::boxed::Box<crate::model::QueryList>),
    }
}

/// A Dataproc job for running
/// [Apache SparkR](https://spark.apache.org/docs/latest/sparkr.html)
/// applications on YARN.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SparkRJob {
    /// Required. The HCFS URI of the main R file to use as the driver.
    /// Must be a .R file.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub main_r_file_uri: std::string::String,

    /// Optional. The arguments to pass to the driver.  Do not include arguments,
    /// such as `--conf`, that can be set as job properties, since a collision may
    /// occur that causes an incorrect job submission.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub args: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of files to be placed in the working directory of
    /// each executor. Useful for naively parallel tasks.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of archives to be extracted into the working directory
    /// of each executor. Supported file types:
    /// .jar, .tar, .tar.gz, .tgz, and .zip.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub archive_uris: std::vec::Vec<std::string::String>,

    /// Optional. A mapping of property names to values, used to configure SparkR.
    /// Properties that conflict with values set by the Dataproc API might be
    /// overwritten. Can include properties set in
    /// /etc/spark/conf/spark-defaults.conf and classes in user code.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The runtime log config for job execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SparkRJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [main_r_file_uri][crate::model::SparkRJob::main_r_file_uri].
    pub fn set_main_r_file_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.main_r_file_uri = v.into();
        self
    }

    /// Sets the value of [args][crate::model::SparkRJob::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [file_uris][crate::model::SparkRJob::file_uris].
    pub fn set_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [archive_uris][crate::model::SparkRJob::archive_uris].
    pub fn set_archive_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.archive_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [properties][crate::model::SparkRJob::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [logging_config][crate::model::SparkRJob::logging_config].
    pub fn set_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::LoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logging_config = v.into();
        self
    }
}

impl wkt::message::Message for SparkRJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SparkRJob"
    }
}

/// A Dataproc job for running [Presto](https://prestosql.io/) queries.
/// **IMPORTANT**: The [Dataproc Presto Optional
/// Component](https://cloud.google.com/dataproc/docs/concepts/components/presto)
/// must be enabled when the cluster is created to submit a Presto job to the
/// cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrestoJob {
    /// Optional. Whether to continue executing queries if a query fails.
    /// The default value is `false`. Setting to `true` can be useful when
    /// executing independent parallel queries.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub continue_on_failure: bool,

    /// Optional. The format in which query output will be displayed. See the
    /// Presto documentation for supported output formats
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_format: std::string::String,

    /// Optional. Presto client tags to attach to this query
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub client_tags: std::vec::Vec<std::string::String>,

    /// Optional. A mapping of property names to values. Used to set Presto
    /// [session properties](https://prestodb.io/docs/current/sql/set-session.html)
    /// Equivalent to using the --session flag in the Presto CLI
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The runtime log config for job execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Required. The sequence of Presto queries to execute, specified as
    /// either an HCFS file URI or as a list of queries.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub queries: std::option::Option<crate::model::presto_job::Queries>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrestoJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [continue_on_failure][crate::model::PrestoJob::continue_on_failure].
    pub fn set_continue_on_failure<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.continue_on_failure = v.into();
        self
    }

    /// Sets the value of [output_format][crate::model::PrestoJob::output_format].
    pub fn set_output_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output_format = v.into();
        self
    }

    /// Sets the value of [client_tags][crate::model::PrestoJob::client_tags].
    pub fn set_client_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.client_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [properties][crate::model::PrestoJob::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [logging_config][crate::model::PrestoJob::logging_config].
    pub fn set_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::LoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logging_config = v.into();
        self
    }

    /// Sets the value of [queries][crate::model::PrestoJob::queries].
    ///
    /// Note that all the setters affecting `queries` are mutually
    /// exclusive.
    pub fn set_queries<
        T: std::convert::Into<std::option::Option<crate::model::presto_job::Queries>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.queries = v.into();
        self
    }

    /// The value of [queries][crate::model::PrestoJob::queries]
    /// if it holds a `QueryFileUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query_file_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.queries.as_ref().and_then(|v| match v {
            crate::model::presto_job::Queries::QueryFileUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [queries][crate::model::PrestoJob::queries]
    /// to hold a `QueryFileUri`.
    ///
    /// Note that all the setters affecting `queries` are
    /// mutually exclusive.
    pub fn set_query_file_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.queries =
            std::option::Option::Some(crate::model::presto_job::Queries::QueryFileUri(v.into()));
        self
    }

    /// The value of [queries][crate::model::PrestoJob::queries]
    /// if it holds a `QueryList`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query_list(&self) -> std::option::Option<&std::boxed::Box<crate::model::QueryList>> {
        #[allow(unreachable_patterns)]
        self.queries.as_ref().and_then(|v| match v {
            crate::model::presto_job::Queries::QueryList(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [queries][crate::model::PrestoJob::queries]
    /// to hold a `QueryList`.
    ///
    /// Note that all the setters affecting `queries` are
    /// mutually exclusive.
    pub fn set_query_list<T: std::convert::Into<std::boxed::Box<crate::model::QueryList>>>(
        mut self,
        v: T,
    ) -> Self {
        self.queries =
            std::option::Option::Some(crate::model::presto_job::Queries::QueryList(v.into()));
        self
    }
}

impl wkt::message::Message for PrestoJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.PrestoJob"
    }
}

/// Defines additional types related to [PrestoJob].
pub mod presto_job {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The sequence of Presto queries to execute, specified as
    /// either an HCFS file URI or as a list of queries.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Queries {
        /// The HCFS URI of the script that contains SQL queries.
        QueryFileUri(std::string::String),
        /// A list of queries.
        QueryList(std::boxed::Box<crate::model::QueryList>),
    }
}

/// A Dataproc job for running [Trino](https://trino.io/) queries.
/// **IMPORTANT**: The [Dataproc Trino Optional
/// Component](https://cloud.google.com/dataproc/docs/concepts/components/trino)
/// must be enabled when the cluster is created to submit a Trino job to the
/// cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TrinoJob {
    /// Optional. Whether to continue executing queries if a query fails.
    /// The default value is `false`. Setting to `true` can be useful when
    /// executing independent parallel queries.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub continue_on_failure: bool,

    /// Optional. The format in which query output will be displayed. See the
    /// Trino documentation for supported output formats
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_format: std::string::String,

    /// Optional. Trino client tags to attach to this query
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub client_tags: std::vec::Vec<std::string::String>,

    /// Optional. A mapping of property names to values. Used to set Trino
    /// [session properties](https://trino.io/docs/current/sql/set-session.html)
    /// Equivalent to using the --session flag in the Trino CLI
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The runtime log config for job execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Required. The sequence of Trino queries to execute, specified as
    /// either an HCFS file URI or as a list of queries.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub queries: std::option::Option<crate::model::trino_job::Queries>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TrinoJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [continue_on_failure][crate::model::TrinoJob::continue_on_failure].
    pub fn set_continue_on_failure<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.continue_on_failure = v.into();
        self
    }

    /// Sets the value of [output_format][crate::model::TrinoJob::output_format].
    pub fn set_output_format<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output_format = v.into();
        self
    }

    /// Sets the value of [client_tags][crate::model::TrinoJob::client_tags].
    pub fn set_client_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.client_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [properties][crate::model::TrinoJob::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [logging_config][crate::model::TrinoJob::logging_config].
    pub fn set_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::LoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logging_config = v.into();
        self
    }

    /// Sets the value of [queries][crate::model::TrinoJob::queries].
    ///
    /// Note that all the setters affecting `queries` are mutually
    /// exclusive.
    pub fn set_queries<
        T: std::convert::Into<std::option::Option<crate::model::trino_job::Queries>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.queries = v.into();
        self
    }

    /// The value of [queries][crate::model::TrinoJob::queries]
    /// if it holds a `QueryFileUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query_file_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.queries.as_ref().and_then(|v| match v {
            crate::model::trino_job::Queries::QueryFileUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [queries][crate::model::TrinoJob::queries]
    /// to hold a `QueryFileUri`.
    ///
    /// Note that all the setters affecting `queries` are
    /// mutually exclusive.
    pub fn set_query_file_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.queries =
            std::option::Option::Some(crate::model::trino_job::Queries::QueryFileUri(v.into()));
        self
    }

    /// The value of [queries][crate::model::TrinoJob::queries]
    /// if it holds a `QueryList`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query_list(&self) -> std::option::Option<&std::boxed::Box<crate::model::QueryList>> {
        #[allow(unreachable_patterns)]
        self.queries.as_ref().and_then(|v| match v {
            crate::model::trino_job::Queries::QueryList(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [queries][crate::model::TrinoJob::queries]
    /// to hold a `QueryList`.
    ///
    /// Note that all the setters affecting `queries` are
    /// mutually exclusive.
    pub fn set_query_list<T: std::convert::Into<std::boxed::Box<crate::model::QueryList>>>(
        mut self,
        v: T,
    ) -> Self {
        self.queries =
            std::option::Option::Some(crate::model::trino_job::Queries::QueryList(v.into()));
        self
    }
}

impl wkt::message::Message for TrinoJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.TrinoJob"
    }
}

/// Defines additional types related to [TrinoJob].
pub mod trino_job {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The sequence of Trino queries to execute, specified as
    /// either an HCFS file URI or as a list of queries.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Queries {
        /// The HCFS URI of the script that contains SQL queries.
        QueryFileUri(std::string::String),
        /// A list of queries.
        QueryList(std::boxed::Box<crate::model::QueryList>),
    }
}

/// A Dataproc job for running Apache Flink applications on YARN.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FlinkJob {
    /// Optional. The arguments to pass to the driver. Do not include arguments,
    /// such as `--conf`, that can be set as job properties, since a collision
    /// might occur that causes an incorrect job submission.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub args: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URIs of jar files to add to the CLASSPATHs of the
    /// Flink driver and tasks.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jar_file_uris: std::vec::Vec<std::string::String>,

    /// Optional. HCFS URI of the savepoint, which contains the last saved progress
    /// for starting the current job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub savepoint_uri: std::string::String,

    /// Optional. A mapping of property names to values, used to configure Flink.
    /// Properties that conflict with values set by the Dataproc API might be
    /// overwritten. Can include properties set in
    /// `/etc/flink/conf/flink-defaults.conf` and classes in user code.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The runtime log config for job execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Required. The specification of the main method to call to drive the job.
    /// Specify either the jar file that contains the main class or the main class
    /// name. To pass both a main jar and a main class in the jar, add the jar to
    /// [jarFileUris][google.cloud.dataproc.v1.FlinkJob.jar_file_uris], and then
    /// specify the main class name in
    /// [mainClass][google.cloud.dataproc.v1.FlinkJob.main_class].
    ///
    /// [google.cloud.dataproc.v1.FlinkJob.jar_file_uris]: crate::model::FlinkJob::jar_file_uris
    /// [google.cloud.dataproc.v1.FlinkJob.main_class]: crate::model::FlinkJob::driver
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub driver: std::option::Option<crate::model::flink_job::Driver>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FlinkJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [args][crate::model::FlinkJob::args].
    pub fn set_args<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.args = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [jar_file_uris][crate::model::FlinkJob::jar_file_uris].
    pub fn set_jar_file_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.jar_file_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [savepoint_uri][crate::model::FlinkJob::savepoint_uri].
    pub fn set_savepoint_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.savepoint_uri = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::FlinkJob::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [logging_config][crate::model::FlinkJob::logging_config].
    pub fn set_logging_config<
        T: std::convert::Into<std::option::Option<crate::model::LoggingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.logging_config = v.into();
        self
    }

    /// Sets the value of [driver][crate::model::FlinkJob::driver].
    ///
    /// Note that all the setters affecting `driver` are mutually
    /// exclusive.
    pub fn set_driver<
        T: std::convert::Into<std::option::Option<crate::model::flink_job::Driver>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.driver = v.into();
        self
    }

    /// The value of [driver][crate::model::FlinkJob::driver]
    /// if it holds a `MainJarFileUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn main_jar_file_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.driver.as_ref().and_then(|v| match v {
            crate::model::flink_job::Driver::MainJarFileUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [driver][crate::model::FlinkJob::driver]
    /// to hold a `MainJarFileUri`.
    ///
    /// Note that all the setters affecting `driver` are
    /// mutually exclusive.
    pub fn set_main_jar_file_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.driver =
            std::option::Option::Some(crate::model::flink_job::Driver::MainJarFileUri(v.into()));
        self
    }

    /// The value of [driver][crate::model::FlinkJob::driver]
    /// if it holds a `MainClass`, `None` if the field is not set or
    /// holds a different branch.
    pub fn main_class(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.driver.as_ref().and_then(|v| match v {
            crate::model::flink_job::Driver::MainClass(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [driver][crate::model::FlinkJob::driver]
    /// to hold a `MainClass`.
    ///
    /// Note that all the setters affecting `driver` are
    /// mutually exclusive.
    pub fn set_main_class<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.driver =
            std::option::Option::Some(crate::model::flink_job::Driver::MainClass(v.into()));
        self
    }
}

impl wkt::message::Message for FlinkJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.FlinkJob"
    }
}

/// Defines additional types related to [FlinkJob].
pub mod flink_job {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The specification of the main method to call to drive the job.
    /// Specify either the jar file that contains the main class or the main class
    /// name. To pass both a main jar and a main class in the jar, add the jar to
    /// [jarFileUris][google.cloud.dataproc.v1.FlinkJob.jar_file_uris], and then
    /// specify the main class name in
    /// [mainClass][google.cloud.dataproc.v1.FlinkJob.main_class].
    ///
    /// [google.cloud.dataproc.v1.FlinkJob.jar_file_uris]: crate::model::FlinkJob::jar_file_uris
    /// [google.cloud.dataproc.v1.FlinkJob.main_class]: crate::model::FlinkJob::driver
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Driver {
        /// The HCFS URI of the jar file that contains the main class.
        MainJarFileUri(std::string::String),
        /// The name of the driver's main class. The jar file that contains the class
        /// must be in the default CLASSPATH or specified in
        /// [jarFileUris][google.cloud.dataproc.v1.FlinkJob.jar_file_uris].
        ///
        /// [google.cloud.dataproc.v1.FlinkJob.jar_file_uris]: crate::model::FlinkJob::jar_file_uris
        MainClass(std::string::String),
    }
}

/// Dataproc job config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobPlacement {
    /// Required. The name of the cluster where the job will be submitted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_name: std::string::String,

    /// Output only. A cluster UUID generated by the Dataproc service when
    /// the job is submitted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_uuid: std::string::String,

    /// Optional. Cluster labels to identify a cluster where the job will be
    /// submitted.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub cluster_labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JobPlacement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_name][crate::model::JobPlacement::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [cluster_uuid][crate::model::JobPlacement::cluster_uuid].
    pub fn set_cluster_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uuid = v.into();
        self
    }

    /// Sets the value of [cluster_labels][crate::model::JobPlacement::cluster_labels].
    pub fn set_cluster_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.cluster_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for JobPlacement {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.JobPlacement"
    }
}

/// Dataproc job status.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobStatus {
    /// Output only. A state message specifying the overall job state.
    pub state: crate::model::job_status::State,

    /// Optional. Output only. Job state details, such as an error
    /// description if the state is `ERROR`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub details: std::string::String,

    /// Output only. The time when this state was entered.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub state_start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Additional state information, which includes
    /// status reported by the agent.
    pub substate: crate::model::job_status::Substate,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JobStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::JobStatus::state].
    pub fn set_state<T: std::convert::Into<crate::model::job_status::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [details][crate::model::JobStatus::details].
    pub fn set_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.details = v.into();
        self
    }

    /// Sets the value of [state_start_time][crate::model::JobStatus::state_start_time].
    pub fn set_state_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.state_start_time = v.into();
        self
    }

    /// Sets the value of [substate][crate::model::JobStatus::substate].
    pub fn set_substate<T: std::convert::Into<crate::model::job_status::Substate>>(
        mut self,
        v: T,
    ) -> Self {
        self.substate = v.into();
        self
    }
}

impl wkt::message::Message for JobStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.JobStatus"
    }
}

/// Defines additional types related to [JobStatus].
pub mod job_status {
    #[allow(unused_imports)]
    use super::*;

    /// The job state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The job state is unknown.
        Unspecified,
        /// The job is pending; it has been submitted, but is not yet running.
        Pending,
        /// Job has been received by the service and completed initial setup;
        /// it will soon be submitted to the cluster.
        SetupDone,
        /// The job is running on the cluster.
        Running,
        /// A CancelJob request has been received, but is pending.
        CancelPending,
        /// Transient in-flight resources have been canceled, and the request to
        /// cancel the running job has been issued to the cluster.
        CancelStarted,
        /// The job cancellation was successful.
        Cancelled,
        /// The job has completed successfully.
        Done,
        /// The job has completed, but encountered an error.
        Error,
        /// Job attempt has failed. The detail field contains failure details for
        /// this attempt.
        ///
        /// Applies to restartable jobs only.
        AttemptFailure,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::SetupDone => std::option::Option::Some(8),
                Self::Running => std::option::Option::Some(2),
                Self::CancelPending => std::option::Option::Some(3),
                Self::CancelStarted => std::option::Option::Some(7),
                Self::Cancelled => std::option::Option::Some(4),
                Self::Done => std::option::Option::Some(5),
                Self::Error => std::option::Option::Some(6),
                Self::AttemptFailure => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::SetupDone => std::option::Option::Some("SETUP_DONE"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::CancelPending => std::option::Option::Some("CANCEL_PENDING"),
                Self::CancelStarted => std::option::Option::Some("CANCEL_STARTED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::AttemptFailure => std::option::Option::Some("ATTEMPT_FAILURE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Running,
                3 => Self::CancelPending,
                4 => Self::Cancelled,
                5 => Self::Done,
                6 => Self::Error,
                7 => Self::CancelStarted,
                8 => Self::SetupDone,
                9 => Self::AttemptFailure,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "SETUP_DONE" => Self::SetupDone,
                "RUNNING" => Self::Running,
                "CANCEL_PENDING" => Self::CancelPending,
                "CANCEL_STARTED" => Self::CancelStarted,
                "CANCELLED" => Self::Cancelled,
                "DONE" => Self::Done,
                "ERROR" => Self::Error,
                "ATTEMPT_FAILURE" => Self::AttemptFailure,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::SetupDone => serializer.serialize_i32(8),
                Self::Running => serializer.serialize_i32(2),
                Self::CancelPending => serializer.serialize_i32(3),
                Self::CancelStarted => serializer.serialize_i32(7),
                Self::Cancelled => serializer.serialize_i32(4),
                Self::Done => serializer.serialize_i32(5),
                Self::Error => serializer.serialize_i32(6),
                Self::AttemptFailure => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataproc.v1.JobStatus.State",
            ))
        }
    }

    /// The job substate.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Substate {
        /// The job substate is unknown.
        Unspecified,
        /// The Job is submitted to the agent.
        ///
        /// Applies to RUNNING state.
        Submitted,
        /// The Job has been received and is awaiting execution (it might be waiting
        /// for a condition to be met). See the "details" field for the reason for
        /// the delay.
        ///
        /// Applies to RUNNING state.
        Queued,
        /// The agent-reported status is out of date, which can be caused by a
        /// loss of communication between the agent and Dataproc. If the
        /// agent does not send a timely update, the job will fail.
        ///
        /// Applies to RUNNING state.
        StaleStatus,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Substate::value] or
        /// [Substate::name].
        UnknownValue(substate::UnknownValue),
    }

    #[doc(hidden)]
    pub mod substate {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Substate {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Submitted => std::option::Option::Some(1),
                Self::Queued => std::option::Option::Some(2),
                Self::StaleStatus => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::Submitted => std::option::Option::Some("SUBMITTED"),
                Self::Queued => std::option::Option::Some("QUEUED"),
                Self::StaleStatus => std::option::Option::Some("STALE_STATUS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Substate {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Substate {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Substate {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Submitted,
                2 => Self::Queued,
                3 => Self::StaleStatus,
                _ => Self::UnknownValue(substate::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Substate {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "SUBMITTED" => Self::Submitted,
                "QUEUED" => Self::Queued,
                "STALE_STATUS" => Self::StaleStatus,
                _ => Self::UnknownValue(substate::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Substate {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Submitted => serializer.serialize_i32(1),
                Self::Queued => serializer.serialize_i32(2),
                Self::StaleStatus => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Substate {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Substate>::new(
                ".google.cloud.dataproc.v1.JobStatus.Substate",
            ))
        }
    }
}

/// Encapsulates the full scoping used to reference a job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobReference {
    /// Optional. The ID of the Google Cloud Platform project that the job belongs
    /// to. If specified, must match the request project ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Optional. The job ID, which must be unique within the project.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), or hyphens (-). The maximum length is 100 characters.
    ///
    /// If not specified by the caller, the job ID will be provided by the server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JobReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::JobReference::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::JobReference::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }
}

impl wkt::message::Message for JobReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.JobReference"
    }
}

/// A YARN application created by a job. Application information is a subset of
/// \<code\>org.apache.hadoop.yarn.proto.YarnProtos.ApplicationReportProto\</code\>.
///
/// **Beta Feature**: This report is available for testing purposes only. It may
/// be changed before final release.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct YarnApplication {
    /// Required. The application name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The application state.
    pub state: crate::model::yarn_application::State,

    /// Required. The numerical progress of the application, from 1 to 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::F32")]
    pub progress: f32,

    /// Optional. The HTTP URL of the ApplicationMaster, HistoryServer, or
    /// TimelineServer that provides application-specific information. The URL uses
    /// the internal hostname, and requires a proxy server for resolution and,
    /// possibly, access.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tracking_url: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl YarnApplication {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::YarnApplication::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::YarnApplication::state].
    pub fn set_state<T: std::convert::Into<crate::model::yarn_application::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [progress][crate::model::YarnApplication::progress].
    pub fn set_progress<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.progress = v.into();
        self
    }

    /// Sets the value of [tracking_url][crate::model::YarnApplication::tracking_url].
    pub fn set_tracking_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tracking_url = v.into();
        self
    }
}

impl wkt::message::Message for YarnApplication {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.YarnApplication"
    }
}

/// Defines additional types related to [YarnApplication].
pub mod yarn_application {
    #[allow(unused_imports)]
    use super::*;

    /// The application state, corresponding to
    /// \<code\>YarnProtos.YarnApplicationStateProto\</code\>.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Status is unspecified.
        Unspecified,
        /// Status is NEW.
        New,
        /// Status is NEW_SAVING.
        NewSaving,
        /// Status is SUBMITTED.
        Submitted,
        /// Status is ACCEPTED.
        Accepted,
        /// Status is RUNNING.
        Running,
        /// Status is FINISHED.
        Finished,
        /// Status is FAILED.
        Failed,
        /// Status is KILLED.
        Killed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::New => std::option::Option::Some(1),
                Self::NewSaving => std::option::Option::Some(2),
                Self::Submitted => std::option::Option::Some(3),
                Self::Accepted => std::option::Option::Some(4),
                Self::Running => std::option::Option::Some(5),
                Self::Finished => std::option::Option::Some(6),
                Self::Failed => std::option::Option::Some(7),
                Self::Killed => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::New => std::option::Option::Some("NEW"),
                Self::NewSaving => std::option::Option::Some("NEW_SAVING"),
                Self::Submitted => std::option::Option::Some("SUBMITTED"),
                Self::Accepted => std::option::Option::Some("ACCEPTED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Finished => std::option::Option::Some("FINISHED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Killed => std::option::Option::Some("KILLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::New,
                2 => Self::NewSaving,
                3 => Self::Submitted,
                4 => Self::Accepted,
                5 => Self::Running,
                6 => Self::Finished,
                7 => Self::Failed,
                8 => Self::Killed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "NEW" => Self::New,
                "NEW_SAVING" => Self::NewSaving,
                "SUBMITTED" => Self::Submitted,
                "ACCEPTED" => Self::Accepted,
                "RUNNING" => Self::Running,
                "FINISHED" => Self::Finished,
                "FAILED" => Self::Failed,
                "KILLED" => Self::Killed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::New => serializer.serialize_i32(1),
                Self::NewSaving => serializer.serialize_i32(2),
                Self::Submitted => serializer.serialize_i32(3),
                Self::Accepted => serializer.serialize_i32(4),
                Self::Running => serializer.serialize_i32(5),
                Self::Finished => serializer.serialize_i32(6),
                Self::Failed => serializer.serialize_i32(7),
                Self::Killed => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataproc.v1.YarnApplication.State",
            ))
        }
    }
}

/// A Dataproc job resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Job {
    /// Optional. The fully qualified reference to the job, which can be used to
    /// obtain the equivalent REST path of the job resource. If this property
    /// is not specified when a job is created, the server generates a
    /// \<code\>job_id\</code\>.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub reference: std::option::Option<crate::model::JobReference>,

    /// Required. Job information, including how, when, and where to
    /// run the job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub placement: std::option::Option<crate::model::JobPlacement>,

    /// Output only. The job status. Additional application-specific
    /// status information might be contained in the \<code\>type_job\</code\>
    /// and \<code\>yarn_applications\</code\> fields.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<crate::model::JobStatus>,

    /// Output only. The previous job status.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub status_history: std::vec::Vec<crate::model::JobStatus>,

    /// Output only. The collection of YARN applications spun up by this job.
    ///
    /// **Beta** Feature: This report is available for testing purposes only. It
    /// might be changed before final release.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub yarn_applications: std::vec::Vec<crate::model::YarnApplication>,

    /// Output only. A URI pointing to the location of the stdout of the job's
    /// driver program.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub driver_output_resource_uri: std::string::String,

    /// Output only. If present, the location of miscellaneous control files
    /// which can be used as part of job setup and handling. If not present,
    /// control files might be placed in the same location as `driver_output_uri`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub driver_control_files_uri: std::string::String,

    /// Optional. The labels to associate with this job.
    /// Label **keys** must contain 1 to 63 characters, and must conform to
    /// [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt).
    /// Label **values** can be empty, but, if present, must contain 1 to 63
    /// characters, and must conform to [RFC
    /// 1035](https://www.ietf.org/rfc/rfc1035.txt). No more than 32 labels can be
    /// associated with a job.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Job scheduling configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scheduling: std::option::Option<crate::model::JobScheduling>,

    /// Output only. A UUID that uniquely identifies a job within the project
    /// over time. This is in contrast to a user-settable reference.job_id that
    /// might be reused over time.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_uuid: std::string::String,

    /// Output only. Indicates whether the job is completed. If the value is
    /// `false`, the job is still in progress. If `true`, the job is completed, and
    /// `status.state` field will indicate if it was successful, failed,
    /// or cancelled.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub done: bool,

    /// Optional. Driver scheduling configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub driver_scheduling_config: std::option::Option<crate::model::DriverSchedulingConfig>,

    /// Required. The application/framework-specific portion of the job.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub type_job: std::option::Option<crate::model::job::TypeJob>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Job {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reference][crate::model::Job::reference].
    pub fn set_reference<T: std::convert::Into<std::option::Option<crate::model::JobReference>>>(
        mut self,
        v: T,
    ) -> Self {
        self.reference = v.into();
        self
    }

    /// Sets the value of [placement][crate::model::Job::placement].
    pub fn set_placement<T: std::convert::Into<std::option::Option<crate::model::JobPlacement>>>(
        mut self,
        v: T,
    ) -> Self {
        self.placement = v.into();
        self
    }

    /// Sets the value of [status][crate::model::Job::status].
    pub fn set_status<T: std::convert::Into<std::option::Option<crate::model::JobStatus>>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [status_history][crate::model::Job::status_history].
    pub fn set_status_history<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::JobStatus>,
    {
        use std::iter::Iterator;
        self.status_history = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [yarn_applications][crate::model::Job::yarn_applications].
    pub fn set_yarn_applications<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::YarnApplication>,
    {
        use std::iter::Iterator;
        self.yarn_applications = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [driver_output_resource_uri][crate::model::Job::driver_output_resource_uri].
    pub fn set_driver_output_resource_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.driver_output_resource_uri = v.into();
        self
    }

    /// Sets the value of [driver_control_files_uri][crate::model::Job::driver_control_files_uri].
    pub fn set_driver_control_files_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.driver_control_files_uri = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Job::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [scheduling][crate::model::Job::scheduling].
    pub fn set_scheduling<
        T: std::convert::Into<std::option::Option<crate::model::JobScheduling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scheduling = v.into();
        self
    }

    /// Sets the value of [job_uuid][crate::model::Job::job_uuid].
    pub fn set_job_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_uuid = v.into();
        self
    }

    /// Sets the value of [done][crate::model::Job::done].
    pub fn set_done<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.done = v.into();
        self
    }

    /// Sets the value of [driver_scheduling_config][crate::model::Job::driver_scheduling_config].
    pub fn set_driver_scheduling_config<
        T: std::convert::Into<std::option::Option<crate::model::DriverSchedulingConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.driver_scheduling_config = v.into();
        self
    }

    /// Sets the value of [type_job][crate::model::Job::type_job].
    ///
    /// Note that all the setters affecting `type_job` are mutually
    /// exclusive.
    pub fn set_type_job<T: std::convert::Into<std::option::Option<crate::model::job::TypeJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_job = v.into();
        self
    }

    /// The value of [type_job][crate::model::Job::type_job]
    /// if it holds a `HadoopJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn hadoop_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::HadoopJob>> {
        #[allow(unreachable_patterns)]
        self.type_job.as_ref().and_then(|v| match v {
            crate::model::job::TypeJob::HadoopJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_job][crate::model::Job::type_job]
    /// to hold a `HadoopJob`.
    ///
    /// Note that all the setters affecting `type_job` are
    /// mutually exclusive.
    pub fn set_hadoop_job<T: std::convert::Into<std::boxed::Box<crate::model::HadoopJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_job = std::option::Option::Some(crate::model::job::TypeJob::HadoopJob(v.into()));
        self
    }

    /// The value of [type_job][crate::model::Job::type_job]
    /// if it holds a `SparkJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::SparkJob>> {
        #[allow(unreachable_patterns)]
        self.type_job.as_ref().and_then(|v| match v {
            crate::model::job::TypeJob::SparkJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_job][crate::model::Job::type_job]
    /// to hold a `SparkJob`.
    ///
    /// Note that all the setters affecting `type_job` are
    /// mutually exclusive.
    pub fn set_spark_job<T: std::convert::Into<std::boxed::Box<crate::model::SparkJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_job = std::option::Option::Some(crate::model::job::TypeJob::SparkJob(v.into()));
        self
    }

    /// The value of [type_job][crate::model::Job::type_job]
    /// if it holds a `PysparkJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pyspark_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::PySparkJob>> {
        #[allow(unreachable_patterns)]
        self.type_job.as_ref().and_then(|v| match v {
            crate::model::job::TypeJob::PysparkJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_job][crate::model::Job::type_job]
    /// to hold a `PysparkJob`.
    ///
    /// Note that all the setters affecting `type_job` are
    /// mutually exclusive.
    pub fn set_pyspark_job<T: std::convert::Into<std::boxed::Box<crate::model::PySparkJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_job = std::option::Option::Some(crate::model::job::TypeJob::PysparkJob(v.into()));
        self
    }

    /// The value of [type_job][crate::model::Job::type_job]
    /// if it holds a `HiveJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn hive_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::HiveJob>> {
        #[allow(unreachable_patterns)]
        self.type_job.as_ref().and_then(|v| match v {
            crate::model::job::TypeJob::HiveJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_job][crate::model::Job::type_job]
    /// to hold a `HiveJob`.
    ///
    /// Note that all the setters affecting `type_job` are
    /// mutually exclusive.
    pub fn set_hive_job<T: std::convert::Into<std::boxed::Box<crate::model::HiveJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_job = std::option::Option::Some(crate::model::job::TypeJob::HiveJob(v.into()));
        self
    }

    /// The value of [type_job][crate::model::Job::type_job]
    /// if it holds a `PigJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pig_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::PigJob>> {
        #[allow(unreachable_patterns)]
        self.type_job.as_ref().and_then(|v| match v {
            crate::model::job::TypeJob::PigJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_job][crate::model::Job::type_job]
    /// to hold a `PigJob`.
    ///
    /// Note that all the setters affecting `type_job` are
    /// mutually exclusive.
    pub fn set_pig_job<T: std::convert::Into<std::boxed::Box<crate::model::PigJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_job = std::option::Option::Some(crate::model::job::TypeJob::PigJob(v.into()));
        self
    }

    /// The value of [type_job][crate::model::Job::type_job]
    /// if it holds a `SparkRJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_r_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::SparkRJob>> {
        #[allow(unreachable_patterns)]
        self.type_job.as_ref().and_then(|v| match v {
            crate::model::job::TypeJob::SparkRJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_job][crate::model::Job::type_job]
    /// to hold a `SparkRJob`.
    ///
    /// Note that all the setters affecting `type_job` are
    /// mutually exclusive.
    pub fn set_spark_r_job<T: std::convert::Into<std::boxed::Box<crate::model::SparkRJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_job = std::option::Option::Some(crate::model::job::TypeJob::SparkRJob(v.into()));
        self
    }

    /// The value of [type_job][crate::model::Job::type_job]
    /// if it holds a `SparkSqlJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_sql_job(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SparkSqlJob>> {
        #[allow(unreachable_patterns)]
        self.type_job.as_ref().and_then(|v| match v {
            crate::model::job::TypeJob::SparkSqlJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_job][crate::model::Job::type_job]
    /// to hold a `SparkSqlJob`.
    ///
    /// Note that all the setters affecting `type_job` are
    /// mutually exclusive.
    pub fn set_spark_sql_job<T: std::convert::Into<std::boxed::Box<crate::model::SparkSqlJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_job =
            std::option::Option::Some(crate::model::job::TypeJob::SparkSqlJob(v.into()));
        self
    }

    /// The value of [type_job][crate::model::Job::type_job]
    /// if it holds a `PrestoJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn presto_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::PrestoJob>> {
        #[allow(unreachable_patterns)]
        self.type_job.as_ref().and_then(|v| match v {
            crate::model::job::TypeJob::PrestoJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_job][crate::model::Job::type_job]
    /// to hold a `PrestoJob`.
    ///
    /// Note that all the setters affecting `type_job` are
    /// mutually exclusive.
    pub fn set_presto_job<T: std::convert::Into<std::boxed::Box<crate::model::PrestoJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_job = std::option::Option::Some(crate::model::job::TypeJob::PrestoJob(v.into()));
        self
    }

    /// The value of [type_job][crate::model::Job::type_job]
    /// if it holds a `TrinoJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn trino_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::TrinoJob>> {
        #[allow(unreachable_patterns)]
        self.type_job.as_ref().and_then(|v| match v {
            crate::model::job::TypeJob::TrinoJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_job][crate::model::Job::type_job]
    /// to hold a `TrinoJob`.
    ///
    /// Note that all the setters affecting `type_job` are
    /// mutually exclusive.
    pub fn set_trino_job<T: std::convert::Into<std::boxed::Box<crate::model::TrinoJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_job = std::option::Option::Some(crate::model::job::TypeJob::TrinoJob(v.into()));
        self
    }

    /// The value of [type_job][crate::model::Job::type_job]
    /// if it holds a `FlinkJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn flink_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::FlinkJob>> {
        #[allow(unreachable_patterns)]
        self.type_job.as_ref().and_then(|v| match v {
            crate::model::job::TypeJob::FlinkJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [type_job][crate::model::Job::type_job]
    /// to hold a `FlinkJob`.
    ///
    /// Note that all the setters affecting `type_job` are
    /// mutually exclusive.
    pub fn set_flink_job<T: std::convert::Into<std::boxed::Box<crate::model::FlinkJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.type_job = std::option::Option::Some(crate::model::job::TypeJob::FlinkJob(v.into()));
        self
    }
}

impl wkt::message::Message for Job {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.Job"
    }
}

/// Defines additional types related to [Job].
pub mod job {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The application/framework-specific portion of the job.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TypeJob {
        /// Optional. Job is a Hadoop job.
        HadoopJob(std::boxed::Box<crate::model::HadoopJob>),
        /// Optional. Job is a Spark job.
        SparkJob(std::boxed::Box<crate::model::SparkJob>),
        /// Optional. Job is a PySpark job.
        PysparkJob(std::boxed::Box<crate::model::PySparkJob>),
        /// Optional. Job is a Hive job.
        HiveJob(std::boxed::Box<crate::model::HiveJob>),
        /// Optional. Job is a Pig job.
        PigJob(std::boxed::Box<crate::model::PigJob>),
        /// Optional. Job is a SparkR job.
        SparkRJob(std::boxed::Box<crate::model::SparkRJob>),
        /// Optional. Job is a SparkSql job.
        SparkSqlJob(std::boxed::Box<crate::model::SparkSqlJob>),
        /// Optional. Job is a Presto job.
        PrestoJob(std::boxed::Box<crate::model::PrestoJob>),
        /// Optional. Job is a Trino job.
        TrinoJob(std::boxed::Box<crate::model::TrinoJob>),
        /// Optional. Job is a Flink job.
        FlinkJob(std::boxed::Box<crate::model::FlinkJob>),
    }
}

/// Driver scheduling configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DriverSchedulingConfig {
    /// Required. The amount of memory in MB the driver is requesting.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub memory_mb: i32,

    /// Required. The number of vCPUs the driver is requesting.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub vcores: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DriverSchedulingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [memory_mb][crate::model::DriverSchedulingConfig::memory_mb].
    pub fn set_memory_mb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_mb = v.into();
        self
    }

    /// Sets the value of [vcores][crate::model::DriverSchedulingConfig::vcores].
    pub fn set_vcores<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.vcores = v.into();
        self
    }
}

impl wkt::message::Message for DriverSchedulingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DriverSchedulingConfig"
    }
}

/// Job scheduling options.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobScheduling {
    /// Optional. Maximum number of times per hour a driver can be restarted as
    /// a result of driver exiting with non-zero code before job is
    /// reported failed.
    ///
    /// A job might be reported as thrashing if the driver exits with a non-zero
    /// code four times within a 10-minute window.
    ///
    /// Maximum value is 10.
    ///
    /// **Note:** This restartable job option is not supported in Dataproc
    /// [workflow templates]
    /// (<https://cloud.google.com/dataproc/docs/concepts/workflows/using-workflows#adding_jobs_to_a_template>).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_failures_per_hour: i32,

    /// Optional. Maximum total number of times a driver can be restarted as a
    /// result of the driver exiting with a non-zero code. After the maximum number
    /// is reached, the job will be reported as failed.
    ///
    /// Maximum value is 240.
    ///
    /// **Note:** Currently, this restartable job option is
    /// not supported in Dataproc
    /// [workflow
    /// templates](https://cloud.google.com/dataproc/docs/concepts/workflows/using-workflows#adding_jobs_to_a_template).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub max_failures_total: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JobScheduling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [max_failures_per_hour][crate::model::JobScheduling::max_failures_per_hour].
    pub fn set_max_failures_per_hour<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_failures_per_hour = v.into();
        self
    }

    /// Sets the value of [max_failures_total][crate::model::JobScheduling::max_failures_total].
    pub fn set_max_failures_total<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_failures_total = v.into();
        self
    }
}

impl wkt::message::Message for JobScheduling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.JobScheduling"
    }
}

/// A request to submit a job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SubmitJobRequest {
    /// Required. The ID of the Google Cloud Platform project that the job
    /// belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// Required. The job resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub job: std::option::Option<crate::model::Job>,

    /// Optional. A unique id used to identify the request. If the server
    /// receives two
    /// [SubmitJobRequest](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.SubmitJobRequest)s
    /// with the same id, then the second request will be ignored and the
    /// first [Job][google.cloud.dataproc.v1.Job] created and stored in the backend
    /// is returned.
    ///
    /// It is recommended to always set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The id must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    ///
    /// [google.cloud.dataproc.v1.Job]: crate::model::Job
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubmitJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SubmitJobRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::SubmitJobRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [job][crate::model::SubmitJobRequest::job].
    pub fn set_job<T: std::convert::Into<std::option::Option<crate::model::Job>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::SubmitJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for SubmitJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SubmitJobRequest"
    }
}

/// Job Operation metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JobMetadata {
    /// Output only. The job id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_id: std::string::String,

    /// Output only. Most recent job status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<crate::model::JobStatus>,

    /// Output only. Operation type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub operation_type: std::string::String,

    /// Output only. Job submission time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JobMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [job_id][crate::model::JobMetadata::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [status][crate::model::JobMetadata::status].
    pub fn set_status<T: std::convert::Into<std::option::Option<crate::model::JobStatus>>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [operation_type][crate::model::JobMetadata::operation_type].
    pub fn set_operation_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_type = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::JobMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }
}

impl wkt::message::Message for JobMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.JobMetadata"
    }
}

/// A request to get the resource representation for a job in a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetJobRequest {
    /// Required. The ID of the Google Cloud Platform project that the job
    /// belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// Required. The job ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetJobRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::GetJobRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::GetJobRequest::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }
}

impl wkt::message::Message for GetJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GetJobRequest"
    }
}

/// A request to list jobs in a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListJobsRequest {
    /// Required. The ID of the Google Cloud Platform project that the job
    /// belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// Optional. The number of results to return in each response.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The page token, returned by a previous call, to request the
    /// next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. If set, the returned jobs list includes only jobs that were
    /// submitted to the named cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_name: std::string::String,

    /// Optional. Specifies enumerated categories of jobs to list.
    /// (default = match ALL jobs).
    ///
    /// If `filter` is provided, `jobStateMatcher` will be ignored.
    pub job_state_matcher: crate::model::list_jobs_request::JobStateMatcher,

    /// Optional. A filter constraining the jobs to list. Filters are
    /// case-sensitive and have the following syntax:
    ///
    /// [field = value] AND [field [= value]] ...
    ///
    /// where **field** is `status.state` or `labels.[KEY]`, and `[KEY]` is a label
    /// key. **value** can be `*` to match all values.
    /// `status.state` can be either `ACTIVE` or `NON_ACTIVE`.
    /// Only the logical `AND` operator is supported; space-separated items are
    /// treated as having an implicit `AND` operator.
    ///
    /// Example filter:
    ///
    /// status.state = ACTIVE AND labels.env = staging AND labels.starred = *
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListJobsRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::ListJobsRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::ListJobsRequest::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [job_state_matcher][crate::model::ListJobsRequest::job_state_matcher].
    pub fn set_job_state_matcher<
        T: std::convert::Into<crate::model::list_jobs_request::JobStateMatcher>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_state_matcher = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListJobsRequest"
    }
}

/// Defines additional types related to [ListJobsRequest].
pub mod list_jobs_request {
    #[allow(unused_imports)]
    use super::*;

    /// A matcher that specifies categories of job states.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum JobStateMatcher {
        /// Match all jobs, regardless of state.
        All,
        /// Only match jobs in non-terminal states: PENDING, RUNNING, or
        /// CANCEL_PENDING.
        Active,
        /// Only match jobs in terminal states: CANCELLED, DONE, or ERROR.
        NonActive,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [JobStateMatcher::value] or
        /// [JobStateMatcher::name].
        UnknownValue(job_state_matcher::UnknownValue),
    }

    #[doc(hidden)]
    pub mod job_state_matcher {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl JobStateMatcher {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::All => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::NonActive => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::All => std::option::Option::Some("ALL"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::NonActive => std::option::Option::Some("NON_ACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for JobStateMatcher {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for JobStateMatcher {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for JobStateMatcher {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::All,
                1 => Self::Active,
                2 => Self::NonActive,
                _ => Self::UnknownValue(job_state_matcher::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for JobStateMatcher {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ALL" => Self::All,
                "ACTIVE" => Self::Active,
                "NON_ACTIVE" => Self::NonActive,
                _ => Self::UnknownValue(job_state_matcher::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for JobStateMatcher {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::All => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::NonActive => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for JobStateMatcher {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<JobStateMatcher>::new(
                ".google.cloud.dataproc.v1.ListJobsRequest.JobStateMatcher",
            ))
        }
    }
}

/// A request to update a job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateJobRequest {
    /// Required. The ID of the Google Cloud Platform project that the job
    /// belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// Required. The job ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_id: std::string::String,

    /// Required. The changes to the job.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub job: std::option::Option<crate::model::Job>,

    /// Required. Specifies the path, relative to \<code\>Job\</code\>, of
    /// the field to update. For example, to update the labels of a Job the
    /// \<code\>update_mask\</code\> parameter would be specified as
    /// \<code\>labels\</code\>, and the `PATCH` request body would specify the new
    /// value. \<strong\>Note:\</strong\> Currently, \<code\>labels\</code\> is the only
    /// field that can be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::UpdateJobRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::UpdateJobRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::UpdateJobRequest::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [job][crate::model::UpdateJobRequest::job].
    pub fn set_job<T: std::convert::Into<std::option::Option<crate::model::Job>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateJobRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.UpdateJobRequest"
    }
}

/// A list of jobs in a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListJobsResponse {
    /// Output only. Jobs list.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jobs: std::vec::Vec<crate::model::Job>,

    /// Optional. This token is included in the response if there are more results
    /// to fetch. To fetch additional results, provide this value as the
    /// `page_token` in a subsequent \<code\>ListJobsRequest\</code\>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Output only. List of jobs with
    /// [kms_key][google.cloud.dataproc.v1.EncryptionConfig.kms_key]-encrypted
    /// parameters that could not be decrypted. A response to a `jobs.get` request
    /// may indicate the reason for the decryption failure for a specific job.
    ///
    /// [google.cloud.dataproc.v1.EncryptionConfig.kms_key]: crate::model::EncryptionConfig::kms_key
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [jobs][crate::model::ListJobsResponse::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Job>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListJobsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListJobsResponse {
    type PageItem = crate::model::Job;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A request to cancel a job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelJobRequest {
    /// Required. The ID of the Google Cloud Platform project that the job
    /// belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// Required. The job ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::CancelJobRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::CancelJobRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::CancelJobRequest::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }
}

impl wkt::message::Message for CancelJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.CancelJobRequest"
    }
}

/// A request to delete a job.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteJobRequest {
    /// Required. The ID of the Google Cloud Platform project that the job
    /// belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The Dataproc region in which to handle the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub region: std::string::String,

    /// Required. The job ID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DeleteJobRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [region][crate::model::DeleteJobRequest::region].
    pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region = v.into();
        self
    }

    /// Sets the value of [job_id][crate::model::DeleteJobRequest::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DeleteJobRequest"
    }
}

/// A request to create a node group.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateNodeGroupRequest {
    /// Required. The parent resource where this node group will be created.
    /// Format: `projects/{project}/regions/{region}/clusters/{cluster}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The node group to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub node_group: std::option::Option<crate::model::NodeGroup>,

    /// Optional. An optional node group ID. Generated if not specified.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). Cannot begin or end with underscore
    /// or hyphen. Must consist of from 3 to 33 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub node_group_id: std::string::String,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two
    /// [CreateNodeGroupRequest](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.CreateNodeGroupRequests)
    /// with the same ID, the second request is ignored and the
    /// first [google.longrunning.Operation][google.longrunning.Operation] created
    /// and stored in the backend is returned.
    ///
    /// Recommendation: Set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    ///
    /// [google.longrunning.Operation]: longrunning::model::Operation
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateNodeGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateNodeGroupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [node_group][crate::model::CreateNodeGroupRequest::node_group].
    pub fn set_node_group<T: std::convert::Into<std::option::Option<crate::model::NodeGroup>>>(
        mut self,
        v: T,
    ) -> Self {
        self.node_group = v.into();
        self
    }

    /// Sets the value of [node_group_id][crate::model::CreateNodeGroupRequest::node_group_id].
    pub fn set_node_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_group_id = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateNodeGroupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateNodeGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.CreateNodeGroupRequest"
    }
}

/// A request to resize a node group.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResizeNodeGroupRequest {
    /// Required. The name of the node group to resize.
    /// Format:
    /// `projects/{project}/regions/{region}/clusters/{cluster}/nodeGroups/{nodeGroup}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The number of running instances for the node group to maintain.
    /// The group adds or removes instances to maintain the number of instances
    /// specified by this parameter.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub size: i32,

    /// Optional. A unique ID used to identify the request. If the server receives
    /// two
    /// [ResizeNodeGroupRequest](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.ResizeNodeGroupRequests)
    /// with the same ID, the second request is ignored and the
    /// first [google.longrunning.Operation][google.longrunning.Operation] created
    /// and stored in the backend is returned.
    ///
    /// Recommendation: Set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    ///
    /// [google.longrunning.Operation]: longrunning::model::Operation
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. Timeout for graceful YARN decommissioning. [Graceful
    /// decommissioning]
    /// (<https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/scaling-clusters#graceful_decommissioning>)
    /// allows the removal of nodes from the Compute Engine node group
    /// without interrupting jobs in progress. This timeout specifies how long to
    /// wait for jobs in progress to finish before forcefully removing nodes (and
    /// potentially interrupting jobs). Default timeout is 0 (for forceful
    /// decommission), and the maximum allowed timeout is 1 day. (see JSON
    /// representation of
    /// [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json)).
    ///
    /// Only supported on Dataproc image versions 1.2 and higher.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub graceful_decommission_timeout: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResizeNodeGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResizeNodeGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [size][crate::model::ResizeNodeGroupRequest::size].
    pub fn set_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.size = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::ResizeNodeGroupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [graceful_decommission_timeout][crate::model::ResizeNodeGroupRequest::graceful_decommission_timeout].
    pub fn set_graceful_decommission_timeout<
        T: std::convert::Into<std::option::Option<wkt::Duration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.graceful_decommission_timeout = v.into();
        self
    }
}

impl wkt::message::Message for ResizeNodeGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ResizeNodeGroupRequest"
    }
}

/// A request to get a node group .
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNodeGroupRequest {
    /// Required. The name of the node group to retrieve.
    /// Format:
    /// `projects/{project}/regions/{region}/clusters/{cluster}/nodeGroups/{nodeGroup}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNodeGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNodeGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNodeGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GetNodeGroupRequest"
    }
}

/// Metadata describing the Batch operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BatchOperationMetadata {
    /// Name of the batch for the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub batch: std::string::String,

    /// Batch UUID for the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub batch_uuid: std::string::String,

    /// The time when the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time when the operation finished.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub done_time: std::option::Option<wkt::Timestamp>,

    /// The operation type.
    pub operation_type: crate::model::batch_operation_metadata::BatchOperationType,

    /// Short description of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Labels associated with the operation.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Warnings encountered during operation execution.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub warnings: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [batch][crate::model::BatchOperationMetadata::batch].
    pub fn set_batch<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.batch = v.into();
        self
    }

    /// Sets the value of [batch_uuid][crate::model::BatchOperationMetadata::batch_uuid].
    pub fn set_batch_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.batch_uuid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BatchOperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [done_time][crate::model::BatchOperationMetadata::done_time].
    pub fn set_done_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.done_time = v.into();
        self
    }

    /// Sets the value of [operation_type][crate::model::BatchOperationMetadata::operation_type].
    pub fn set_operation_type<
        T: std::convert::Into<crate::model::batch_operation_metadata::BatchOperationType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation_type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::BatchOperationMetadata::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::BatchOperationMetadata::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [warnings][crate::model::BatchOperationMetadata::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.BatchOperationMetadata"
    }
}

/// Defines additional types related to [BatchOperationMetadata].
pub mod batch_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Operation type for Batch resources
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BatchOperationType {
        /// Batch operation type is unknown.
        Unspecified,
        /// Batch operation type.
        Batch,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BatchOperationType::value] or
        /// [BatchOperationType::name].
        UnknownValue(batch_operation_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod batch_operation_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BatchOperationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Batch => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BATCH_OPERATION_TYPE_UNSPECIFIED"),
                Self::Batch => std::option::Option::Some("BATCH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BatchOperationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BatchOperationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BatchOperationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Batch,
                _ => Self::UnknownValue(batch_operation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BatchOperationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BATCH_OPERATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "BATCH" => Self::Batch,
                _ => Self::UnknownValue(batch_operation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BatchOperationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Batch => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BatchOperationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BatchOperationType>::new(
                ".google.cloud.dataproc.v1.BatchOperationMetadata.BatchOperationType",
            ))
        }
    }
}

/// Metadata describing the Session operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SessionOperationMetadata {
    /// Name of the session for the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub session: std::string::String,

    /// Session UUID for the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub session_uuid: std::string::String,

    /// The time when the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time when the operation was finished.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub done_time: std::option::Option<wkt::Timestamp>,

    /// The operation type.
    pub operation_type: crate::model::session_operation_metadata::SessionOperationType,

    /// Short description of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Labels associated with the operation.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Warnings encountered during operation execution.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub warnings: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SessionOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [session][crate::model::SessionOperationMetadata::session].
    pub fn set_session<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.session = v.into();
        self
    }

    /// Sets the value of [session_uuid][crate::model::SessionOperationMetadata::session_uuid].
    pub fn set_session_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.session_uuid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::SessionOperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [done_time][crate::model::SessionOperationMetadata::done_time].
    pub fn set_done_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.done_time = v.into();
        self
    }

    /// Sets the value of [operation_type][crate::model::SessionOperationMetadata::operation_type].
    pub fn set_operation_type<
        T: std::convert::Into<crate::model::session_operation_metadata::SessionOperationType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation_type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::SessionOperationMetadata::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::SessionOperationMetadata::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [warnings][crate::model::SessionOperationMetadata::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SessionOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SessionOperationMetadata"
    }
}

/// Defines additional types related to [SessionOperationMetadata].
pub mod session_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Operation type for Session resources
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SessionOperationType {
        /// Session operation type is unknown.
        Unspecified,
        /// Create Session operation type.
        Create,
        /// Terminate Session operation type.
        Terminate,
        /// Delete Session operation type.
        Delete,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SessionOperationType::value] or
        /// [SessionOperationType::name].
        UnknownValue(session_operation_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod session_operation_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SessionOperationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Create => std::option::Option::Some(1),
                Self::Terminate => std::option::Option::Some(2),
                Self::Delete => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("SESSION_OPERATION_TYPE_UNSPECIFIED")
                }
                Self::Create => std::option::Option::Some("CREATE"),
                Self::Terminate => std::option::Option::Some("TERMINATE"),
                Self::Delete => std::option::Option::Some("DELETE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SessionOperationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SessionOperationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SessionOperationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Create,
                2 => Self::Terminate,
                3 => Self::Delete,
                _ => Self::UnknownValue(session_operation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SessionOperationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SESSION_OPERATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CREATE" => Self::Create,
                "TERMINATE" => Self::Terminate,
                "DELETE" => Self::Delete,
                _ => Self::UnknownValue(session_operation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SessionOperationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Create => serializer.serialize_i32(1),
                Self::Terminate => serializer.serialize_i32(2),
                Self::Delete => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SessionOperationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SessionOperationType>::new(
                ".google.cloud.dataproc.v1.SessionOperationMetadata.SessionOperationType",
            ))
        }
    }
}

/// The status of the operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClusterOperationStatus {
    /// Output only. A message containing the operation state.
    pub state: crate::model::cluster_operation_status::State,

    /// Output only. A message containing the detailed operation state.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub inner_state: std::string::String,

    /// Output only. A message containing any operation metadata details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub details: std::string::String,

    /// Output only. The time this state was entered.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub state_start_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterOperationStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::ClusterOperationStatus::state].
    pub fn set_state<T: std::convert::Into<crate::model::cluster_operation_status::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [inner_state][crate::model::ClusterOperationStatus::inner_state].
    pub fn set_inner_state<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.inner_state = v.into();
        self
    }

    /// Sets the value of [details][crate::model::ClusterOperationStatus::details].
    pub fn set_details<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.details = v.into();
        self
    }

    /// Sets the value of [state_start_time][crate::model::ClusterOperationStatus::state_start_time].
    pub fn set_state_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.state_start_time = v.into();
        self
    }
}

impl wkt::message::Message for ClusterOperationStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ClusterOperationStatus"
    }
}

/// Defines additional types related to [ClusterOperationStatus].
pub mod cluster_operation_status {
    #[allow(unused_imports)]
    use super::*;

    /// The operation state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unused.
        Unknown,
        /// The operation has been created.
        Pending,
        /// The operation is running.
        Running,
        /// The operation is done; either cancelled or completed.
        Done,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Done => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Pending,
                2 => Self::Running,
                3 => Self::Done,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "PENDING" => Self::Pending,
                "RUNNING" => Self::Running,
                "DONE" => Self::Done,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Done => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataproc.v1.ClusterOperationStatus.State",
            ))
        }
    }
}

/// Metadata describing the operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClusterOperationMetadata {
    /// Output only. Name of the cluster for the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_name: std::string::String,

    /// Output only. Cluster UUID for the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_uuid: std::string::String,

    /// Output only. Current operation status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<crate::model::ClusterOperationStatus>,

    /// Output only. The previous operation status.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub status_history: std::vec::Vec<crate::model::ClusterOperationStatus>,

    /// Output only. The operation type.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub operation_type: std::string::String,

    /// Output only. Short description of operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Labels associated with the operation
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Errors encountered during operation execution.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub warnings: std::vec::Vec<std::string::String>,

    /// Output only. Child operation ids
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub child_operation_ids: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_name][crate::model::ClusterOperationMetadata::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [cluster_uuid][crate::model::ClusterOperationMetadata::cluster_uuid].
    pub fn set_cluster_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uuid = v.into();
        self
    }

    /// Sets the value of [status][crate::model::ClusterOperationMetadata::status].
    pub fn set_status<
        T: std::convert::Into<std::option::Option<crate::model::ClusterOperationStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [status_history][crate::model::ClusterOperationMetadata::status_history].
    pub fn set_status_history<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClusterOperationStatus>,
    {
        use std::iter::Iterator;
        self.status_history = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [operation_type][crate::model::ClusterOperationMetadata::operation_type].
    pub fn set_operation_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ClusterOperationMetadata::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ClusterOperationMetadata::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [warnings][crate::model::ClusterOperationMetadata::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [child_operation_ids][crate::model::ClusterOperationMetadata::child_operation_ids].
    pub fn set_child_operation_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.child_operation_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ClusterOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ClusterOperationMetadata"
    }
}

/// Metadata describing the node group operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodeGroupOperationMetadata {
    /// Output only. Node group ID for the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub node_group_id: std::string::String,

    /// Output only. Cluster UUID associated with the node group operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_uuid: std::string::String,

    /// Output only. Current operation status.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<crate::model::ClusterOperationStatus>,

    /// Output only. The previous operation status.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub status_history: std::vec::Vec<crate::model::ClusterOperationStatus>,

    /// The operation type.
    pub operation_type: crate::model::node_group_operation_metadata::NodeGroupOperationType,

    /// Output only. Short description of operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. Labels associated with the operation.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Errors encountered during operation execution.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub warnings: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeGroupOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [node_group_id][crate::model::NodeGroupOperationMetadata::node_group_id].
    pub fn set_node_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_group_id = v.into();
        self
    }

    /// Sets the value of [cluster_uuid][crate::model::NodeGroupOperationMetadata::cluster_uuid].
    pub fn set_cluster_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uuid = v.into();
        self
    }

    /// Sets the value of [status][crate::model::NodeGroupOperationMetadata::status].
    pub fn set_status<
        T: std::convert::Into<std::option::Option<crate::model::ClusterOperationStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [status_history][crate::model::NodeGroupOperationMetadata::status_history].
    pub fn set_status_history<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClusterOperationStatus>,
    {
        use std::iter::Iterator;
        self.status_history = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [operation_type][crate::model::NodeGroupOperationMetadata::operation_type].
    pub fn set_operation_type<
        T: std::convert::Into<crate::model::node_group_operation_metadata::NodeGroupOperationType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation_type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::NodeGroupOperationMetadata::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::NodeGroupOperationMetadata::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [warnings][crate::model::NodeGroupOperationMetadata::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NodeGroupOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.NodeGroupOperationMetadata"
    }
}

/// Defines additional types related to [NodeGroupOperationMetadata].
pub mod node_group_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Operation type for node group resources.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NodeGroupOperationType {
        /// Node group operation type is unknown.
        Unspecified,
        /// Create node group operation type.
        Create,
        /// Update node group operation type.
        Update,
        /// Delete node group operation type.
        Delete,
        /// Resize node group operation type.
        Resize,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [NodeGroupOperationType::value] or
        /// [NodeGroupOperationType::name].
        UnknownValue(node_group_operation_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod node_group_operation_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl NodeGroupOperationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Create => std::option::Option::Some(1),
                Self::Update => std::option::Option::Some(2),
                Self::Delete => std::option::Option::Some(3),
                Self::Resize => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("NODE_GROUP_OPERATION_TYPE_UNSPECIFIED")
                }
                Self::Create => std::option::Option::Some("CREATE"),
                Self::Update => std::option::Option::Some("UPDATE"),
                Self::Delete => std::option::Option::Some("DELETE"),
                Self::Resize => std::option::Option::Some("RESIZE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for NodeGroupOperationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for NodeGroupOperationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for NodeGroupOperationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Create,
                2 => Self::Update,
                3 => Self::Delete,
                4 => Self::Resize,
                _ => Self::UnknownValue(node_group_operation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for NodeGroupOperationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NODE_GROUP_OPERATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "CREATE" => Self::Create,
                "UPDATE" => Self::Update,
                "DELETE" => Self::Delete,
                "RESIZE" => Self::Resize,
                _ => Self::UnknownValue(node_group_operation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for NodeGroupOperationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Create => serializer.serialize_i32(1),
                Self::Update => serializer.serialize_i32(2),
                Self::Delete => serializer.serialize_i32(3),
                Self::Resize => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for NodeGroupOperationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<NodeGroupOperationType>::new(
                ".google.cloud.dataproc.v1.NodeGroupOperationMetadata.NodeGroupOperationType",
            ))
        }
    }
}

/// A request to create a session template.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSessionTemplateRequest {
    /// Required. The parent resource where this session template will be created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The session template to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub session_template: std::option::Option<crate::model::SessionTemplate>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSessionTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSessionTemplateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [session_template][crate::model::CreateSessionTemplateRequest::session_template].
    pub fn set_session_template<
        T: std::convert::Into<std::option::Option<crate::model::SessionTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.session_template = v.into();
        self
    }
}

impl wkt::message::Message for CreateSessionTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.CreateSessionTemplateRequest"
    }
}

/// A request to update a session template.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSessionTemplateRequest {
    /// Required. The updated session template.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub session_template: std::option::Option<crate::model::SessionTemplate>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSessionTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [session_template][crate::model::UpdateSessionTemplateRequest::session_template].
    pub fn set_session_template<
        T: std::convert::Into<std::option::Option<crate::model::SessionTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.session_template = v.into();
        self
    }
}

impl wkt::message::Message for UpdateSessionTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.UpdateSessionTemplateRequest"
    }
}

/// A request to get the resource representation for a session template.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSessionTemplateRequest {
    /// Required. The name of the session template to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSessionTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSessionTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSessionTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GetSessionTemplateRequest"
    }
}

/// A request to list session templates in a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSessionTemplatesRequest {
    /// Required. The parent that owns this collection of session templates.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of sessions to return in each response.
    /// The service may return fewer than this value.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. A page token received from a previous `ListSessions` call.
    /// Provide this token to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. A filter for the session templates to return in the response.
    /// Filters are case sensitive and have the following syntax:
    ///
    /// [field = value] AND [field [= value]] ...
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSessionTemplatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSessionTemplatesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSessionTemplatesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSessionTemplatesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSessionTemplatesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListSessionTemplatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListSessionTemplatesRequest"
    }
}

/// A list of session templates.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSessionTemplatesResponse {
    /// Output only. Session template list
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub session_templates: std::vec::Vec<crate::model::SessionTemplate>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSessionTemplatesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [session_templates][crate::model::ListSessionTemplatesResponse::session_templates].
    pub fn set_session_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SessionTemplate>,
    {
        use std::iter::Iterator;
        self.session_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSessionTemplatesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSessionTemplatesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListSessionTemplatesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSessionTemplatesResponse {
    type PageItem = crate::model::SessionTemplate;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.session_templates
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A request to delete a session template.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSessionTemplateRequest {
    /// Required. The name of the session template resource to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSessionTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSessionTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSessionTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DeleteSessionTemplateRequest"
    }
}

/// A representation of a session template.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SessionTemplate {
    /// Required. The resource name of the session template.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Brief description of the template.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The time when the template was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The email address of the user who created the template.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub creator: std::string::String,

    /// Optional. Labels to associate with sessions created using this template.
    /// Label **keys** must contain 1 to 63 characters, and must conform to
    /// [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt).
    /// Label **values** can be empty, but, if present, must contain 1 to 63
    /// characters and conform to [RFC
    /// 1035](https://www.ietf.org/rfc/rfc1035.txt). No more than 32 labels can be
    /// associated with a session.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Runtime configuration for session execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub runtime_config: std::option::Option<crate::model::RuntimeConfig>,

    /// Optional. Environment configuration for session execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub environment_config: std::option::Option<crate::model::EnvironmentConfig>,

    /// Output only. The time the template was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. A session template UUID (Unique Universal Identifier). The
    /// service generates this value when it creates the session template.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uuid: std::string::String,

    /// The session configuration.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub session_config: std::option::Option<crate::model::session_template::SessionConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SessionTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SessionTemplate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::SessionTemplate::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::SessionTemplate::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [creator][crate::model::SessionTemplate::creator].
    pub fn set_creator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.creator = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::SessionTemplate::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [runtime_config][crate::model::SessionTemplate::runtime_config].
    pub fn set_runtime_config<
        T: std::convert::Into<std::option::Option<crate::model::RuntimeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_config = v.into();
        self
    }

    /// Sets the value of [environment_config][crate::model::SessionTemplate::environment_config].
    pub fn set_environment_config<
        T: std::convert::Into<std::option::Option<crate::model::EnvironmentConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.environment_config = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::SessionTemplate::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [uuid][crate::model::SessionTemplate::uuid].
    pub fn set_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uuid = v.into();
        self
    }

    /// Sets the value of [session_config][crate::model::SessionTemplate::session_config].
    ///
    /// Note that all the setters affecting `session_config` are mutually
    /// exclusive.
    pub fn set_session_config<
        T: std::convert::Into<std::option::Option<crate::model::session_template::SessionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.session_config = v.into();
        self
    }

    /// The value of [session_config][crate::model::SessionTemplate::session_config]
    /// if it holds a `JupyterSession`, `None` if the field is not set or
    /// holds a different branch.
    pub fn jupyter_session(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::JupyterConfig>> {
        #[allow(unreachable_patterns)]
        self.session_config.as_ref().and_then(|v| match v {
            crate::model::session_template::SessionConfig::JupyterSession(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [session_config][crate::model::SessionTemplate::session_config]
    /// to hold a `JupyterSession`.
    ///
    /// Note that all the setters affecting `session_config` are
    /// mutually exclusive.
    pub fn set_jupyter_session<
        T: std::convert::Into<std::boxed::Box<crate::model::JupyterConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.session_config = std::option::Option::Some(
            crate::model::session_template::SessionConfig::JupyterSession(v.into()),
        );
        self
    }

    /// The value of [session_config][crate::model::SessionTemplate::session_config]
    /// if it holds a `SparkConnectSession`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_connect_session(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SparkConnectConfig>> {
        #[allow(unreachable_patterns)]
        self.session_config.as_ref().and_then(|v| match v {
            crate::model::session_template::SessionConfig::SparkConnectSession(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [session_config][crate::model::SessionTemplate::session_config]
    /// to hold a `SparkConnectSession`.
    ///
    /// Note that all the setters affecting `session_config` are
    /// mutually exclusive.
    pub fn set_spark_connect_session<
        T: std::convert::Into<std::boxed::Box<crate::model::SparkConnectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.session_config = std::option::Option::Some(
            crate::model::session_template::SessionConfig::SparkConnectSession(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SessionTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SessionTemplate"
    }
}

/// Defines additional types related to [SessionTemplate].
pub mod session_template {
    #[allow(unused_imports)]
    use super::*;

    /// The session configuration.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SessionConfig {
        /// Optional. Jupyter session config.
        JupyterSession(std::boxed::Box<crate::model::JupyterConfig>),
        /// Optional. Spark Connect session config.
        SparkConnectSession(std::boxed::Box<crate::model::SparkConnectConfig>),
    }
}

/// A request to create a session.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSessionRequest {
    /// Required. The parent resource where this session will be created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The interactive session to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub session: std::option::Option<crate::model::Session>,

    /// Required. The ID to use for the session, which becomes the final component
    /// of the session's resource name.
    ///
    /// This value must be 4-63 characters. Valid characters
    /// are /[a-z][0-9]-/.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub session_id: std::string::String,

    /// Optional. A unique ID used to identify the request. If the service
    /// receives two
    /// [CreateSessionRequests](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.CreateSessionRequest)s
    /// with the same ID, the second request is ignored, and the
    /// first [Session][google.cloud.dataproc.v1.Session] is created and stored in
    /// the backend.
    ///
    /// Recommendation: Set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The value must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    ///
    /// [google.cloud.dataproc.v1.Session]: crate::model::Session
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSessionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [session][crate::model::CreateSessionRequest::session].
    pub fn set_session<T: std::convert::Into<std::option::Option<crate::model::Session>>>(
        mut self,
        v: T,
    ) -> Self {
        self.session = v.into();
        self
    }

    /// Sets the value of [session_id][crate::model::CreateSessionRequest::session_id].
    pub fn set_session_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.session_id = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateSessionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.CreateSessionRequest"
    }
}

/// A request to get the resource representation for a session.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSessionRequest {
    /// Required. The name of the session to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSessionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GetSessionRequest"
    }
}

/// A request to list sessions in a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSessionsRequest {
    /// Required. The parent, which owns this collection of sessions.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of sessions to return in each response.
    /// The service may return fewer than this value.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. A page token received from a previous `ListSessions` call.
    /// Provide this token to retrieve the subsequent page.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. A filter for the sessions to return in the response.
    ///
    /// A filter is a logical expression constraining the values of various fields
    /// in each session resource. Filters are case sensitive, and may contain
    /// multiple clauses combined with logical operators (AND, OR).
    /// Supported fields are `session_id`, `session_uuid`, `state`, `create_time`,
    /// and `labels`.
    ///
    /// Example: `state = ACTIVE and create_time < "2023-01-01T00:00:00Z"`
    /// is a filter for sessions in an ACTIVE state that were created before
    /// 2023-01-01. `state = ACTIVE and labels.environment=production` is a filter
    /// for sessions in an ACTIVE state that have a production environment label.
    ///
    /// See <https://google.aip.dev/assets/misc/ebnf-filtering.txt> for a detailed
    /// description of the filter syntax and a list of supported comparators.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSessionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSessionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSessionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSessionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSessionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListSessionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListSessionsRequest"
    }
}

/// A list of interactive sessions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSessionsResponse {
    /// Output only. The sessions from the specified collection.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub sessions: std::vec::Vec<crate::model::Session>,

    /// A token, which can be sent as `page_token`, to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSessionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sessions][crate::model::ListSessionsResponse::sessions].
    pub fn set_sessions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Session>,
    {
        use std::iter::Iterator;
        self.sessions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSessionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSessionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListSessionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSessionsResponse {
    type PageItem = crate::model::Session;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.sessions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A request to terminate an interactive session.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TerminateSessionRequest {
    /// Required. The name of the session resource to terminate.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A unique ID used to identify the request. If the service
    /// receives two
    /// [TerminateSessionRequest](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.TerminateSessionRequest)s
    /// with the same ID, the second request is ignored.
    ///
    /// Recommendation: Set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The value must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TerminateSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TerminateSessionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::TerminateSessionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for TerminateSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.TerminateSessionRequest"
    }
}

/// A request to delete a session.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSessionRequest {
    /// Required. The name of the session resource to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A unique ID used to identify the request. If the service
    /// receives two
    /// [DeleteSessionRequest](https://cloud.google.com/dataproc/docs/reference/rpc/google.cloud.dataproc.v1#google.cloud.dataproc.v1.DeleteSessionRequest)s
    /// with the same ID, the second request is ignored.
    ///
    /// Recommendation: Set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The value must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSessionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteSessionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DeleteSessionRequest"
    }
}

/// A representation of a session.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Session {
    /// Required. The resource name of the session.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. A session UUID (Unique Universal Identifier). The service
    /// generates this value when it creates the session.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uuid: std::string::String,

    /// Output only. The time when the session was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Runtime information about session execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub runtime_info: std::option::Option<crate::model::RuntimeInfo>,

    /// Output only. A state of the session.
    pub state: crate::model::session::State,

    /// Output only. Session state details, such as the failure
    /// description if the state is `FAILED`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub state_message: std::string::String,

    /// Output only. The time when the session entered the current state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub state_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The email address of the user who created the session.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub creator: std::string::String,

    /// Optional. The labels to associate with the session.
    /// Label **keys** must contain 1 to 63 characters, and must conform to
    /// [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt).
    /// Label **values** may be empty, but, if present, must contain 1 to 63
    /// characters, and must conform to [RFC
    /// 1035](https://www.ietf.org/rfc/rfc1035.txt). No more than 32 labels can be
    /// associated with a session.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Runtime configuration for the session execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub runtime_config: std::option::Option<crate::model::RuntimeConfig>,

    /// Optional. Environment configuration for the session execution.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub environment_config: std::option::Option<crate::model::EnvironmentConfig>,

    /// Optional. The email address of the user who owns the session.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user: std::string::String,

    /// Output only. Historical state information for the session.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub state_history: std::vec::Vec<crate::model::session::SessionStateHistory>,

    /// Optional. The session template used by the session.
    ///
    /// Only resource names, including project ID and location, are valid.
    ///
    /// Example:
    ///
    /// * `<https://www.googleapis.com/compute/v1/projects/>[project_id]/locations/[dataproc_region]/sessionTemplates/[template_id]`
    /// * `projects/[project_id]/locations/[dataproc_region]/sessionTemplates/[template_id]`
    ///
    /// The template must be in the same project and Dataproc region as the
    /// session.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub session_template: std::string::String,

    /// The session configuration.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub session_config: std::option::Option<crate::model::session::SessionConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Session {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Session::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uuid][crate::model::Session::uuid].
    pub fn set_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uuid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Session::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [runtime_info][crate::model::Session::runtime_info].
    pub fn set_runtime_info<
        T: std::convert::Into<std::option::Option<crate::model::RuntimeInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_info = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Session::state].
    pub fn set_state<T: std::convert::Into<crate::model::session::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_message][crate::model::Session::state_message].
    pub fn set_state_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_message = v.into();
        self
    }

    /// Sets the value of [state_time][crate::model::Session::state_time].
    pub fn set_state_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.state_time = v.into();
        self
    }

    /// Sets the value of [creator][crate::model::Session::creator].
    pub fn set_creator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.creator = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Session::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [runtime_config][crate::model::Session::runtime_config].
    pub fn set_runtime_config<
        T: std::convert::Into<std::option::Option<crate::model::RuntimeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.runtime_config = v.into();
        self
    }

    /// Sets the value of [environment_config][crate::model::Session::environment_config].
    pub fn set_environment_config<
        T: std::convert::Into<std::option::Option<crate::model::EnvironmentConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.environment_config = v.into();
        self
    }

    /// Sets the value of [user][crate::model::Session::user].
    pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [state_history][crate::model::Session::state_history].
    pub fn set_state_history<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::session::SessionStateHistory>,
    {
        use std::iter::Iterator;
        self.state_history = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [session_template][crate::model::Session::session_template].
    pub fn set_session_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.session_template = v.into();
        self
    }

    /// Sets the value of [session_config][crate::model::Session::session_config].
    ///
    /// Note that all the setters affecting `session_config` are mutually
    /// exclusive.
    pub fn set_session_config<
        T: std::convert::Into<std::option::Option<crate::model::session::SessionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.session_config = v.into();
        self
    }

    /// The value of [session_config][crate::model::Session::session_config]
    /// if it holds a `JupyterSession`, `None` if the field is not set or
    /// holds a different branch.
    pub fn jupyter_session(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::JupyterConfig>> {
        #[allow(unreachable_patterns)]
        self.session_config.as_ref().and_then(|v| match v {
            crate::model::session::SessionConfig::JupyterSession(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [session_config][crate::model::Session::session_config]
    /// to hold a `JupyterSession`.
    ///
    /// Note that all the setters affecting `session_config` are
    /// mutually exclusive.
    pub fn set_jupyter_session<
        T: std::convert::Into<std::boxed::Box<crate::model::JupyterConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.session_config = std::option::Option::Some(
            crate::model::session::SessionConfig::JupyterSession(v.into()),
        );
        self
    }

    /// The value of [session_config][crate::model::Session::session_config]
    /// if it holds a `SparkConnectSession`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_connect_session(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SparkConnectConfig>> {
        #[allow(unreachable_patterns)]
        self.session_config.as_ref().and_then(|v| match v {
            crate::model::session::SessionConfig::SparkConnectSession(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [session_config][crate::model::Session::session_config]
    /// to hold a `SparkConnectSession`.
    ///
    /// Note that all the setters affecting `session_config` are
    /// mutually exclusive.
    pub fn set_spark_connect_session<
        T: std::convert::Into<std::boxed::Box<crate::model::SparkConnectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.session_config = std::option::Option::Some(
            crate::model::session::SessionConfig::SparkConnectSession(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Session {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.Session"
    }
}

/// Defines additional types related to [Session].
pub mod session {
    #[allow(unused_imports)]
    use super::*;

    /// Historical state information.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SessionStateHistory {
        /// Output only. The state of the session at this point in the session
        /// history.
        pub state: crate::model::session::State,

        /// Output only. Details about the state at this point in the session
        /// history.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub state_message: std::string::String,

        /// Output only. The time when the session entered the historical state.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub state_start_time: std::option::Option<wkt::Timestamp>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SessionStateHistory {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::session::SessionStateHistory::state].
        pub fn set_state<T: std::convert::Into<crate::model::session::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [state_message][crate::model::session::SessionStateHistory::state_message].
        pub fn set_state_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.state_message = v.into();
            self
        }

        /// Sets the value of [state_start_time][crate::model::session::SessionStateHistory::state_start_time].
        pub fn set_state_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.state_start_time = v.into();
            self
        }
    }

    impl wkt::message::Message for SessionStateHistory {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataproc.v1.Session.SessionStateHistory"
        }
    }

    /// The session state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The session state is unknown.
        Unspecified,
        /// The session is created prior to running.
        Creating,
        /// The session is running.
        Active,
        /// The session is terminating.
        Terminating,
        /// The session is terminated successfully.
        Terminated,
        /// The session is no longer running due to an error.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Terminating => std::option::Option::Some(3),
                Self::Terminated => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Terminating => std::option::Option::Some("TERMINATING"),
                Self::Terminated => std::option::Option::Some("TERMINATED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Terminating,
                4 => Self::Terminated,
                5 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "TERMINATING" => Self::Terminating,
                "TERMINATED" => Self::Terminated,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Terminating => serializer.serialize_i32(3),
                Self::Terminated => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataproc.v1.Session.State",
            ))
        }
    }

    /// The session configuration.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SessionConfig {
        /// Optional. Jupyter session config.
        JupyterSession(std::boxed::Box<crate::model::JupyterConfig>),
        /// Optional. Spark Connect session config.
        SparkConnectSession(std::boxed::Box<crate::model::SparkConnectConfig>),
    }
}

/// Jupyter configuration for an interactive session.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct JupyterConfig {
    /// Optional. Kernel
    pub kernel: crate::model::jupyter_config::Kernel,

    /// Optional. Display name, shown in the Jupyter kernelspec card.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl JupyterConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kernel][crate::model::JupyterConfig::kernel].
    pub fn set_kernel<T: std::convert::Into<crate::model::jupyter_config::Kernel>>(
        mut self,
        v: T,
    ) -> Self {
        self.kernel = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::JupyterConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for JupyterConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.JupyterConfig"
    }
}

/// Defines additional types related to [JupyterConfig].
pub mod jupyter_config {
    #[allow(unused_imports)]
    use super::*;

    /// Jupyter kernel types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Kernel {
        /// The kernel is unknown.
        Unspecified,
        /// Python kernel.
        Python,
        /// Scala kernel.
        Scala,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Kernel::value] or
        /// [Kernel::name].
        UnknownValue(kernel::UnknownValue),
    }

    #[doc(hidden)]
    pub mod kernel {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Kernel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Python => std::option::Option::Some(1),
                Self::Scala => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("KERNEL_UNSPECIFIED"),
                Self::Python => std::option::Option::Some("PYTHON"),
                Self::Scala => std::option::Option::Some("SCALA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Kernel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Kernel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Kernel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Python,
                2 => Self::Scala,
                _ => Self::UnknownValue(kernel::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Kernel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "KERNEL_UNSPECIFIED" => Self::Unspecified,
                "PYTHON" => Self::Python,
                "SCALA" => Self::Scala,
                _ => Self::UnknownValue(kernel::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Kernel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Python => serializer.serialize_i32(1),
                Self::Scala => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Kernel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Kernel>::new(
                ".google.cloud.dataproc.v1.JupyterConfig.Kernel",
            ))
        }
    }
}

/// Spark Connect configuration for an interactive session.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SparkConnectConfig {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SparkConnectConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SparkConnectConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SparkConnectConfig"
    }
}

/// Runtime configuration for a workload.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RuntimeConfig {
    /// Optional. Version of the batch runtime.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Optional. Optional custom container image for the job runtime environment.
    /// If not specified, a default container image will be used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub container_image: std::string::String,

    /// Optional. A mapping of property names to values, which are used to
    /// configure workload execution.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Dependency repository configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub repository_config: std::option::Option<crate::model::RepositoryConfig>,

    /// Optional. Autotuning configuration of the workload.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub autotuning_config: std::option::Option<crate::model::AutotuningConfig>,

    /// Optional. Cohort identifier. Identifies families of the workloads having
    /// the same shape, e.g. daily ETL jobs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cohort: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RuntimeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::RuntimeConfig::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [container_image][crate::model::RuntimeConfig::container_image].
    pub fn set_container_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.container_image = v.into();
        self
    }

    /// Sets the value of [properties][crate::model::RuntimeConfig::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [repository_config][crate::model::RuntimeConfig::repository_config].
    pub fn set_repository_config<
        T: std::convert::Into<std::option::Option<crate::model::RepositoryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.repository_config = v.into();
        self
    }

    /// Sets the value of [autotuning_config][crate::model::RuntimeConfig::autotuning_config].
    pub fn set_autotuning_config<
        T: std::convert::Into<std::option::Option<crate::model::AutotuningConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.autotuning_config = v.into();
        self
    }

    /// Sets the value of [cohort][crate::model::RuntimeConfig::cohort].
    pub fn set_cohort<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cohort = v.into();
        self
    }
}

impl wkt::message::Message for RuntimeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.RuntimeConfig"
    }
}

/// Environment configuration for a workload.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EnvironmentConfig {
    /// Optional. Execution configuration for a workload.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub execution_config: std::option::Option<crate::model::ExecutionConfig>,

    /// Optional. Peripherals configuration that workload has access to.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub peripherals_config: std::option::Option<crate::model::PeripheralsConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnvironmentConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [execution_config][crate::model::EnvironmentConfig::execution_config].
    pub fn set_execution_config<
        T: std::convert::Into<std::option::Option<crate::model::ExecutionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.execution_config = v.into();
        self
    }

    /// Sets the value of [peripherals_config][crate::model::EnvironmentConfig::peripherals_config].
    pub fn set_peripherals_config<
        T: std::convert::Into<std::option::Option<crate::model::PeripheralsConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.peripherals_config = v.into();
        self
    }
}

impl wkt::message::Message for EnvironmentConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.EnvironmentConfig"
    }
}

/// Execution configuration for a workload.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExecutionConfig {
    /// Optional. Service account that used to execute workload.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// Optional. Tags used for network traffic control.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub network_tags: std::vec::Vec<std::string::String>,

    /// Optional. The Cloud KMS key to use for encryption.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key: std::string::String,

    /// Optional. Applies to sessions only. The duration to keep the session alive
    /// while it's idling. Exceeding this threshold causes the session to
    /// terminate. This field cannot be set on a batch workload. Minimum value is
    /// 10 minutes; maximum value is 14 days (see JSON representation of
    /// [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json)).
    /// Defaults to 1 hour if not set.
    /// If both `ttl` and `idle_ttl` are specified for an interactive session,
    /// the conditions are treated as `OR` conditions: the workload will be
    /// terminated when it has been idle for `idle_ttl` or when `ttl` has been
    /// exceeded, whichever occurs first.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub idle_ttl: std::option::Option<wkt::Duration>,

    /// Optional. The duration after which the workload will be terminated,
    /// specified as the JSON representation for
    /// [Duration](https://protobuf.dev/programming-guides/proto3/#json).
    /// When the workload exceeds this duration, it will be unconditionally
    /// terminated without waiting for ongoing work to finish. If `ttl` is not
    /// specified for a batch workload, the workload will be allowed to run until
    /// it exits naturally (or run forever without exiting). If `ttl` is not
    /// specified for an interactive session, it defaults to 24 hours. If `ttl` is
    /// not specified for a batch that uses 2.1+ runtime version, it defaults to 4
    /// hours. Minimum value is 10 minutes; maximum value is 14 days. If both `ttl`
    /// and `idle_ttl` are specified (for an interactive session), the conditions
    /// are treated as `OR` conditions: the workload will be terminated when it has
    /// been idle for `idle_ttl` or when `ttl` has been exceeded, whichever occurs
    /// first.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ttl: std::option::Option<wkt::Duration>,

    /// Optional. A Cloud Storage bucket used to stage workload dependencies,
    /// config files, and store workload output and other ephemeral data, such as
    /// Spark history files. If you do not specify a staging bucket, Cloud Dataproc
    /// will determine a Cloud Storage location according to the region where your
    /// workload is running, and then create and manage project-level, per-location
    /// staging and temporary buckets.
    /// **This field requires a Cloud Storage bucket name, not a `gs://...` URI to
    /// a Cloud Storage bucket.**
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub staging_bucket: std::string::String,

    /// Optional. Authentication configuration used to set the default identity for
    /// the workload execution. The config specifies the type of identity
    /// (service account or user) that will be used by workloads to access
    /// resources on the project(s).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub authentication_config: std::option::Option<crate::model::AuthenticationConfig>,

    /// Network configuration for workload execution.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub network: std::option::Option<crate::model::execution_config::Network>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExecutionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_account][crate::model::ExecutionConfig::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [network_tags][crate::model::ExecutionConfig::network_tags].
    pub fn set_network_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.network_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kms_key][crate::model::ExecutionConfig::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }

    /// Sets the value of [idle_ttl][crate::model::ExecutionConfig::idle_ttl].
    pub fn set_idle_ttl<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.idle_ttl = v.into();
        self
    }

    /// Sets the value of [ttl][crate::model::ExecutionConfig::ttl].
    pub fn set_ttl<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ttl = v.into();
        self
    }

    /// Sets the value of [staging_bucket][crate::model::ExecutionConfig::staging_bucket].
    pub fn set_staging_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.staging_bucket = v.into();
        self
    }

    /// Sets the value of [authentication_config][crate::model::ExecutionConfig::authentication_config].
    pub fn set_authentication_config<
        T: std::convert::Into<std::option::Option<crate::model::AuthenticationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authentication_config = v.into();
        self
    }

    /// Sets the value of [network][crate::model::ExecutionConfig::network].
    ///
    /// Note that all the setters affecting `network` are mutually
    /// exclusive.
    pub fn set_network<
        T: std::convert::Into<std::option::Option<crate::model::execution_config::Network>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.network = v.into();
        self
    }

    /// The value of [network][crate::model::ExecutionConfig::network]
    /// if it holds a `NetworkUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn network_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.network.as_ref().and_then(|v| match v {
            crate::model::execution_config::Network::NetworkUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [network][crate::model::ExecutionConfig::network]
    /// to hold a `NetworkUri`.
    ///
    /// Note that all the setters affecting `network` are
    /// mutually exclusive.
    pub fn set_network_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = std::option::Option::Some(
            crate::model::execution_config::Network::NetworkUri(v.into()),
        );
        self
    }

    /// The value of [network][crate::model::ExecutionConfig::network]
    /// if it holds a `SubnetworkUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn subnetwork_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.network.as_ref().and_then(|v| match v {
            crate::model::execution_config::Network::SubnetworkUri(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [network][crate::model::ExecutionConfig::network]
    /// to hold a `SubnetworkUri`.
    ///
    /// Note that all the setters affecting `network` are
    /// mutually exclusive.
    pub fn set_subnetwork_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = std::option::Option::Some(
            crate::model::execution_config::Network::SubnetworkUri(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExecutionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ExecutionConfig"
    }
}

/// Defines additional types related to [ExecutionConfig].
pub mod execution_config {
    #[allow(unused_imports)]
    use super::*;

    /// Network configuration for workload execution.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Network {
        /// Optional. Network URI to connect workload to.
        NetworkUri(std::string::String),
        /// Optional. Subnetwork URI to connect workload to.
        SubnetworkUri(std::string::String),
    }
}

/// Spark History Server configuration for the workload.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SparkHistoryServerConfig {
    /// Optional. Resource name of an existing Dataproc Cluster to act as a Spark
    /// History Server for the workload.
    ///
    /// Example:
    ///
    /// * `projects/[project_id]/regions/[region]/clusters/[cluster_name]`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataproc_cluster: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SparkHistoryServerConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataproc_cluster][crate::model::SparkHistoryServerConfig::dataproc_cluster].
    pub fn set_dataproc_cluster<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataproc_cluster = v.into();
        self
    }
}

impl wkt::message::Message for SparkHistoryServerConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.SparkHistoryServerConfig"
    }
}

/// Auxiliary services configuration for a workload.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PeripheralsConfig {
    /// Optional. Resource name of an existing Dataproc Metastore service.
    ///
    /// Example:
    ///
    /// * `projects/[project_id]/locations/[region]/services/[service_id]`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metastore_service: std::string::String,

    /// Optional. The Spark History Server configuration for the workload.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub spark_history_server_config: std::option::Option<crate::model::SparkHistoryServerConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PeripheralsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metastore_service][crate::model::PeripheralsConfig::metastore_service].
    pub fn set_metastore_service<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metastore_service = v.into();
        self
    }

    /// Sets the value of [spark_history_server_config][crate::model::PeripheralsConfig::spark_history_server_config].
    pub fn set_spark_history_server_config<
        T: std::convert::Into<std::option::Option<crate::model::SparkHistoryServerConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.spark_history_server_config = v.into();
        self
    }
}

impl wkt::message::Message for PeripheralsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.PeripheralsConfig"
    }
}

/// Runtime information about workload execution.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RuntimeInfo {
    /// Output only. Map of remote access endpoints (such as web interfaces and
    /// APIs) to their URIs.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub endpoints: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. A URI pointing to the location of the stdout and stderr of the
    /// workload.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub output_uri: std::string::String,

    /// Output only. A URI pointing to the location of the diagnostics tarball.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub diagnostic_output_uri: std::string::String,

    /// Output only. Approximate workload resource usage, calculated when
    /// the workload completes (see [Dataproc Serverless pricing]
    /// (<https://cloud.google.com/dataproc-serverless/pricing>)).
    ///
    /// **Note:** This metric calculation may change in the future, for
    /// example, to capture cumulative workload resource
    /// consumption during workload execution (see the
    /// [Dataproc Serverless release notes]
    /// (<https://cloud.google.com/dataproc-serverless/docs/release-notes>)
    /// for announcements, changes, fixes
    /// and other Dataproc developments).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub approximate_usage: std::option::Option<crate::model::UsageMetrics>,

    /// Output only. Snapshot of current workload resource usage.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub current_usage: std::option::Option<crate::model::UsageSnapshot>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RuntimeInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [endpoints][crate::model::RuntimeInfo::endpoints].
    pub fn set_endpoints<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.endpoints = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [output_uri][crate::model::RuntimeInfo::output_uri].
    pub fn set_output_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output_uri = v.into();
        self
    }

    /// Sets the value of [diagnostic_output_uri][crate::model::RuntimeInfo::diagnostic_output_uri].
    pub fn set_diagnostic_output_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.diagnostic_output_uri = v.into();
        self
    }

    /// Sets the value of [approximate_usage][crate::model::RuntimeInfo::approximate_usage].
    pub fn set_approximate_usage<
        T: std::convert::Into<std::option::Option<crate::model::UsageMetrics>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.approximate_usage = v.into();
        self
    }

    /// Sets the value of [current_usage][crate::model::RuntimeInfo::current_usage].
    pub fn set_current_usage<
        T: std::convert::Into<std::option::Option<crate::model::UsageSnapshot>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.current_usage = v.into();
        self
    }
}

impl wkt::message::Message for RuntimeInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.RuntimeInfo"
    }
}

/// Usage metrics represent approximate total resources consumed by a workload.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UsageMetrics {
    /// Optional. DCU (Dataproc Compute Units) usage in (`milliDCU` x `seconds`)
    /// (see [Dataproc Serverless pricing]
    /// (<https://cloud.google.com/dataproc-serverless/pricing>)).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub milli_dcu_seconds: i64,

    /// Optional. Shuffle storage usage in (`GB` x `seconds`) (see
    /// [Dataproc Serverless pricing]
    /// (<https://cloud.google.com/dataproc-serverless/pricing>)).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub shuffle_storage_gb_seconds: i64,

    /// Optional. Accelerator usage in (`milliAccelerator` x `seconds`) (see
    /// [Dataproc Serverless pricing]
    /// (<https://cloud.google.com/dataproc-serverless/pricing>)).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub milli_accelerator_seconds: i64,

    /// Optional. Accelerator type being used, if any
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub accelerator_type: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UsageMetrics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [milli_dcu_seconds][crate::model::UsageMetrics::milli_dcu_seconds].
    pub fn set_milli_dcu_seconds<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.milli_dcu_seconds = v.into();
        self
    }

    /// Sets the value of [shuffle_storage_gb_seconds][crate::model::UsageMetrics::shuffle_storage_gb_seconds].
    pub fn set_shuffle_storage_gb_seconds<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.shuffle_storage_gb_seconds = v.into();
        self
    }

    /// Sets the value of [milli_accelerator_seconds][crate::model::UsageMetrics::milli_accelerator_seconds].
    pub fn set_milli_accelerator_seconds<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.milli_accelerator_seconds = v.into();
        self
    }

    /// Sets the value of [accelerator_type][crate::model::UsageMetrics::accelerator_type].
    pub fn set_accelerator_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.accelerator_type = v.into();
        self
    }
}

impl wkt::message::Message for UsageMetrics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.UsageMetrics"
    }
}

/// The usage snapshot represents the resources consumed by a workload at a
/// specified time.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UsageSnapshot {
    /// Optional. Milli (one-thousandth) Dataproc Compute Units (DCUs) (see
    /// [Dataproc Serverless pricing]
    /// (<https://cloud.google.com/dataproc-serverless/pricing>)).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub milli_dcu: i64,

    /// Optional. Shuffle Storage in gigabytes (GB). (see [Dataproc Serverless
    /// pricing] (<https://cloud.google.com/dataproc-serverless/pricing>))
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub shuffle_storage_gb: i64,

    /// Optional. Milli (one-thousandth) Dataproc Compute Units (DCUs) charged at
    /// premium tier (see [Dataproc Serverless pricing]
    /// (<https://cloud.google.com/dataproc-serverless/pricing>)).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub milli_dcu_premium: i64,

    /// Optional. Shuffle Storage in gigabytes (GB) charged at premium tier. (see
    /// [Dataproc Serverless pricing]
    /// (<https://cloud.google.com/dataproc-serverless/pricing>))
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub shuffle_storage_gb_premium: i64,

    /// Optional. Milli (one-thousandth) accelerator. (see [Dataproc
    /// Serverless pricing] (<https://cloud.google.com/dataproc-serverless/pricing>))
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub milli_accelerator: i64,

    /// Optional. Accelerator type being used, if any
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub accelerator_type: std::string::String,

    /// Optional. The timestamp of the usage snapshot.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub snapshot_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UsageSnapshot {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [milli_dcu][crate::model::UsageSnapshot::milli_dcu].
    pub fn set_milli_dcu<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.milli_dcu = v.into();
        self
    }

    /// Sets the value of [shuffle_storage_gb][crate::model::UsageSnapshot::shuffle_storage_gb].
    pub fn set_shuffle_storage_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.shuffle_storage_gb = v.into();
        self
    }

    /// Sets the value of [milli_dcu_premium][crate::model::UsageSnapshot::milli_dcu_premium].
    pub fn set_milli_dcu_premium<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.milli_dcu_premium = v.into();
        self
    }

    /// Sets the value of [shuffle_storage_gb_premium][crate::model::UsageSnapshot::shuffle_storage_gb_premium].
    pub fn set_shuffle_storage_gb_premium<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.shuffle_storage_gb_premium = v.into();
        self
    }

    /// Sets the value of [milli_accelerator][crate::model::UsageSnapshot::milli_accelerator].
    pub fn set_milli_accelerator<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.milli_accelerator = v.into();
        self
    }

    /// Sets the value of [accelerator_type][crate::model::UsageSnapshot::accelerator_type].
    pub fn set_accelerator_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.accelerator_type = v.into();
        self
    }

    /// Sets the value of [snapshot_time][crate::model::UsageSnapshot::snapshot_time].
    pub fn set_snapshot_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.snapshot_time = v.into();
        self
    }
}

impl wkt::message::Message for UsageSnapshot {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.UsageSnapshot"
    }
}

/// The cluster's GKE config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GkeClusterConfig {
    /// Optional. A target GKE cluster to deploy to. It must be in the same project
    /// and region as the Dataproc cluster (the GKE cluster can be zonal or
    /// regional). Format:
    /// 'projects/{project}/locations/{location}/clusters/{cluster_id}'
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gke_cluster_target: std::string::String,

    /// Optional. GKE node pools where workloads will be scheduled. At least one
    /// node pool must be assigned the `DEFAULT`
    /// [GkeNodePoolTarget.Role][google.cloud.dataproc.v1.GkeNodePoolTarget.Role].
    /// If a `GkeNodePoolTarget` is not specified, Dataproc constructs a `DEFAULT`
    /// `GkeNodePoolTarget`. Each role can be given to only one
    /// `GkeNodePoolTarget`. All node pools must have the same location settings.
    ///
    /// [google.cloud.dataproc.v1.GkeNodePoolTarget.Role]: crate::model::gke_node_pool_target::Role
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub node_pool_target: std::vec::Vec<crate::model::GkeNodePoolTarget>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GkeClusterConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gke_cluster_target][crate::model::GkeClusterConfig::gke_cluster_target].
    pub fn set_gke_cluster_target<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.gke_cluster_target = v.into();
        self
    }

    /// Sets the value of [node_pool_target][crate::model::GkeClusterConfig::node_pool_target].
    pub fn set_node_pool_target<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GkeNodePoolTarget>,
    {
        use std::iter::Iterator;
        self.node_pool_target = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GkeClusterConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GkeClusterConfig"
    }
}

/// The configuration for running the Dataproc cluster on Kubernetes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct KubernetesClusterConfig {
    /// Optional. A namespace within the Kubernetes cluster to deploy into. If this
    /// namespace does not exist, it is created. If it exists, Dataproc verifies
    /// that another Dataproc VirtualCluster is not installed into it. If not
    /// specified, the name of the Dataproc Cluster is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kubernetes_namespace: std::string::String,

    /// Optional. The software configuration for this Dataproc cluster running on
    /// Kubernetes.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub kubernetes_software_config: std::option::Option<crate::model::KubernetesSoftwareConfig>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::kubernetes_cluster_config::Config>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KubernetesClusterConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kubernetes_namespace][crate::model::KubernetesClusterConfig::kubernetes_namespace].
    pub fn set_kubernetes_namespace<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kubernetes_namespace = v.into();
        self
    }

    /// Sets the value of [kubernetes_software_config][crate::model::KubernetesClusterConfig::kubernetes_software_config].
    pub fn set_kubernetes_software_config<
        T: std::convert::Into<std::option::Option<crate::model::KubernetesSoftwareConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.kubernetes_software_config = v.into();
        self
    }

    /// Sets the value of [config][crate::model::KubernetesClusterConfig::config].
    ///
    /// Note that all the setters affecting `config` are mutually
    /// exclusive.
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::kubernetes_cluster_config::Config>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// The value of [config][crate::model::KubernetesClusterConfig::config]
    /// if it holds a `GkeClusterConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gke_cluster_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GkeClusterConfig>> {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::kubernetes_cluster_config::Config::GkeClusterConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [config][crate::model::KubernetesClusterConfig::config]
    /// to hold a `GkeClusterConfig`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_gke_cluster_config<
        T: std::convert::Into<std::boxed::Box<crate::model::GkeClusterConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = std::option::Option::Some(
            crate::model::kubernetes_cluster_config::Config::GkeClusterConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for KubernetesClusterConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.KubernetesClusterConfig"
    }
}

/// Defines additional types related to [KubernetesClusterConfig].
pub mod kubernetes_cluster_config {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Config {
        /// Required. The configuration for running the Dataproc cluster on GKE.
        GkeClusterConfig(std::boxed::Box<crate::model::GkeClusterConfig>),
    }
}

/// The software configuration for this Dataproc cluster running on Kubernetes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct KubernetesSoftwareConfig {
    /// The components that should be installed in this Dataproc cluster. The key
    /// must be a string from the KubernetesComponent enumeration. The value is
    /// the version of the software to be installed.
    /// At least one entry must be specified.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub component_version: std::collections::HashMap<std::string::String, std::string::String>,

    /// The properties to set on daemon config files.
    ///
    /// Property keys are specified in `prefix:property` format, for example
    /// `spark:spark.kubernetes.container.image`. The following are supported
    /// prefixes and their mappings:
    ///
    /// * spark:  `spark-defaults.conf`
    ///
    /// For more information, see [Cluster
    /// properties](https://cloud.google.com/dataproc/docs/concepts/cluster-properties).
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub properties: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KubernetesSoftwareConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [component_version][crate::model::KubernetesSoftwareConfig::component_version].
    pub fn set_component_version<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.component_version = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [properties][crate::model::KubernetesSoftwareConfig::properties].
    pub fn set_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for KubernetesSoftwareConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.KubernetesSoftwareConfig"
    }
}

/// GKE node pools that Dataproc workloads run on.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GkeNodePoolTarget {
    /// Required. The target GKE node pool.
    /// Format:
    /// 'projects/{project}/locations/{location}/clusters/{cluster}/nodePools/{node_pool}'
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub node_pool: std::string::String,

    /// Required. The roles associated with the GKE node pool.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub roles: std::vec::Vec<crate::model::gke_node_pool_target::Role>,

    /// Input only. The configuration for the GKE node pool.
    ///
    /// If specified, Dataproc attempts to create a node pool with the
    /// specified shape. If one with the same name already exists, it is
    /// verified against all specified fields. If a field differs, the
    /// virtual cluster creation will fail.
    ///
    /// If omitted, any node pool with the specified name is used. If a
    /// node pool with the specified name does not exist, Dataproc create a
    /// node pool with default values.
    ///
    /// This is an input only field. It will not be returned by the API.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub node_pool_config: std::option::Option<crate::model::GkeNodePoolConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GkeNodePoolTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [node_pool][crate::model::GkeNodePoolTarget::node_pool].
    pub fn set_node_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_pool = v.into();
        self
    }

    /// Sets the value of [roles][crate::model::GkeNodePoolTarget::roles].
    pub fn set_roles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::gke_node_pool_target::Role>,
    {
        use std::iter::Iterator;
        self.roles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [node_pool_config][crate::model::GkeNodePoolTarget::node_pool_config].
    pub fn set_node_pool_config<
        T: std::convert::Into<std::option::Option<crate::model::GkeNodePoolConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.node_pool_config = v.into();
        self
    }
}

impl wkt::message::Message for GkeNodePoolTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GkeNodePoolTarget"
    }
}

/// Defines additional types related to [GkeNodePoolTarget].
pub mod gke_node_pool_target {
    #[allow(unused_imports)]
    use super::*;

    /// `Role` specifies the tasks that will run on the node pool. Roles can be
    /// specific to workloads. Exactly one
    /// [GkeNodePoolTarget][google.cloud.dataproc.v1.GkeNodePoolTarget] within the
    /// virtual cluster must have the `DEFAULT` role, which is used to run all
    /// workloads that are not associated with a node pool.
    ///
    /// [google.cloud.dataproc.v1.GkeNodePoolTarget]: crate::model::GkeNodePoolTarget
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Role {
        /// Role is unspecified.
        Unspecified,
        /// At least one node pool must have the `DEFAULT` role.
        /// Work assigned to a role that is not associated with a node pool
        /// is assigned to the node pool with the `DEFAULT` role. For example,
        /// work assigned to the `CONTROLLER` role will be assigned to the node pool
        /// with the `DEFAULT` role if no node pool has the `CONTROLLER` role.
        Default,
        /// Run work associated with the Dataproc control plane (for example,
        /// controllers and webhooks). Very low resource requirements.
        Controller,
        /// Run work associated with a Spark driver of a job.
        SparkDriver,
        /// Run work associated with a Spark executor of a job.
        SparkExecutor,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Role::value] or
        /// [Role::name].
        UnknownValue(role::UnknownValue),
    }

    #[doc(hidden)]
    pub mod role {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Role {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Default => std::option::Option::Some(1),
                Self::Controller => std::option::Option::Some(2),
                Self::SparkDriver => std::option::Option::Some(3),
                Self::SparkExecutor => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROLE_UNSPECIFIED"),
                Self::Default => std::option::Option::Some("DEFAULT"),
                Self::Controller => std::option::Option::Some("CONTROLLER"),
                Self::SparkDriver => std::option::Option::Some("SPARK_DRIVER"),
                Self::SparkExecutor => std::option::Option::Some("SPARK_EXECUTOR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Role {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Role {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Role {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Default,
                2 => Self::Controller,
                3 => Self::SparkDriver,
                4 => Self::SparkExecutor,
                _ => Self::UnknownValue(role::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Role {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROLE_UNSPECIFIED" => Self::Unspecified,
                "DEFAULT" => Self::Default,
                "CONTROLLER" => Self::Controller,
                "SPARK_DRIVER" => Self::SparkDriver,
                "SPARK_EXECUTOR" => Self::SparkExecutor,
                _ => Self::UnknownValue(role::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Role {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Default => serializer.serialize_i32(1),
                Self::Controller => serializer.serialize_i32(2),
                Self::SparkDriver => serializer.serialize_i32(3),
                Self::SparkExecutor => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Role {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Role>::new(
                ".google.cloud.dataproc.v1.GkeNodePoolTarget.Role",
            ))
        }
    }
}

/// The configuration of a GKE node pool used by a [Dataproc-on-GKE
/// cluster](https://cloud.google.com/dataproc/docs/concepts/jobs/dataproc-gke#create-a-dataproc-on-gke-cluster).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GkeNodePoolConfig {
    /// Optional. The node pool configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::gke_node_pool_config::GkeNodeConfig>,

    /// Optional. The list of Compute Engine
    /// [zones](https://cloud.google.com/compute/docs/zones#available) where
    /// node pool nodes associated with a Dataproc on GKE virtual cluster
    /// will be located.
    ///
    /// **Note:** All node pools associated with a virtual cluster
    /// must be located in the same region as the virtual cluster, and they must
    /// be located in the same zone within that region.
    ///
    /// If a location is not specified during node pool creation, Dataproc on GKE
    /// will choose the zone.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub locations: std::vec::Vec<std::string::String>,

    /// Optional. The autoscaler configuration for this node pool. The autoscaler
    /// is enabled only when a valid configuration is present.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub autoscaling:
        std::option::Option<crate::model::gke_node_pool_config::GkeNodePoolAutoscalingConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GkeNodePoolConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config][crate::model::GkeNodePoolConfig::config].
    pub fn set_config<
        T: std::convert::Into<std::option::Option<crate::model::gke_node_pool_config::GkeNodeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [locations][crate::model::GkeNodePoolConfig::locations].
    pub fn set_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [autoscaling][crate::model::GkeNodePoolConfig::autoscaling].
    pub fn set_autoscaling<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::gke_node_pool_config::GkeNodePoolAutoscalingConfig,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.autoscaling = v.into();
        self
    }
}

impl wkt::message::Message for GkeNodePoolConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GkeNodePoolConfig"
    }
}

/// Defines additional types related to [GkeNodePoolConfig].
pub mod gke_node_pool_config {
    #[allow(unused_imports)]
    use super::*;

    /// Parameters that describe cluster nodes.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GkeNodeConfig {
        /// Optional. The name of a Compute Engine [machine
        /// type](https://cloud.google.com/compute/docs/machine-types).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub machine_type: std::string::String,

        /// Optional. The number of local SSD disks to attach to the node, which is
        /// limited by the maximum number of disks allowable per zone (see [Adding
        /// Local SSDs](https://cloud.google.com/compute/docs/disks/local-ssd)).
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub local_ssd_count: i32,

        /// Optional. Whether the nodes are created as legacy [preemptible VM
        /// instances] (<https://cloud.google.com/compute/docs/instances/preemptible>).
        /// Also see
        /// [Spot][google.cloud.dataproc.v1.GkeNodePoolConfig.GkeNodeConfig.spot]
        /// VMs, preemptible VM instances without a maximum lifetime. Legacy and Spot
        /// preemptible nodes cannot be used in a node pool with the `CONTROLLER`
        /// [role]
        /// (/dataproc/docs/reference/rest/v1/projects.regions.clusters#role)
        /// or in the DEFAULT node pool if the CONTROLLER role is not assigned (the
        /// DEFAULT node pool will assume the CONTROLLER role).
        ///
        /// [google.cloud.dataproc.v1.GkeNodePoolConfig.GkeNodeConfig.spot]: crate::model::gke_node_pool_config::GkeNodeConfig::spot
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub preemptible: bool,

        /// Optional. A list of [hardware
        /// accelerators](https://cloud.google.com/compute/docs/gpus) to attach to
        /// each node.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub accelerators:
            std::vec::Vec<crate::model::gke_node_pool_config::GkeNodePoolAcceleratorConfig>,

        /// Optional. [Minimum CPU
        /// platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
        /// to be used by this instance. The instance may be scheduled on the
        /// specified or a newer CPU platform. Specify the friendly names of CPU
        /// platforms, such as "Intel Haswell"` or Intel Sandy Bridge".
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub min_cpu_platform: std::string::String,

        /// Optional. The [Customer Managed Encryption Key (CMEK)]
        /// (<https://cloud.google.com/kubernetes-engine/docs/how-to/using-cmek>)
        /// used to encrypt the boot disk attached to each node in the node pool.
        /// Specify the key using the following format:
        /// \<code\>projects/\<var\>KEY_PROJECT_ID\</var\>/locations/\<var\>LOCATION\</var\>/keyRings/\<var\>RING_NAME\</var\>/cryptoKeys/\<var\>KEY_NAME\</var\>\</code\>.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub boot_disk_kms_key: std::string::String,

        /// Optional. Whether the nodes are created as [Spot VM instances]
        /// (<https://cloud.google.com/compute/docs/instances/spot>).
        /// Spot VMs are the latest update to legacy
        /// [preemptible
        /// VMs][google.cloud.dataproc.v1.GkeNodePoolConfig.GkeNodeConfig.preemptible].
        /// Spot VMs do not have a maximum lifetime. Legacy and Spot preemptible
        /// nodes cannot be used in a node pool with the `CONTROLLER`
        /// [role](/dataproc/docs/reference/rest/v1/projects.regions.clusters#role)
        /// or in the DEFAULT node pool if the CONTROLLER role is not assigned (the
        /// DEFAULT node pool will assume the CONTROLLER role).
        ///
        /// [google.cloud.dataproc.v1.GkeNodePoolConfig.GkeNodeConfig.preemptible]: crate::model::gke_node_pool_config::GkeNodeConfig::preemptible
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub spot: bool,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GkeNodeConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [machine_type][crate::model::gke_node_pool_config::GkeNodeConfig::machine_type].
        pub fn set_machine_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.machine_type = v.into();
            self
        }

        /// Sets the value of [local_ssd_count][crate::model::gke_node_pool_config::GkeNodeConfig::local_ssd_count].
        pub fn set_local_ssd_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.local_ssd_count = v.into();
            self
        }

        /// Sets the value of [preemptible][crate::model::gke_node_pool_config::GkeNodeConfig::preemptible].
        pub fn set_preemptible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.preemptible = v.into();
            self
        }

        /// Sets the value of [accelerators][crate::model::gke_node_pool_config::GkeNodeConfig::accelerators].
        pub fn set_accelerators<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::gke_node_pool_config::GkeNodePoolAcceleratorConfig>,
        {
            use std::iter::Iterator;
            self.accelerators = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [min_cpu_platform][crate::model::gke_node_pool_config::GkeNodeConfig::min_cpu_platform].
        pub fn set_min_cpu_platform<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.min_cpu_platform = v.into();
            self
        }

        /// Sets the value of [boot_disk_kms_key][crate::model::gke_node_pool_config::GkeNodeConfig::boot_disk_kms_key].
        pub fn set_boot_disk_kms_key<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.boot_disk_kms_key = v.into();
            self
        }

        /// Sets the value of [spot][crate::model::gke_node_pool_config::GkeNodeConfig::spot].
        pub fn set_spot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.spot = v.into();
            self
        }
    }

    impl wkt::message::Message for GkeNodeConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataproc.v1.GkeNodePoolConfig.GkeNodeConfig"
        }
    }

    /// A GkeNodeConfigAcceleratorConfig represents a Hardware Accelerator request
    /// for a node pool.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GkeNodePoolAcceleratorConfig {
        /// The number of accelerator cards exposed to an instance.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub accelerator_count: i64,

        /// The accelerator type resource namename (see GPUs on Compute Engine).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub accelerator_type: std::string::String,

        /// Size of partitions to create on the GPU. Valid values are described in
        /// the NVIDIA [mig user
        /// guide](https://docs.nvidia.com/datacenter/tesla/mig-user-guide/#partitioning).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub gpu_partition_size: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GkeNodePoolAcceleratorConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [accelerator_count][crate::model::gke_node_pool_config::GkeNodePoolAcceleratorConfig::accelerator_count].
        pub fn set_accelerator_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.accelerator_count = v.into();
            self
        }

        /// Sets the value of [accelerator_type][crate::model::gke_node_pool_config::GkeNodePoolAcceleratorConfig::accelerator_type].
        pub fn set_accelerator_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.accelerator_type = v.into();
            self
        }

        /// Sets the value of [gpu_partition_size][crate::model::gke_node_pool_config::GkeNodePoolAcceleratorConfig::gpu_partition_size].
        pub fn set_gpu_partition_size<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.gpu_partition_size = v.into();
            self
        }
    }

    impl wkt::message::Message for GkeNodePoolAcceleratorConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataproc.v1.GkeNodePoolConfig.GkeNodePoolAcceleratorConfig"
        }
    }

    /// GkeNodePoolAutoscaling contains information the cluster autoscaler needs to
    /// adjust the size of the node pool to the current cluster usage.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GkeNodePoolAutoscalingConfig {
        /// The minimum number of nodes in the node pool. Must be >= 0 and <=
        /// max_node_count.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub min_node_count: i32,

        /// The maximum number of nodes in the node pool. Must be >= min_node_count,
        /// and must be > 0.
        /// **Note:** Quota must be sufficient to scale up the cluster.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        pub max_node_count: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GkeNodePoolAutoscalingConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [min_node_count][crate::model::gke_node_pool_config::GkeNodePoolAutoscalingConfig::min_node_count].
        pub fn set_min_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.min_node_count = v.into();
            self
        }

        /// Sets the value of [max_node_count][crate::model::gke_node_pool_config::GkeNodePoolAutoscalingConfig::max_node_count].
        pub fn set_max_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_node_count = v.into();
            self
        }
    }

    impl wkt::message::Message for GkeNodePoolAutoscalingConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataproc.v1.GkeNodePoolConfig.GkeNodePoolAutoscalingConfig"
        }
    }
}

/// Authentication configuration for a workload is used to set the default
/// identity for the workload execution.
/// The config specifies the type of identity (service account or user) that
/// will be used by workloads to access resources on the project(s).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AuthenticationConfig {
    /// Optional. Authentication type for the user workload running in containers.
    pub user_workload_authentication_type: crate::model::authentication_config::AuthenticationType,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuthenticationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_workload_authentication_type][crate::model::AuthenticationConfig::user_workload_authentication_type].
    pub fn set_user_workload_authentication_type<
        T: std::convert::Into<crate::model::authentication_config::AuthenticationType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_workload_authentication_type = v.into();
        self
    }
}

impl wkt::message::Message for AuthenticationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.AuthenticationConfig"
    }
}

/// Defines additional types related to [AuthenticationConfig].
pub mod authentication_config {
    #[allow(unused_imports)]
    use super::*;

    /// Authentication types for workload execution.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AuthenticationType {
        /// If AuthenticationType is unspecified then END_USER_CREDENTIALS is used
        /// for 3.0 and newer runtimes, and SERVICE_ACCOUNT is used for older
        /// runtimes.
        Unspecified,
        /// Use service account credentials for authenticating to other services.
        ServiceAccount,
        /// Use OAuth credentials associated with the workload creator/user for
        /// authenticating to other services.
        EndUserCredentials,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AuthenticationType::value] or
        /// [AuthenticationType::name].
        UnknownValue(authentication_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod authentication_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AuthenticationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ServiceAccount => std::option::Option::Some(1),
                Self::EndUserCredentials => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("AUTHENTICATION_TYPE_UNSPECIFIED"),
                Self::ServiceAccount => std::option::Option::Some("SERVICE_ACCOUNT"),
                Self::EndUserCredentials => std::option::Option::Some("END_USER_CREDENTIALS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AuthenticationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AuthenticationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AuthenticationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ServiceAccount,
                2 => Self::EndUserCredentials,
                _ => Self::UnknownValue(authentication_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AuthenticationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AUTHENTICATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SERVICE_ACCOUNT" => Self::ServiceAccount,
                "END_USER_CREDENTIALS" => Self::EndUserCredentials,
                _ => Self::UnknownValue(authentication_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AuthenticationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ServiceAccount => serializer.serialize_i32(1),
                Self::EndUserCredentials => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AuthenticationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AuthenticationType>::new(
                ".google.cloud.dataproc.v1.AuthenticationConfig.AuthenticationType",
            ))
        }
    }
}

/// Autotuning configuration of the workload.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutotuningConfig {
    /// Optional. Scenarios for which tunings are applied.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub scenarios: std::vec::Vec<crate::model::autotuning_config::Scenario>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutotuningConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scenarios][crate::model::AutotuningConfig::scenarios].
    pub fn set_scenarios<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::autotuning_config::Scenario>,
    {
        use std::iter::Iterator;
        self.scenarios = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AutotuningConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.AutotuningConfig"
    }
}

/// Defines additional types related to [AutotuningConfig].
pub mod autotuning_config {
    #[allow(unused_imports)]
    use super::*;

    /// Scenario represents a specific goal that autotuning will attempt to achieve
    /// by modifying workloads.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scenario {
        /// Default value.
        Unspecified,
        /// Scaling recommendations such as initialExecutors.
        Scaling,
        /// Adding hints for potential relation broadcasts.
        BroadcastHashJoin,
        /// Memory management for workloads.
        Memory,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Scenario::value] or
        /// [Scenario::name].
        UnknownValue(scenario::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scenario {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Scenario {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Scaling => std::option::Option::Some(2),
                Self::BroadcastHashJoin => std::option::Option::Some(3),
                Self::Memory => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCENARIO_UNSPECIFIED"),
                Self::Scaling => std::option::Option::Some("SCALING"),
                Self::BroadcastHashJoin => std::option::Option::Some("BROADCAST_HASH_JOIN"),
                Self::Memory => std::option::Option::Some("MEMORY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Scenario {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Scenario {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Scenario {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::Scaling,
                3 => Self::BroadcastHashJoin,
                4 => Self::Memory,
                _ => Self::UnknownValue(scenario::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Scenario {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCENARIO_UNSPECIFIED" => Self::Unspecified,
                "SCALING" => Self::Scaling,
                "BROADCAST_HASH_JOIN" => Self::BroadcastHashJoin,
                "MEMORY" => Self::Memory,
                _ => Self::UnknownValue(scenario::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Scenario {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Scaling => serializer.serialize_i32(2),
                Self::BroadcastHashJoin => serializer.serialize_i32(3),
                Self::Memory => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Scenario {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scenario>::new(
                ".google.cloud.dataproc.v1.AutotuningConfig.Scenario",
            ))
        }
    }
}

/// Configuration for dependency repositories
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RepositoryConfig {
    /// Optional. Configuration for PyPi repository.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub pypi_repository_config: std::option::Option<crate::model::PyPiRepositoryConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepositoryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pypi_repository_config][crate::model::RepositoryConfig::pypi_repository_config].
    pub fn set_pypi_repository_config<
        T: std::convert::Into<std::option::Option<crate::model::PyPiRepositoryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.pypi_repository_config = v.into();
        self
    }
}

impl wkt::message::Message for RepositoryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.RepositoryConfig"
    }
}

/// Configuration for PyPi repository
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PyPiRepositoryConfig {
    /// Optional. PyPi repository address
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub pypi_repository: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PyPiRepositoryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pypi_repository][crate::model::PyPiRepositoryConfig::pypi_repository].
    pub fn set_pypi_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pypi_repository = v.into();
        self
    }
}

impl wkt::message::Message for PyPiRepositoryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.PyPiRepositoryConfig"
    }
}

/// A Dataproc workflow template resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkflowTemplate {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Output only. The resource name of the workflow template, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.workflowTemplates`, the resource name of the
    ///   template has the following format:
    ///   `projects/{project_id}/regions/{region}/workflowTemplates/{template_id}`
    ///
    /// * For `projects.locations.workflowTemplates`, the resource name of the
    ///   template has the following format:
    ///   `projects/{project_id}/locations/{location}/workflowTemplates/{template_id}`
    ///
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Used to perform a consistent read-modify-write.
    ///
    /// This field should be left blank for a `CreateWorkflowTemplate` request. It
    /// is required for an `UpdateWorkflowTemplate` request, and must match the
    /// current server version. A typical update template flow would fetch the
    /// current template with a `GetWorkflowTemplate` request, which will return
    /// the current template with the `version` field filled in with the
    /// current server version. The user updates other fields in the template,
    /// then returns it as part of the `UpdateWorkflowTemplate` request.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub version: i32,

    /// Output only. The time template was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time template was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The labels to associate with this template. These labels
    /// will be propagated to all jobs and clusters created by the workflow
    /// instance.
    ///
    /// Label **keys** must contain 1 to 63 characters, and must conform to
    /// [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt).
    ///
    /// Label **values** may be empty, but, if present, must contain 1 to 63
    /// characters, and must conform to
    /// [RFC 1035](https://www.ietf.org/rfc/rfc1035.txt).
    ///
    /// No more than 32 labels can be associated with a template.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. WorkflowTemplate scheduling information.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub placement: std::option::Option<crate::model::WorkflowTemplatePlacement>,

    /// Required. The Directed Acyclic Graph of Jobs to submit.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub jobs: std::vec::Vec<crate::model::OrderedJob>,

    /// Optional. Template parameters whose values are substituted into the
    /// template. Values for parameters must be provided when the template is
    /// instantiated.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub parameters: std::vec::Vec<crate::model::TemplateParameter>,

    /// Optional. Timeout duration for the DAG of jobs, expressed in seconds (see
    /// [JSON representation of
    /// duration](https://developers.google.com/protocol-buffers/docs/proto3#json)).
    /// The timeout duration must be from 10 minutes ("600s") to 24 hours
    /// ("86400s"). The timer begins when the first job is submitted. If the
    /// workflow is running at the end of the timeout period, any remaining jobs
    /// are cancelled, the workflow is ended, and if the workflow was running on a
    /// [managed
    /// cluster](/dataproc/docs/concepts/workflows/using-workflows#configuring_or_selecting_a_cluster),
    /// the cluster is deleted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dag_timeout: std::option::Option<wkt::Duration>,

    /// Optional. Encryption settings for encrypting workflow template job
    /// arguments.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_config: std::option::Option<crate::model::workflow_template::EncryptionConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkflowTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::WorkflowTemplate::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::WorkflowTemplate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::WorkflowTemplate::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::WorkflowTemplate::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::WorkflowTemplate::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::WorkflowTemplate::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [placement][crate::model::WorkflowTemplate::placement].
    pub fn set_placement<
        T: std::convert::Into<std::option::Option<crate::model::WorkflowTemplatePlacement>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.placement = v.into();
        self
    }

    /// Sets the value of [jobs][crate::model::WorkflowTemplate::jobs].
    pub fn set_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OrderedJob>,
    {
        use std::iter::Iterator;
        self.jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [parameters][crate::model::WorkflowTemplate::parameters].
    pub fn set_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TemplateParameter>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dag_timeout][crate::model::WorkflowTemplate::dag_timeout].
    pub fn set_dag_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dag_timeout = v.into();
        self
    }

    /// Sets the value of [encryption_config][crate::model::WorkflowTemplate::encryption_config].
    pub fn set_encryption_config<
        T: std::convert::Into<std::option::Option<crate::model::workflow_template::EncryptionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_config = v.into();
        self
    }
}

impl wkt::message::Message for WorkflowTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.WorkflowTemplate"
    }
}

/// Defines additional types related to [WorkflowTemplate].
pub mod workflow_template {
    #[allow(unused_imports)]
    use super::*;

    /// Encryption settings for encrypting workflow template job arguments.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct EncryptionConfig {
        /// Optional. The Cloud KMS key name to use for encrypting
        /// workflow template job arguments.
        ///
        /// When this this key is provided, the following workflow template
        /// [job arguments]
        /// (<https://cloud.google.com/dataproc/docs/concepts/workflows/use-workflows#adding_jobs_to_a_template>),
        /// if present, are
        /// [CMEK
        /// encrypted](https://cloud.google.com/dataproc/docs/concepts/configuring-clusters/customer-managed-encryption#use_cmek_with_workflow_template_data):
        ///
        /// * [FlinkJob
        ///   args](https://cloud.google.com/dataproc/docs/reference/rest/v1/FlinkJob)
        /// * [HadoopJob
        ///   args](https://cloud.google.com/dataproc/docs/reference/rest/v1/HadoopJob)
        /// * [SparkJob
        ///   args](https://cloud.google.com/dataproc/docs/reference/rest/v1/SparkJob)
        /// * [SparkRJob
        ///   args](https://cloud.google.com/dataproc/docs/reference/rest/v1/SparkRJob)
        /// * [PySparkJob
        ///   args](https://cloud.google.com/dataproc/docs/reference/rest/v1/PySparkJob)
        /// * [SparkSqlJob](https://cloud.google.com/dataproc/docs/reference/rest/v1/SparkSqlJob)
        ///   scriptVariables and queryList.queries
        /// * [HiveJob](https://cloud.google.com/dataproc/docs/reference/rest/v1/HiveJob)
        ///   scriptVariables and queryList.queries
        /// * [PigJob](https://cloud.google.com/dataproc/docs/reference/rest/v1/PigJob)
        ///   scriptVariables and queryList.queries
        /// * [PrestoJob](https://cloud.google.com/dataproc/docs/reference/rest/v1/PrestoJob)
        ///   scriptVariables and queryList.queries
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub kms_key: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl EncryptionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kms_key][crate::model::workflow_template::EncryptionConfig::kms_key].
        pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.kms_key = v.into();
            self
        }
    }

    impl wkt::message::Message for EncryptionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataproc.v1.WorkflowTemplate.EncryptionConfig"
        }
    }
}

/// Specifies workflow execution target.
///
/// Either `managed_cluster` or `cluster_selector` is required.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkflowTemplatePlacement {
    /// Required. Specifies where workflow executes; either on a managed
    /// cluster or an existing cluster chosen by labels.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub placement: std::option::Option<crate::model::workflow_template_placement::Placement>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkflowTemplatePlacement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [placement][crate::model::WorkflowTemplatePlacement::placement].
    ///
    /// Note that all the setters affecting `placement` are mutually
    /// exclusive.
    pub fn set_placement<
        T: std::convert::Into<
                std::option::Option<crate::model::workflow_template_placement::Placement>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.placement = v.into();
        self
    }

    /// The value of [placement][crate::model::WorkflowTemplatePlacement::placement]
    /// if it holds a `ManagedCluster`, `None` if the field is not set or
    /// holds a different branch.
    pub fn managed_cluster(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ManagedCluster>> {
        #[allow(unreachable_patterns)]
        self.placement.as_ref().and_then(|v| match v {
            crate::model::workflow_template_placement::Placement::ManagedCluster(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [placement][crate::model::WorkflowTemplatePlacement::placement]
    /// to hold a `ManagedCluster`.
    ///
    /// Note that all the setters affecting `placement` are
    /// mutually exclusive.
    pub fn set_managed_cluster<
        T: std::convert::Into<std::boxed::Box<crate::model::ManagedCluster>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.placement = std::option::Option::Some(
            crate::model::workflow_template_placement::Placement::ManagedCluster(v.into()),
        );
        self
    }

    /// The value of [placement][crate::model::WorkflowTemplatePlacement::placement]
    /// if it holds a `ClusterSelector`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cluster_selector(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ClusterSelector>> {
        #[allow(unreachable_patterns)]
        self.placement.as_ref().and_then(|v| match v {
            crate::model::workflow_template_placement::Placement::ClusterSelector(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [placement][crate::model::WorkflowTemplatePlacement::placement]
    /// to hold a `ClusterSelector`.
    ///
    /// Note that all the setters affecting `placement` are
    /// mutually exclusive.
    pub fn set_cluster_selector<
        T: std::convert::Into<std::boxed::Box<crate::model::ClusterSelector>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.placement = std::option::Option::Some(
            crate::model::workflow_template_placement::Placement::ClusterSelector(v.into()),
        );
        self
    }
}

impl wkt::message::Message for WorkflowTemplatePlacement {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.WorkflowTemplatePlacement"
    }
}

/// Defines additional types related to [WorkflowTemplatePlacement].
pub mod workflow_template_placement {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Specifies where workflow executes; either on a managed
    /// cluster or an existing cluster chosen by labels.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Placement {
        /// A cluster that is managed by the workflow.
        ManagedCluster(std::boxed::Box<crate::model::ManagedCluster>),
        /// Optional. A selector that chooses target cluster for jobs based
        /// on metadata.
        ///
        /// The selector is evaluated at the time each job is submitted.
        ClusterSelector(std::boxed::Box<crate::model::ClusterSelector>),
    }
}

/// Cluster that is managed by the workflow.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ManagedCluster {
    /// Required. The cluster name prefix. A unique cluster name will be formed by
    /// appending a random suffix.
    ///
    /// The name must contain only lower-case letters (a-z), numbers (0-9),
    /// and hyphens (-). Must begin with a letter. Cannot begin or end with
    /// hyphen. Must consist of between 2 and 35 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_name: std::string::String,

    /// Required. The cluster configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::ClusterConfig>,

    /// Optional. The labels to associate with this cluster.
    ///
    /// Label keys must be between 1 and 63 characters long, and must conform to
    /// the following PCRE regular expression:
    /// [\p{Ll}\p{Lo}][\p{Ll}\p{Lo}\p{N}_-]{0,62}
    ///
    /// Label values must be between 1 and 63 characters long, and must conform to
    /// the following PCRE regular expression: [\p{Ll}\p{Lo}\p{N}_-]{0,63}
    ///
    /// No more than 32 labels can be associated with a given cluster.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManagedCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_name][crate::model::ManagedCluster::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [config][crate::model::ManagedCluster::config].
    pub fn set_config<T: std::convert::Into<std::option::Option<crate::model::ClusterConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ManagedCluster::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ManagedCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ManagedCluster"
    }
}

/// A selector that chooses target cluster for jobs based on metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClusterSelector {
    /// Optional. The zone where workflow process executes. This parameter does not
    /// affect the selection of the cluster.
    ///
    /// If unspecified, the zone of the first cluster matching the selector
    /// is used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub zone: std::string::String,

    /// Required. The cluster labels. Cluster must have all labels
    /// to match.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub cluster_labels: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterSelector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [zone][crate::model::ClusterSelector::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_labels][crate::model::ClusterSelector::cluster_labels].
    pub fn set_cluster_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.cluster_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ClusterSelector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ClusterSelector"
    }
}

/// A job executed by the workflow.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OrderedJob {
    /// Required. The step id. The id must be unique among all jobs
    /// within the template.
    ///
    /// The step id is used as prefix for job id, as job
    /// `goog-dataproc-workflow-step-id` label, and in
    /// [prerequisiteStepIds][google.cloud.dataproc.v1.OrderedJob.prerequisite_step_ids]
    /// field from other steps.
    ///
    /// The id must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). Cannot begin or end with underscore
    /// or hyphen. Must consist of between 3 and 50 characters.
    ///
    /// [google.cloud.dataproc.v1.OrderedJob.prerequisite_step_ids]: crate::model::OrderedJob::prerequisite_step_ids
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub step_id: std::string::String,

    /// Optional. The labels to associate with this job.
    ///
    /// Label keys must be between 1 and 63 characters long, and must conform to
    /// the following regular expression:
    /// [\p{Ll}\p{Lo}][\p{Ll}\p{Lo}\p{N}_-]{0,62}
    ///
    /// Label values must be between 1 and 63 characters long, and must conform to
    /// the following regular expression: [\p{Ll}\p{Lo}\p{N}_-]{0,63}
    ///
    /// No more than 32 labels can be associated with a given job.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Job scheduling configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scheduling: std::option::Option<crate::model::JobScheduling>,

    /// Optional. The optional list of prerequisite job step_ids.
    /// If not specified, the job will start at the beginning of workflow.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub prerequisite_step_ids: std::vec::Vec<std::string::String>,

    /// Required. The job definition.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub job_type: std::option::Option<crate::model::ordered_job::JobType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OrderedJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [step_id][crate::model::OrderedJob::step_id].
    pub fn set_step_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.step_id = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::OrderedJob::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [scheduling][crate::model::OrderedJob::scheduling].
    pub fn set_scheduling<
        T: std::convert::Into<std::option::Option<crate::model::JobScheduling>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scheduling = v.into();
        self
    }

    /// Sets the value of [prerequisite_step_ids][crate::model::OrderedJob::prerequisite_step_ids].
    pub fn set_prerequisite_step_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.prerequisite_step_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [job_type][crate::model::OrderedJob::job_type].
    ///
    /// Note that all the setters affecting `job_type` are mutually
    /// exclusive.
    pub fn set_job_type<
        T: std::convert::Into<std::option::Option<crate::model::ordered_job::JobType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.job_type = v.into();
        self
    }

    /// The value of [job_type][crate::model::OrderedJob::job_type]
    /// if it holds a `HadoopJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn hadoop_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::HadoopJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::ordered_job::JobType::HadoopJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::OrderedJob::job_type]
    /// to hold a `HadoopJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_hadoop_job<T: std::convert::Into<std::boxed::Box<crate::model::HadoopJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::ordered_job::JobType::HadoopJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::OrderedJob::job_type]
    /// if it holds a `SparkJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::SparkJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::ordered_job::JobType::SparkJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::OrderedJob::job_type]
    /// to hold a `SparkJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_spark_job<T: std::convert::Into<std::boxed::Box<crate::model::SparkJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::ordered_job::JobType::SparkJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::OrderedJob::job_type]
    /// if it holds a `PysparkJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pyspark_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::PySparkJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::ordered_job::JobType::PysparkJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::OrderedJob::job_type]
    /// to hold a `PysparkJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_pyspark_job<T: std::convert::Into<std::boxed::Box<crate::model::PySparkJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::ordered_job::JobType::PysparkJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::OrderedJob::job_type]
    /// if it holds a `HiveJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn hive_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::HiveJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::ordered_job::JobType::HiveJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::OrderedJob::job_type]
    /// to hold a `HiveJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_hive_job<T: std::convert::Into<std::boxed::Box<crate::model::HiveJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::ordered_job::JobType::HiveJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::OrderedJob::job_type]
    /// if it holds a `PigJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pig_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::PigJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::ordered_job::JobType::PigJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::OrderedJob::job_type]
    /// to hold a `PigJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_pig_job<T: std::convert::Into<std::boxed::Box<crate::model::PigJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::ordered_job::JobType::PigJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::OrderedJob::job_type]
    /// if it holds a `SparkRJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_r_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::SparkRJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::ordered_job::JobType::SparkRJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::OrderedJob::job_type]
    /// to hold a `SparkRJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_spark_r_job<T: std::convert::Into<std::boxed::Box<crate::model::SparkRJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::ordered_job::JobType::SparkRJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::OrderedJob::job_type]
    /// if it holds a `SparkSqlJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn spark_sql_job(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SparkSqlJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::ordered_job::JobType::SparkSqlJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::OrderedJob::job_type]
    /// to hold a `SparkSqlJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_spark_sql_job<T: std::convert::Into<std::boxed::Box<crate::model::SparkSqlJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::ordered_job::JobType::SparkSqlJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::OrderedJob::job_type]
    /// if it holds a `PrestoJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn presto_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::PrestoJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::ordered_job::JobType::PrestoJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::OrderedJob::job_type]
    /// to hold a `PrestoJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_presto_job<T: std::convert::Into<std::boxed::Box<crate::model::PrestoJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::ordered_job::JobType::PrestoJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::OrderedJob::job_type]
    /// if it holds a `TrinoJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn trino_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::TrinoJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::ordered_job::JobType::TrinoJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::OrderedJob::job_type]
    /// to hold a `TrinoJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_trino_job<T: std::convert::Into<std::boxed::Box<crate::model::TrinoJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::ordered_job::JobType::TrinoJob(v.into()));
        self
    }

    /// The value of [job_type][crate::model::OrderedJob::job_type]
    /// if it holds a `FlinkJob`, `None` if the field is not set or
    /// holds a different branch.
    pub fn flink_job(&self) -> std::option::Option<&std::boxed::Box<crate::model::FlinkJob>> {
        #[allow(unreachable_patterns)]
        self.job_type.as_ref().and_then(|v| match v {
            crate::model::ordered_job::JobType::FlinkJob(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [job_type][crate::model::OrderedJob::job_type]
    /// to hold a `FlinkJob`.
    ///
    /// Note that all the setters affecting `job_type` are
    /// mutually exclusive.
    pub fn set_flink_job<T: std::convert::Into<std::boxed::Box<crate::model::FlinkJob>>>(
        mut self,
        v: T,
    ) -> Self {
        self.job_type =
            std::option::Option::Some(crate::model::ordered_job::JobType::FlinkJob(v.into()));
        self
    }
}

impl wkt::message::Message for OrderedJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.OrderedJob"
    }
}

/// Defines additional types related to [OrderedJob].
pub mod ordered_job {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The job definition.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum JobType {
        /// Optional. Job is a Hadoop job.
        HadoopJob(std::boxed::Box<crate::model::HadoopJob>),
        /// Optional. Job is a Spark job.
        SparkJob(std::boxed::Box<crate::model::SparkJob>),
        /// Optional. Job is a PySpark job.
        PysparkJob(std::boxed::Box<crate::model::PySparkJob>),
        /// Optional. Job is a Hive job.
        HiveJob(std::boxed::Box<crate::model::HiveJob>),
        /// Optional. Job is a Pig job.
        PigJob(std::boxed::Box<crate::model::PigJob>),
        /// Optional. Job is a SparkR job.
        SparkRJob(std::boxed::Box<crate::model::SparkRJob>),
        /// Optional. Job is a SparkSql job.
        SparkSqlJob(std::boxed::Box<crate::model::SparkSqlJob>),
        /// Optional. Job is a Presto job.
        PrestoJob(std::boxed::Box<crate::model::PrestoJob>),
        /// Optional. Job is a Trino job.
        TrinoJob(std::boxed::Box<crate::model::TrinoJob>),
        /// Optional. Job is a Flink job.
        FlinkJob(std::boxed::Box<crate::model::FlinkJob>),
    }
}

/// A configurable parameter that replaces one or more fields in the template.
/// Parameterizable fields:
///
/// - Labels
/// - File uris
/// - Job properties
/// - Job arguments
/// - Script variables
/// - Main class (in HadoopJob and SparkJob)
/// - Zone (in ClusterSelector)
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TemplateParameter {
    /// Required. Parameter name.
    /// The parameter name is used as the key, and paired with the
    /// parameter value, which are passed to the template when the template
    /// is instantiated.
    /// The name must contain only capital letters (A-Z), numbers (0-9), and
    /// underscores (_), and must not start with a number. The maximum length is
    /// 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Paths to all fields that the parameter replaces.
    /// A field is allowed to appear in at most one parameter's list of field
    /// paths.
    ///
    /// A field path is similar in syntax to a
    /// [google.protobuf.FieldMask][google.protobuf.FieldMask]. For example, a
    /// field path that references the zone field of a workflow template's cluster
    /// selector would be specified as `placement.clusterSelector.zone`.
    ///
    /// Also, field paths can reference fields using the following syntax:
    ///
    /// * Values in maps can be referenced by key:
    ///
    ///   * labels['key']
    ///   * placement.clusterSelector.clusterLabels['key']
    ///   * placement.managedCluster.labels['key']
    ///   * placement.clusterSelector.clusterLabels['key']
    ///   * jobs['step-id'].labels['key']
    /// * Jobs in the jobs list can be referenced by step-id:
    ///
    ///   * jobs['step-id'].hadoopJob.mainJarFileUri
    ///   * jobs['step-id'].hiveJob.queryFileUri
    ///   * jobs['step-id'].pySparkJob.mainPythonFileUri
    ///   * jobs['step-id'].hadoopJob.jarFileUris[0]
    ///   * jobs['step-id'].hadoopJob.archiveUris[0]
    ///   * jobs['step-id'].hadoopJob.fileUris[0]
    ///   * jobs['step-id'].pySparkJob.pythonFileUris[0]
    /// * Items in repeated fields can be referenced by a zero-based index:
    ///
    ///   * jobs['step-id'].sparkJob.args[0]
    /// * Other examples:
    ///
    ///   * jobs['step-id'].hadoopJob.properties['key']
    ///   * jobs['step-id'].hadoopJob.args[0]
    ///   * jobs['step-id'].hiveJob.scriptVariables['key']
    ///   * jobs['step-id'].hadoopJob.mainJarFileUri
    ///   * placement.clusterSelector.zone
    ///
    /// It may not be possible to parameterize maps and repeated fields in their
    /// entirety since only individual map values and individual items in repeated
    /// fields can be referenced. For example, the following field paths are
    /// invalid:
    ///
    /// - placement.clusterSelector.clusterLabels
    /// - jobs['step-id'].sparkJob.args
    ///
    /// [google.protobuf.FieldMask]: wkt::FieldMask
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub fields: std::vec::Vec<std::string::String>,

    /// Optional. Brief description of the parameter.
    /// Must not exceed 1024 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Optional. Validation rules to be applied to this parameter's value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub validation: std::option::Option<crate::model::ParameterValidation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TemplateParameter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TemplateParameter::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [fields][crate::model::TemplateParameter::fields].
    pub fn set_fields<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.fields = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [description][crate::model::TemplateParameter::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [validation][crate::model::TemplateParameter::validation].
    pub fn set_validation<
        T: std::convert::Into<std::option::Option<crate::model::ParameterValidation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.validation = v.into();
        self
    }
}

impl wkt::message::Message for TemplateParameter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.TemplateParameter"
    }
}

/// Configuration for parameter validation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ParameterValidation {
    /// Required. The type of validation to be performed.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub validation_type: std::option::Option<crate::model::parameter_validation::ValidationType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ParameterValidation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [validation_type][crate::model::ParameterValidation::validation_type].
    ///
    /// Note that all the setters affecting `validation_type` are mutually
    /// exclusive.
    pub fn set_validation_type<
        T: std::convert::Into<std::option::Option<crate::model::parameter_validation::ValidationType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.validation_type = v.into();
        self
    }

    /// The value of [validation_type][crate::model::ParameterValidation::validation_type]
    /// if it holds a `Regex`, `None` if the field is not set or
    /// holds a different branch.
    pub fn regex(&self) -> std::option::Option<&std::boxed::Box<crate::model::RegexValidation>> {
        #[allow(unreachable_patterns)]
        self.validation_type.as_ref().and_then(|v| match v {
            crate::model::parameter_validation::ValidationType::Regex(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [validation_type][crate::model::ParameterValidation::validation_type]
    /// to hold a `Regex`.
    ///
    /// Note that all the setters affecting `validation_type` are
    /// mutually exclusive.
    pub fn set_regex<T: std::convert::Into<std::boxed::Box<crate::model::RegexValidation>>>(
        mut self,
        v: T,
    ) -> Self {
        self.validation_type = std::option::Option::Some(
            crate::model::parameter_validation::ValidationType::Regex(v.into()),
        );
        self
    }

    /// The value of [validation_type][crate::model::ParameterValidation::validation_type]
    /// if it holds a `Values`, `None` if the field is not set or
    /// holds a different branch.
    pub fn values(&self) -> std::option::Option<&std::boxed::Box<crate::model::ValueValidation>> {
        #[allow(unreachable_patterns)]
        self.validation_type.as_ref().and_then(|v| match v {
            crate::model::parameter_validation::ValidationType::Values(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [validation_type][crate::model::ParameterValidation::validation_type]
    /// to hold a `Values`.
    ///
    /// Note that all the setters affecting `validation_type` are
    /// mutually exclusive.
    pub fn set_values<T: std::convert::Into<std::boxed::Box<crate::model::ValueValidation>>>(
        mut self,
        v: T,
    ) -> Self {
        self.validation_type = std::option::Option::Some(
            crate::model::parameter_validation::ValidationType::Values(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ParameterValidation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ParameterValidation"
    }
}

/// Defines additional types related to [ParameterValidation].
pub mod parameter_validation {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The type of validation to be performed.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ValidationType {
        /// Validation based on regular expressions.
        Regex(std::boxed::Box<crate::model::RegexValidation>),
        /// Validation based on a list of allowed values.
        Values(std::boxed::Box<crate::model::ValueValidation>),
    }
}

/// Validation based on regular expressions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RegexValidation {
    /// Required. RE2 regular expressions used to validate the parameter's value.
    /// The value must match the regex in its entirety (substring
    /// matches are not sufficient).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub regexes: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RegexValidation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [regexes][crate::model::RegexValidation::regexes].
    pub fn set_regexes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.regexes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RegexValidation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.RegexValidation"
    }
}

/// Validation based on a list of allowed values.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ValueValidation {
    /// Required. List of allowed values for the parameter.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValueValidation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::ValueValidation::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ValueValidation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ValueValidation"
    }
}

/// A Dataproc workflow template resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkflowMetadata {
    /// Output only. The resource name of the workflow template as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.workflowTemplates`, the resource name of the
    ///   template has the following format:
    ///   `projects/{project_id}/regions/{region}/workflowTemplates/{template_id}`
    ///
    /// * For `projects.locations.workflowTemplates`, the resource name of the
    ///   template has the following format:
    ///   `projects/{project_id}/locations/{location}/workflowTemplates/{template_id}`
    ///
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub template: std::string::String,

    /// Output only. The version of template at the time of
    /// workflow instantiation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub version: i32,

    /// Output only. The create cluster operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_cluster: std::option::Option<crate::model::ClusterOperation>,

    /// Output only. The workflow graph.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub graph: std::option::Option<crate::model::WorkflowGraph>,

    /// Output only. The delete cluster operation metadata.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_cluster: std::option::Option<crate::model::ClusterOperation>,

    /// Output only. The workflow state.
    pub state: crate::model::workflow_metadata::State,

    /// Output only. The name of the target cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_name: std::string::String,

    /// Map from parameter names to values that were used for those parameters.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub parameters: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Workflow start time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Workflow end time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The UUID of target cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_uuid: std::string::String,

    /// Output only. The timeout duration for the DAG of jobs, expressed in seconds
    /// (see [JSON representation of
    /// duration](https://developers.google.com/protocol-buffers/docs/proto3#json)).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dag_timeout: std::option::Option<wkt::Duration>,

    /// Output only. DAG start time, only set for workflows with
    /// [dag_timeout][google.cloud.dataproc.v1.WorkflowMetadata.dag_timeout] when
    /// DAG begins.
    ///
    /// [google.cloud.dataproc.v1.WorkflowMetadata.dag_timeout]: crate::model::WorkflowMetadata::dag_timeout
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dag_start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. DAG end time, only set for workflows with
    /// [dag_timeout][google.cloud.dataproc.v1.WorkflowMetadata.dag_timeout] when
    /// DAG ends.
    ///
    /// [google.cloud.dataproc.v1.WorkflowMetadata.dag_timeout]: crate::model::WorkflowMetadata::dag_timeout
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dag_end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkflowMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [template][crate::model::WorkflowMetadata::template].
    pub fn set_template<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.template = v.into();
        self
    }

    /// Sets the value of [version][crate::model::WorkflowMetadata::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [create_cluster][crate::model::WorkflowMetadata::create_cluster].
    pub fn set_create_cluster<
        T: std::convert::Into<std::option::Option<crate::model::ClusterOperation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.create_cluster = v.into();
        self
    }

    /// Sets the value of [graph][crate::model::WorkflowMetadata::graph].
    pub fn set_graph<T: std::convert::Into<std::option::Option<crate::model::WorkflowGraph>>>(
        mut self,
        v: T,
    ) -> Self {
        self.graph = v.into();
        self
    }

    /// Sets the value of [delete_cluster][crate::model::WorkflowMetadata::delete_cluster].
    pub fn set_delete_cluster<
        T: std::convert::Into<std::option::Option<crate::model::ClusterOperation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.delete_cluster = v.into();
        self
    }

    /// Sets the value of [state][crate::model::WorkflowMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::workflow_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [cluster_name][crate::model::WorkflowMetadata::cluster_name].
    pub fn set_cluster_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_name = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::WorkflowMetadata::parameters].
    pub fn set_parameters<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [start_time][crate::model::WorkflowMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::WorkflowMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [cluster_uuid][crate::model::WorkflowMetadata::cluster_uuid].
    pub fn set_cluster_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uuid = v.into();
        self
    }

    /// Sets the value of [dag_timeout][crate::model::WorkflowMetadata::dag_timeout].
    pub fn set_dag_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dag_timeout = v.into();
        self
    }

    /// Sets the value of [dag_start_time][crate::model::WorkflowMetadata::dag_start_time].
    pub fn set_dag_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dag_start_time = v.into();
        self
    }

    /// Sets the value of [dag_end_time][crate::model::WorkflowMetadata::dag_end_time].
    pub fn set_dag_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dag_end_time = v.into();
        self
    }
}

impl wkt::message::Message for WorkflowMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.WorkflowMetadata"
    }
}

/// Defines additional types related to [WorkflowMetadata].
pub mod workflow_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// The operation state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unused.
        Unknown,
        /// The operation has been created.
        Pending,
        /// The operation is running.
        Running,
        /// The operation is done; either cancelled or completed.
        Done,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Done => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Pending,
                2 => Self::Running,
                3 => Self::Done,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "PENDING" => Self::Pending,
                "RUNNING" => Self::Running,
                "DONE" => Self::Done,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Done => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataproc.v1.WorkflowMetadata.State",
            ))
        }
    }
}

/// The cluster operation triggered by a workflow.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClusterOperation {
    /// Output only. The id of the cluster operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub operation_id: std::string::String,

    /// Output only. Error, if operation failed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error: std::string::String,

    /// Output only. Indicates the operation is done.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub done: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterOperation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation_id][crate::model::ClusterOperation::operation_id].
    pub fn set_operation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_id = v.into();
        self
    }

    /// Sets the value of [error][crate::model::ClusterOperation::error].
    pub fn set_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [done][crate::model::ClusterOperation::done].
    pub fn set_done<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.done = v.into();
        self
    }
}

impl wkt::message::Message for ClusterOperation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ClusterOperation"
    }
}

/// The workflow graph.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkflowGraph {
    /// Output only. The workflow nodes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub nodes: std::vec::Vec<crate::model::WorkflowNode>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkflowGraph {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [nodes][crate::model::WorkflowGraph::nodes].
    pub fn set_nodes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WorkflowNode>,
    {
        use std::iter::Iterator;
        self.nodes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for WorkflowGraph {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.WorkflowGraph"
    }
}

/// The workflow node.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkflowNode {
    /// Output only. The name of the node.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub step_id: std::string::String,

    /// Output only. Node's prerequisite nodes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub prerequisite_step_ids: std::vec::Vec<std::string::String>,

    /// Output only. The job id; populated after the node enters RUNNING state.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub job_id: std::string::String,

    /// Output only. The node state.
    pub state: crate::model::workflow_node::NodeState,

    /// Output only. The error detail.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub error: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkflowNode {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [step_id][crate::model::WorkflowNode::step_id].
    pub fn set_step_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.step_id = v.into();
        self
    }

    /// Sets the value of [prerequisite_step_ids][crate::model::WorkflowNode::prerequisite_step_ids].
    pub fn set_prerequisite_step_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.prerequisite_step_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [job_id][crate::model::WorkflowNode::job_id].
    pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.job_id = v.into();
        self
    }

    /// Sets the value of [state][crate::model::WorkflowNode::state].
    pub fn set_state<T: std::convert::Into<crate::model::workflow_node::NodeState>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::WorkflowNode::error].
    pub fn set_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error = v.into();
        self
    }
}

impl wkt::message::Message for WorkflowNode {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.WorkflowNode"
    }
}

/// Defines additional types related to [WorkflowNode].
pub mod workflow_node {
    #[allow(unused_imports)]
    use super::*;

    /// The workflow node state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NodeState {
        /// State is unspecified.
        Unspecified,
        /// The node is awaiting prerequisite node to finish.
        Blocked,
        /// The node is runnable but not running.
        Runnable,
        /// The node is running.
        Running,
        /// The node completed successfully.
        Completed,
        /// The node failed. A node can be marked FAILED because
        /// its ancestor or peer failed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [NodeState::value] or
        /// [NodeState::name].
        UnknownValue(node_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod node_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl NodeState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Blocked => std::option::Option::Some(1),
                Self::Runnable => std::option::Option::Some(2),
                Self::Running => std::option::Option::Some(3),
                Self::Completed => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("NODE_STATE_UNSPECIFIED"),
                Self::Blocked => std::option::Option::Some("BLOCKED"),
                Self::Runnable => std::option::Option::Some("RUNNABLE"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Completed => std::option::Option::Some("COMPLETED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for NodeState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for NodeState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for NodeState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Blocked,
                2 => Self::Runnable,
                3 => Self::Running,
                4 => Self::Completed,
                5 => Self::Failed,
                _ => Self::UnknownValue(node_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for NodeState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NODE_STATE_UNSPECIFIED" => Self::Unspecified,
                "BLOCKED" => Self::Blocked,
                "RUNNABLE" => Self::Runnable,
                "RUNNING" => Self::Running,
                "COMPLETED" => Self::Completed,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(node_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for NodeState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Blocked => serializer.serialize_i32(1),
                Self::Runnable => serializer.serialize_i32(2),
                Self::Running => serializer.serialize_i32(3),
                Self::Completed => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for NodeState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<NodeState>::new(
                ".google.cloud.dataproc.v1.WorkflowNode.NodeState",
            ))
        }
    }
}

/// A request to create a workflow template.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateWorkflowTemplateRequest {
    /// Required. The resource name of the region or location, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.workflowTemplates.create`, the resource name of the
    ///   region has the following format:
    ///   `projects/{project_id}/regions/{region}`
    ///
    /// * For `projects.locations.workflowTemplates.create`, the resource name of
    ///   the location has the following format:
    ///   `projects/{project_id}/locations/{location}`
    ///
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The Dataproc workflow template to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub template: std::option::Option<crate::model::WorkflowTemplate>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateWorkflowTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateWorkflowTemplateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [template][crate::model::CreateWorkflowTemplateRequest::template].
    pub fn set_template<
        T: std::convert::Into<std::option::Option<crate::model::WorkflowTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.template = v.into();
        self
    }
}

impl wkt::message::Message for CreateWorkflowTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.CreateWorkflowTemplateRequest"
    }
}

/// A request to fetch a workflow template.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetWorkflowTemplateRequest {
    /// Required. The resource name of the workflow template, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.workflowTemplates.get`, the resource name of the
    ///   template has the following format:
    ///   `projects/{project_id}/regions/{region}/workflowTemplates/{template_id}`
    ///
    /// * For `projects.locations.workflowTemplates.get`, the resource name of the
    ///   template has the following format:
    ///   `projects/{project_id}/locations/{location}/workflowTemplates/{template_id}`
    ///
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The version of workflow template to retrieve. Only previously
    /// instantiated versions can be retrieved.
    ///
    /// If unspecified, retrieves the current version.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub version: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetWorkflowTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetWorkflowTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::GetWorkflowTemplateRequest::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for GetWorkflowTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.GetWorkflowTemplateRequest"
    }
}

/// A request to instantiate a workflow template.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstantiateWorkflowTemplateRequest {
    /// Required. The resource name of the workflow template, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.workflowTemplates.instantiate`, the resource name
    ///   of the template has the following format:
    ///   `projects/{project_id}/regions/{region}/workflowTemplates/{template_id}`
    ///
    /// * For `projects.locations.workflowTemplates.instantiate`, the resource name
    ///   of the template has the following format:
    ///   `projects/{project_id}/locations/{location}/workflowTemplates/{template_id}`
    ///
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The version of workflow template to instantiate. If specified,
    /// the workflow will be instantiated only if the current version of
    /// the workflow template has the supplied version.
    ///
    /// This option cannot be used to instantiate a previous version of
    /// workflow template.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub version: i32,

    /// Optional. A tag that prevents multiple concurrent workflow
    /// instances with the same tag from running. This mitigates risk of
    /// concurrent instances started due to retries.
    ///
    /// It is recommended to always set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The tag must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. Map from parameter names to values that should be used for those
    /// parameters. Values may not exceed 1000 characters.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub parameters: std::collections::HashMap<std::string::String, std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstantiateWorkflowTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::InstantiateWorkflowTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::InstantiateWorkflowTemplateRequest::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::InstantiateWorkflowTemplateRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::InstantiateWorkflowTemplateRequest::parameters].
    pub fn set_parameters<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for InstantiateWorkflowTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.InstantiateWorkflowTemplateRequest"
    }
}

/// A request to instantiate an inline workflow template.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstantiateInlineWorkflowTemplateRequest {
    /// Required. The resource name of the region or location, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.workflowTemplates,instantiateinline`, the resource
    ///   name of the region has the following format:
    ///   `projects/{project_id}/regions/{region}`
    ///
    /// * For `projects.locations.workflowTemplates.instantiateinline`, the
    ///   resource name of the location has the following format:
    ///   `projects/{project_id}/locations/{location}`
    ///
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The workflow template to instantiate.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub template: std::option::Option<crate::model::WorkflowTemplate>,

    /// Optional. A tag that prevents multiple concurrent workflow
    /// instances with the same tag from running. This mitigates risk of
    /// concurrent instances started due to retries.
    ///
    /// It is recommended to always set this value to a
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier).
    ///
    /// The tag must contain only letters (a-z, A-Z), numbers (0-9),
    /// underscores (_), and hyphens (-). The maximum length is 40 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstantiateInlineWorkflowTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::InstantiateInlineWorkflowTemplateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [template][crate::model::InstantiateInlineWorkflowTemplateRequest::template].
    pub fn set_template<
        T: std::convert::Into<std::option::Option<crate::model::WorkflowTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.template = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::InstantiateInlineWorkflowTemplateRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for InstantiateInlineWorkflowTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.InstantiateInlineWorkflowTemplateRequest"
    }
}

/// A request to update a workflow template.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateWorkflowTemplateRequest {
    /// Required. The updated workflow template.
    ///
    /// The `template.version` field must match the current version.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub template: std::option::Option<crate::model::WorkflowTemplate>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateWorkflowTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [template][crate::model::UpdateWorkflowTemplateRequest::template].
    pub fn set_template<
        T: std::convert::Into<std::option::Option<crate::model::WorkflowTemplate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.template = v.into();
        self
    }
}

impl wkt::message::Message for UpdateWorkflowTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.UpdateWorkflowTemplateRequest"
    }
}

/// A request to list workflow templates in a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListWorkflowTemplatesRequest {
    /// Required. The resource name of the region or location, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.workflowTemplates,list`, the resource
    ///   name of the region has the following format:
    ///   `projects/{project_id}/regions/{region}`
    ///
    /// * For `projects.locations.workflowTemplates.list`, the
    ///   resource name of the location has the following format:
    ///   `projects/{project_id}/locations/{location}`
    ///
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of results to return in each response.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The page token, returned by a previous call, to request the
    /// next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkflowTemplatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListWorkflowTemplatesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListWorkflowTemplatesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListWorkflowTemplatesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListWorkflowTemplatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListWorkflowTemplatesRequest"
    }
}

/// A response to a request to list workflow templates in a project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListWorkflowTemplatesResponse {
    /// Output only. WorkflowTemplates list.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub templates: std::vec::Vec<crate::model::WorkflowTemplate>,

    /// Output only. This token is included in the response if there are more
    /// results to fetch. To fetch additional results, provide this value as the
    /// page_token in a subsequent \<code\>ListWorkflowTemplatesRequest\</code\>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Output only. List of workflow templates that could not be included in the
    /// response. Attempting to get one of these resources may indicate why it was
    /// not included in the list response.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkflowTemplatesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [templates][crate::model::ListWorkflowTemplatesResponse::templates].
    pub fn set_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WorkflowTemplate>,
    {
        use std::iter::Iterator;
        self.templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListWorkflowTemplatesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListWorkflowTemplatesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListWorkflowTemplatesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.ListWorkflowTemplatesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListWorkflowTemplatesResponse {
    type PageItem = crate::model::WorkflowTemplate;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.templates
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A request to delete a workflow template.
///
/// Currently started workflows will remain running.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteWorkflowTemplateRequest {
    /// Required. The resource name of the workflow template, as described
    /// in <https://cloud.google.com/apis/design/resource_names>.
    ///
    /// * For `projects.regions.workflowTemplates.delete`, the resource name
    ///   of the template has the following format:
    ///   `projects/{project_id}/regions/{region}/workflowTemplates/{template_id}`
    ///
    /// * For `projects.locations.workflowTemplates.instantiate`, the resource name
    ///   of the template has the following format:
    ///   `projects/{project_id}/locations/{location}/workflowTemplates/{template_id}`
    ///
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The version of workflow template to delete. If specified,
    /// will only delete the template if the current server version matches
    /// specified version.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub version: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteWorkflowTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteWorkflowTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::DeleteWorkflowTemplateRequest::version].
    pub fn set_version<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for DeleteWorkflowTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataproc.v1.DeleteWorkflowTemplateRequest"
    }
}

/// Cluster components that can be activated.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Component {
    /// Unspecified component. Specifying this will cause Cluster creation to fail.
    Unspecified,
    /// The Anaconda component is no longer supported or applicable to
    /// [supported Dataproc on Compute Engine image versions]
    /// (<https://cloud.google.com/dataproc/docs/concepts/versioning/dataproc-version-clusters#supported-dataproc-image-versions>).
    /// It cannot be activated on clusters created with supported Dataproc on
    /// Compute Engine image versions.
    Anaconda,
    /// Docker
    Docker,
    /// The Druid query engine. (alpha)
    Druid,
    /// Flink
    Flink,
    /// HBase. (beta)
    Hbase,
    /// The Hive Web HCatalog (the REST service for accessing HCatalog).
    HiveWebhcat,
    /// Hudi.
    Hudi,
    /// The Jupyter Notebook.
    Jupyter,
    /// The Presto query engine.
    Presto,
    /// The Trino query engine.
    Trino,
    /// The Ranger service.
    Ranger,
    /// The Solr service.
    Solr,
    /// The Zeppelin notebook.
    Zeppelin,
    /// The Zookeeper service.
    Zookeeper,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Component::value] or
    /// [Component::name].
    UnknownValue(component::UnknownValue),
}

#[doc(hidden)]
pub mod component {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Component {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Anaconda => std::option::Option::Some(5),
            Self::Docker => std::option::Option::Some(13),
            Self::Druid => std::option::Option::Some(9),
            Self::Flink => std::option::Option::Some(14),
            Self::Hbase => std::option::Option::Some(11),
            Self::HiveWebhcat => std::option::Option::Some(3),
            Self::Hudi => std::option::Option::Some(18),
            Self::Jupyter => std::option::Option::Some(1),
            Self::Presto => std::option::Option::Some(6),
            Self::Trino => std::option::Option::Some(17),
            Self::Ranger => std::option::Option::Some(12),
            Self::Solr => std::option::Option::Some(10),
            Self::Zeppelin => std::option::Option::Some(4),
            Self::Zookeeper => std::option::Option::Some(8),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("COMPONENT_UNSPECIFIED"),
            Self::Anaconda => std::option::Option::Some("ANACONDA"),
            Self::Docker => std::option::Option::Some("DOCKER"),
            Self::Druid => std::option::Option::Some("DRUID"),
            Self::Flink => std::option::Option::Some("FLINK"),
            Self::Hbase => std::option::Option::Some("HBASE"),
            Self::HiveWebhcat => std::option::Option::Some("HIVE_WEBHCAT"),
            Self::Hudi => std::option::Option::Some("HUDI"),
            Self::Jupyter => std::option::Option::Some("JUPYTER"),
            Self::Presto => std::option::Option::Some("PRESTO"),
            Self::Trino => std::option::Option::Some("TRINO"),
            Self::Ranger => std::option::Option::Some("RANGER"),
            Self::Solr => std::option::Option::Some("SOLR"),
            Self::Zeppelin => std::option::Option::Some("ZEPPELIN"),
            Self::Zookeeper => std::option::Option::Some("ZOOKEEPER"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Component {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Component {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Component {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Jupyter,
            3 => Self::HiveWebhcat,
            4 => Self::Zeppelin,
            5 => Self::Anaconda,
            6 => Self::Presto,
            8 => Self::Zookeeper,
            9 => Self::Druid,
            10 => Self::Solr,
            11 => Self::Hbase,
            12 => Self::Ranger,
            13 => Self::Docker,
            14 => Self::Flink,
            17 => Self::Trino,
            18 => Self::Hudi,
            _ => Self::UnknownValue(component::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Component {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COMPONENT_UNSPECIFIED" => Self::Unspecified,
            "ANACONDA" => Self::Anaconda,
            "DOCKER" => Self::Docker,
            "DRUID" => Self::Druid,
            "FLINK" => Self::Flink,
            "HBASE" => Self::Hbase,
            "HIVE_WEBHCAT" => Self::HiveWebhcat,
            "HUDI" => Self::Hudi,
            "JUPYTER" => Self::Jupyter,
            "PRESTO" => Self::Presto,
            "TRINO" => Self::Trino,
            "RANGER" => Self::Ranger,
            "SOLR" => Self::Solr,
            "ZEPPELIN" => Self::Zeppelin,
            "ZOOKEEPER" => Self::Zookeeper,
            _ => Self::UnknownValue(component::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Component {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Anaconda => serializer.serialize_i32(5),
            Self::Docker => serializer.serialize_i32(13),
            Self::Druid => serializer.serialize_i32(9),
            Self::Flink => serializer.serialize_i32(14),
            Self::Hbase => serializer.serialize_i32(11),
            Self::HiveWebhcat => serializer.serialize_i32(3),
            Self::Hudi => serializer.serialize_i32(18),
            Self::Jupyter => serializer.serialize_i32(1),
            Self::Presto => serializer.serialize_i32(6),
            Self::Trino => serializer.serialize_i32(17),
            Self::Ranger => serializer.serialize_i32(12),
            Self::Solr => serializer.serialize_i32(10),
            Self::Zeppelin => serializer.serialize_i32(4),
            Self::Zookeeper => serializer.serialize_i32(8),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Component {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Component>::new(
            ".google.cloud.dataproc.v1.Component",
        ))
    }
}

/// Actions in response to failure of a resource associated with a cluster.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum FailureAction {
    /// When FailureAction is unspecified, failure action defaults to NO_ACTION.
    Unspecified,
    /// Take no action on failure to create a cluster resource. NO_ACTION is the
    /// default.
    NoAction,
    /// Delete the failed cluster resource.
    Delete,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [FailureAction::value] or
    /// [FailureAction::name].
    UnknownValue(failure_action::UnknownValue),
}

#[doc(hidden)]
pub mod failure_action {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl FailureAction {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::NoAction => std::option::Option::Some(1),
            Self::Delete => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("FAILURE_ACTION_UNSPECIFIED"),
            Self::NoAction => std::option::Option::Some("NO_ACTION"),
            Self::Delete => std::option::Option::Some("DELETE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for FailureAction {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for FailureAction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for FailureAction {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::NoAction,
            2 => Self::Delete,
            _ => Self::UnknownValue(failure_action::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for FailureAction {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "FAILURE_ACTION_UNSPECIFIED" => Self::Unspecified,
            "NO_ACTION" => Self::NoAction,
            "DELETE" => Self::Delete,
            _ => Self::UnknownValue(failure_action::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for FailureAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::NoAction => serializer.serialize_i32(1),
            Self::Delete => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for FailureAction {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<FailureAction>::new(
            ".google.cloud.dataproc.v1.FailureAction",
        ))
    }
}
