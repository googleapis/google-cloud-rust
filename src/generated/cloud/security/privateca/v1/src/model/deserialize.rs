// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CertificateAuthority {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            __config,
            __lifetime,
            __key_spec,
            __subordinate_config,
            __tier,
            __state,
            __pem_ca_certificates,
            __ca_certificate_descriptions,
            __gcs_bucket,
            __access_urls,
            __create_time,
            __update_time,
            __delete_time,
            __expire_time,
            __labels,
            __user_defined_access_urls,
            __satisfies_pzs,
            __satisfies_pzi,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CertificateAuthority")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            "config" => Ok(__FieldTag::__config),
                            "lifetime" => Ok(__FieldTag::__lifetime),
                            "keySpec" => Ok(__FieldTag::__key_spec),
                            "key_spec" => Ok(__FieldTag::__key_spec),
                            "subordinateConfig" => Ok(__FieldTag::__subordinate_config),
                            "subordinate_config" => Ok(__FieldTag::__subordinate_config),
                            "tier" => Ok(__FieldTag::__tier),
                            "state" => Ok(__FieldTag::__state),
                            "pemCaCertificates" => Ok(__FieldTag::__pem_ca_certificates),
                            "pem_ca_certificates" => Ok(__FieldTag::__pem_ca_certificates),
                            "caCertificateDescriptions" => {
                                Ok(__FieldTag::__ca_certificate_descriptions)
                            }
                            "ca_certificate_descriptions" => {
                                Ok(__FieldTag::__ca_certificate_descriptions)
                            }
                            "gcsBucket" => Ok(__FieldTag::__gcs_bucket),
                            "gcs_bucket" => Ok(__FieldTag::__gcs_bucket),
                            "accessUrls" => Ok(__FieldTag::__access_urls),
                            "access_urls" => Ok(__FieldTag::__access_urls),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "userDefinedAccessUrls" => Ok(__FieldTag::__user_defined_access_urls),
                            "user_defined_access_urls" => {
                                Ok(__FieldTag::__user_defined_access_urls)
                            }
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CertificateAuthority;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CertificateAuthority")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::certificate_authority::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map
                                .next_value::<std::option::Option<crate::model::CertificateConfig>>(
                                )?;
                        }
                        __FieldTag::__lifetime => {
                            if !fields.insert(__FieldTag::__lifetime) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lifetime",
                                ));
                            }
                            result.lifetime =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__key_spec => {
                            if !fields.insert(__FieldTag::__key_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_spec",
                                ));
                            }
                            result.key_spec = map.next_value::<std::option::Option<
                                crate::model::certificate_authority::KeyVersionSpec,
                            >>()?;
                        }
                        __FieldTag::__subordinate_config => {
                            if !fields.insert(__FieldTag::__subordinate_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subordinate_config",
                                ));
                            }
                            result.subordinate_config = map
                                .next_value::<std::option::Option<crate::model::SubordinateConfig>>(
                                )?;
                        }
                        __FieldTag::__tier => {
                            if !fields.insert(__FieldTag::__tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tier",
                                ));
                            }
                            result.tier = map
                                .next_value::<std::option::Option<crate::model::ca_pool::Tier>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::certificate_authority::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__pem_ca_certificates => {
                            if !fields.insert(__FieldTag::__pem_ca_certificates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pem_ca_certificates",
                                ));
                            }
                            result.pem_ca_certificates = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__ca_certificate_descriptions => {
                            if !fields.insert(__FieldTag::__ca_certificate_descriptions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_certificate_descriptions",
                                ));
                            }
                            result.ca_certificate_descriptions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CertificateDescription>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcs_bucket => {
                            if !fields.insert(__FieldTag::__gcs_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_bucket",
                                ));
                            }
                            result.gcs_bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__access_urls => {
                            if !fields.insert(__FieldTag::__access_urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_urls",
                                ));
                            }
                            result.access_urls = map.next_value::<std::option::Option<
                                crate::model::certificate_authority::AccessUrls,
                            >>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_defined_access_urls => {
                            if !fields.insert(__FieldTag::__user_defined_access_urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_defined_access_urls",
                                ));
                            }
                            result.user_defined_access_urls = map
                                .next_value::<std::option::Option<
                                    crate::model::certificate_authority::UserDefinedAccessUrls,
                                >>()?;
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzi",
                                ));
                            }
                            result.satisfies_pzi = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::certificate_authority::AccessUrls {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ca_certificate_access_url,
            __crl_access_urls,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AccessUrls")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "caCertificateAccessUrl" => Ok(__FieldTag::__ca_certificate_access_url),
                            "ca_certificate_access_url" => {
                                Ok(__FieldTag::__ca_certificate_access_url)
                            }
                            "crlAccessUrls" => Ok(__FieldTag::__crl_access_urls),
                            "crl_access_urls" => Ok(__FieldTag::__crl_access_urls),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::certificate_authority::AccessUrls;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AccessUrls")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ca_certificate_access_url => {
                            if !fields.insert(__FieldTag::__ca_certificate_access_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_certificate_access_url",
                                ));
                            }
                            result.ca_certificate_access_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__crl_access_urls => {
                            if !fields.insert(__FieldTag::__crl_access_urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crl_access_urls",
                                ));
                            }
                            result.crl_access_urls = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::certificate_authority::KeyVersionSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_kms_key_version,
            __algorithm,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KeyVersionSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudKmsKeyVersion" => Ok(__FieldTag::__cloud_kms_key_version),
                            "cloud_kms_key_version" => Ok(__FieldTag::__cloud_kms_key_version),
                            "algorithm" => Ok(__FieldTag::__algorithm),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::certificate_authority::KeyVersionSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KeyVersionSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_kms_key_version => {
                            if !fields.insert(__FieldTag::__cloud_kms_key_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_kms_key_version",
                                ));
                            }
                            if result.key_version.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `key_version`, a oneof with full ID .google.cloud.security.privateca.v1.CertificateAuthority.KeyVersionSpec.cloud_kms_key_version, latest field was cloudKmsKeyVersion",
                                ));
                            }
                            result.key_version = std::option::Option::Some(
                                crate::model::certificate_authority::key_version_spec::KeyVersion::CloudKmsKeyVersion(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__algorithm => {
                            if !fields.insert(__FieldTag::__algorithm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for algorithm",
                                ));
                            }
                            if result.key_version.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `key_version`, a oneof with full ID .google.cloud.security.privateca.v1.CertificateAuthority.KeyVersionSpec.algorithm, latest field was algorithm",
                                ));
                            }
                            result.key_version = std::option::Option::Some(
                                crate::model::certificate_authority::key_version_spec::KeyVersion::Algorithm(
                                    map.next_value::<std::option::Option<crate::model::certificate_authority::SignHashAlgorithm>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::certificate_authority::UserDefinedAccessUrls {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aia_issuing_certificate_urls,
            __crl_access_urls,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UserDefinedAccessUrls")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "aiaIssuingCertificateUrls" => {
                                Ok(__FieldTag::__aia_issuing_certificate_urls)
                            }
                            "aia_issuing_certificate_urls" => {
                                Ok(__FieldTag::__aia_issuing_certificate_urls)
                            }
                            "crlAccessUrls" => Ok(__FieldTag::__crl_access_urls),
                            "crl_access_urls" => Ok(__FieldTag::__crl_access_urls),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::certificate_authority::UserDefinedAccessUrls;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UserDefinedAccessUrls")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aia_issuing_certificate_urls => {
                            if !fields.insert(__FieldTag::__aia_issuing_certificate_urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aia_issuing_certificate_urls",
                                ));
                            }
                            result.aia_issuing_certificate_urls = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__crl_access_urls => {
                            if !fields.insert(__FieldTag::__crl_access_urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crl_access_urls",
                                ));
                            }
                            result.crl_access_urls = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CaPool {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __tier,
            __issuance_policy,
            __publishing_options,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CaPool")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "tier" => Ok(__FieldTag::__tier),
                            "issuancePolicy" => Ok(__FieldTag::__issuance_policy),
                            "issuance_policy" => Ok(__FieldTag::__issuance_policy),
                            "publishingOptions" => Ok(__FieldTag::__publishing_options),
                            "publishing_options" => Ok(__FieldTag::__publishing_options),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CaPool;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CaPool")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tier => {
                            if !fields.insert(__FieldTag::__tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tier",
                                ));
                            }
                            result.tier = map
                                .next_value::<std::option::Option<crate::model::ca_pool::Tier>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__issuance_policy => {
                            if !fields.insert(__FieldTag::__issuance_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issuance_policy",
                                ));
                            }
                            result.issuance_policy = map.next_value::<std::option::Option<crate::model::ca_pool::IssuancePolicy>>()?
                                ;
                        }
                        __FieldTag::__publishing_options => {
                            if !fields.insert(__FieldTag::__publishing_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for publishing_options",
                                ));
                            }
                            result.publishing_options = map.next_value::<std::option::Option<crate::model::ca_pool::PublishingOptions>>()?
                                ;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ca_pool::PublishingOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __publish_ca_cert,
            __publish_crl,
            __encoding_format,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PublishingOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "publishCaCert" => Ok(__FieldTag::__publish_ca_cert),
                            "publish_ca_cert" => Ok(__FieldTag::__publish_ca_cert),
                            "publishCrl" => Ok(__FieldTag::__publish_crl),
                            "publish_crl" => Ok(__FieldTag::__publish_crl),
                            "encodingFormat" => Ok(__FieldTag::__encoding_format),
                            "encoding_format" => Ok(__FieldTag::__encoding_format),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ca_pool::PublishingOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PublishingOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__publish_ca_cert => {
                            if !fields.insert(__FieldTag::__publish_ca_cert) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for publish_ca_cert",
                                ));
                            }
                            result.publish_ca_cert = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__publish_crl => {
                            if !fields.insert(__FieldTag::__publish_crl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for publish_crl",
                                ));
                            }
                            result.publish_crl = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encoding_format => {
                            if !fields.insert(__FieldTag::__encoding_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encoding_format",
                                ));
                            }
                            result.encoding_format = map
                                .next_value::<std::option::Option<
                                    crate::model::ca_pool::publishing_options::EncodingFormat,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ca_pool::IssuancePolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allowed_key_types,
            __backdate_duration,
            __maximum_lifetime,
            __allowed_issuance_modes,
            __baseline_values,
            __identity_constraints,
            __passthrough_extensions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IssuancePolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowedKeyTypes" => Ok(__FieldTag::__allowed_key_types),
                            "allowed_key_types" => Ok(__FieldTag::__allowed_key_types),
                            "backdateDuration" => Ok(__FieldTag::__backdate_duration),
                            "backdate_duration" => Ok(__FieldTag::__backdate_duration),
                            "maximumLifetime" => Ok(__FieldTag::__maximum_lifetime),
                            "maximum_lifetime" => Ok(__FieldTag::__maximum_lifetime),
                            "allowedIssuanceModes" => Ok(__FieldTag::__allowed_issuance_modes),
                            "allowed_issuance_modes" => Ok(__FieldTag::__allowed_issuance_modes),
                            "baselineValues" => Ok(__FieldTag::__baseline_values),
                            "baseline_values" => Ok(__FieldTag::__baseline_values),
                            "identityConstraints" => Ok(__FieldTag::__identity_constraints),
                            "identity_constraints" => Ok(__FieldTag::__identity_constraints),
                            "passthroughExtensions" => Ok(__FieldTag::__passthrough_extensions),
                            "passthrough_extensions" => Ok(__FieldTag::__passthrough_extensions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ca_pool::IssuancePolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IssuancePolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allowed_key_types => {
                            if !fields.insert(__FieldTag::__allowed_key_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_key_types",
                                ));
                            }
                            result.allowed_key_types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::ca_pool::issuance_policy::AllowedKeyType,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backdate_duration => {
                            if !fields.insert(__FieldTag::__backdate_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backdate_duration",
                                ));
                            }
                            result.backdate_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__maximum_lifetime => {
                            if !fields.insert(__FieldTag::__maximum_lifetime) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maximum_lifetime",
                                ));
                            }
                            result.maximum_lifetime =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__allowed_issuance_modes => {
                            if !fields.insert(__FieldTag::__allowed_issuance_modes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_issuance_modes",
                                ));
                            }
                            result.allowed_issuance_modes = map.next_value::<std::option::Option<
                                crate::model::ca_pool::issuance_policy::IssuanceModes,
                            >>()?;
                        }
                        __FieldTag::__baseline_values => {
                            if !fields.insert(__FieldTag::__baseline_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for baseline_values",
                                ));
                            }
                            result.baseline_values = map
                                .next_value::<std::option::Option<crate::model::X509Parameters>>(
                                )?;
                        }
                        __FieldTag::__identity_constraints => {
                            if !fields.insert(__FieldTag::__identity_constraints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for identity_constraints",
                                ));
                            }
                            result.identity_constraints =
                                map.next_value::<std::option::Option<
                                    crate::model::CertificateIdentityConstraints,
                                >>()?;
                        }
                        __FieldTag::__passthrough_extensions => {
                            if !fields.insert(__FieldTag::__passthrough_extensions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for passthrough_extensions",
                                ));
                            }
                            result.passthrough_extensions = map.next_value::<std::option::Option<
                                crate::model::CertificateExtensionConstraints,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ca_pool::issuance_policy::AllowedKeyType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rsa,
            __elliptic_curve,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AllowedKeyType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rsa" => Ok(__FieldTag::__rsa),
                            "ellipticCurve" => Ok(__FieldTag::__elliptic_curve),
                            "elliptic_curve" => Ok(__FieldTag::__elliptic_curve),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ca_pool::issuance_policy::AllowedKeyType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AllowedKeyType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rsa => {
                            if !fields.insert(__FieldTag::__rsa) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rsa",
                                ));
                            }
                            if result.key_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `key_type`, a oneof with full ID .google.cloud.security.privateca.v1.CaPool.IssuancePolicy.AllowedKeyType.rsa, latest field was rsa",
                                ));
                            }
                            result.key_type = std::option::Option::Some(
                                crate::model::ca_pool::issuance_policy::allowed_key_type::KeyType::Rsa(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ca_pool::issuance_policy::allowed_key_type::RsaKeyType>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__elliptic_curve => {
                            if !fields.insert(__FieldTag::__elliptic_curve) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for elliptic_curve",
                                ));
                            }
                            if result.key_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `key_type`, a oneof with full ID .google.cloud.security.privateca.v1.CaPool.IssuancePolicy.AllowedKeyType.elliptic_curve, latest field was ellipticCurve",
                                ));
                            }
                            result.key_type = std::option::Option::Some(
                                crate::model::ca_pool::issuance_policy::allowed_key_type::KeyType::EllipticCurve(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ca_pool::issuance_policy::allowed_key_type::EcKeyType>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::ca_pool::issuance_policy::allowed_key_type::RsaKeyType
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __min_modulus_size,
            __max_modulus_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RsaKeyType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "minModulusSize" => Ok(__FieldTag::__min_modulus_size),
                            "min_modulus_size" => Ok(__FieldTag::__min_modulus_size),
                            "maxModulusSize" => Ok(__FieldTag::__max_modulus_size),
                            "max_modulus_size" => Ok(__FieldTag::__max_modulus_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ca_pool::issuance_policy::allowed_key_type::RsaKeyType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RsaKeyType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__min_modulus_size => {
                            if !fields.insert(__FieldTag::__min_modulus_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_modulus_size",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_modulus_size =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_modulus_size => {
                            if !fields.insert(__FieldTag::__max_modulus_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_modulus_size",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_modulus_size =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::ca_pool::issuance_policy::allowed_key_type::EcKeyType
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __signature_algorithm,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EcKeyType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "signatureAlgorithm" => Ok(__FieldTag::__signature_algorithm),
                            "signature_algorithm" => Ok(__FieldTag::__signature_algorithm),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ca_pool::issuance_policy::allowed_key_type::EcKeyType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EcKeyType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__signature_algorithm => {
                            if !fields.insert(__FieldTag::__signature_algorithm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for signature_algorithm",
                                ));
                            }
                            result.signature_algorithm = map.next_value::<std::option::Option<crate::model::ca_pool::issuance_policy::allowed_key_type::ec_key_type::EcSignatureAlgorithm>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ca_pool::issuance_policy::IssuanceModes {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allow_csr_based_issuance,
            __allow_config_based_issuance,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IssuanceModes")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowCsrBasedIssuance" => Ok(__FieldTag::__allow_csr_based_issuance),
                            "allow_csr_based_issuance" => {
                                Ok(__FieldTag::__allow_csr_based_issuance)
                            }
                            "allowConfigBasedIssuance" => {
                                Ok(__FieldTag::__allow_config_based_issuance)
                            }
                            "allow_config_based_issuance" => {
                                Ok(__FieldTag::__allow_config_based_issuance)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ca_pool::issuance_policy::IssuanceModes;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IssuanceModes")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allow_csr_based_issuance => {
                            if !fields.insert(__FieldTag::__allow_csr_based_issuance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_csr_based_issuance",
                                ));
                            }
                            result.allow_csr_based_issuance = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_config_based_issuance => {
                            if !fields.insert(__FieldTag::__allow_config_based_issuance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_config_based_issuance",
                                ));
                            }
                            result.allow_config_based_issuance = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CertificateRevocationList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __sequence_number,
            __revoked_certificates,
            __pem_crl,
            __access_url,
            __state,
            __create_time,
            __update_time,
            __revision_id,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CertificateRevocationList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "sequenceNumber" => Ok(__FieldTag::__sequence_number),
                            "sequence_number" => Ok(__FieldTag::__sequence_number),
                            "revokedCertificates" => Ok(__FieldTag::__revoked_certificates),
                            "revoked_certificates" => Ok(__FieldTag::__revoked_certificates),
                            "pemCrl" => Ok(__FieldTag::__pem_crl),
                            "pem_crl" => Ok(__FieldTag::__pem_crl),
                            "accessUrl" => Ok(__FieldTag::__access_url),
                            "access_url" => Ok(__FieldTag::__access_url),
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "revisionId" => Ok(__FieldTag::__revision_id),
                            "revision_id" => Ok(__FieldTag::__revision_id),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CertificateRevocationList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CertificateRevocationList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sequence_number => {
                            if !fields.insert(__FieldTag::__sequence_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sequence_number",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sequence_number =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__revoked_certificates => {
                            if !fields.insert(__FieldTag::__revoked_certificates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revoked_certificates",
                                ));
                            }
                            result.revoked_certificates = map.next_value::<std::option::Option<std::vec::Vec<crate::model::certificate_revocation_list::RevokedCertificate>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__pem_crl => {
                            if !fields.insert(__FieldTag::__pem_crl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pem_crl",
                                ));
                            }
                            result.pem_crl = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__access_url => {
                            if !fields.insert(__FieldTag::__access_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_url",
                                ));
                            }
                            result.access_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<
                                    crate::model::certificate_revocation_list::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__revision_id => {
                            if !fields.insert(__FieldTag::__revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_id",
                                ));
                            }
                            result.revision_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::certificate_revocation_list::RevokedCertificate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certificate,
            __hex_serial_number,
            __revocation_reason,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RevokedCertificate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certificate" => Ok(__FieldTag::__certificate),
                            "hexSerialNumber" => Ok(__FieldTag::__hex_serial_number),
                            "hex_serial_number" => Ok(__FieldTag::__hex_serial_number),
                            "revocationReason" => Ok(__FieldTag::__revocation_reason),
                            "revocation_reason" => Ok(__FieldTag::__revocation_reason),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::certificate_revocation_list::RevokedCertificate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RevokedCertificate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certificate => {
                            if !fields.insert(__FieldTag::__certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate",
                                ));
                            }
                            result.certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hex_serial_number => {
                            if !fields.insert(__FieldTag::__hex_serial_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hex_serial_number",
                                ));
                            }
                            result.hex_serial_number = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revocation_reason => {
                            if !fields.insert(__FieldTag::__revocation_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revocation_reason",
                                ));
                            }
                            result.revocation_reason = map
                                .next_value::<std::option::Option<crate::model::RevocationReason>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Certificate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __pem_csr,
            __config,
            __issuer_certificate_authority,
            __lifetime,
            __certificate_template,
            __subject_mode,
            __revocation_details,
            __pem_certificate,
            __certificate_description,
            __pem_certificate_chain,
            __create_time,
            __update_time,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Certificate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "pemCsr" => Ok(__FieldTag::__pem_csr),
                            "pem_csr" => Ok(__FieldTag::__pem_csr),
                            "config" => Ok(__FieldTag::__config),
                            "issuerCertificateAuthority" => {
                                Ok(__FieldTag::__issuer_certificate_authority)
                            }
                            "issuer_certificate_authority" => {
                                Ok(__FieldTag::__issuer_certificate_authority)
                            }
                            "lifetime" => Ok(__FieldTag::__lifetime),
                            "certificateTemplate" => Ok(__FieldTag::__certificate_template),
                            "certificate_template" => Ok(__FieldTag::__certificate_template),
                            "subjectMode" => Ok(__FieldTag::__subject_mode),
                            "subject_mode" => Ok(__FieldTag::__subject_mode),
                            "revocationDetails" => Ok(__FieldTag::__revocation_details),
                            "revocation_details" => Ok(__FieldTag::__revocation_details),
                            "pemCertificate" => Ok(__FieldTag::__pem_certificate),
                            "pem_certificate" => Ok(__FieldTag::__pem_certificate),
                            "certificateDescription" => Ok(__FieldTag::__certificate_description),
                            "certificate_description" => Ok(__FieldTag::__certificate_description),
                            "pemCertificateChain" => Ok(__FieldTag::__pem_certificate_chain),
                            "pem_certificate_chain" => Ok(__FieldTag::__pem_certificate_chain),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Certificate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Certificate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pem_csr => {
                            if !fields.insert(__FieldTag::__pem_csr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pem_csr",
                                ));
                            }
                            if result.certificate_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `certificate_config`, a oneof with full ID .google.cloud.security.privateca.v1.Certificate.pem_csr, latest field was pemCsr",
                                ));
                            }
                            result.certificate_config = std::option::Option::Some(
                                crate::model::certificate::CertificateConfig::PemCsr(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            if result.certificate_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `certificate_config`, a oneof with full ID .google.cloud.security.privateca.v1.Certificate.config, latest field was config",
                                ));
                            }
                            result.certificate_config = std::option::Option::Some(
                                crate::model::certificate::CertificateConfig::Config(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CertificateConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__issuer_certificate_authority => {
                            if !fields.insert(__FieldTag::__issuer_certificate_authority) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issuer_certificate_authority",
                                ));
                            }
                            result.issuer_certificate_authority = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__lifetime => {
                            if !fields.insert(__FieldTag::__lifetime) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lifetime",
                                ));
                            }
                            result.lifetime =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__certificate_template => {
                            if !fields.insert(__FieldTag::__certificate_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_template",
                                ));
                            }
                            result.certificate_template = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject_mode => {
                            if !fields.insert(__FieldTag::__subject_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_mode",
                                ));
                            }
                            result.subject_mode = map.next_value::<std::option::Option<crate::model::SubjectRequestMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__revocation_details => {
                            if !fields.insert(__FieldTag::__revocation_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revocation_details",
                                ));
                            }
                            result.revocation_details =
                                map.next_value::<std::option::Option<
                                    crate::model::certificate::RevocationDetails,
                                >>()?;
                        }
                        __FieldTag::__pem_certificate => {
                            if !fields.insert(__FieldTag::__pem_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pem_certificate",
                                ));
                            }
                            result.pem_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__certificate_description => {
                            if !fields.insert(__FieldTag::__certificate_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_description",
                                ));
                            }
                            result.certificate_description = map.next_value::<std::option::Option<crate::model::CertificateDescription>>()?
                                ;
                        }
                        __FieldTag::__pem_certificate_chain => {
                            if !fields.insert(__FieldTag::__pem_certificate_chain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pem_certificate_chain",
                                ));
                            }
                            result.pem_certificate_chain = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::certificate::RevocationDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __revocation_state,
            __revocation_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RevocationDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "revocationState" => Ok(__FieldTag::__revocation_state),
                            "revocation_state" => Ok(__FieldTag::__revocation_state),
                            "revocationTime" => Ok(__FieldTag::__revocation_time),
                            "revocation_time" => Ok(__FieldTag::__revocation_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::certificate::RevocationDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RevocationDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__revocation_state => {
                            if !fields.insert(__FieldTag::__revocation_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revocation_state",
                                ));
                            }
                            result.revocation_state = map
                                .next_value::<std::option::Option<crate::model::RevocationReason>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revocation_time => {
                            if !fields.insert(__FieldTag::__revocation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revocation_time",
                                ));
                            }
                            result.revocation_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CertificateTemplate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __maximum_lifetime,
            __predefined_values,
            __identity_constraints,
            __passthrough_extensions,
            __description,
            __create_time,
            __update_time,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CertificateTemplate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "maximumLifetime" => Ok(__FieldTag::__maximum_lifetime),
                            "maximum_lifetime" => Ok(__FieldTag::__maximum_lifetime),
                            "predefinedValues" => Ok(__FieldTag::__predefined_values),
                            "predefined_values" => Ok(__FieldTag::__predefined_values),
                            "identityConstraints" => Ok(__FieldTag::__identity_constraints),
                            "identity_constraints" => Ok(__FieldTag::__identity_constraints),
                            "passthroughExtensions" => Ok(__FieldTag::__passthrough_extensions),
                            "passthrough_extensions" => Ok(__FieldTag::__passthrough_extensions),
                            "description" => Ok(__FieldTag::__description),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CertificateTemplate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CertificateTemplate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__maximum_lifetime => {
                            if !fields.insert(__FieldTag::__maximum_lifetime) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maximum_lifetime",
                                ));
                            }
                            result.maximum_lifetime =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__predefined_values => {
                            if !fields.insert(__FieldTag::__predefined_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predefined_values",
                                ));
                            }
                            result.predefined_values = map
                                .next_value::<std::option::Option<crate::model::X509Parameters>>(
                                )?;
                        }
                        __FieldTag::__identity_constraints => {
                            if !fields.insert(__FieldTag::__identity_constraints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for identity_constraints",
                                ));
                            }
                            result.identity_constraints =
                                map.next_value::<std::option::Option<
                                    crate::model::CertificateIdentityConstraints,
                                >>()?;
                        }
                        __FieldTag::__passthrough_extensions => {
                            if !fields.insert(__FieldTag::__passthrough_extensions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for passthrough_extensions",
                                ));
                            }
                            result.passthrough_extensions = map.next_value::<std::option::Option<
                                crate::model::CertificateExtensionConstraints,
                            >>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::X509Parameters {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key_usage,
            __ca_options,
            __policy_ids,
            __aia_ocsp_servers,
            __name_constraints,
            __additional_extensions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for X509Parameters")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "keyUsage" => Ok(__FieldTag::__key_usage),
                            "key_usage" => Ok(__FieldTag::__key_usage),
                            "caOptions" => Ok(__FieldTag::__ca_options),
                            "ca_options" => Ok(__FieldTag::__ca_options),
                            "policyIds" => Ok(__FieldTag::__policy_ids),
                            "policy_ids" => Ok(__FieldTag::__policy_ids),
                            "aiaOcspServers" => Ok(__FieldTag::__aia_ocsp_servers),
                            "aia_ocsp_servers" => Ok(__FieldTag::__aia_ocsp_servers),
                            "nameConstraints" => Ok(__FieldTag::__name_constraints),
                            "name_constraints" => Ok(__FieldTag::__name_constraints),
                            "additionalExtensions" => Ok(__FieldTag::__additional_extensions),
                            "additional_extensions" => Ok(__FieldTag::__additional_extensions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::X509Parameters;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct X509Parameters")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key_usage => {
                            if !fields.insert(__FieldTag::__key_usage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_usage",
                                ));
                            }
                            result.key_usage =
                                map.next_value::<std::option::Option<crate::model::KeyUsage>>()?;
                        }
                        __FieldTag::__ca_options => {
                            if !fields.insert(__FieldTag::__ca_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_options",
                                ));
                            }
                            result.ca_options = map.next_value::<std::option::Option<crate::model::x_509_parameters::CaOptions>>()?
                                ;
                        }
                        __FieldTag::__policy_ids => {
                            if !fields.insert(__FieldTag::__policy_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_ids",
                                ));
                            }
                            result.policy_ids = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ObjectId>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__aia_ocsp_servers => {
                            if !fields.insert(__FieldTag::__aia_ocsp_servers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aia_ocsp_servers",
                                ));
                            }
                            result.aia_ocsp_servers = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__name_constraints => {
                            if !fields.insert(__FieldTag::__name_constraints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name_constraints",
                                ));
                            }
                            result.name_constraints = map.next_value::<std::option::Option<
                                crate::model::x_509_parameters::NameConstraints,
                            >>()?;
                        }
                        __FieldTag::__additional_extensions => {
                            if !fields.insert(__FieldTag::__additional_extensions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_extensions",
                                ));
                            }
                            result.additional_extensions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::X509Extension>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::x_509_parameters::CaOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __is_ca,
            __max_issuer_path_length,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CaOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "isCa" => Ok(__FieldTag::__is_ca),
                            "is_ca" => Ok(__FieldTag::__is_ca),
                            "maxIssuerPathLength" => Ok(__FieldTag::__max_issuer_path_length),
                            "max_issuer_path_length" => Ok(__FieldTag::__max_issuer_path_length),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::x_509_parameters::CaOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CaOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__is_ca => {
                            if !fields.insert(__FieldTag::__is_ca) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_ca",
                                ));
                            }
                            result.is_ca = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__max_issuer_path_length => {
                            if !fields.insert(__FieldTag::__max_issuer_path_length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_issuer_path_length",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_issuer_path_length = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::x_509_parameters::NameConstraints {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __critical,
            __permitted_dns_names,
            __excluded_dns_names,
            __permitted_ip_ranges,
            __excluded_ip_ranges,
            __permitted_email_addresses,
            __excluded_email_addresses,
            __permitted_uris,
            __excluded_uris,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NameConstraints")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "critical" => Ok(__FieldTag::__critical),
                            "permittedDnsNames" => Ok(__FieldTag::__permitted_dns_names),
                            "permitted_dns_names" => Ok(__FieldTag::__permitted_dns_names),
                            "excludedDnsNames" => Ok(__FieldTag::__excluded_dns_names),
                            "excluded_dns_names" => Ok(__FieldTag::__excluded_dns_names),
                            "permittedIpRanges" => Ok(__FieldTag::__permitted_ip_ranges),
                            "permitted_ip_ranges" => Ok(__FieldTag::__permitted_ip_ranges),
                            "excludedIpRanges" => Ok(__FieldTag::__excluded_ip_ranges),
                            "excluded_ip_ranges" => Ok(__FieldTag::__excluded_ip_ranges),
                            "permittedEmailAddresses" => {
                                Ok(__FieldTag::__permitted_email_addresses)
                            }
                            "permitted_email_addresses" => {
                                Ok(__FieldTag::__permitted_email_addresses)
                            }
                            "excludedEmailAddresses" => Ok(__FieldTag::__excluded_email_addresses),
                            "excluded_email_addresses" => {
                                Ok(__FieldTag::__excluded_email_addresses)
                            }
                            "permittedUris" => Ok(__FieldTag::__permitted_uris),
                            "permitted_uris" => Ok(__FieldTag::__permitted_uris),
                            "excludedUris" => Ok(__FieldTag::__excluded_uris),
                            "excluded_uris" => Ok(__FieldTag::__excluded_uris),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::x_509_parameters::NameConstraints;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NameConstraints")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__critical => {
                            if !fields.insert(__FieldTag::__critical) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for critical",
                                ));
                            }
                            result.critical = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__permitted_dns_names => {
                            if !fields.insert(__FieldTag::__permitted_dns_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for permitted_dns_names",
                                ));
                            }
                            result.permitted_dns_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__excluded_dns_names => {
                            if !fields.insert(__FieldTag::__excluded_dns_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for excluded_dns_names",
                                ));
                            }
                            result.excluded_dns_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__permitted_ip_ranges => {
                            if !fields.insert(__FieldTag::__permitted_ip_ranges) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for permitted_ip_ranges",
                                ));
                            }
                            result.permitted_ip_ranges = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__excluded_ip_ranges => {
                            if !fields.insert(__FieldTag::__excluded_ip_ranges) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for excluded_ip_ranges",
                                ));
                            }
                            result.excluded_ip_ranges = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__permitted_email_addresses => {
                            if !fields.insert(__FieldTag::__permitted_email_addresses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for permitted_email_addresses",
                                ));
                            }
                            result.permitted_email_addresses = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__excluded_email_addresses => {
                            if !fields.insert(__FieldTag::__excluded_email_addresses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for excluded_email_addresses",
                                ));
                            }
                            result.excluded_email_addresses = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__permitted_uris => {
                            if !fields.insert(__FieldTag::__permitted_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for permitted_uris",
                                ));
                            }
                            result.permitted_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__excluded_uris => {
                            if !fields.insert(__FieldTag::__excluded_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for excluded_uris",
                                ));
                            }
                            result.excluded_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SubordinateConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certificate_authority,
            __pem_issuer_chain,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SubordinateConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certificateAuthority" => Ok(__FieldTag::__certificate_authority),
                            "certificate_authority" => Ok(__FieldTag::__certificate_authority),
                            "pemIssuerChain" => Ok(__FieldTag::__pem_issuer_chain),
                            "pem_issuer_chain" => Ok(__FieldTag::__pem_issuer_chain),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SubordinateConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SubordinateConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certificate_authority => {
                            if !fields.insert(__FieldTag::__certificate_authority) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_authority",
                                ));
                            }
                            if result.subordinate_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `subordinate_config`, a oneof with full ID .google.cloud.security.privateca.v1.SubordinateConfig.certificate_authority, latest field was certificateAuthority",
                                ));
                            }
                            result.subordinate_config = std::option::Option::Some(
                                crate::model::subordinate_config::SubordinateConfig::CertificateAuthority(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__pem_issuer_chain => {
                            if !fields.insert(__FieldTag::__pem_issuer_chain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pem_issuer_chain",
                                ));
                            }
                            if result.subordinate_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `subordinate_config`, a oneof with full ID .google.cloud.security.privateca.v1.SubordinateConfig.pem_issuer_chain, latest field was pemIssuerChain",
                                ));
                            }
                            result.subordinate_config = std::option::Option::Some(
                                crate::model::subordinate_config::SubordinateConfig::PemIssuerChain(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::subordinate_config::SubordinateConfigChain>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::subordinate_config::SubordinateConfigChain {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pem_certificates,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SubordinateConfigChain")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pemCertificates" => Ok(__FieldTag::__pem_certificates),
                            "pem_certificates" => Ok(__FieldTag::__pem_certificates),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::subordinate_config::SubordinateConfigChain;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SubordinateConfigChain")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pem_certificates => {
                            if !fields.insert(__FieldTag::__pem_certificates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pem_certificates",
                                ));
                            }
                            result.pem_certificates = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PublicKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            __format,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PublicKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            "format" => Ok(__FieldTag::__format),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PublicKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PublicKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.key = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__format => {
                            if !fields.insert(__FieldTag::__format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for format",
                                ));
                            }
                            result.format = map.next_value::<std::option::Option<crate::model::public_key::KeyFormat>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CertificateConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subject_config,
            __x509_config,
            __public_key,
            __subject_key_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CertificateConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subjectConfig" => Ok(__FieldTag::__subject_config),
                            "subject_config" => Ok(__FieldTag::__subject_config),
                            "x509Config" => Ok(__FieldTag::__x509_config),
                            "x509_config" => Ok(__FieldTag::__x509_config),
                            "publicKey" => Ok(__FieldTag::__public_key),
                            "public_key" => Ok(__FieldTag::__public_key),
                            "subjectKeyId" => Ok(__FieldTag::__subject_key_id),
                            "subject_key_id" => Ok(__FieldTag::__subject_key_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CertificateConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CertificateConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subject_config => {
                            if !fields.insert(__FieldTag::__subject_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_config",
                                ));
                            }
                            result.subject_config = map.next_value::<std::option::Option<
                                crate::model::certificate_config::SubjectConfig,
                            >>()?;
                        }
                        __FieldTag::__x509_config => {
                            if !fields.insert(__FieldTag::__x509_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for x509_config",
                                ));
                            }
                            result.x509_config = map
                                .next_value::<std::option::Option<crate::model::X509Parameters>>(
                                )?;
                        }
                        __FieldTag::__public_key => {
                            if !fields.insert(__FieldTag::__public_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_key",
                                ));
                            }
                            result.public_key =
                                map.next_value::<std::option::Option<crate::model::PublicKey>>()?;
                        }
                        __FieldTag::__subject_key_id => {
                            if !fields.insert(__FieldTag::__subject_key_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_key_id",
                                ));
                            }
                            result.subject_key_id = map.next_value::<std::option::Option<crate::model::certificate_config::KeyId>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::certificate_config::SubjectConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subject,
            __subject_alt_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SubjectConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subject" => Ok(__FieldTag::__subject),
                            "subjectAltName" => Ok(__FieldTag::__subject_alt_name),
                            "subject_alt_name" => Ok(__FieldTag::__subject_alt_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::certificate_config::SubjectConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SubjectConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subject => {
                            if !fields.insert(__FieldTag::__subject) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject",
                                ));
                            }
                            result.subject =
                                map.next_value::<std::option::Option<crate::model::Subject>>()?;
                        }
                        __FieldTag::__subject_alt_name => {
                            if !fields.insert(__FieldTag::__subject_alt_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_alt_name",
                                ));
                            }
                            result.subject_alt_name = map
                                .next_value::<std::option::Option<crate::model::SubjectAltNames>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::certificate_config::KeyId {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KeyId")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "keyId" => Ok(__FieldTag::__key_id),
                            "key_id" => Ok(__FieldTag::__key_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::certificate_config::KeyId;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KeyId")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key_id => {
                            if !fields.insert(__FieldTag::__key_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_id",
                                ));
                            }
                            result.key_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CertificateDescription {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subject_description,
            __x509_description,
            __public_key,
            __subject_key_id,
            __authority_key_id,
            __crl_distribution_points,
            __aia_issuing_certificate_urls,
            __cert_fingerprint,
            __tbs_certificate_digest,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CertificateDescription")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subjectDescription" => Ok(__FieldTag::__subject_description),
                            "subject_description" => Ok(__FieldTag::__subject_description),
                            "x509Description" => Ok(__FieldTag::__x509_description),
                            "x509_description" => Ok(__FieldTag::__x509_description),
                            "publicKey" => Ok(__FieldTag::__public_key),
                            "public_key" => Ok(__FieldTag::__public_key),
                            "subjectKeyId" => Ok(__FieldTag::__subject_key_id),
                            "subject_key_id" => Ok(__FieldTag::__subject_key_id),
                            "authorityKeyId" => Ok(__FieldTag::__authority_key_id),
                            "authority_key_id" => Ok(__FieldTag::__authority_key_id),
                            "crlDistributionPoints" => Ok(__FieldTag::__crl_distribution_points),
                            "crl_distribution_points" => Ok(__FieldTag::__crl_distribution_points),
                            "aiaIssuingCertificateUrls" => {
                                Ok(__FieldTag::__aia_issuing_certificate_urls)
                            }
                            "aia_issuing_certificate_urls" => {
                                Ok(__FieldTag::__aia_issuing_certificate_urls)
                            }
                            "certFingerprint" => Ok(__FieldTag::__cert_fingerprint),
                            "cert_fingerprint" => Ok(__FieldTag::__cert_fingerprint),
                            "tbsCertificateDigest" => Ok(__FieldTag::__tbs_certificate_digest),
                            "tbs_certificate_digest" => Ok(__FieldTag::__tbs_certificate_digest),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CertificateDescription;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CertificateDescription")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subject_description => {
                            if !fields.insert(__FieldTag::__subject_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_description",
                                ));
                            }
                            result.subject_description = map.next_value::<std::option::Option<
                                crate::model::certificate_description::SubjectDescription,
                            >>()?;
                        }
                        __FieldTag::__x509_description => {
                            if !fields.insert(__FieldTag::__x509_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for x509_description",
                                ));
                            }
                            result.x509_description = map
                                .next_value::<std::option::Option<crate::model::X509Parameters>>(
                                )?;
                        }
                        __FieldTag::__public_key => {
                            if !fields.insert(__FieldTag::__public_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_key",
                                ));
                            }
                            result.public_key =
                                map.next_value::<std::option::Option<crate::model::PublicKey>>()?;
                        }
                        __FieldTag::__subject_key_id => {
                            if !fields.insert(__FieldTag::__subject_key_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_key_id",
                                ));
                            }
                            result.subject_key_id =
                                map.next_value::<std::option::Option<
                                    crate::model::certificate_description::KeyId,
                                >>()?;
                        }
                        __FieldTag::__authority_key_id => {
                            if !fields.insert(__FieldTag::__authority_key_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authority_key_id",
                                ));
                            }
                            result.authority_key_id =
                                map.next_value::<std::option::Option<
                                    crate::model::certificate_description::KeyId,
                                >>()?;
                        }
                        __FieldTag::__crl_distribution_points => {
                            if !fields.insert(__FieldTag::__crl_distribution_points) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crl_distribution_points",
                                ));
                            }
                            result.crl_distribution_points = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__aia_issuing_certificate_urls => {
                            if !fields.insert(__FieldTag::__aia_issuing_certificate_urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aia_issuing_certificate_urls",
                                ));
                            }
                            result.aia_issuing_certificate_urls = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cert_fingerprint => {
                            if !fields.insert(__FieldTag::__cert_fingerprint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cert_fingerprint",
                                ));
                            }
                            result.cert_fingerprint = map.next_value::<std::option::Option<
                                crate::model::certificate_description::CertificateFingerprint,
                            >>()?;
                        }
                        __FieldTag::__tbs_certificate_digest => {
                            if !fields.insert(__FieldTag::__tbs_certificate_digest) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tbs_certificate_digest",
                                ));
                            }
                            result.tbs_certificate_digest = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::certificate_description::SubjectDescription {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subject,
            __subject_alt_name,
            __hex_serial_number,
            __lifetime,
            __not_before_time,
            __not_after_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SubjectDescription")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subject" => Ok(__FieldTag::__subject),
                            "subjectAltName" => Ok(__FieldTag::__subject_alt_name),
                            "subject_alt_name" => Ok(__FieldTag::__subject_alt_name),
                            "hexSerialNumber" => Ok(__FieldTag::__hex_serial_number),
                            "hex_serial_number" => Ok(__FieldTag::__hex_serial_number),
                            "lifetime" => Ok(__FieldTag::__lifetime),
                            "notBeforeTime" => Ok(__FieldTag::__not_before_time),
                            "not_before_time" => Ok(__FieldTag::__not_before_time),
                            "notAfterTime" => Ok(__FieldTag::__not_after_time),
                            "not_after_time" => Ok(__FieldTag::__not_after_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::certificate_description::SubjectDescription;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SubjectDescription")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subject => {
                            if !fields.insert(__FieldTag::__subject) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject",
                                ));
                            }
                            result.subject =
                                map.next_value::<std::option::Option<crate::model::Subject>>()?;
                        }
                        __FieldTag::__subject_alt_name => {
                            if !fields.insert(__FieldTag::__subject_alt_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_alt_name",
                                ));
                            }
                            result.subject_alt_name = map
                                .next_value::<std::option::Option<crate::model::SubjectAltNames>>(
                                )?;
                        }
                        __FieldTag::__hex_serial_number => {
                            if !fields.insert(__FieldTag::__hex_serial_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hex_serial_number",
                                ));
                            }
                            result.hex_serial_number = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__lifetime => {
                            if !fields.insert(__FieldTag::__lifetime) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lifetime",
                                ));
                            }
                            result.lifetime =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__not_before_time => {
                            if !fields.insert(__FieldTag::__not_before_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for not_before_time",
                                ));
                            }
                            result.not_before_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__not_after_time => {
                            if !fields.insert(__FieldTag::__not_after_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for not_after_time",
                                ));
                            }
                            result.not_after_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::certificate_description::KeyId {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KeyId")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "keyId" => Ok(__FieldTag::__key_id),
                            "key_id" => Ok(__FieldTag::__key_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::certificate_description::KeyId;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KeyId")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key_id => {
                            if !fields.insert(__FieldTag::__key_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_id",
                                ));
                            }
                            result.key_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::certificate_description::CertificateFingerprint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sha256_hash,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CertificateFingerprint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sha256Hash" => Ok(__FieldTag::__sha256_hash),
                            "sha256_hash" => Ok(__FieldTag::__sha256_hash),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::certificate_description::CertificateFingerprint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CertificateFingerprint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sha256_hash => {
                            if !fields.insert(__FieldTag::__sha256_hash) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sha256_hash",
                                ));
                            }
                            result.sha256_hash = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ObjectId {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __object_id_path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ObjectId")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "objectIdPath" => Ok(__FieldTag::__object_id_path),
                            "object_id_path" => Ok(__FieldTag::__object_id_path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ObjectId;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ObjectId")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__object_id_path => {
                            if !fields.insert(__FieldTag::__object_id_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object_id_path",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.object_id_path =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::X509Extension {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __object_id,
            __critical,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for X509Extension")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "objectId" => Ok(__FieldTag::__object_id),
                            "object_id" => Ok(__FieldTag::__object_id),
                            "critical" => Ok(__FieldTag::__critical),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::X509Extension;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct X509Extension")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__object_id => {
                            if !fields.insert(__FieldTag::__object_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object_id",
                                ));
                            }
                            result.object_id =
                                map.next_value::<std::option::Option<crate::model::ObjectId>>()?;
                        }
                        __FieldTag::__critical => {
                            if !fields.insert(__FieldTag::__critical) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for critical",
                                ));
                            }
                            result.critical = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::KeyUsage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __base_key_usage,
            __extended_key_usage,
            __unknown_extended_key_usages,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KeyUsage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "baseKeyUsage" => Ok(__FieldTag::__base_key_usage),
                            "base_key_usage" => Ok(__FieldTag::__base_key_usage),
                            "extendedKeyUsage" => Ok(__FieldTag::__extended_key_usage),
                            "extended_key_usage" => Ok(__FieldTag::__extended_key_usage),
                            "unknownExtendedKeyUsages" => {
                                Ok(__FieldTag::__unknown_extended_key_usages)
                            }
                            "unknown_extended_key_usages" => {
                                Ok(__FieldTag::__unknown_extended_key_usages)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::KeyUsage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KeyUsage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__base_key_usage => {
                            if !fields.insert(__FieldTag::__base_key_usage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_key_usage",
                                ));
                            }
                            result.base_key_usage = map.next_value::<std::option::Option<crate::model::key_usage::KeyUsageOptions>>()?
                                ;
                        }
                        __FieldTag::__extended_key_usage => {
                            if !fields.insert(__FieldTag::__extended_key_usage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for extended_key_usage",
                                ));
                            }
                            result.extended_key_usage = map.next_value::<std::option::Option<
                                crate::model::key_usage::ExtendedKeyUsageOptions,
                            >>()?;
                        }
                        __FieldTag::__unknown_extended_key_usages => {
                            if !fields.insert(__FieldTag::__unknown_extended_key_usages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unknown_extended_key_usages",
                                ));
                            }
                            result.unknown_extended_key_usages = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ObjectId>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::key_usage::KeyUsageOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __digital_signature,
            __content_commitment,
            __key_encipherment,
            __data_encipherment,
            __key_agreement,
            __cert_sign,
            __crl_sign,
            __encipher_only,
            __decipher_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KeyUsageOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "digitalSignature" => Ok(__FieldTag::__digital_signature),
                            "digital_signature" => Ok(__FieldTag::__digital_signature),
                            "contentCommitment" => Ok(__FieldTag::__content_commitment),
                            "content_commitment" => Ok(__FieldTag::__content_commitment),
                            "keyEncipherment" => Ok(__FieldTag::__key_encipherment),
                            "key_encipherment" => Ok(__FieldTag::__key_encipherment),
                            "dataEncipherment" => Ok(__FieldTag::__data_encipherment),
                            "data_encipherment" => Ok(__FieldTag::__data_encipherment),
                            "keyAgreement" => Ok(__FieldTag::__key_agreement),
                            "key_agreement" => Ok(__FieldTag::__key_agreement),
                            "certSign" => Ok(__FieldTag::__cert_sign),
                            "cert_sign" => Ok(__FieldTag::__cert_sign),
                            "crlSign" => Ok(__FieldTag::__crl_sign),
                            "crl_sign" => Ok(__FieldTag::__crl_sign),
                            "encipherOnly" => Ok(__FieldTag::__encipher_only),
                            "encipher_only" => Ok(__FieldTag::__encipher_only),
                            "decipherOnly" => Ok(__FieldTag::__decipher_only),
                            "decipher_only" => Ok(__FieldTag::__decipher_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::key_usage::KeyUsageOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KeyUsageOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__digital_signature => {
                            if !fields.insert(__FieldTag::__digital_signature) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for digital_signature",
                                ));
                            }
                            result.digital_signature = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__content_commitment => {
                            if !fields.insert(__FieldTag::__content_commitment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content_commitment",
                                ));
                            }
                            result.content_commitment = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__key_encipherment => {
                            if !fields.insert(__FieldTag::__key_encipherment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_encipherment",
                                ));
                            }
                            result.key_encipherment = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_encipherment => {
                            if !fields.insert(__FieldTag::__data_encipherment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_encipherment",
                                ));
                            }
                            result.data_encipherment = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__key_agreement => {
                            if !fields.insert(__FieldTag::__key_agreement) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_agreement",
                                ));
                            }
                            result.key_agreement = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cert_sign => {
                            if !fields.insert(__FieldTag::__cert_sign) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cert_sign",
                                ));
                            }
                            result.cert_sign = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__crl_sign => {
                            if !fields.insert(__FieldTag::__crl_sign) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crl_sign",
                                ));
                            }
                            result.crl_sign = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encipher_only => {
                            if !fields.insert(__FieldTag::__encipher_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encipher_only",
                                ));
                            }
                            result.encipher_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__decipher_only => {
                            if !fields.insert(__FieldTag::__decipher_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for decipher_only",
                                ));
                            }
                            result.decipher_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::key_usage::ExtendedKeyUsageOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __server_auth,
            __client_auth,
            __code_signing,
            __email_protection,
            __time_stamping,
            __ocsp_signing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExtendedKeyUsageOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serverAuth" => Ok(__FieldTag::__server_auth),
                            "server_auth" => Ok(__FieldTag::__server_auth),
                            "clientAuth" => Ok(__FieldTag::__client_auth),
                            "client_auth" => Ok(__FieldTag::__client_auth),
                            "codeSigning" => Ok(__FieldTag::__code_signing),
                            "code_signing" => Ok(__FieldTag::__code_signing),
                            "emailProtection" => Ok(__FieldTag::__email_protection),
                            "email_protection" => Ok(__FieldTag::__email_protection),
                            "timeStamping" => Ok(__FieldTag::__time_stamping),
                            "time_stamping" => Ok(__FieldTag::__time_stamping),
                            "ocspSigning" => Ok(__FieldTag::__ocsp_signing),
                            "ocsp_signing" => Ok(__FieldTag::__ocsp_signing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::key_usage::ExtendedKeyUsageOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExtendedKeyUsageOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__server_auth => {
                            if !fields.insert(__FieldTag::__server_auth) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for server_auth",
                                ));
                            }
                            result.server_auth = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_auth => {
                            if !fields.insert(__FieldTag::__client_auth) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_auth",
                                ));
                            }
                            result.client_auth = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__code_signing => {
                            if !fields.insert(__FieldTag::__code_signing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code_signing",
                                ));
                            }
                            result.code_signing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__email_protection => {
                            if !fields.insert(__FieldTag::__email_protection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email_protection",
                                ));
                            }
                            result.email_protection = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_stamping => {
                            if !fields.insert(__FieldTag::__time_stamping) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_stamping",
                                ));
                            }
                            result.time_stamping = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ocsp_signing => {
                            if !fields.insert(__FieldTag::__ocsp_signing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ocsp_signing",
                                ));
                            }
                            result.ocsp_signing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AttributeTypeAndValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __object_id,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttributeTypeAndValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "objectId" => Ok(__FieldTag::__object_id),
                            "object_id" => Ok(__FieldTag::__object_id),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AttributeTypeAndValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttributeTypeAndValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            if result.attribute_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `attribute_type`, a oneof with full ID .google.cloud.security.privateca.v1.AttributeTypeAndValue.type, latest field was type",
                                ));
                            }
                            result.attribute_type = std::option::Option::Some(
                                crate::model::attribute_type_and_value::AttributeType::Type(
                                    map.next_value::<std::option::Option<crate::model::AttributeType>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__object_id => {
                            if !fields.insert(__FieldTag::__object_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object_id",
                                ));
                            }
                            if result.attribute_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `attribute_type`, a oneof with full ID .google.cloud.security.privateca.v1.AttributeTypeAndValue.object_id, latest field was objectId",
                                ));
                            }
                            result.attribute_type = std::option::Option::Some(
                                crate::model::attribute_type_and_value::AttributeType::ObjectId(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ObjectId>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RelativeDistinguishedName {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attributes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RelativeDistinguishedName")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attributes" => Ok(__FieldTag::__attributes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RelativeDistinguishedName;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RelativeDistinguishedName")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes",
                                ));
                            }
                            result.attributes = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AttributeTypeAndValue>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Subject {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __common_name,
            __country_code,
            __organization,
            __organizational_unit,
            __locality,
            __province,
            __street_address,
            __postal_code,
            __rdn_sequence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Subject")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "commonName" => Ok(__FieldTag::__common_name),
                            "common_name" => Ok(__FieldTag::__common_name),
                            "countryCode" => Ok(__FieldTag::__country_code),
                            "country_code" => Ok(__FieldTag::__country_code),
                            "organization" => Ok(__FieldTag::__organization),
                            "organizationalUnit" => Ok(__FieldTag::__organizational_unit),
                            "organizational_unit" => Ok(__FieldTag::__organizational_unit),
                            "locality" => Ok(__FieldTag::__locality),
                            "province" => Ok(__FieldTag::__province),
                            "streetAddress" => Ok(__FieldTag::__street_address),
                            "street_address" => Ok(__FieldTag::__street_address),
                            "postalCode" => Ok(__FieldTag::__postal_code),
                            "postal_code" => Ok(__FieldTag::__postal_code),
                            "rdnSequence" => Ok(__FieldTag::__rdn_sequence),
                            "rdn_sequence" => Ok(__FieldTag::__rdn_sequence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Subject;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Subject")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__common_name => {
                            if !fields.insert(__FieldTag::__common_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_name",
                                ));
                            }
                            result.common_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__country_code => {
                            if !fields.insert(__FieldTag::__country_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for country_code",
                                ));
                            }
                            result.country_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__organization => {
                            if !fields.insert(__FieldTag::__organization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for organization",
                                ));
                            }
                            result.organization = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__organizational_unit => {
                            if !fields.insert(__FieldTag::__organizational_unit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for organizational_unit",
                                ));
                            }
                            result.organizational_unit = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__locality => {
                            if !fields.insert(__FieldTag::__locality) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locality",
                                ));
                            }
                            result.locality = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__province => {
                            if !fields.insert(__FieldTag::__province) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for province",
                                ));
                            }
                            result.province = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__street_address => {
                            if !fields.insert(__FieldTag::__street_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for street_address",
                                ));
                            }
                            result.street_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__postal_code => {
                            if !fields.insert(__FieldTag::__postal_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for postal_code",
                                ));
                            }
                            result.postal_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rdn_sequence => {
                            if !fields.insert(__FieldTag::__rdn_sequence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rdn_sequence",
                                ));
                            }
                            result.rdn_sequence = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RelativeDistinguishedName>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SubjectAltNames {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dns_names,
            __uris,
            __email_addresses,
            __ip_addresses,
            __custom_sans,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SubjectAltNames")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dnsNames" => Ok(__FieldTag::__dns_names),
                            "dns_names" => Ok(__FieldTag::__dns_names),
                            "uris" => Ok(__FieldTag::__uris),
                            "emailAddresses" => Ok(__FieldTag::__email_addresses),
                            "email_addresses" => Ok(__FieldTag::__email_addresses),
                            "ipAddresses" => Ok(__FieldTag::__ip_addresses),
                            "ip_addresses" => Ok(__FieldTag::__ip_addresses),
                            "customSans" => Ok(__FieldTag::__custom_sans),
                            "custom_sans" => Ok(__FieldTag::__custom_sans),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SubjectAltNames;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SubjectAltNames")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dns_names => {
                            if !fields.insert(__FieldTag::__dns_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dns_names",
                                ));
                            }
                            result.dns_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__uris => {
                            if !fields.insert(__FieldTag::__uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uris",
                                ));
                            }
                            result.uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__email_addresses => {
                            if !fields.insert(__FieldTag::__email_addresses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email_addresses",
                                ));
                            }
                            result.email_addresses = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__ip_addresses => {
                            if !fields.insert(__FieldTag::__ip_addresses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_addresses",
                                ));
                            }
                            result.ip_addresses = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__custom_sans => {
                            if !fields.insert(__FieldTag::__custom_sans) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_sans",
                                ));
                            }
                            result.custom_sans = map.next_value::<std::option::Option<std::vec::Vec<crate::model::X509Extension>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CertificateIdentityConstraints {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cel_expression,
            __allow_subject_passthrough,
            __allow_subject_alt_names_passthrough,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CertificateIdentityConstraints")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "celExpression" => Ok(__FieldTag::__cel_expression),
                            "cel_expression" => Ok(__FieldTag::__cel_expression),
                            "allowSubjectPassthrough" => {
                                Ok(__FieldTag::__allow_subject_passthrough)
                            }
                            "allow_subject_passthrough" => {
                                Ok(__FieldTag::__allow_subject_passthrough)
                            }
                            "allowSubjectAltNamesPassthrough" => {
                                Ok(__FieldTag::__allow_subject_alt_names_passthrough)
                            }
                            "allow_subject_alt_names_passthrough" => {
                                Ok(__FieldTag::__allow_subject_alt_names_passthrough)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CertificateIdentityConstraints;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CertificateIdentityConstraints")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cel_expression => {
                            if !fields.insert(__FieldTag::__cel_expression) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cel_expression",
                                ));
                            }
                            result.cel_expression =
                                map.next_value::<std::option::Option<gtype::model::Expr>>()?;
                        }
                        __FieldTag::__allow_subject_passthrough => {
                            if !fields.insert(__FieldTag::__allow_subject_passthrough) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_subject_passthrough",
                                ));
                            }
                            result.allow_subject_passthrough =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__allow_subject_alt_names_passthrough => {
                            if !fields.insert(__FieldTag::__allow_subject_alt_names_passthrough) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_subject_alt_names_passthrough",
                                ));
                            }
                            result.allow_subject_alt_names_passthrough =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CertificateExtensionConstraints {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __known_extensions,
            __additional_extensions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CertificateExtensionConstraints")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "knownExtensions" => Ok(__FieldTag::__known_extensions),
                            "known_extensions" => Ok(__FieldTag::__known_extensions),
                            "additionalExtensions" => Ok(__FieldTag::__additional_extensions),
                            "additional_extensions" => Ok(__FieldTag::__additional_extensions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CertificateExtensionConstraints;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CertificateExtensionConstraints")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__known_extensions => {
                            if !fields.insert(__FieldTag::__known_extensions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for known_extensions",
                                ));
                            }
                            result.known_extensions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::certificate_extension_constraints::KnownCertificateExtension>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__additional_extensions => {
                            if !fields.insert(__FieldTag::__additional_extensions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_extensions",
                                ));
                            }
                            result.additional_extensions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ObjectId>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateCertificateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __certificate_id,
            __certificate,
            __request_id,
            __validate_only,
            __issuing_certificate_authority_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCertificateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "certificateId" => Ok(__FieldTag::__certificate_id),
                            "certificate_id" => Ok(__FieldTag::__certificate_id),
                            "certificate" => Ok(__FieldTag::__certificate),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "issuingCertificateAuthorityId" => {
                                Ok(__FieldTag::__issuing_certificate_authority_id)
                            }
                            "issuing_certificate_authority_id" => {
                                Ok(__FieldTag::__issuing_certificate_authority_id)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateCertificateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCertificateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__certificate_id => {
                            if !fields.insert(__FieldTag::__certificate_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_id",
                                ));
                            }
                            result.certificate_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__certificate => {
                            if !fields.insert(__FieldTag::__certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate",
                                ));
                            }
                            result.certificate =
                                map.next_value::<std::option::Option<crate::model::Certificate>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__issuing_certificate_authority_id => {
                            if !fields.insert(__FieldTag::__issuing_certificate_authority_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issuing_certificate_authority_id",
                                ));
                            }
                            result.issuing_certificate_authority_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetCertificateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCertificateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetCertificateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCertificateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListCertificatesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCertificatesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListCertificatesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCertificatesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListCertificatesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certificates,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCertificatesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certificates" => Ok(__FieldTag::__certificates),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListCertificatesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCertificatesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certificates => {
                            if !fields.insert(__FieldTag::__certificates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificates",
                                ));
                            }
                            result.certificates = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Certificate>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RevokeCertificateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __reason,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RevokeCertificateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "reason" => Ok(__FieldTag::__reason),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RevokeCertificateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RevokeCertificateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reason => {
                            if !fields.insert(__FieldTag::__reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reason",
                                ));
                            }
                            result.reason = map
                                .next_value::<std::option::Option<crate::model::RevocationReason>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateCertificateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certificate,
            __update_mask,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateCertificateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certificate" => Ok(__FieldTag::__certificate),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateCertificateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCertificateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certificate => {
                            if !fields.insert(__FieldTag::__certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate",
                                ));
                            }
                            result.certificate =
                                map.next_value::<std::option::Option<crate::model::Certificate>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ActivateCertificateAuthorityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __pem_ca_certificate,
            __subordinate_config,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ActivateCertificateAuthorityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "pemCaCertificate" => Ok(__FieldTag::__pem_ca_certificate),
                            "pem_ca_certificate" => Ok(__FieldTag::__pem_ca_certificate),
                            "subordinateConfig" => Ok(__FieldTag::__subordinate_config),
                            "subordinate_config" => Ok(__FieldTag::__subordinate_config),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ActivateCertificateAuthorityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ActivateCertificateAuthorityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pem_ca_certificate => {
                            if !fields.insert(__FieldTag::__pem_ca_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pem_ca_certificate",
                                ));
                            }
                            result.pem_ca_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subordinate_config => {
                            if !fields.insert(__FieldTag::__subordinate_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subordinate_config",
                                ));
                            }
                            result.subordinate_config = map
                                .next_value::<std::option::Option<crate::model::SubordinateConfig>>(
                                )?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateCertificateAuthorityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __certificate_authority_id,
            __certificate_authority,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCertificateAuthorityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "certificateAuthorityId" => Ok(__FieldTag::__certificate_authority_id),
                            "certificate_authority_id" => {
                                Ok(__FieldTag::__certificate_authority_id)
                            }
                            "certificateAuthority" => Ok(__FieldTag::__certificate_authority),
                            "certificate_authority" => Ok(__FieldTag::__certificate_authority),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateCertificateAuthorityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCertificateAuthorityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__certificate_authority_id => {
                            if !fields.insert(__FieldTag::__certificate_authority_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_authority_id",
                                ));
                            }
                            result.certificate_authority_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__certificate_authority => {
                            if !fields.insert(__FieldTag::__certificate_authority) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_authority",
                                ));
                            }
                            result.certificate_authority = map.next_value::<std::option::Option<crate::model::CertificateAuthority>>()?
                                ;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DisableCertificateAuthorityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __ignore_dependent_resources,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DisableCertificateAuthorityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "ignoreDependentResources" => {
                                Ok(__FieldTag::__ignore_dependent_resources)
                            }
                            "ignore_dependent_resources" => {
                                Ok(__FieldTag::__ignore_dependent_resources)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DisableCertificateAuthorityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DisableCertificateAuthorityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore_dependent_resources => {
                            if !fields.insert(__FieldTag::__ignore_dependent_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_dependent_resources",
                                ));
                            }
                            result.ignore_dependent_resources = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::EnableCertificateAuthorityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnableCertificateAuthorityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::EnableCertificateAuthorityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnableCertificateAuthorityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::FetchCertificateAuthorityCsrRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchCertificateAuthorityCsrRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::FetchCertificateAuthorityCsrRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchCertificateAuthorityCsrRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::FetchCertificateAuthorityCsrResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pem_csr,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchCertificateAuthorityCsrResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pemCsr" => Ok(__FieldTag::__pem_csr),
                            "pem_csr" => Ok(__FieldTag::__pem_csr),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::FetchCertificateAuthorityCsrResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchCertificateAuthorityCsrResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pem_csr => {
                            if !fields.insert(__FieldTag::__pem_csr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pem_csr",
                                ));
                            }
                            result.pem_csr = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetCertificateAuthorityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCertificateAuthorityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetCertificateAuthorityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCertificateAuthorityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListCertificateAuthoritiesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCertificateAuthoritiesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListCertificateAuthoritiesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCertificateAuthoritiesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListCertificateAuthoritiesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certificate_authorities,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCertificateAuthoritiesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certificateAuthorities" => Ok(__FieldTag::__certificate_authorities),
                            "certificate_authorities" => Ok(__FieldTag::__certificate_authorities),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListCertificateAuthoritiesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCertificateAuthoritiesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certificate_authorities => {
                            if !fields.insert(__FieldTag::__certificate_authorities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_authorities",
                                ));
                            }
                            result.certificate_authorities = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CertificateAuthority>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UndeleteCertificateAuthorityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UndeleteCertificateAuthorityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UndeleteCertificateAuthorityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UndeleteCertificateAuthorityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteCertificateAuthorityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __ignore_active_certificates,
            __skip_grace_period,
            __ignore_dependent_resources,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteCertificateAuthorityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "ignoreActiveCertificates" => {
                                Ok(__FieldTag::__ignore_active_certificates)
                            }
                            "ignore_active_certificates" => {
                                Ok(__FieldTag::__ignore_active_certificates)
                            }
                            "skipGracePeriod" => Ok(__FieldTag::__skip_grace_period),
                            "skip_grace_period" => Ok(__FieldTag::__skip_grace_period),
                            "ignoreDependentResources" => {
                                Ok(__FieldTag::__ignore_dependent_resources)
                            }
                            "ignore_dependent_resources" => {
                                Ok(__FieldTag::__ignore_dependent_resources)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteCertificateAuthorityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteCertificateAuthorityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore_active_certificates => {
                            if !fields.insert(__FieldTag::__ignore_active_certificates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_active_certificates",
                                ));
                            }
                            result.ignore_active_certificates = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skip_grace_period => {
                            if !fields.insert(__FieldTag::__skip_grace_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_grace_period",
                                ));
                            }
                            result.skip_grace_period = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore_dependent_resources => {
                            if !fields.insert(__FieldTag::__ignore_dependent_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_dependent_resources",
                                ));
                            }
                            result.ignore_dependent_resources = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateCertificateAuthorityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certificate_authority,
            __update_mask,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateCertificateAuthorityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certificateAuthority" => Ok(__FieldTag::__certificate_authority),
                            "certificate_authority" => Ok(__FieldTag::__certificate_authority),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateCertificateAuthorityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCertificateAuthorityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certificate_authority => {
                            if !fields.insert(__FieldTag::__certificate_authority) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_authority",
                                ));
                            }
                            result.certificate_authority = map.next_value::<std::option::Option<crate::model::CertificateAuthority>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateCaPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __ca_pool_id,
            __ca_pool,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCaPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "caPoolId" => Ok(__FieldTag::__ca_pool_id),
                            "ca_pool_id" => Ok(__FieldTag::__ca_pool_id),
                            "caPool" => Ok(__FieldTag::__ca_pool),
                            "ca_pool" => Ok(__FieldTag::__ca_pool),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateCaPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCaPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ca_pool_id => {
                            if !fields.insert(__FieldTag::__ca_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_pool_id",
                                ));
                            }
                            result.ca_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ca_pool => {
                            if !fields.insert(__FieldTag::__ca_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_pool",
                                ));
                            }
                            result.ca_pool =
                                map.next_value::<std::option::Option<crate::model::CaPool>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateCaPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ca_pool,
            __update_mask,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateCaPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "caPool" => Ok(__FieldTag::__ca_pool),
                            "ca_pool" => Ok(__FieldTag::__ca_pool),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateCaPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCaPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ca_pool => {
                            if !fields.insert(__FieldTag::__ca_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_pool",
                                ));
                            }
                            result.ca_pool =
                                map.next_value::<std::option::Option<crate::model::CaPool>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteCaPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __ignore_dependent_resources,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteCaPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "ignoreDependentResources" => {
                                Ok(__FieldTag::__ignore_dependent_resources)
                            }
                            "ignore_dependent_resources" => {
                                Ok(__FieldTag::__ignore_dependent_resources)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteCaPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteCaPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore_dependent_resources => {
                            if !fields.insert(__FieldTag::__ignore_dependent_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_dependent_resources",
                                ));
                            }
                            result.ignore_dependent_resources = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::FetchCaCertsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ca_pool,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchCaCertsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "caPool" => Ok(__FieldTag::__ca_pool),
                            "ca_pool" => Ok(__FieldTag::__ca_pool),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::FetchCaCertsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchCaCertsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ca_pool => {
                            if !fields.insert(__FieldTag::__ca_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_pool",
                                ));
                            }
                            result.ca_pool = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::FetchCaCertsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ca_certs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchCaCertsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "caCerts" => Ok(__FieldTag::__ca_certs),
                            "ca_certs" => Ok(__FieldTag::__ca_certs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::FetchCaCertsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchCaCertsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ca_certs => {
                            if !fields.insert(__FieldTag::__ca_certs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_certs",
                                ));
                            }
                            result.ca_certs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::fetch_ca_certs_response::CertChain>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::fetch_ca_certs_response::CertChain {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certificates,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CertChain")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certificates" => Ok(__FieldTag::__certificates),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::fetch_ca_certs_response::CertChain;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CertChain")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certificates => {
                            if !fields.insert(__FieldTag::__certificates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificates",
                                ));
                            }
                            result.certificates = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetCaPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCaPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetCaPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCaPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListCaPoolsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCaPoolsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListCaPoolsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCaPoolsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListCaPoolsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ca_pools,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCaPoolsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "caPools" => Ok(__FieldTag::__ca_pools),
                            "ca_pools" => Ok(__FieldTag::__ca_pools),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListCaPoolsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCaPoolsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ca_pools => {
                            if !fields.insert(__FieldTag::__ca_pools) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_pools",
                                ));
                            }
                            result.ca_pools = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CaPool>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetCertificateRevocationListRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCertificateRevocationListRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetCertificateRevocationListRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCertificateRevocationListRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListCertificateRevocationListsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListCertificateRevocationListsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListCertificateRevocationListsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCertificateRevocationListsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListCertificateRevocationListsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certificate_revocation_lists,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListCertificateRevocationListsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certificateRevocationLists" => {
                                Ok(__FieldTag::__certificate_revocation_lists)
                            }
                            "certificate_revocation_lists" => {
                                Ok(__FieldTag::__certificate_revocation_lists)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListCertificateRevocationListsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCertificateRevocationListsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certificate_revocation_lists => {
                            if !fields.insert(__FieldTag::__certificate_revocation_lists) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_revocation_lists",
                                ));
                            }
                            result.certificate_revocation_lists = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CertificateRevocationList>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateCertificateRevocationListRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certificate_revocation_list,
            __update_mask,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for UpdateCertificateRevocationListRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certificateRevocationList" => {
                                Ok(__FieldTag::__certificate_revocation_list)
                            }
                            "certificate_revocation_list" => {
                                Ok(__FieldTag::__certificate_revocation_list)
                            }
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateCertificateRevocationListRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCertificateRevocationListRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certificate_revocation_list => {
                            if !fields.insert(__FieldTag::__certificate_revocation_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_revocation_list",
                                ));
                            }
                            result.certificate_revocation_list = map.next_value::<std::option::Option<crate::model::CertificateRevocationList>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateCertificateTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __certificate_template_id,
            __certificate_template,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCertificateTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "certificateTemplateId" => Ok(__FieldTag::__certificate_template_id),
                            "certificate_template_id" => Ok(__FieldTag::__certificate_template_id),
                            "certificateTemplate" => Ok(__FieldTag::__certificate_template),
                            "certificate_template" => Ok(__FieldTag::__certificate_template),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateCertificateTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCertificateTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__certificate_template_id => {
                            if !fields.insert(__FieldTag::__certificate_template_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_template_id",
                                ));
                            }
                            result.certificate_template_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__certificate_template => {
                            if !fields.insert(__FieldTag::__certificate_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_template",
                                ));
                            }
                            result.certificate_template = map.next_value::<std::option::Option<crate::model::CertificateTemplate>>()?
                                ;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteCertificateTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteCertificateTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteCertificateTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteCertificateTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetCertificateTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCertificateTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetCertificateTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCertificateTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListCertificateTemplatesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCertificateTemplatesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListCertificateTemplatesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCertificateTemplatesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListCertificateTemplatesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certificate_templates,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCertificateTemplatesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certificateTemplates" => Ok(__FieldTag::__certificate_templates),
                            "certificate_templates" => Ok(__FieldTag::__certificate_templates),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListCertificateTemplatesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCertificateTemplatesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certificate_templates => {
                            if !fields.insert(__FieldTag::__certificate_templates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_templates",
                                ));
                            }
                            result.certificate_templates = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CertificateTemplate>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateCertificateTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certificate_template,
            __update_mask,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateCertificateTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certificateTemplate" => Ok(__FieldTag::__certificate_template),
                            "certificate_template" => Ok(__FieldTag::__certificate_template),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateCertificateTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCertificateTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certificate_template => {
                            if !fields.insert(__FieldTag::__certificate_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_template",
                                ));
                            }
                            result.certificate_template = map.next_value::<std::option::Option<crate::model::CertificateTemplate>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
