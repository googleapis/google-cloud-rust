// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A
/// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
/// represents an individual Certificate Authority. A
/// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
/// can be used to create
/// [Certificates][google.cloud.security.privateca.v1.Certificate].
///
/// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
/// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CertificateAuthority {
    /// Output only. The resource name for this
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// in the format `projects/*/locations/*/caPools/*/certificateAuthorities/*`.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub name: std::string::String,

    /// Required. Immutable. The
    /// [Type][google.cloud.security.privateca.v1.CertificateAuthority.Type] of
    /// this
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority].
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    /// [google.cloud.security.privateca.v1.CertificateAuthority.Type]: crate::model::certificate_authority::Type
    pub r#type: crate::model::certificate_authority::Type,

    /// Required. Immutable. The config used to create a self-signed X.509
    /// certificate or CSR.
    pub config: std::option::Option<crate::model::CertificateConfig>,

    /// Required. Immutable. The desired lifetime of the CA certificate. Used to
    /// create the "not_before_time" and "not_after_time" fields inside an X.509
    /// certificate.
    pub lifetime: std::option::Option<wkt::Duration>,

    /// Required. Immutable. Used when issuing certificates for this
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority].
    /// If this
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// is a self-signed CertificateAuthority, this key is also used to sign the
    /// self-signed CA certificate. Otherwise, it is used to sign a CSR.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub key_spec: std::option::Option<crate::model::certificate_authority::KeyVersionSpec>,

    /// Optional. If this is a subordinate
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority],
    /// this field will be set with the subordinate configuration, which describes
    /// its issuers. This may be updated, but this
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// must continue to validate.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub subordinate_config: std::option::Option<crate::model::SubordinateConfig>,

    /// Output only. The
    /// [CaPool.Tier][google.cloud.security.privateca.v1.CaPool.Tier] of the
    /// [CaPool][google.cloud.security.privateca.v1.CaPool] that includes this
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority].
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    /// [google.cloud.security.privateca.v1.CaPool.Tier]: crate::model::ca_pool::Tier
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub tier: crate::model::ca_pool::Tier,

    /// Output only. The
    /// [State][google.cloud.security.privateca.v1.CertificateAuthority.State] for
    /// this
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority].
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    /// [google.cloud.security.privateca.v1.CertificateAuthority.State]: crate::model::certificate_authority::State
    pub state: crate::model::certificate_authority::State,

    /// Output only. This
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s
    /// certificate chain, including the current
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s
    /// certificate. Ordered such that the root issuer is the final element
    /// (consistent with RFC 5246). For a self-signed CA, this will only list the
    /// current
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s
    /// certificate.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub pem_ca_certificates: std::vec::Vec<std::string::String>,

    /// Output only. A structured description of this
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s
    /// CA certificate and its issuers. Ordered as self-to-root.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub ca_certificate_descriptions: std::vec::Vec<crate::model::CertificateDescription>,

    /// Immutable. The name of a Cloud Storage bucket where this
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// will publish content, such as the CA certificate and CRLs. This must be a
    /// bucket name, without any prefixes (such as `gs://`) or suffixes (such as
    /// `.googleapis.com`). For example, to use a bucket named `my-bucket`, you
    /// would simply specify `my-bucket`. If not specified, a managed bucket will
    /// be created.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub gcs_bucket: std::string::String,

    /// Output only. URLs for accessing content published by this CA, such as the
    /// CA certificate and CRLs.
    pub access_urls: std::option::Option<crate::model::certificate_authority::AccessUrls>,

    /// Output only. The time at which this
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// was created.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// was last updated.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// was soft deleted, if it is in the
    /// [DELETED][google.cloud.security.privateca.v1.CertificateAuthority.State.DELETED]
    /// state.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    /// [google.cloud.security.privateca.v1.CertificateAuthority.State.DELETED]: crate::model::certificate_authority::State::Deleted
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// will be permanently purged, if it is in the
    /// [DELETED][google.cloud.security.privateca.v1.CertificateAuthority.State.DELETED]
    /// state.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    /// [google.cloud.security.privateca.v1.CertificateAuthority.State.DELETED]: crate::model::certificate_authority::State::Deleted
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Labels with user-defined metadata.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CertificateAuthority {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CertificateAuthority::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::CertificateAuthority::type].
    pub fn set_type<T: std::convert::Into<crate::model::certificate_authority::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [config][crate::model::CertificateAuthority::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CertificateConfig>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::CertificateAuthority::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CertificateConfig>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [lifetime][crate::model::CertificateAuthority::lifetime].
    pub fn set_lifetime<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.lifetime = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [lifetime][crate::model::CertificateAuthority::lifetime].
    pub fn set_or_clear_lifetime<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.lifetime = v.map(|x| x.into());
        self
    }

    /// Sets the value of [key_spec][crate::model::CertificateAuthority::key_spec].
    pub fn set_key_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::certificate_authority::KeyVersionSpec>,
    {
        self.key_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [key_spec][crate::model::CertificateAuthority::key_spec].
    pub fn set_or_clear_key_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::certificate_authority::KeyVersionSpec>,
    {
        self.key_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [subordinate_config][crate::model::CertificateAuthority::subordinate_config].
    pub fn set_subordinate_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SubordinateConfig>,
    {
        self.subordinate_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subordinate_config][crate::model::CertificateAuthority::subordinate_config].
    pub fn set_or_clear_subordinate_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SubordinateConfig>,
    {
        self.subordinate_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tier][crate::model::CertificateAuthority::tier].
    pub fn set_tier<T: std::convert::Into<crate::model::ca_pool::Tier>>(mut self, v: T) -> Self {
        self.tier = v.into();
        self
    }

    /// Sets the value of [state][crate::model::CertificateAuthority::state].
    pub fn set_state<T: std::convert::Into<crate::model::certificate_authority::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [pem_ca_certificates][crate::model::CertificateAuthority::pem_ca_certificates].
    pub fn set_pem_ca_certificates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.pem_ca_certificates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ca_certificate_descriptions][crate::model::CertificateAuthority::ca_certificate_descriptions].
    pub fn set_ca_certificate_descriptions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CertificateDescription>,
    {
        use std::iter::Iterator;
        self.ca_certificate_descriptions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [gcs_bucket][crate::model::CertificateAuthority::gcs_bucket].
    pub fn set_gcs_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcs_bucket = v.into();
        self
    }

    /// Sets the value of [access_urls][crate::model::CertificateAuthority::access_urls].
    pub fn set_access_urls<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::certificate_authority::AccessUrls>,
    {
        self.access_urls = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [access_urls][crate::model::CertificateAuthority::access_urls].
    pub fn set_or_clear_access_urls<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::certificate_authority::AccessUrls>,
    {
        self.access_urls = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::CertificateAuthority::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CertificateAuthority::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::CertificateAuthority::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::CertificateAuthority::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::CertificateAuthority::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::CertificateAuthority::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expire_time][crate::model::CertificateAuthority::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::CertificateAuthority::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::CertificateAuthority::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for CertificateAuthority {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.CertificateAuthority"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CertificateAuthority {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __type,
            __config,
            __lifetime,
            __key_spec,
            __subordinate_config,
            __tier,
            __state,
            __pem_ca_certificates,
            __ca_certificate_descriptions,
            __gcs_bucket,
            __access_urls,
            __create_time,
            __update_time,
            __delete_time,
            __expire_time,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CertificateAuthority")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "type" => Ok(__FieldTag::__type),
                            "config" => Ok(__FieldTag::__config),
                            "lifetime" => Ok(__FieldTag::__lifetime),
                            "keySpec" => Ok(__FieldTag::__key_spec),
                            "key_spec" => Ok(__FieldTag::__key_spec),
                            "subordinateConfig" => Ok(__FieldTag::__subordinate_config),
                            "subordinate_config" => Ok(__FieldTag::__subordinate_config),
                            "tier" => Ok(__FieldTag::__tier),
                            "state" => Ok(__FieldTag::__state),
                            "pemCaCertificates" => Ok(__FieldTag::__pem_ca_certificates),
                            "pem_ca_certificates" => Ok(__FieldTag::__pem_ca_certificates),
                            "caCertificateDescriptions" => {
                                Ok(__FieldTag::__ca_certificate_descriptions)
                            }
                            "ca_certificate_descriptions" => {
                                Ok(__FieldTag::__ca_certificate_descriptions)
                            }
                            "gcsBucket" => Ok(__FieldTag::__gcs_bucket),
                            "gcs_bucket" => Ok(__FieldTag::__gcs_bucket),
                            "accessUrls" => Ok(__FieldTag::__access_urls),
                            "access_urls" => Ok(__FieldTag::__access_urls),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CertificateAuthority;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CertificateAuthority")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::certificate_authority::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map
                                .next_value::<std::option::Option<crate::model::CertificateConfig>>(
                                )?;
                        }
                        __FieldTag::__lifetime => {
                            if !fields.insert(__FieldTag::__lifetime) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lifetime",
                                ));
                            }
                            result.lifetime =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__key_spec => {
                            if !fields.insert(__FieldTag::__key_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_spec",
                                ));
                            }
                            result.key_spec = map.next_value::<std::option::Option<
                                crate::model::certificate_authority::KeyVersionSpec,
                            >>()?;
                        }
                        __FieldTag::__subordinate_config => {
                            if !fields.insert(__FieldTag::__subordinate_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subordinate_config",
                                ));
                            }
                            result.subordinate_config = map
                                .next_value::<std::option::Option<crate::model::SubordinateConfig>>(
                                )?;
                        }
                        __FieldTag::__tier => {
                            if !fields.insert(__FieldTag::__tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tier",
                                ));
                            }
                            result.tier = map
                                .next_value::<std::option::Option<crate::model::ca_pool::Tier>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::certificate_authority::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__pem_ca_certificates => {
                            if !fields.insert(__FieldTag::__pem_ca_certificates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pem_ca_certificates",
                                ));
                            }
                            result.pem_ca_certificates = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__ca_certificate_descriptions => {
                            if !fields.insert(__FieldTag::__ca_certificate_descriptions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_certificate_descriptions",
                                ));
                            }
                            result.ca_certificate_descriptions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CertificateDescription>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcs_bucket => {
                            if !fields.insert(__FieldTag::__gcs_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_bucket",
                                ));
                            }
                            result.gcs_bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__access_urls => {
                            if !fields.insert(__FieldTag::__access_urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_urls",
                                ));
                            }
                            result.access_urls = map.next_value::<std::option::Option<
                                crate::model::certificate_authority::AccessUrls,
                            >>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CertificateAuthority {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if self.lifetime.is_some() {
            state.serialize_entry("lifetime", &self.lifetime)?;
        }
        if self.key_spec.is_some() {
            state.serialize_entry("keySpec", &self.key_spec)?;
        }
        if self.subordinate_config.is_some() {
            state.serialize_entry("subordinateConfig", &self.subordinate_config)?;
        }
        if !wkt::internal::is_default(&self.tier) {
            state.serialize_entry("tier", &self.tier)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.pem_ca_certificates.is_empty() {
            state.serialize_entry("pemCaCertificates", &self.pem_ca_certificates)?;
        }
        if !self.ca_certificate_descriptions.is_empty() {
            state.serialize_entry(
                "caCertificateDescriptions",
                &self.ca_certificate_descriptions,
            )?;
        }
        if !self.gcs_bucket.is_empty() {
            state.serialize_entry("gcsBucket", &self.gcs_bucket)?;
        }
        if self.access_urls.is_some() {
            state.serialize_entry("accessUrls", &self.access_urls)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.delete_time.is_some() {
            state.serialize_entry("deleteTime", &self.delete_time)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CertificateAuthority].
pub mod certificate_authority {
    #[allow(unused_imports)]
    use super::*;

    /// URLs where a
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// will publish content.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AccessUrls {
        /// The URL where this
        /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s
        /// CA certificate is published. This will only be set for CAs that have been
        /// activated.
        ///
        /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
        pub ca_certificate_access_url: std::string::String,

        /// The URLs where this
        /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s
        /// CRLs are published. This will only be set for CAs that have been
        /// activated.
        ///
        /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
        pub crl_access_urls: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AccessUrls {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ca_certificate_access_url][crate::model::certificate_authority::AccessUrls::ca_certificate_access_url].
        pub fn set_ca_certificate_access_url<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.ca_certificate_access_url = v.into();
            self
        }

        /// Sets the value of [crl_access_urls][crate::model::certificate_authority::AccessUrls::crl_access_urls].
        pub fn set_crl_access_urls<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.crl_access_urls = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for AccessUrls {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.security.privateca.v1.CertificateAuthority.AccessUrls"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AccessUrls {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __ca_certificate_access_url,
                __crl_access_urls,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AccessUrls")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "caCertificateAccessUrl" => {
                                    Ok(__FieldTag::__ca_certificate_access_url)
                                }
                                "ca_certificate_access_url" => {
                                    Ok(__FieldTag::__ca_certificate_access_url)
                                }
                                "crlAccessUrls" => Ok(__FieldTag::__crl_access_urls),
                                "crl_access_urls" => Ok(__FieldTag::__crl_access_urls),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AccessUrls;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AccessUrls")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__ca_certificate_access_url => {
                                if !fields.insert(__FieldTag::__ca_certificate_access_url) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ca_certificate_access_url",
                                    ));
                                }
                                result.ca_certificate_access_url = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__crl_access_urls => {
                                if !fields.insert(__FieldTag::__crl_access_urls) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for crl_access_urls",
                                    ));
                                }
                                result.crl_access_urls = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AccessUrls {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.ca_certificate_access_url.is_empty() {
                state.serialize_entry("caCertificateAccessUrl", &self.ca_certificate_access_url)?;
            }
            if !self.crl_access_urls.is_empty() {
                state.serialize_entry("crlAccessUrls", &self.crl_access_urls)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A Cloud KMS key configuration that a
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// will use.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct KeyVersionSpec {
        pub key_version:
            std::option::Option<crate::model::certificate_authority::key_version_spec::KeyVersion>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl KeyVersionSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key_version][crate::model::certificate_authority::KeyVersionSpec::key_version].
        ///
        /// Note that all the setters affecting `key_version` are mutually
        /// exclusive.
        pub fn set_key_version<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::certificate_authority::key_version_spec::KeyVersion,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.key_version = v.into();
            self
        }

        /// The value of [key_version][crate::model::certificate_authority::KeyVersionSpec::key_version]
        /// if it holds a `CloudKmsKeyVersion`, `None` if the field is not set or
        /// holds a different branch.
        pub fn cloud_kms_key_version(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.key_version.as_ref().and_then(|v| match v {
                crate::model::certificate_authority::key_version_spec::KeyVersion::CloudKmsKeyVersion(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [key_version][crate::model::certificate_authority::KeyVersionSpec::key_version]
        /// to hold a `CloudKmsKeyVersion`.
        ///
        /// Note that all the setters affecting `key_version` are
        /// mutually exclusive.
        pub fn set_cloud_kms_key_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.key_version = std::option::Option::Some(
                crate::model::certificate_authority::key_version_spec::KeyVersion::CloudKmsKeyVersion(
                    v.into()
                )
            );
            self
        }

        /// The value of [key_version][crate::model::certificate_authority::KeyVersionSpec::key_version]
        /// if it holds a `Algorithm`, `None` if the field is not set or
        /// holds a different branch.
        pub fn algorithm(
            &self,
        ) -> std::option::Option<&crate::model::certificate_authority::SignHashAlgorithm> {
            #[allow(unreachable_patterns)]
            self.key_version.as_ref().and_then(|v| match v {
                crate::model::certificate_authority::key_version_spec::KeyVersion::Algorithm(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [key_version][crate::model::certificate_authority::KeyVersionSpec::key_version]
        /// to hold a `Algorithm`.
        ///
        /// Note that all the setters affecting `key_version` are
        /// mutually exclusive.
        pub fn set_algorithm<
            T: std::convert::Into<crate::model::certificate_authority::SignHashAlgorithm>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.key_version = std::option::Option::Some(
                crate::model::certificate_authority::key_version_spec::KeyVersion::Algorithm(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for KeyVersionSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.security.privateca.v1.CertificateAuthority.KeyVersionSpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for KeyVersionSpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __cloud_kms_key_version,
                __algorithm,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for KeyVersionSpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "cloudKmsKeyVersion" => Ok(__FieldTag::__cloud_kms_key_version),
                                "cloud_kms_key_version" => Ok(__FieldTag::__cloud_kms_key_version),
                                "algorithm" => Ok(__FieldTag::__algorithm),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = KeyVersionSpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct KeyVersionSpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__cloud_kms_key_version => {
                                if !fields.insert(__FieldTag::__cloud_kms_key_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cloud_kms_key_version",
                                    ));
                                }
                                if result.key_version.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `key_version`, a oneof with full ID .google.cloud.security.privateca.v1.CertificateAuthority.KeyVersionSpec.cloud_kms_key_version, latest field was cloudKmsKeyVersion",
                                    ));
                                }
                                result.key_version = std::option::Option::Some(
                                    crate::model::certificate_authority::key_version_spec::KeyVersion::CloudKmsKeyVersion(
                                        map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__algorithm => {
                                if !fields.insert(__FieldTag::__algorithm) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for algorithm",
                                    ));
                                }
                                if result.key_version.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `key_version`, a oneof with full ID .google.cloud.security.privateca.v1.CertificateAuthority.KeyVersionSpec.algorithm, latest field was algorithm",
                                    ));
                                }
                                result.key_version = std::option::Option::Some(
                                    crate::model::certificate_authority::key_version_spec::KeyVersion::Algorithm(
                                        map.next_value::<std::option::Option<crate::model::certificate_authority::SignHashAlgorithm>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for KeyVersionSpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.cloud_kms_key_version() {
                state.serialize_entry("cloudKmsKeyVersion", value)?;
            }
            if let Some(value) = self.algorithm() {
                state.serialize_entry("algorithm", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [KeyVersionSpec].
    pub mod key_version_spec {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum KeyVersion {
            /// The resource name for an existing Cloud KMS CryptoKeyVersion in the
            /// format
            /// `projects/*/locations/*/keyRings/*/cryptoKeys/*/cryptoKeyVersions/*`.
            /// This option enables full flexibility in the key's capabilities and
            /// properties.
            CloudKmsKeyVersion(std::string::String),
            /// The algorithm to use for creating a managed Cloud KMS key for a for a
            /// simplified experience. All managed keys will be have their
            /// [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] as `HSM`.
            Algorithm(crate::model::certificate_authority::SignHashAlgorithm),
        }
    }

    /// The type of a
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority],
    /// indicating its issuing chain.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Not specified.
        Unspecified,
        /// Self-signed CA.
        SelfSigned,
        /// Subordinate CA. Could be issued by a Private CA
        /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
        /// or an unmanaged CA.
        ///
        /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
        Subordinate,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SelfSigned => std::option::Option::Some(1),
                Self::Subordinate => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::SelfSigned => std::option::Option::Some("SELF_SIGNED"),
                Self::Subordinate => std::option::Option::Some("SUBORDINATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SelfSigned,
                2 => Self::Subordinate,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "SELF_SIGNED" => Self::SelfSigned,
                "SUBORDINATE" => Self::Subordinate,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SelfSigned => serializer.serialize_i32(1),
                Self::Subordinate => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.security.privateca.v1.CertificateAuthority.Type",
            ))
        }
    }

    /// The state of a
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority],
    /// indicating if it can be used.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not specified.
        Unspecified,
        /// Certificates can be issued from this CA. CRLs will be generated for this
        /// CA. The CA will be part of the
        /// [CaPool][google.cloud.security.privateca.v1.CaPool]'s trust anchor, and
        /// will be used to issue certificates from the
        /// [CaPool][google.cloud.security.privateca.v1.CaPool].
        ///
        /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
        Enabled,
        /// Certificates cannot be issued from this CA. CRLs will still be generated.
        /// The CA will be part of the
        /// [CaPool][google.cloud.security.privateca.v1.CaPool]'s trust anchor, but
        /// will not be used to issue certificates from the
        /// [CaPool][google.cloud.security.privateca.v1.CaPool].
        ///
        /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
        Disabled,
        /// Certificates can be issued from this CA. CRLs will be generated for this
        /// CA. The CA will be part of the
        /// [CaPool][google.cloud.security.privateca.v1.CaPool]'s trust anchor, but
        /// will not be used to issue certificates from the
        /// [CaPool][google.cloud.security.privateca.v1.CaPool].
        ///
        /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
        Staged,
        /// Certificates cannot be issued from this CA. CRLs will not be generated.
        /// The CA will not be part of the
        /// [CaPool][google.cloud.security.privateca.v1.CaPool]'s trust anchor, and
        /// will not be used to issue certificates from the
        /// [CaPool][google.cloud.security.privateca.v1.CaPool].
        ///
        /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
        AwaitingUserActivation,
        /// Certificates cannot be issued from this CA. CRLs will not be generated.
        /// The CA may still be recovered by calling
        /// [CertificateAuthorityService.UndeleteCertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthorityService.UndeleteCertificateAuthority]
        /// before
        /// [expire_time][google.cloud.security.privateca.v1.CertificateAuthority.expire_time].
        /// The CA will not be part of the
        /// [CaPool][google.cloud.security.privateca.v1.CaPool]'s trust anchor, and
        /// will not be used to issue certificates from the
        /// [CaPool][google.cloud.security.privateca.v1.CaPool].
        ///
        /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
        /// [google.cloud.security.privateca.v1.CertificateAuthority.expire_time]: crate::model::CertificateAuthority::expire_time
        /// [google.cloud.security.privateca.v1.CertificateAuthorityService.UndeleteCertificateAuthority]: crate::client::CertificateAuthorityService::undelete_certificate_authority
        Deleted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Disabled => std::option::Option::Some(2),
                Self::Staged => std::option::Option::Some(3),
                Self::AwaitingUserActivation => std::option::Option::Some(4),
                Self::Deleted => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Staged => std::option::Option::Some("STAGED"),
                Self::AwaitingUserActivation => {
                    std::option::Option::Some("AWAITING_USER_ACTIVATION")
                }
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Disabled,
                3 => Self::Staged,
                4 => Self::AwaitingUserActivation,
                5 => Self::Deleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "DISABLED" => Self::Disabled,
                "STAGED" => Self::Staged,
                "AWAITING_USER_ACTIVATION" => Self::AwaitingUserActivation,
                "DELETED" => Self::Deleted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Disabled => serializer.serialize_i32(2),
                Self::Staged => serializer.serialize_i32(3),
                Self::AwaitingUserActivation => serializer.serialize_i32(4),
                Self::Deleted => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.security.privateca.v1.CertificateAuthority.State",
            ))
        }
    }

    /// The algorithm of a Cloud KMS CryptoKeyVersion of a
    /// [CryptoKey][google.cloud.kms.v1.CryptoKey] with the
    /// [CryptoKeyPurpose][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose] value
    /// `ASYMMETRIC_SIGN`. These values correspond to the
    /// [CryptoKeyVersionAlgorithm][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]
    /// values. For RSA signing algorithms, the PSS algorithms should be preferred,
    /// use PKCS1 algorithms if required for compatibility. For further
    /// recommendations, see
    /// <https://cloud.google.com/kms/docs/algorithms#algorithm_recommendations>.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SignHashAlgorithm {
        /// Not specified.
        Unspecified,
        /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_2048_SHA256
        RsaPss2048Sha256,
        /// maps to CryptoKeyVersionAlgorithm. RSA_SIGN_PSS_3072_SHA256
        RsaPss3072Sha256,
        /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_4096_SHA256
        RsaPss4096Sha256,
        /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_2048_SHA256
        RsaPkcs12048Sha256,
        /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_3072_SHA256
        RsaPkcs13072Sha256,
        /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_4096_SHA256
        RsaPkcs14096Sha256,
        /// maps to CryptoKeyVersionAlgorithm.EC_SIGN_P256_SHA256
        EcP256Sha256,
        /// maps to CryptoKeyVersionAlgorithm.EC_SIGN_P384_SHA384
        EcP384Sha384,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SignHashAlgorithm::value] or
        /// [SignHashAlgorithm::name].
        UnknownValue(sign_hash_algorithm::UnknownValue),
    }

    #[doc(hidden)]
    pub mod sign_hash_algorithm {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SignHashAlgorithm {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::RsaPss2048Sha256 => std::option::Option::Some(1),
                Self::RsaPss3072Sha256 => std::option::Option::Some(2),
                Self::RsaPss4096Sha256 => std::option::Option::Some(3),
                Self::RsaPkcs12048Sha256 => std::option::Option::Some(6),
                Self::RsaPkcs13072Sha256 => std::option::Option::Some(7),
                Self::RsaPkcs14096Sha256 => std::option::Option::Some(8),
                Self::EcP256Sha256 => std::option::Option::Some(4),
                Self::EcP384Sha384 => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SIGN_HASH_ALGORITHM_UNSPECIFIED"),
                Self::RsaPss2048Sha256 => std::option::Option::Some("RSA_PSS_2048_SHA256"),
                Self::RsaPss3072Sha256 => std::option::Option::Some("RSA_PSS_3072_SHA256"),
                Self::RsaPss4096Sha256 => std::option::Option::Some("RSA_PSS_4096_SHA256"),
                Self::RsaPkcs12048Sha256 => std::option::Option::Some("RSA_PKCS1_2048_SHA256"),
                Self::RsaPkcs13072Sha256 => std::option::Option::Some("RSA_PKCS1_3072_SHA256"),
                Self::RsaPkcs14096Sha256 => std::option::Option::Some("RSA_PKCS1_4096_SHA256"),
                Self::EcP256Sha256 => std::option::Option::Some("EC_P256_SHA256"),
                Self::EcP384Sha384 => std::option::Option::Some("EC_P384_SHA384"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SignHashAlgorithm {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SignHashAlgorithm {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SignHashAlgorithm {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::RsaPss2048Sha256,
                2 => Self::RsaPss3072Sha256,
                3 => Self::RsaPss4096Sha256,
                4 => Self::EcP256Sha256,
                5 => Self::EcP384Sha384,
                6 => Self::RsaPkcs12048Sha256,
                7 => Self::RsaPkcs13072Sha256,
                8 => Self::RsaPkcs14096Sha256,
                _ => Self::UnknownValue(sign_hash_algorithm::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SignHashAlgorithm {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SIGN_HASH_ALGORITHM_UNSPECIFIED" => Self::Unspecified,
                "RSA_PSS_2048_SHA256" => Self::RsaPss2048Sha256,
                "RSA_PSS_3072_SHA256" => Self::RsaPss3072Sha256,
                "RSA_PSS_4096_SHA256" => Self::RsaPss4096Sha256,
                "RSA_PKCS1_2048_SHA256" => Self::RsaPkcs12048Sha256,
                "RSA_PKCS1_3072_SHA256" => Self::RsaPkcs13072Sha256,
                "RSA_PKCS1_4096_SHA256" => Self::RsaPkcs14096Sha256,
                "EC_P256_SHA256" => Self::EcP256Sha256,
                "EC_P384_SHA384" => Self::EcP384Sha384,
                _ => Self::UnknownValue(sign_hash_algorithm::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SignHashAlgorithm {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::RsaPss2048Sha256 => serializer.serialize_i32(1),
                Self::RsaPss3072Sha256 => serializer.serialize_i32(2),
                Self::RsaPss4096Sha256 => serializer.serialize_i32(3),
                Self::RsaPkcs12048Sha256 => serializer.serialize_i32(6),
                Self::RsaPkcs13072Sha256 => serializer.serialize_i32(7),
                Self::RsaPkcs14096Sha256 => serializer.serialize_i32(8),
                Self::EcP256Sha256 => serializer.serialize_i32(4),
                Self::EcP384Sha384 => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SignHashAlgorithm {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SignHashAlgorithm>::new(
                ".google.cloud.security.privateca.v1.CertificateAuthority.SignHashAlgorithm",
            ))
        }
    }
}

/// A [CaPool][google.cloud.security.privateca.v1.CaPool] represents a group of
/// [CertificateAuthorities][google.cloud.security.privateca.v1.CertificateAuthority]
/// that form a trust anchor. A
/// [CaPool][google.cloud.security.privateca.v1.CaPool] can be used to manage
/// issuance policies for one or more
/// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
/// resources and to rotate CA certificates in and out of the trust anchor.
///
/// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
/// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CaPool {
    /// Output only. The resource name for this
    /// [CaPool][google.cloud.security.privateca.v1.CaPool] in the format
    /// `projects/*/locations/*/caPools/*`.
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    pub name: std::string::String,

    /// Required. Immutable. The
    /// [Tier][google.cloud.security.privateca.v1.CaPool.Tier] of this
    /// [CaPool][google.cloud.security.privateca.v1.CaPool].
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    /// [google.cloud.security.privateca.v1.CaPool.Tier]: crate::model::ca_pool::Tier
    pub tier: crate::model::ca_pool::Tier,

    /// Optional. The
    /// [IssuancePolicy][google.cloud.security.privateca.v1.CaPool.IssuancePolicy]
    /// to control how
    /// [Certificates][google.cloud.security.privateca.v1.Certificate] will be
    /// issued from this [CaPool][google.cloud.security.privateca.v1.CaPool].
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    /// [google.cloud.security.privateca.v1.CaPool.IssuancePolicy]: crate::model::ca_pool::IssuancePolicy
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    pub issuance_policy: std::option::Option<crate::model::ca_pool::IssuancePolicy>,

    /// Optional. The
    /// [PublishingOptions][google.cloud.security.privateca.v1.CaPool.PublishingOptions]
    /// to follow when issuing
    /// [Certificates][google.cloud.security.privateca.v1.Certificate] from any
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// in this [CaPool][google.cloud.security.privateca.v1.CaPool].
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    /// [google.cloud.security.privateca.v1.CaPool.PublishingOptions]: crate::model::ca_pool::PublishingOptions
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub publishing_options: std::option::Option<crate::model::ca_pool::PublishingOptions>,

    /// Optional. Labels with user-defined metadata.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CaPool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CaPool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [tier][crate::model::CaPool::tier].
    pub fn set_tier<T: std::convert::Into<crate::model::ca_pool::Tier>>(mut self, v: T) -> Self {
        self.tier = v.into();
        self
    }

    /// Sets the value of [issuance_policy][crate::model::CaPool::issuance_policy].
    pub fn set_issuance_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ca_pool::IssuancePolicy>,
    {
        self.issuance_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [issuance_policy][crate::model::CaPool::issuance_policy].
    pub fn set_or_clear_issuance_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ca_pool::IssuancePolicy>,
    {
        self.issuance_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [publishing_options][crate::model::CaPool::publishing_options].
    pub fn set_publishing_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ca_pool::PublishingOptions>,
    {
        self.publishing_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [publishing_options][crate::model::CaPool::publishing_options].
    pub fn set_or_clear_publishing_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ca_pool::PublishingOptions>,
    {
        self.publishing_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::CaPool::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for CaPool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.CaPool"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CaPool {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __tier,
            __issuance_policy,
            __publishing_options,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CaPool")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "tier" => Ok(__FieldTag::__tier),
                            "issuancePolicy" => Ok(__FieldTag::__issuance_policy),
                            "issuance_policy" => Ok(__FieldTag::__issuance_policy),
                            "publishingOptions" => Ok(__FieldTag::__publishing_options),
                            "publishing_options" => Ok(__FieldTag::__publishing_options),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CaPool;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CaPool")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tier => {
                            if !fields.insert(__FieldTag::__tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tier",
                                ));
                            }
                            result.tier = map
                                .next_value::<std::option::Option<crate::model::ca_pool::Tier>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__issuance_policy => {
                            if !fields.insert(__FieldTag::__issuance_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issuance_policy",
                                ));
                            }
                            result.issuance_policy = map.next_value::<std::option::Option<crate::model::ca_pool::IssuancePolicy>>()?
                                ;
                        }
                        __FieldTag::__publishing_options => {
                            if !fields.insert(__FieldTag::__publishing_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for publishing_options",
                                ));
                            }
                            result.publishing_options = map.next_value::<std::option::Option<crate::model::ca_pool::PublishingOptions>>()?
                                ;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CaPool {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.tier) {
            state.serialize_entry("tier", &self.tier)?;
        }
        if self.issuance_policy.is_some() {
            state.serialize_entry("issuancePolicy", &self.issuance_policy)?;
        }
        if self.publishing_options.is_some() {
            state.serialize_entry("publishingOptions", &self.publishing_options)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CaPool].
pub mod ca_pool {
    #[allow(unused_imports)]
    use super::*;

    /// Options relating to the publication of each
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s
    /// CA certificate and CRLs and their inclusion as extensions in issued
    /// [Certificates][google.cloud.security.privateca.v1.Certificate]. The options
    /// set here apply to certificates issued by any
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// in the [CaPool][google.cloud.security.privateca.v1.CaPool].
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PublishingOptions {
        /// Optional. When true, publishes each
        /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s
        /// CA certificate and includes its URL in the "Authority Information Access"
        /// X.509 extension in all issued
        /// [Certificates][google.cloud.security.privateca.v1.Certificate]. If this
        /// is false, the CA certificate will not be published and the corresponding
        /// X.509 extension will not be written in issued certificates.
        ///
        /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
        /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
        pub publish_ca_cert: bool,

        /// Optional. When true, publishes each
        /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s
        /// CRL and includes its URL in the "CRL Distribution Points" X.509 extension
        /// in all issued
        /// [Certificates][google.cloud.security.privateca.v1.Certificate]. If this
        /// is false, CRLs will not be published and the corresponding X.509
        /// extension will not be written in issued certificates. CRLs will expire 7
        /// days from their creation. However, we will rebuild daily. CRLs are also
        /// rebuilt shortly after a certificate is revoked.
        ///
        /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
        /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
        pub publish_crl: bool,

        /// Optional. Specifies the encoding format of each
        /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
        /// resource's CA certificate and CRLs. If this is omitted, CA certificates
        /// and CRLs will be published in PEM.
        ///
        /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
        pub encoding_format: crate::model::ca_pool::publishing_options::EncodingFormat,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PublishingOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [publish_ca_cert][crate::model::ca_pool::PublishingOptions::publish_ca_cert].
        pub fn set_publish_ca_cert<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.publish_ca_cert = v.into();
            self
        }

        /// Sets the value of [publish_crl][crate::model::ca_pool::PublishingOptions::publish_crl].
        pub fn set_publish_crl<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.publish_crl = v.into();
            self
        }

        /// Sets the value of [encoding_format][crate::model::ca_pool::PublishingOptions::encoding_format].
        pub fn set_encoding_format<
            T: std::convert::Into<crate::model::ca_pool::publishing_options::EncodingFormat>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.encoding_format = v.into();
            self
        }
    }

    impl wkt::message::Message for PublishingOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.security.privateca.v1.CaPool.PublishingOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PublishingOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __publish_ca_cert,
                __publish_crl,
                __encoding_format,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PublishingOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "publishCaCert" => Ok(__FieldTag::__publish_ca_cert),
                                "publish_ca_cert" => Ok(__FieldTag::__publish_ca_cert),
                                "publishCrl" => Ok(__FieldTag::__publish_crl),
                                "publish_crl" => Ok(__FieldTag::__publish_crl),
                                "encodingFormat" => Ok(__FieldTag::__encoding_format),
                                "encoding_format" => Ok(__FieldTag::__encoding_format),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PublishingOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PublishingOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__publish_ca_cert => {
                                if !fields.insert(__FieldTag::__publish_ca_cert) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for publish_ca_cert",
                                    ));
                                }
                                result.publish_ca_cert = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__publish_crl => {
                                if !fields.insert(__FieldTag::__publish_crl) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for publish_crl",
                                    ));
                                }
                                result.publish_crl = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__encoding_format => {
                                if !fields.insert(__FieldTag::__encoding_format) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for encoding_format",
                                    ));
                                }
                                result.encoding_format = map
                                    .next_value::<std::option::Option<
                                        crate::model::ca_pool::publishing_options::EncodingFormat,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PublishingOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.publish_ca_cert) {
                state.serialize_entry("publishCaCert", &self.publish_ca_cert)?;
            }
            if !wkt::internal::is_default(&self.publish_crl) {
                state.serialize_entry("publishCrl", &self.publish_crl)?;
            }
            if !wkt::internal::is_default(&self.encoding_format) {
                state.serialize_entry("encodingFormat", &self.encoding_format)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [PublishingOptions].
    pub mod publishing_options {
        #[allow(unused_imports)]
        use super::*;

        /// Supported encoding formats for publishing.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum EncodingFormat {
            /// Not specified. By default, PEM format will be used.
            Unspecified,
            /// The
            /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s
            /// CA certificate and CRLs will be published in PEM format.
            ///
            /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
            Pem,
            /// The
            /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]'s
            /// CA certificate and CRLs will be published in DER format.
            ///
            /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
            Der,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [EncodingFormat::value] or
            /// [EncodingFormat::name].
            UnknownValue(encoding_format::UnknownValue),
        }

        #[doc(hidden)]
        pub mod encoding_format {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl EncodingFormat {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Pem => std::option::Option::Some(1),
                    Self::Der => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("ENCODING_FORMAT_UNSPECIFIED"),
                    Self::Pem => std::option::Option::Some("PEM"),
                    Self::Der => std::option::Option::Some("DER"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for EncodingFormat {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for EncodingFormat {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for EncodingFormat {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Pem,
                    2 => Self::Der,
                    _ => Self::UnknownValue(encoding_format::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for EncodingFormat {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "ENCODING_FORMAT_UNSPECIFIED" => Self::Unspecified,
                    "PEM" => Self::Pem,
                    "DER" => Self::Der,
                    _ => Self::UnknownValue(encoding_format::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for EncodingFormat {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Pem => serializer.serialize_i32(1),
                    Self::Der => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for EncodingFormat {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<EncodingFormat>::new(
                    ".google.cloud.security.privateca.v1.CaPool.PublishingOptions.EncodingFormat",
                ))
            }
        }
    }

    /// Defines controls over all certificate issuance within a
    /// [CaPool][google.cloud.security.privateca.v1.CaPool].
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IssuancePolicy {
        /// Optional. If any
        /// [AllowedKeyType][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.AllowedKeyType]
        /// is specified, then the certificate request's public key must match one of
        /// the key types listed here. Otherwise, any key may be used.
        ///
        /// [google.cloud.security.privateca.v1.CaPool.IssuancePolicy.AllowedKeyType]: crate::model::ca_pool::issuance_policy::AllowedKeyType
        pub allowed_key_types:
            std::vec::Vec<crate::model::ca_pool::issuance_policy::AllowedKeyType>,

        /// Optional. The maximum lifetime allowed for issued
        /// [Certificates][google.cloud.security.privateca.v1.Certificate]. Note that
        /// if the issuing
        /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
        /// expires before a
        /// [Certificate][google.cloud.security.privateca.v1.Certificate] resource's
        /// requested maximum_lifetime, the effective lifetime will be explicitly
        /// truncated to match it.
        ///
        /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
        /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
        pub maximum_lifetime: std::option::Option<wkt::Duration>,

        /// Optional. If specified, then only methods allowed in the
        /// [IssuanceModes][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.IssuanceModes]
        /// may be used to issue
        /// [Certificates][google.cloud.security.privateca.v1.Certificate].
        ///
        /// [google.cloud.security.privateca.v1.CaPool.IssuancePolicy.IssuanceModes]: crate::model::ca_pool::issuance_policy::IssuanceModes
        /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
        pub allowed_issuance_modes:
            std::option::Option<crate::model::ca_pool::issuance_policy::IssuanceModes>,

        /// Optional. A set of X.509 values that will be applied to all certificates
        /// issued through this [CaPool][google.cloud.security.privateca.v1.CaPool].
        /// If a certificate request includes conflicting values for the same
        /// properties, they will be overwritten by the values defined here. If a
        /// certificate request uses a
        /// [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate]
        /// that defines conflicting
        /// [predefined_values][google.cloud.security.privateca.v1.CertificateTemplate.predefined_values]
        /// for the same properties, the certificate issuance request will fail.
        ///
        /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
        /// [google.cloud.security.privateca.v1.CertificateTemplate]: crate::model::CertificateTemplate
        /// [google.cloud.security.privateca.v1.CertificateTemplate.predefined_values]: crate::model::CertificateTemplate::predefined_values
        pub baseline_values: std::option::Option<crate::model::X509Parameters>,

        /// Optional. Describes constraints on identities that may appear in
        /// [Certificates][google.cloud.security.privateca.v1.Certificate] issued
        /// through this [CaPool][google.cloud.security.privateca.v1.CaPool]. If this
        /// is omitted, then this [CaPool][google.cloud.security.privateca.v1.CaPool]
        /// will not add restrictions on a certificate's identity.
        ///
        /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
        /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
        pub identity_constraints: std::option::Option<crate::model::CertificateIdentityConstraints>,

        /// Optional. Describes the set of X.509 extensions that may appear in a
        /// [Certificate][google.cloud.security.privateca.v1.Certificate] issued
        /// through this [CaPool][google.cloud.security.privateca.v1.CaPool]. If a
        /// certificate request sets extensions that don't appear in the
        /// [passthrough_extensions][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.passthrough_extensions],
        /// those extensions will be dropped. If a certificate request uses a
        /// [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate]
        /// with
        /// [predefined_values][google.cloud.security.privateca.v1.CertificateTemplate.predefined_values]
        /// that don't appear here, the certificate issuance request will fail. If
        /// this is omitted, then this
        /// [CaPool][google.cloud.security.privateca.v1.CaPool] will not add
        /// restrictions on a certificate's X.509 extensions. These constraints do
        /// not apply to X.509 extensions set in this
        /// [CaPool][google.cloud.security.privateca.v1.CaPool]'s
        /// [baseline_values][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.baseline_values].
        ///
        /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
        /// [google.cloud.security.privateca.v1.CaPool.IssuancePolicy.baseline_values]: crate::model::ca_pool::IssuancePolicy::baseline_values
        /// [google.cloud.security.privateca.v1.CaPool.IssuancePolicy.passthrough_extensions]: crate::model::ca_pool::IssuancePolicy::passthrough_extensions
        /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
        /// [google.cloud.security.privateca.v1.CertificateTemplate]: crate::model::CertificateTemplate
        /// [google.cloud.security.privateca.v1.CertificateTemplate.predefined_values]: crate::model::CertificateTemplate::predefined_values
        pub passthrough_extensions:
            std::option::Option<crate::model::CertificateExtensionConstraints>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IssuancePolicy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [allowed_key_types][crate::model::ca_pool::IssuancePolicy::allowed_key_types].
        pub fn set_allowed_key_types<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ca_pool::issuance_policy::AllowedKeyType>,
        {
            use std::iter::Iterator;
            self.allowed_key_types = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [maximum_lifetime][crate::model::ca_pool::IssuancePolicy::maximum_lifetime].
        pub fn set_maximum_lifetime<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.maximum_lifetime = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [maximum_lifetime][crate::model::ca_pool::IssuancePolicy::maximum_lifetime].
        pub fn set_or_clear_maximum_lifetime<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.maximum_lifetime = v.map(|x| x.into());
            self
        }

        /// Sets the value of [allowed_issuance_modes][crate::model::ca_pool::IssuancePolicy::allowed_issuance_modes].
        pub fn set_allowed_issuance_modes<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::ca_pool::issuance_policy::IssuanceModes>,
        {
            self.allowed_issuance_modes = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [allowed_issuance_modes][crate::model::ca_pool::IssuancePolicy::allowed_issuance_modes].
        pub fn set_or_clear_allowed_issuance_modes<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::ca_pool::issuance_policy::IssuanceModes>,
        {
            self.allowed_issuance_modes = v.map(|x| x.into());
            self
        }

        /// Sets the value of [baseline_values][crate::model::ca_pool::IssuancePolicy::baseline_values].
        pub fn set_baseline_values<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::X509Parameters>,
        {
            self.baseline_values = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [baseline_values][crate::model::ca_pool::IssuancePolicy::baseline_values].
        pub fn set_or_clear_baseline_values<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::X509Parameters>,
        {
            self.baseline_values = v.map(|x| x.into());
            self
        }

        /// Sets the value of [identity_constraints][crate::model::ca_pool::IssuancePolicy::identity_constraints].
        pub fn set_identity_constraints<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::CertificateIdentityConstraints>,
        {
            self.identity_constraints = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [identity_constraints][crate::model::ca_pool::IssuancePolicy::identity_constraints].
        pub fn set_or_clear_identity_constraints<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::CertificateIdentityConstraints>,
        {
            self.identity_constraints = v.map(|x| x.into());
            self
        }

        /// Sets the value of [passthrough_extensions][crate::model::ca_pool::IssuancePolicy::passthrough_extensions].
        pub fn set_passthrough_extensions<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::CertificateExtensionConstraints>,
        {
            self.passthrough_extensions = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [passthrough_extensions][crate::model::ca_pool::IssuancePolicy::passthrough_extensions].
        pub fn set_or_clear_passthrough_extensions<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::CertificateExtensionConstraints>,
        {
            self.passthrough_extensions = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for IssuancePolicy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.security.privateca.v1.CaPool.IssuancePolicy"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IssuancePolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __allowed_key_types,
                __maximum_lifetime,
                __allowed_issuance_modes,
                __baseline_values,
                __identity_constraints,
                __passthrough_extensions,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IssuancePolicy")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "allowedKeyTypes" => Ok(__FieldTag::__allowed_key_types),
                                "allowed_key_types" => Ok(__FieldTag::__allowed_key_types),
                                "maximumLifetime" => Ok(__FieldTag::__maximum_lifetime),
                                "maximum_lifetime" => Ok(__FieldTag::__maximum_lifetime),
                                "allowedIssuanceModes" => Ok(__FieldTag::__allowed_issuance_modes),
                                "allowed_issuance_modes" => {
                                    Ok(__FieldTag::__allowed_issuance_modes)
                                }
                                "baselineValues" => Ok(__FieldTag::__baseline_values),
                                "baseline_values" => Ok(__FieldTag::__baseline_values),
                                "identityConstraints" => Ok(__FieldTag::__identity_constraints),
                                "identity_constraints" => Ok(__FieldTag::__identity_constraints),
                                "passthroughExtensions" => Ok(__FieldTag::__passthrough_extensions),
                                "passthrough_extensions" => {
                                    Ok(__FieldTag::__passthrough_extensions)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IssuancePolicy;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IssuancePolicy")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__allowed_key_types => {
                                if !fields.insert(__FieldTag::__allowed_key_types) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allowed_key_types",
                                    ));
                                }
                                result.allowed_key_types = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::ca_pool::issuance_policy::AllowedKeyType,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__maximum_lifetime => {
                                if !fields.insert(__FieldTag::__maximum_lifetime) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for maximum_lifetime",
                                    ));
                                }
                                result.maximum_lifetime =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::__allowed_issuance_modes => {
                                if !fields.insert(__FieldTag::__allowed_issuance_modes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allowed_issuance_modes",
                                    ));
                                }
                                result.allowed_issuance_modes = map
                                    .next_value::<std::option::Option<
                                        crate::model::ca_pool::issuance_policy::IssuanceModes,
                                    >>()?;
                            }
                            __FieldTag::__baseline_values => {
                                if !fields.insert(__FieldTag::__baseline_values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for baseline_values",
                                    ));
                                }
                                result.baseline_values = map.next_value::<std::option::Option<crate::model::X509Parameters>>()?
                                    ;
                            }
                            __FieldTag::__identity_constraints => {
                                if !fields.insert(__FieldTag::__identity_constraints) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for identity_constraints",
                                    ));
                                }
                                result.identity_constraints = map
                                    .next_value::<std::option::Option<
                                        crate::model::CertificateIdentityConstraints,
                                    >>()?;
                            }
                            __FieldTag::__passthrough_extensions => {
                                if !fields.insert(__FieldTag::__passthrough_extensions) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for passthrough_extensions",
                                    ));
                                }
                                result.passthrough_extensions = map
                                    .next_value::<std::option::Option<
                                        crate::model::CertificateExtensionConstraints,
                                    >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IssuancePolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.allowed_key_types.is_empty() {
                state.serialize_entry("allowedKeyTypes", &self.allowed_key_types)?;
            }
            if self.maximum_lifetime.is_some() {
                state.serialize_entry("maximumLifetime", &self.maximum_lifetime)?;
            }
            if self.allowed_issuance_modes.is_some() {
                state.serialize_entry("allowedIssuanceModes", &self.allowed_issuance_modes)?;
            }
            if self.baseline_values.is_some() {
                state.serialize_entry("baselineValues", &self.baseline_values)?;
            }
            if self.identity_constraints.is_some() {
                state.serialize_entry("identityConstraints", &self.identity_constraints)?;
            }
            if self.passthrough_extensions.is_some() {
                state.serialize_entry("passthroughExtensions", &self.passthrough_extensions)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [IssuancePolicy].
    pub mod issuance_policy {
        #[allow(unused_imports)]
        use super::*;

        /// Describes a "type" of key that may be used in a
        /// [Certificate][google.cloud.security.privateca.v1.Certificate] issued from
        /// a [CaPool][google.cloud.security.privateca.v1.CaPool]. Note that a single
        /// [AllowedKeyType][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.AllowedKeyType]
        /// may refer to either a fully-qualified key algorithm, such as RSA 4096, or
        /// a family of key algorithms, such as any RSA key.
        ///
        /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
        /// [google.cloud.security.privateca.v1.CaPool.IssuancePolicy.AllowedKeyType]: crate::model::ca_pool::issuance_policy::AllowedKeyType
        /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct AllowedKeyType {
            pub key_type: std::option::Option<
                crate::model::ca_pool::issuance_policy::allowed_key_type::KeyType,
            >,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AllowedKeyType {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key_type][crate::model::ca_pool::issuance_policy::AllowedKeyType::key_type].
            ///
            /// Note that all the setters affecting `key_type` are mutually
            /// exclusive.
            pub fn set_key_type<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::ca_pool::issuance_policy::allowed_key_type::KeyType,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.key_type = v.into();
                self
            }

            /// The value of [key_type][crate::model::ca_pool::issuance_policy::AllowedKeyType::key_type]
            /// if it holds a `Rsa`, `None` if the field is not set or
            /// holds a different branch.
            pub fn rsa(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<
                    crate::model::ca_pool::issuance_policy::allowed_key_type::RsaKeyType,
                >,
            > {
                #[allow(unreachable_patterns)]
                self.key_type.as_ref().and_then(|v| match v {
                    crate::model::ca_pool::issuance_policy::allowed_key_type::KeyType::Rsa(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [key_type][crate::model::ca_pool::issuance_policy::AllowedKeyType::key_type]
            /// to hold a `Rsa`.
            ///
            /// Note that all the setters affecting `key_type` are
            /// mutually exclusive.
            pub fn set_rsa<
                T: std::convert::Into<
                        std::boxed::Box<
                            crate::model::ca_pool::issuance_policy::allowed_key_type::RsaKeyType,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.key_type = std::option::Option::Some(
                    crate::model::ca_pool::issuance_policy::allowed_key_type::KeyType::Rsa(
                        v.into(),
                    ),
                );
                self
            }

            /// The value of [key_type][crate::model::ca_pool::issuance_policy::AllowedKeyType::key_type]
            /// if it holds a `EllipticCurve`, `None` if the field is not set or
            /// holds a different branch.
            pub fn elliptic_curve(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<
                    crate::model::ca_pool::issuance_policy::allowed_key_type::EcKeyType,
                >,
            > {
                #[allow(unreachable_patterns)]
                self.key_type.as_ref().and_then(|v| match v {
                    crate::model::ca_pool::issuance_policy::allowed_key_type::KeyType::EllipticCurve(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [key_type][crate::model::ca_pool::issuance_policy::AllowedKeyType::key_type]
            /// to hold a `EllipticCurve`.
            ///
            /// Note that all the setters affecting `key_type` are
            /// mutually exclusive.
            pub fn set_elliptic_curve<
                T: std::convert::Into<
                        std::boxed::Box<
                            crate::model::ca_pool::issuance_policy::allowed_key_type::EcKeyType,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.key_type = std::option::Option::Some(
                    crate::model::ca_pool::issuance_policy::allowed_key_type::KeyType::EllipticCurve(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for AllowedKeyType {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.security.privateca.v1.CaPool.IssuancePolicy.AllowedKeyType"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for AllowedKeyType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __rsa,
                    __elliptic_curve,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for AllowedKeyType")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "rsa" => Ok(__FieldTag::__rsa),
                                    "ellipticCurve" => Ok(__FieldTag::__elliptic_curve),
                                    "elliptic_curve" => Ok(__FieldTag::__elliptic_curve),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = AllowedKeyType;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct AllowedKeyType")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__rsa => {
                                    if !fields.insert(__FieldTag::__rsa) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for rsa"),
                                        );
                                    }
                                    if result.key_type.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `key_type`, a oneof with full ID .google.cloud.security.privateca.v1.CaPool.IssuancePolicy.AllowedKeyType.rsa, latest field was rsa",
                                            ),
                                        );
                                    }
                                    result.key_type = std::option::Option::Some(
                                        crate::model::ca_pool::issuance_policy::allowed_key_type::KeyType::Rsa(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::ca_pool::issuance_policy::allowed_key_type::RsaKeyType>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__elliptic_curve => {
                                    if !fields.insert(__FieldTag::__elliptic_curve) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for elliptic_curve",
                                            ),
                                        );
                                    }
                                    if result.key_type.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `key_type`, a oneof with full ID .google.cloud.security.privateca.v1.CaPool.IssuancePolicy.AllowedKeyType.elliptic_curve, latest field was ellipticCurve",
                                            ),
                                        );
                                    }
                                    result.key_type = std::option::Option::Some(
                                        crate::model::ca_pool::issuance_policy::allowed_key_type::KeyType::EllipticCurve(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::ca_pool::issuance_policy::allowed_key_type::EcKeyType>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for AllowedKeyType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.rsa() {
                    state.serialize_entry("rsa", value)?;
                }
                if let Some(value) = self.elliptic_curve() {
                    state.serialize_entry("ellipticCurve", value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [AllowedKeyType].
        pub mod allowed_key_type {
            #[allow(unused_imports)]
            use super::*;

            /// Describes an RSA key that may be used in a
            /// [Certificate][google.cloud.security.privateca.v1.Certificate] issued
            /// from a [CaPool][google.cloud.security.privateca.v1.CaPool].
            ///
            /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
            /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct RsaKeyType {
                /// Optional. The minimum allowed RSA modulus size (inclusive), in bits.
                /// If this is not set, or if set to zero, the service-level min RSA
                /// modulus size will continue to apply.
                pub min_modulus_size: i64,

                /// Optional. The maximum allowed RSA modulus size (inclusive), in bits.
                /// If this is not set, or if set to zero, the service will not enforce
                /// an explicit upper bound on RSA modulus sizes.
                pub max_modulus_size: i64,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl RsaKeyType {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [min_modulus_size][crate::model::ca_pool::issuance_policy::allowed_key_type::RsaKeyType::min_modulus_size].
                pub fn set_min_modulus_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                    self.min_modulus_size = v.into();
                    self
                }

                /// Sets the value of [max_modulus_size][crate::model::ca_pool::issuance_policy::allowed_key_type::RsaKeyType::max_modulus_size].
                pub fn set_max_modulus_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                    self.max_modulus_size = v.into();
                    self
                }
            }

            impl wkt::message::Message for RsaKeyType {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.security.privateca.v1.CaPool.IssuancePolicy.AllowedKeyType.RsaKeyType"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for RsaKeyType {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __min_modulus_size,
                        __max_modulus_size,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for RsaKeyType")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "minModulusSize" => Ok(__FieldTag::__min_modulus_size),
                                        "min_modulus_size" => Ok(__FieldTag::__min_modulus_size),
                                        "maxModulusSize" => Ok(__FieldTag::__max_modulus_size),
                                        "max_modulus_size" => Ok(__FieldTag::__max_modulus_size),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = RsaKeyType;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct RsaKeyType")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__min_modulus_size => {
                                        if !fields.insert(__FieldTag::__min_modulus_size) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for min_modulus_size",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i64>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I64>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.min_modulus_size =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::__max_modulus_size => {
                                        if !fields.insert(__FieldTag::__max_modulus_size) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for max_modulus_size",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<i64>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::I64>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.max_modulus_size =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for RsaKeyType {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !wkt::internal::is_default(&self.min_modulus_size) {
                        struct __With<'a>(&'a i64);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("minModulusSize", &__With(&self.min_modulus_size))?;
                    }
                    if !wkt::internal::is_default(&self.max_modulus_size) {
                        struct __With<'a>(&'a i64);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("maxModulusSize", &__With(&self.max_modulus_size))?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// Describes an Elliptic Curve key that may be used in a
            /// [Certificate][google.cloud.security.privateca.v1.Certificate] issued
            /// from a [CaPool][google.cloud.security.privateca.v1.CaPool].
            ///
            /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
            /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct EcKeyType {

                /// Optional. A signature algorithm that must be used. If this is
                /// omitted, any EC-based signature algorithm will be allowed.
                pub signature_algorithm: crate::model::ca_pool::issuance_policy::allowed_key_type::ec_key_type::EcSignatureAlgorithm,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl EcKeyType {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [signature_algorithm][crate::model::ca_pool::issuance_policy::allowed_key_type::EcKeyType::signature_algorithm].
                pub fn set_signature_algorithm<T: std::convert::Into<crate::model::ca_pool::issuance_policy::allowed_key_type::ec_key_type::EcSignatureAlgorithm>>(mut self, v: T) -> Self{
                    self.signature_algorithm = v.into();
                    self
                }
            }

            impl wkt::message::Message for EcKeyType {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.security.privateca.v1.CaPool.IssuancePolicy.AllowedKeyType.EcKeyType"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for EcKeyType {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __signature_algorithm,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for EcKeyType")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "signatureAlgorithm" => {
                                            Ok(__FieldTag::__signature_algorithm)
                                        }
                                        "signature_algorithm" => {
                                            Ok(__FieldTag::__signature_algorithm)
                                        }
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = EcKeyType;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct EcKeyType")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__signature_algorithm => {
                                        if !fields.insert(__FieldTag::__signature_algorithm) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for signature_algorithm",
                                                ),
                                            );
                                        }
                                        result.signature_algorithm = map.next_value::<std::option::Option<crate::model::ca_pool::issuance_policy::allowed_key_type::ec_key_type::EcSignatureAlgorithm>>()?.unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for EcKeyType {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !wkt::internal::is_default(&self.signature_algorithm) {
                        state.serialize_entry("signatureAlgorithm", &self.signature_algorithm)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// Defines additional types related to [EcKeyType].
            pub mod ec_key_type {
                #[allow(unused_imports)]
                use super::*;

                /// Describes an elliptic curve-based signature algorithm that may be
                /// used in a
                /// [Certificate][google.cloud.security.privateca.v1.Certificate] issued
                /// from a [CaPool][google.cloud.security.privateca.v1.CaPool].
                ///
                /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
                /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
                ///
                /// # Working with unknown values
                ///
                /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
                /// additional enum variants at any time. Adding new variants is not considered
                /// a breaking change. Applications should write their code in anticipation of:
                ///
                /// - New values appearing in future releases of the client library, **and**
                /// - New values received dynamically, without application changes.
                ///
                /// Please consult the [Working with enums] section in the user guide for some
                /// guidelines.
                ///
                /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
                #[derive(Clone, Debug, PartialEq)]
                #[non_exhaustive]
                pub enum EcSignatureAlgorithm {
                    /// Not specified. Signifies that any signature algorithm may be used.
                    Unspecified,
                    /// Refers to the Elliptic Curve Digital Signature Algorithm over the
                    /// NIST P-256 curve.
                    EcdsaP256,
                    /// Refers to the Elliptic Curve Digital Signature Algorithm over the
                    /// NIST P-384 curve.
                    EcdsaP384,
                    /// Refers to the Edwards-curve Digital Signature Algorithm over curve
                    /// 25519, as described in RFC 8410.
                    Eddsa25519,
                    /// If set, the enum was initialized with an unknown value.
                    ///
                    /// Applications can examine the value using [EcSignatureAlgorithm::value] or
                    /// [EcSignatureAlgorithm::name].
                    UnknownValue(ec_signature_algorithm::UnknownValue),
                }

                #[doc(hidden)]
                pub mod ec_signature_algorithm {
                    #[allow(unused_imports)]
                    use super::*;
                    #[derive(Clone, Debug, PartialEq)]
                    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
                }

                impl EcSignatureAlgorithm {
                    /// Gets the enum value.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the string representation of enums.
                    pub fn value(&self) -> std::option::Option<i32> {
                        match self {
                            Self::Unspecified => std::option::Option::Some(0),
                            Self::EcdsaP256 => std::option::Option::Some(1),
                            Self::EcdsaP384 => std::option::Option::Some(2),
                            Self::Eddsa25519 => std::option::Option::Some(3),
                            Self::UnknownValue(u) => u.0.value(),
                        }
                    }

                    /// Gets the enum value as a string.
                    ///
                    /// Returns `None` if the enum contains an unknown value deserialized from
                    /// the integer representation of enums.
                    pub fn name(&self) -> std::option::Option<&str> {
                        match self {
                            Self::Unspecified => {
                                std::option::Option::Some("EC_SIGNATURE_ALGORITHM_UNSPECIFIED")
                            }
                            Self::EcdsaP256 => std::option::Option::Some("ECDSA_P256"),
                            Self::EcdsaP384 => std::option::Option::Some("ECDSA_P384"),
                            Self::Eddsa25519 => std::option::Option::Some("EDDSA_25519"),
                            Self::UnknownValue(u) => u.0.name(),
                        }
                    }
                }

                impl std::default::Default for EcSignatureAlgorithm {
                    fn default() -> Self {
                        use std::convert::From;
                        Self::from(0)
                    }
                }

                impl std::fmt::Display for EcSignatureAlgorithm {
                    fn fmt(
                        &self,
                        f: &mut std::fmt::Formatter<'_>,
                    ) -> std::result::Result<(), std::fmt::Error> {
                        wkt::internal::display_enum(f, self.name(), self.value())
                    }
                }

                impl std::convert::From<i32> for EcSignatureAlgorithm {
                    fn from(value: i32) -> Self {
                        match value {
                            0 => Self::Unspecified,
                            1 => Self::EcdsaP256,
                            2 => Self::EcdsaP384,
                            3 => Self::Eddsa25519,
                            _ => Self::UnknownValue(ec_signature_algorithm::UnknownValue(
                                wkt::internal::UnknownEnumValue::Integer(value),
                            )),
                        }
                    }
                }

                impl std::convert::From<&str> for EcSignatureAlgorithm {
                    fn from(value: &str) -> Self {
                        use std::string::ToString;
                        match value {
                            "EC_SIGNATURE_ALGORITHM_UNSPECIFIED" => Self::Unspecified,
                            "ECDSA_P256" => Self::EcdsaP256,
                            "ECDSA_P384" => Self::EcdsaP384,
                            "EDDSA_25519" => Self::Eddsa25519,
                            _ => Self::UnknownValue(ec_signature_algorithm::UnknownValue(
                                wkt::internal::UnknownEnumValue::String(value.to_string()),
                            )),
                        }
                    }
                }

                impl serde::ser::Serialize for EcSignatureAlgorithm {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::Serializer,
                    {
                        match self {
                            Self::Unspecified => serializer.serialize_i32(0),
                            Self::EcdsaP256 => serializer.serialize_i32(1),
                            Self::EcdsaP384 => serializer.serialize_i32(2),
                            Self::Eddsa25519 => serializer.serialize_i32(3),
                            Self::UnknownValue(u) => u.0.serialize(serializer),
                        }
                    }
                }

                impl<'de> serde::de::Deserialize<'de> for EcSignatureAlgorithm {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        deserializer.deserialize_any(wkt::internal::EnumVisitor::<EcSignatureAlgorithm>::new(
                            ".google.cloud.security.privateca.v1.CaPool.IssuancePolicy.AllowedKeyType.EcKeyType.EcSignatureAlgorithm"))
                    }
                }
            }

            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum KeyType {
                /// Represents an allowed RSA key type.
                Rsa(
                    std::boxed::Box<
                        crate::model::ca_pool::issuance_policy::allowed_key_type::RsaKeyType,
                    >,
                ),
                /// Represents an allowed Elliptic Curve key type.
                EllipticCurve(
                    std::boxed::Box<
                        crate::model::ca_pool::issuance_policy::allowed_key_type::EcKeyType,
                    >,
                ),
            }
        }

        /// [IssuanceModes][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.IssuanceModes]
        /// specifies the allowed ways in which
        /// [Certificates][google.cloud.security.privateca.v1.Certificate] may be
        /// requested from this [CaPool][google.cloud.security.privateca.v1.CaPool].
        ///
        /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
        /// [google.cloud.security.privateca.v1.CaPool.IssuancePolicy.IssuanceModes]: crate::model::ca_pool::issuance_policy::IssuanceModes
        /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct IssuanceModes {
            /// Optional. When true, allows callers to create
            /// [Certificates][google.cloud.security.privateca.v1.Certificate] by
            /// specifying a CSR.
            ///
            /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
            pub allow_csr_based_issuance: bool,

            /// Optional. When true, allows callers to create
            /// [Certificates][google.cloud.security.privateca.v1.Certificate] by
            /// specifying a
            /// [CertificateConfig][google.cloud.security.privateca.v1.CertificateConfig].
            ///
            /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
            /// [google.cloud.security.privateca.v1.CertificateConfig]: crate::model::CertificateConfig
            pub allow_config_based_issuance: bool,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl IssuanceModes {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [allow_csr_based_issuance][crate::model::ca_pool::issuance_policy::IssuanceModes::allow_csr_based_issuance].
            pub fn set_allow_csr_based_issuance<T: std::convert::Into<bool>>(
                mut self,
                v: T,
            ) -> Self {
                self.allow_csr_based_issuance = v.into();
                self
            }

            /// Sets the value of [allow_config_based_issuance][crate::model::ca_pool::issuance_policy::IssuanceModes::allow_config_based_issuance].
            pub fn set_allow_config_based_issuance<T: std::convert::Into<bool>>(
                mut self,
                v: T,
            ) -> Self {
                self.allow_config_based_issuance = v.into();
                self
            }
        }

        impl wkt::message::Message for IssuanceModes {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.security.privateca.v1.CaPool.IssuancePolicy.IssuanceModes"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for IssuanceModes {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __allow_csr_based_issuance,
                    __allow_config_based_issuance,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for IssuanceModes")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "allowCsrBasedIssuance" => {
                                        Ok(__FieldTag::__allow_csr_based_issuance)
                                    }
                                    "allow_csr_based_issuance" => {
                                        Ok(__FieldTag::__allow_csr_based_issuance)
                                    }
                                    "allowConfigBasedIssuance" => {
                                        Ok(__FieldTag::__allow_config_based_issuance)
                                    }
                                    "allow_config_based_issuance" => {
                                        Ok(__FieldTag::__allow_config_based_issuance)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = IssuanceModes;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct IssuanceModes")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__allow_csr_based_issuance => {
                                    if !fields.insert(__FieldTag::__allow_csr_based_issuance) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for allow_csr_based_issuance",
                                            ),
                                        );
                                    }
                                    result.allow_csr_based_issuance = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__allow_config_based_issuance => {
                                    if !fields.insert(__FieldTag::__allow_config_based_issuance) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for allow_config_based_issuance",
                                            ),
                                        );
                                    }
                                    result.allow_config_based_issuance = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for IssuanceModes {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.allow_csr_based_issuance) {
                    state
                        .serialize_entry("allowCsrBasedIssuance", &self.allow_csr_based_issuance)?;
                }
                if !wkt::internal::is_default(&self.allow_config_based_issuance) {
                    state.serialize_entry(
                        "allowConfigBasedIssuance",
                        &self.allow_config_based_issuance,
                    )?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// The tier of a [CaPool][google.cloud.security.privateca.v1.CaPool],
    /// indicating its supported functionality and/or billing SKU.
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Tier {
        /// Not specified.
        Unspecified,
        /// Enterprise tier.
        Enterprise,
        /// DevOps tier.
        Devops,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Tier::value] or
        /// [Tier::name].
        UnknownValue(tier::UnknownValue),
    }

    #[doc(hidden)]
    pub mod tier {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Tier {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enterprise => std::option::Option::Some(1),
                Self::Devops => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TIER_UNSPECIFIED"),
                Self::Enterprise => std::option::Option::Some("ENTERPRISE"),
                Self::Devops => std::option::Option::Some("DEVOPS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Tier {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Tier {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Tier {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enterprise,
                2 => Self::Devops,
                _ => Self::UnknownValue(tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Tier {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TIER_UNSPECIFIED" => Self::Unspecified,
                "ENTERPRISE" => Self::Enterprise,
                "DEVOPS" => Self::Devops,
                _ => Self::UnknownValue(tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Tier {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enterprise => serializer.serialize_i32(1),
                Self::Devops => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Tier {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Tier>::new(
                ".google.cloud.security.privateca.v1.CaPool.Tier",
            ))
        }
    }
}

/// A
/// [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList]
/// corresponds to a signed X.509 certificate Revocation List (CRL). A CRL
/// contains the serial numbers of certificates that should no longer be trusted.
///
/// [google.cloud.security.privateca.v1.CertificateRevocationList]: crate::model::CertificateRevocationList
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CertificateRevocationList {
    /// Output only. The resource name for this
    /// [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList]
    /// in the format `projects/*/locations/*/caPools/*certificateAuthorities/*/
    /// certificateRevocationLists/*`.
    ///
    /// [google.cloud.security.privateca.v1.CertificateRevocationList]: crate::model::CertificateRevocationList
    pub name: std::string::String,

    /// Output only. The CRL sequence number that appears in pem_crl.
    pub sequence_number: i64,

    /// Output only. The revoked serial numbers that appear in pem_crl.
    pub revoked_certificates:
        std::vec::Vec<crate::model::certificate_revocation_list::RevokedCertificate>,

    /// Output only. The PEM-encoded X.509 CRL.
    pub pem_crl: std::string::String,

    /// Output only. The location where 'pem_crl' can be accessed.
    pub access_url: std::string::String,

    /// Output only. The
    /// [State][google.cloud.security.privateca.v1.CertificateRevocationList.State]
    /// for this
    /// [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList].
    ///
    /// [google.cloud.security.privateca.v1.CertificateRevocationList]: crate::model::CertificateRevocationList
    /// [google.cloud.security.privateca.v1.CertificateRevocationList.State]: crate::model::certificate_revocation_list::State
    pub state: crate::model::certificate_revocation_list::State,

    /// Output only. The time at which this
    /// [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList]
    /// was created.
    ///
    /// [google.cloud.security.privateca.v1.CertificateRevocationList]: crate::model::CertificateRevocationList
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this
    /// [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList]
    /// was updated.
    ///
    /// [google.cloud.security.privateca.v1.CertificateRevocationList]: crate::model::CertificateRevocationList
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The revision ID of this
    /// [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList].
    /// A new revision is committed whenever a new CRL is published. The format is
    /// an 8-character hexadecimal string.
    ///
    /// [google.cloud.security.privateca.v1.CertificateRevocationList]: crate::model::CertificateRevocationList
    pub revision_id: std::string::String,

    /// Optional. Labels with user-defined metadata.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CertificateRevocationList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CertificateRevocationList::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [sequence_number][crate::model::CertificateRevocationList::sequence_number].
    pub fn set_sequence_number<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.sequence_number = v.into();
        self
    }

    /// Sets the value of [revoked_certificates][crate::model::CertificateRevocationList::revoked_certificates].
    pub fn set_revoked_certificates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::certificate_revocation_list::RevokedCertificate>,
    {
        use std::iter::Iterator;
        self.revoked_certificates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pem_crl][crate::model::CertificateRevocationList::pem_crl].
    pub fn set_pem_crl<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pem_crl = v.into();
        self
    }

    /// Sets the value of [access_url][crate::model::CertificateRevocationList::access_url].
    pub fn set_access_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_url = v.into();
        self
    }

    /// Sets the value of [state][crate::model::CertificateRevocationList::state].
    pub fn set_state<T: std::convert::Into<crate::model::certificate_revocation_list::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CertificateRevocationList::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CertificateRevocationList::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::CertificateRevocationList::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::CertificateRevocationList::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [revision_id][crate::model::CertificateRevocationList::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::CertificateRevocationList::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for CertificateRevocationList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.CertificateRevocationList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CertificateRevocationList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __sequence_number,
            __revoked_certificates,
            __pem_crl,
            __access_url,
            __state,
            __create_time,
            __update_time,
            __revision_id,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CertificateRevocationList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "sequenceNumber" => Ok(__FieldTag::__sequence_number),
                            "sequence_number" => Ok(__FieldTag::__sequence_number),
                            "revokedCertificates" => Ok(__FieldTag::__revoked_certificates),
                            "revoked_certificates" => Ok(__FieldTag::__revoked_certificates),
                            "pemCrl" => Ok(__FieldTag::__pem_crl),
                            "pem_crl" => Ok(__FieldTag::__pem_crl),
                            "accessUrl" => Ok(__FieldTag::__access_url),
                            "access_url" => Ok(__FieldTag::__access_url),
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "revisionId" => Ok(__FieldTag::__revision_id),
                            "revision_id" => Ok(__FieldTag::__revision_id),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CertificateRevocationList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CertificateRevocationList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sequence_number => {
                            if !fields.insert(__FieldTag::__sequence_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sequence_number",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sequence_number =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__revoked_certificates => {
                            if !fields.insert(__FieldTag::__revoked_certificates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revoked_certificates",
                                ));
                            }
                            result.revoked_certificates = map.next_value::<std::option::Option<std::vec::Vec<crate::model::certificate_revocation_list::RevokedCertificate>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__pem_crl => {
                            if !fields.insert(__FieldTag::__pem_crl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pem_crl",
                                ));
                            }
                            result.pem_crl = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__access_url => {
                            if !fields.insert(__FieldTag::__access_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_url",
                                ));
                            }
                            result.access_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<
                                    crate::model::certificate_revocation_list::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__revision_id => {
                            if !fields.insert(__FieldTag::__revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_id",
                                ));
                            }
                            result.revision_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CertificateRevocationList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.sequence_number) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sequenceNumber", &__With(&self.sequence_number))?;
        }
        if !self.revoked_certificates.is_empty() {
            state.serialize_entry("revokedCertificates", &self.revoked_certificates)?;
        }
        if !self.pem_crl.is_empty() {
            state.serialize_entry("pemCrl", &self.pem_crl)?;
        }
        if !self.access_url.is_empty() {
            state.serialize_entry("accessUrl", &self.access_url)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.revision_id.is_empty() {
            state.serialize_entry("revisionId", &self.revision_id)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CertificateRevocationList].
pub mod certificate_revocation_list {
    #[allow(unused_imports)]
    use super::*;

    /// Describes a revoked
    /// [Certificate][google.cloud.security.privateca.v1.Certificate].
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RevokedCertificate {
        /// The resource name for the
        /// [Certificate][google.cloud.security.privateca.v1.Certificate] in the
        /// format `projects/*/locations/*/caPools/*/certificates/*`.
        ///
        /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
        pub certificate: std::string::String,

        /// The serial number of the
        /// [Certificate][google.cloud.security.privateca.v1.Certificate].
        ///
        /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
        pub hex_serial_number: std::string::String,

        /// The reason the
        /// [Certificate][google.cloud.security.privateca.v1.Certificate] was
        /// revoked.
        ///
        /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
        pub revocation_reason: crate::model::RevocationReason,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RevokedCertificate {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [certificate][crate::model::certificate_revocation_list::RevokedCertificate::certificate].
        pub fn set_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.certificate = v.into();
            self
        }

        /// Sets the value of [hex_serial_number][crate::model::certificate_revocation_list::RevokedCertificate::hex_serial_number].
        pub fn set_hex_serial_number<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.hex_serial_number = v.into();
            self
        }

        /// Sets the value of [revocation_reason][crate::model::certificate_revocation_list::RevokedCertificate::revocation_reason].
        pub fn set_revocation_reason<T: std::convert::Into<crate::model::RevocationReason>>(
            mut self,
            v: T,
        ) -> Self {
            self.revocation_reason = v.into();
            self
        }
    }

    impl wkt::message::Message for RevokedCertificate {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.security.privateca.v1.CertificateRevocationList.RevokedCertificate"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RevokedCertificate {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __certificate,
                __hex_serial_number,
                __revocation_reason,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RevokedCertificate")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "certificate" => Ok(__FieldTag::__certificate),
                                "hexSerialNumber" => Ok(__FieldTag::__hex_serial_number),
                                "hex_serial_number" => Ok(__FieldTag::__hex_serial_number),
                                "revocationReason" => Ok(__FieldTag::__revocation_reason),
                                "revocation_reason" => Ok(__FieldTag::__revocation_reason),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RevokedCertificate;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RevokedCertificate")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__certificate => {
                                if !fields.insert(__FieldTag::__certificate) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for certificate",
                                    ));
                                }
                                result.certificate = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__hex_serial_number => {
                                if !fields.insert(__FieldTag::__hex_serial_number) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for hex_serial_number",
                                    ));
                                }
                                result.hex_serial_number = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__revocation_reason => {
                                if !fields.insert(__FieldTag::__revocation_reason) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for revocation_reason",
                                    ));
                                }
                                result.revocation_reason = map.next_value::<std::option::Option<crate::model::RevocationReason>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RevokedCertificate {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.certificate.is_empty() {
                state.serialize_entry("certificate", &self.certificate)?;
            }
            if !self.hex_serial_number.is_empty() {
                state.serialize_entry("hexSerialNumber", &self.hex_serial_number)?;
            }
            if !wkt::internal::is_default(&self.revocation_reason) {
                state.serialize_entry("revocationReason", &self.revocation_reason)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The state of a
    /// [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList],
    /// indicating if it is current.
    ///
    /// [google.cloud.security.privateca.v1.CertificateRevocationList]: crate::model::CertificateRevocationList
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not specified.
        Unspecified,
        /// The
        /// [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList]
        /// is up to date.
        ///
        /// [google.cloud.security.privateca.v1.CertificateRevocationList]: crate::model::CertificateRevocationList
        Active,
        /// The
        /// [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList]
        /// is no longer current.
        ///
        /// [google.cloud.security.privateca.v1.CertificateRevocationList]: crate::model::CertificateRevocationList
        Superseded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::Superseded => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Superseded => std::option::Option::Some("SUPERSEDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Active,
                2 => Self::Superseded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "ACTIVE" => Self::Active,
                "SUPERSEDED" => Self::Superseded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::Superseded => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.security.privateca.v1.CertificateRevocationList.State",
            ))
        }
    }
}

/// A [Certificate][google.cloud.security.privateca.v1.Certificate] corresponds
/// to a signed X.509 certificate issued by a
/// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority].
///
/// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
/// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Certificate {
    /// Output only. The resource name for this
    /// [Certificate][google.cloud.security.privateca.v1.Certificate] in the format
    /// `projects/*/locations/*/caPools/*/certificates/*`.
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    pub name: std::string::String,

    /// Output only. The resource name of the issuing
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// in the format `projects/*/locations/*/caPools/*/certificateAuthorities/*`.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub issuer_certificate_authority: std::string::String,

    /// Required. Immutable. The desired lifetime of a certificate. Used to create
    /// the "not_before_time" and "not_after_time" fields inside an X.509
    /// certificate. Note that the lifetime may be truncated if it would extend
    /// past the life of any certificate authority in the issuing chain.
    pub lifetime: std::option::Option<wkt::Duration>,

    /// Immutable. The resource name for a
    /// [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate]
    /// used to issue this certificate, in the format
    /// `projects/*/locations/*/certificateTemplates/*`.
    /// If this is specified, the caller must have the necessary permission to
    /// use this template. If this is omitted, no template will be used.
    /// This template must be in the same location as the
    /// [Certificate][google.cloud.security.privateca.v1.Certificate].
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    /// [google.cloud.security.privateca.v1.CertificateTemplate]: crate::model::CertificateTemplate
    pub certificate_template: std::string::String,

    /// Immutable. Specifies how the
    /// [Certificate][google.cloud.security.privateca.v1.Certificate]'s identity
    /// fields are to be decided. If this is omitted, the `DEFAULT` subject mode
    /// will be used.
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    pub subject_mode: crate::model::SubjectRequestMode,

    /// Output only. Details regarding the revocation of this
    /// [Certificate][google.cloud.security.privateca.v1.Certificate]. This
    /// [Certificate][google.cloud.security.privateca.v1.Certificate] is considered
    /// revoked if and only if this field is present.
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    pub revocation_details: std::option::Option<crate::model::certificate::RevocationDetails>,

    /// Output only. The pem-encoded, signed X.509 certificate.
    pub pem_certificate: std::string::String,

    /// Output only. A structured description of the issued X.509 certificate.
    pub certificate_description: std::option::Option<crate::model::CertificateDescription>,

    /// Output only. The chain that may be used to verify the X.509 certificate.
    /// Expected to be in issuer-to-root order according to RFC 5246.
    pub pem_certificate_chain: std::vec::Vec<std::string::String>,

    /// Output only. The time at which this
    /// [Certificate][google.cloud.security.privateca.v1.Certificate] was created.
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this
    /// [Certificate][google.cloud.security.privateca.v1.Certificate] was updated.
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Labels with user-defined metadata.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The config used to create a signed X.509 certificate.
    pub certificate_config: std::option::Option<crate::model::certificate::CertificateConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Certificate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Certificate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [issuer_certificate_authority][crate::model::Certificate::issuer_certificate_authority].
    pub fn set_issuer_certificate_authority<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.issuer_certificate_authority = v.into();
        self
    }

    /// Sets the value of [lifetime][crate::model::Certificate::lifetime].
    pub fn set_lifetime<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.lifetime = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [lifetime][crate::model::Certificate::lifetime].
    pub fn set_or_clear_lifetime<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.lifetime = v.map(|x| x.into());
        self
    }

    /// Sets the value of [certificate_template][crate::model::Certificate::certificate_template].
    pub fn set_certificate_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.certificate_template = v.into();
        self
    }

    /// Sets the value of [subject_mode][crate::model::Certificate::subject_mode].
    pub fn set_subject_mode<T: std::convert::Into<crate::model::SubjectRequestMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.subject_mode = v.into();
        self
    }

    /// Sets the value of [revocation_details][crate::model::Certificate::revocation_details].
    pub fn set_revocation_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::certificate::RevocationDetails>,
    {
        self.revocation_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [revocation_details][crate::model::Certificate::revocation_details].
    pub fn set_or_clear_revocation_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::certificate::RevocationDetails>,
    {
        self.revocation_details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [pem_certificate][crate::model::Certificate::pem_certificate].
    pub fn set_pem_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pem_certificate = v.into();
        self
    }

    /// Sets the value of [certificate_description][crate::model::Certificate::certificate_description].
    pub fn set_certificate_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CertificateDescription>,
    {
        self.certificate_description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [certificate_description][crate::model::Certificate::certificate_description].
    pub fn set_or_clear_certificate_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CertificateDescription>,
    {
        self.certificate_description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [pem_certificate_chain][crate::model::Certificate::pem_certificate_chain].
    pub fn set_pem_certificate_chain<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.pem_certificate_chain = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Certificate::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Certificate::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Certificate::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Certificate::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Certificate::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [certificate_config][crate::model::Certificate::certificate_config].
    ///
    /// Note that all the setters affecting `certificate_config` are mutually
    /// exclusive.
    pub fn set_certificate_config<
        T: std::convert::Into<std::option::Option<crate::model::certificate::CertificateConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.certificate_config = v.into();
        self
    }

    /// The value of [certificate_config][crate::model::Certificate::certificate_config]
    /// if it holds a `PemCsr`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pem_csr(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.certificate_config.as_ref().and_then(|v| match v {
            crate::model::certificate::CertificateConfig::PemCsr(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [certificate_config][crate::model::Certificate::certificate_config]
    /// to hold a `PemCsr`.
    ///
    /// Note that all the setters affecting `certificate_config` are
    /// mutually exclusive.
    pub fn set_pem_csr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.certificate_config = std::option::Option::Some(
            crate::model::certificate::CertificateConfig::PemCsr(v.into()),
        );
        self
    }

    /// The value of [certificate_config][crate::model::Certificate::certificate_config]
    /// if it holds a `Config`, `None` if the field is not set or
    /// holds a different branch.
    pub fn config(&self) -> std::option::Option<&std::boxed::Box<crate::model::CertificateConfig>> {
        #[allow(unreachable_patterns)]
        self.certificate_config.as_ref().and_then(|v| match v {
            crate::model::certificate::CertificateConfig::Config(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [certificate_config][crate::model::Certificate::certificate_config]
    /// to hold a `Config`.
    ///
    /// Note that all the setters affecting `certificate_config` are
    /// mutually exclusive.
    pub fn set_config<T: std::convert::Into<std::boxed::Box<crate::model::CertificateConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.certificate_config = std::option::Option::Some(
            crate::model::certificate::CertificateConfig::Config(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Certificate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.Certificate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Certificate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __pem_csr,
            __config,
            __issuer_certificate_authority,
            __lifetime,
            __certificate_template,
            __subject_mode,
            __revocation_details,
            __pem_certificate,
            __certificate_description,
            __pem_certificate_chain,
            __create_time,
            __update_time,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Certificate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "pemCsr" => Ok(__FieldTag::__pem_csr),
                            "pem_csr" => Ok(__FieldTag::__pem_csr),
                            "config" => Ok(__FieldTag::__config),
                            "issuerCertificateAuthority" => {
                                Ok(__FieldTag::__issuer_certificate_authority)
                            }
                            "issuer_certificate_authority" => {
                                Ok(__FieldTag::__issuer_certificate_authority)
                            }
                            "lifetime" => Ok(__FieldTag::__lifetime),
                            "certificateTemplate" => Ok(__FieldTag::__certificate_template),
                            "certificate_template" => Ok(__FieldTag::__certificate_template),
                            "subjectMode" => Ok(__FieldTag::__subject_mode),
                            "subject_mode" => Ok(__FieldTag::__subject_mode),
                            "revocationDetails" => Ok(__FieldTag::__revocation_details),
                            "revocation_details" => Ok(__FieldTag::__revocation_details),
                            "pemCertificate" => Ok(__FieldTag::__pem_certificate),
                            "pem_certificate" => Ok(__FieldTag::__pem_certificate),
                            "certificateDescription" => Ok(__FieldTag::__certificate_description),
                            "certificate_description" => Ok(__FieldTag::__certificate_description),
                            "pemCertificateChain" => Ok(__FieldTag::__pem_certificate_chain),
                            "pem_certificate_chain" => Ok(__FieldTag::__pem_certificate_chain),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Certificate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Certificate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pem_csr => {
                            if !fields.insert(__FieldTag::__pem_csr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pem_csr",
                                ));
                            }
                            if result.certificate_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `certificate_config`, a oneof with full ID .google.cloud.security.privateca.v1.Certificate.pem_csr, latest field was pemCsr",
                                ));
                            }
                            result.certificate_config = std::option::Option::Some(
                                crate::model::certificate::CertificateConfig::PemCsr(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            if result.certificate_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `certificate_config`, a oneof with full ID .google.cloud.security.privateca.v1.Certificate.config, latest field was config",
                                ));
                            }
                            result.certificate_config = std::option::Option::Some(
                                crate::model::certificate::CertificateConfig::Config(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CertificateConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__issuer_certificate_authority => {
                            if !fields.insert(__FieldTag::__issuer_certificate_authority) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issuer_certificate_authority",
                                ));
                            }
                            result.issuer_certificate_authority = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__lifetime => {
                            if !fields.insert(__FieldTag::__lifetime) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lifetime",
                                ));
                            }
                            result.lifetime =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__certificate_template => {
                            if !fields.insert(__FieldTag::__certificate_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_template",
                                ));
                            }
                            result.certificate_template = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject_mode => {
                            if !fields.insert(__FieldTag::__subject_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_mode",
                                ));
                            }
                            result.subject_mode = map.next_value::<std::option::Option<crate::model::SubjectRequestMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__revocation_details => {
                            if !fields.insert(__FieldTag::__revocation_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revocation_details",
                                ));
                            }
                            result.revocation_details =
                                map.next_value::<std::option::Option<
                                    crate::model::certificate::RevocationDetails,
                                >>()?;
                        }
                        __FieldTag::__pem_certificate => {
                            if !fields.insert(__FieldTag::__pem_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pem_certificate",
                                ));
                            }
                            result.pem_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__certificate_description => {
                            if !fields.insert(__FieldTag::__certificate_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_description",
                                ));
                            }
                            result.certificate_description = map.next_value::<std::option::Option<crate::model::CertificateDescription>>()?
                                ;
                        }
                        __FieldTag::__pem_certificate_chain => {
                            if !fields.insert(__FieldTag::__pem_certificate_chain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pem_certificate_chain",
                                ));
                            }
                            result.pem_certificate_chain = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Certificate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.pem_csr() {
            state.serialize_entry("pemCsr", value)?;
        }
        if let Some(value) = self.config() {
            state.serialize_entry("config", value)?;
        }
        if !self.issuer_certificate_authority.is_empty() {
            state.serialize_entry(
                "issuerCertificateAuthority",
                &self.issuer_certificate_authority,
            )?;
        }
        if self.lifetime.is_some() {
            state.serialize_entry("lifetime", &self.lifetime)?;
        }
        if !self.certificate_template.is_empty() {
            state.serialize_entry("certificateTemplate", &self.certificate_template)?;
        }
        if !wkt::internal::is_default(&self.subject_mode) {
            state.serialize_entry("subjectMode", &self.subject_mode)?;
        }
        if self.revocation_details.is_some() {
            state.serialize_entry("revocationDetails", &self.revocation_details)?;
        }
        if !self.pem_certificate.is_empty() {
            state.serialize_entry("pemCertificate", &self.pem_certificate)?;
        }
        if self.certificate_description.is_some() {
            state.serialize_entry("certificateDescription", &self.certificate_description)?;
        }
        if !self.pem_certificate_chain.is_empty() {
            state.serialize_entry("pemCertificateChain", &self.pem_certificate_chain)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Certificate].
pub mod certificate {
    #[allow(unused_imports)]
    use super::*;

    /// Describes fields that are relavent to the revocation of a
    /// [Certificate][google.cloud.security.privateca.v1.Certificate].
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RevocationDetails {
        /// Indicates why a
        /// [Certificate][google.cloud.security.privateca.v1.Certificate] was
        /// revoked.
        ///
        /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
        pub revocation_state: crate::model::RevocationReason,

        /// The time at which this
        /// [Certificate][google.cloud.security.privateca.v1.Certificate] was
        /// revoked.
        ///
        /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
        pub revocation_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RevocationDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [revocation_state][crate::model::certificate::RevocationDetails::revocation_state].
        pub fn set_revocation_state<T: std::convert::Into<crate::model::RevocationReason>>(
            mut self,
            v: T,
        ) -> Self {
            self.revocation_state = v.into();
            self
        }

        /// Sets the value of [revocation_time][crate::model::certificate::RevocationDetails::revocation_time].
        pub fn set_revocation_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.revocation_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [revocation_time][crate::model::certificate::RevocationDetails::revocation_time].
        pub fn set_or_clear_revocation_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.revocation_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for RevocationDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.security.privateca.v1.Certificate.RevocationDetails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RevocationDetails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __revocation_state,
                __revocation_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RevocationDetails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "revocationState" => Ok(__FieldTag::__revocation_state),
                                "revocation_state" => Ok(__FieldTag::__revocation_state),
                                "revocationTime" => Ok(__FieldTag::__revocation_time),
                                "revocation_time" => Ok(__FieldTag::__revocation_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RevocationDetails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RevocationDetails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__revocation_state => {
                                if !fields.insert(__FieldTag::__revocation_state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for revocation_state",
                                    ));
                                }
                                result.revocation_state = map.next_value::<std::option::Option<crate::model::RevocationReason>>()?.unwrap_or_default();
                            }
                            __FieldTag::__revocation_time => {
                                if !fields.insert(__FieldTag::__revocation_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for revocation_time",
                                    ));
                                }
                                result.revocation_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RevocationDetails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.revocation_state) {
                state.serialize_entry("revocationState", &self.revocation_state)?;
            }
            if self.revocation_time.is_some() {
                state.serialize_entry("revocationTime", &self.revocation_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The config used to create a signed X.509 certificate.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CertificateConfig {
        /// Immutable. A pem-encoded X.509 certificate signing request (CSR).
        PemCsr(std::string::String),
        /// Immutable. A description of the certificate and key that does not require
        /// X.509 or ASN.1.
        Config(std::boxed::Box<crate::model::CertificateConfig>),
    }
}

/// A
/// [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate]
/// refers to a managed template for certificate issuance.
///
/// [google.cloud.security.privateca.v1.CertificateTemplate]: crate::model::CertificateTemplate
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CertificateTemplate {
    /// Output only. The resource name for this
    /// [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate]
    /// in the format `projects/*/locations/*/certificateTemplates/*`.
    ///
    /// [google.cloud.security.privateca.v1.CertificateTemplate]: crate::model::CertificateTemplate
    pub name: std::string::String,

    /// Optional. The maximum lifetime allowed for issued
    /// [Certificates][google.cloud.security.privateca.v1.Certificate] that use
    /// this template. If the issuing
    /// [CaPool][google.cloud.security.privateca.v1.CaPool] resource's
    /// [IssuancePolicy][google.cloud.security.privateca.v1.CaPool.IssuancePolicy]
    /// specifies a
    /// [maximum_lifetime][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.maximum_lifetime]
    /// the minimum of the two durations will be the maximum lifetime for issued
    /// [Certificates][google.cloud.security.privateca.v1.Certificate]. Note that
    /// if the issuing
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// expires before a
    /// [Certificate][google.cloud.security.privateca.v1.Certificate]'s requested
    /// maximum_lifetime, the effective lifetime will be explicitly truncated
    /// to match it.
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    /// [google.cloud.security.privateca.v1.CaPool.IssuancePolicy]: crate::model::ca_pool::IssuancePolicy
    /// [google.cloud.security.privateca.v1.CaPool.IssuancePolicy.maximum_lifetime]: crate::model::ca_pool::IssuancePolicy::maximum_lifetime
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub maximum_lifetime: std::option::Option<wkt::Duration>,

    /// Optional. A set of X.509 values that will be applied to all issued
    /// certificates that use this template. If the certificate request includes
    /// conflicting values for the same properties, they will be overwritten by the
    /// values defined here. If the issuing
    /// [CaPool][google.cloud.security.privateca.v1.CaPool]'s
    /// [IssuancePolicy][google.cloud.security.privateca.v1.CaPool.IssuancePolicy]
    /// defines conflicting
    /// [baseline_values][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.baseline_values]
    /// for the same properties, the certificate issuance request will fail.
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    /// [google.cloud.security.privateca.v1.CaPool.IssuancePolicy]: crate::model::ca_pool::IssuancePolicy
    /// [google.cloud.security.privateca.v1.CaPool.IssuancePolicy.baseline_values]: crate::model::ca_pool::IssuancePolicy::baseline_values
    pub predefined_values: std::option::Option<crate::model::X509Parameters>,

    /// Optional. Describes constraints on identities that may be appear in
    /// [Certificates][google.cloud.security.privateca.v1.Certificate] issued using
    /// this template. If this is omitted, then this template will not add
    /// restrictions on a certificate's identity.
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    pub identity_constraints: std::option::Option<crate::model::CertificateIdentityConstraints>,

    /// Optional. Describes the set of X.509 extensions that may appear in a
    /// [Certificate][google.cloud.security.privateca.v1.Certificate] issued using
    /// this
    /// [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate].
    /// If a certificate request sets extensions that don't appear in the
    /// [passthrough_extensions][google.cloud.security.privateca.v1.CertificateTemplate.passthrough_extensions],
    /// those extensions will be dropped. If the issuing
    /// [CaPool][google.cloud.security.privateca.v1.CaPool]'s
    /// [IssuancePolicy][google.cloud.security.privateca.v1.CaPool.IssuancePolicy]
    /// defines
    /// [baseline_values][google.cloud.security.privateca.v1.CaPool.IssuancePolicy.baseline_values]
    /// that don't appear here, the certificate issuance request will fail. If this
    /// is omitted, then this template will not add restrictions on a certificate's
    /// X.509 extensions. These constraints do not apply to X.509 extensions set in
    /// this
    /// [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate]'s
    /// [predefined_values][google.cloud.security.privateca.v1.CertificateTemplate.predefined_values].
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    /// [google.cloud.security.privateca.v1.CaPool.IssuancePolicy]: crate::model::ca_pool::IssuancePolicy
    /// [google.cloud.security.privateca.v1.CaPool.IssuancePolicy.baseline_values]: crate::model::ca_pool::IssuancePolicy::baseline_values
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    /// [google.cloud.security.privateca.v1.CertificateTemplate]: crate::model::CertificateTemplate
    /// [google.cloud.security.privateca.v1.CertificateTemplate.passthrough_extensions]: crate::model::CertificateTemplate::passthrough_extensions
    /// [google.cloud.security.privateca.v1.CertificateTemplate.predefined_values]: crate::model::CertificateTemplate::predefined_values
    pub passthrough_extensions: std::option::Option<crate::model::CertificateExtensionConstraints>,

    /// Optional. A human-readable description of scenarios this template is
    /// intended for.
    pub description: std::string::String,

    /// Output only. The time at which this
    /// [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate]
    /// was created.
    ///
    /// [google.cloud.security.privateca.v1.CertificateTemplate]: crate::model::CertificateTemplate
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time at which this
    /// [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate]
    /// was updated.
    ///
    /// [google.cloud.security.privateca.v1.CertificateTemplate]: crate::model::CertificateTemplate
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Labels with user-defined metadata.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CertificateTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CertificateTemplate::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [maximum_lifetime][crate::model::CertificateTemplate::maximum_lifetime].
    pub fn set_maximum_lifetime<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.maximum_lifetime = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maximum_lifetime][crate::model::CertificateTemplate::maximum_lifetime].
    pub fn set_or_clear_maximum_lifetime<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.maximum_lifetime = v.map(|x| x.into());
        self
    }

    /// Sets the value of [predefined_values][crate::model::CertificateTemplate::predefined_values].
    pub fn set_predefined_values<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::X509Parameters>,
    {
        self.predefined_values = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [predefined_values][crate::model::CertificateTemplate::predefined_values].
    pub fn set_or_clear_predefined_values<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::X509Parameters>,
    {
        self.predefined_values = v.map(|x| x.into());
        self
    }

    /// Sets the value of [identity_constraints][crate::model::CertificateTemplate::identity_constraints].
    pub fn set_identity_constraints<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CertificateIdentityConstraints>,
    {
        self.identity_constraints = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [identity_constraints][crate::model::CertificateTemplate::identity_constraints].
    pub fn set_or_clear_identity_constraints<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CertificateIdentityConstraints>,
    {
        self.identity_constraints = v.map(|x| x.into());
        self
    }

    /// Sets the value of [passthrough_extensions][crate::model::CertificateTemplate::passthrough_extensions].
    pub fn set_passthrough_extensions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CertificateExtensionConstraints>,
    {
        self.passthrough_extensions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [passthrough_extensions][crate::model::CertificateTemplate::passthrough_extensions].
    pub fn set_or_clear_passthrough_extensions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CertificateExtensionConstraints>,
    {
        self.passthrough_extensions = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::CertificateTemplate::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CertificateTemplate::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CertificateTemplate::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::CertificateTemplate::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::CertificateTemplate::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::CertificateTemplate::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for CertificateTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.CertificateTemplate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CertificateTemplate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __maximum_lifetime,
            __predefined_values,
            __identity_constraints,
            __passthrough_extensions,
            __description,
            __create_time,
            __update_time,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CertificateTemplate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "maximumLifetime" => Ok(__FieldTag::__maximum_lifetime),
                            "maximum_lifetime" => Ok(__FieldTag::__maximum_lifetime),
                            "predefinedValues" => Ok(__FieldTag::__predefined_values),
                            "predefined_values" => Ok(__FieldTag::__predefined_values),
                            "identityConstraints" => Ok(__FieldTag::__identity_constraints),
                            "identity_constraints" => Ok(__FieldTag::__identity_constraints),
                            "passthroughExtensions" => Ok(__FieldTag::__passthrough_extensions),
                            "passthrough_extensions" => Ok(__FieldTag::__passthrough_extensions),
                            "description" => Ok(__FieldTag::__description),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CertificateTemplate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CertificateTemplate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__maximum_lifetime => {
                            if !fields.insert(__FieldTag::__maximum_lifetime) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maximum_lifetime",
                                ));
                            }
                            result.maximum_lifetime =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__predefined_values => {
                            if !fields.insert(__FieldTag::__predefined_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for predefined_values",
                                ));
                            }
                            result.predefined_values = map
                                .next_value::<std::option::Option<crate::model::X509Parameters>>(
                                )?;
                        }
                        __FieldTag::__identity_constraints => {
                            if !fields.insert(__FieldTag::__identity_constraints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for identity_constraints",
                                ));
                            }
                            result.identity_constraints =
                                map.next_value::<std::option::Option<
                                    crate::model::CertificateIdentityConstraints,
                                >>()?;
                        }
                        __FieldTag::__passthrough_extensions => {
                            if !fields.insert(__FieldTag::__passthrough_extensions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for passthrough_extensions",
                                ));
                            }
                            result.passthrough_extensions = map.next_value::<std::option::Option<
                                crate::model::CertificateExtensionConstraints,
                            >>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CertificateTemplate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.maximum_lifetime.is_some() {
            state.serialize_entry("maximumLifetime", &self.maximum_lifetime)?;
        }
        if self.predefined_values.is_some() {
            state.serialize_entry("predefinedValues", &self.predefined_values)?;
        }
        if self.identity_constraints.is_some() {
            state.serialize_entry("identityConstraints", &self.identity_constraints)?;
        }
        if self.passthrough_extensions.is_some() {
            state.serialize_entry("passthroughExtensions", &self.passthrough_extensions)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An [X509Parameters][google.cloud.security.privateca.v1.X509Parameters] is
/// used to describe certain fields of an X.509 certificate, such as the key
/// usage fields, fields specific to CA certificates, certificate policy
/// extensions and custom extensions.
///
/// [google.cloud.security.privateca.v1.X509Parameters]: crate::model::X509Parameters
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct X509Parameters {
    /// Optional. Indicates the intended use for keys that correspond to a
    /// certificate.
    pub key_usage: std::option::Option<crate::model::KeyUsage>,

    /// Optional. Describes options in this
    /// [X509Parameters][google.cloud.security.privateca.v1.X509Parameters] that
    /// are relevant in a CA certificate.
    ///
    /// [google.cloud.security.privateca.v1.X509Parameters]: crate::model::X509Parameters
    pub ca_options: std::option::Option<crate::model::x_509_parameters::CaOptions>,

    /// Optional. Describes the X.509 certificate policy object identifiers, per
    /// <https://tools.ietf.org/html/rfc5280#section-4.2.1.4>.
    pub policy_ids: std::vec::Vec<crate::model::ObjectId>,

    /// Optional. Describes Online Certificate Status Protocol (OCSP) endpoint
    /// addresses that appear in the "Authority Information Access" extension in
    /// the certificate.
    pub aia_ocsp_servers: std::vec::Vec<std::string::String>,

    /// Optional. Describes the X.509 name constraints extension.
    pub name_constraints: std::option::Option<crate::model::x_509_parameters::NameConstraints>,

    /// Optional. Describes custom X.509 extensions.
    pub additional_extensions: std::vec::Vec<crate::model::X509Extension>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl X509Parameters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key_usage][crate::model::X509Parameters::key_usage].
    pub fn set_key_usage<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::KeyUsage>,
    {
        self.key_usage = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [key_usage][crate::model::X509Parameters::key_usage].
    pub fn set_or_clear_key_usage<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::KeyUsage>,
    {
        self.key_usage = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ca_options][crate::model::X509Parameters::ca_options].
    pub fn set_ca_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::x_509_parameters::CaOptions>,
    {
        self.ca_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ca_options][crate::model::X509Parameters::ca_options].
    pub fn set_or_clear_ca_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::x_509_parameters::CaOptions>,
    {
        self.ca_options = v.map(|x| x.into());
        self
    }

    /// Sets the value of [policy_ids][crate::model::X509Parameters::policy_ids].
    pub fn set_policy_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ObjectId>,
    {
        use std::iter::Iterator;
        self.policy_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [aia_ocsp_servers][crate::model::X509Parameters::aia_ocsp_servers].
    pub fn set_aia_ocsp_servers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.aia_ocsp_servers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [name_constraints][crate::model::X509Parameters::name_constraints].
    pub fn set_name_constraints<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::x_509_parameters::NameConstraints>,
    {
        self.name_constraints = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name_constraints][crate::model::X509Parameters::name_constraints].
    pub fn set_or_clear_name_constraints<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::x_509_parameters::NameConstraints>,
    {
        self.name_constraints = v.map(|x| x.into());
        self
    }

    /// Sets the value of [additional_extensions][crate::model::X509Parameters::additional_extensions].
    pub fn set_additional_extensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::X509Extension>,
    {
        use std::iter::Iterator;
        self.additional_extensions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for X509Parameters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.X509Parameters"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for X509Parameters {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key_usage,
            __ca_options,
            __policy_ids,
            __aia_ocsp_servers,
            __name_constraints,
            __additional_extensions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for X509Parameters")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "keyUsage" => Ok(__FieldTag::__key_usage),
                            "key_usage" => Ok(__FieldTag::__key_usage),
                            "caOptions" => Ok(__FieldTag::__ca_options),
                            "ca_options" => Ok(__FieldTag::__ca_options),
                            "policyIds" => Ok(__FieldTag::__policy_ids),
                            "policy_ids" => Ok(__FieldTag::__policy_ids),
                            "aiaOcspServers" => Ok(__FieldTag::__aia_ocsp_servers),
                            "aia_ocsp_servers" => Ok(__FieldTag::__aia_ocsp_servers),
                            "nameConstraints" => Ok(__FieldTag::__name_constraints),
                            "name_constraints" => Ok(__FieldTag::__name_constraints),
                            "additionalExtensions" => Ok(__FieldTag::__additional_extensions),
                            "additional_extensions" => Ok(__FieldTag::__additional_extensions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = X509Parameters;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct X509Parameters")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key_usage => {
                            if !fields.insert(__FieldTag::__key_usage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_usage",
                                ));
                            }
                            result.key_usage =
                                map.next_value::<std::option::Option<crate::model::KeyUsage>>()?;
                        }
                        __FieldTag::__ca_options => {
                            if !fields.insert(__FieldTag::__ca_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_options",
                                ));
                            }
                            result.ca_options = map.next_value::<std::option::Option<crate::model::x_509_parameters::CaOptions>>()?
                                ;
                        }
                        __FieldTag::__policy_ids => {
                            if !fields.insert(__FieldTag::__policy_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_ids",
                                ));
                            }
                            result.policy_ids = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ObjectId>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__aia_ocsp_servers => {
                            if !fields.insert(__FieldTag::__aia_ocsp_servers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aia_ocsp_servers",
                                ));
                            }
                            result.aia_ocsp_servers = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__name_constraints => {
                            if !fields.insert(__FieldTag::__name_constraints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name_constraints",
                                ));
                            }
                            result.name_constraints = map.next_value::<std::option::Option<
                                crate::model::x_509_parameters::NameConstraints,
                            >>()?;
                        }
                        __FieldTag::__additional_extensions => {
                            if !fields.insert(__FieldTag::__additional_extensions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_extensions",
                                ));
                            }
                            result.additional_extensions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::X509Extension>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for X509Parameters {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key_usage.is_some() {
            state.serialize_entry("keyUsage", &self.key_usage)?;
        }
        if self.ca_options.is_some() {
            state.serialize_entry("caOptions", &self.ca_options)?;
        }
        if !self.policy_ids.is_empty() {
            state.serialize_entry("policyIds", &self.policy_ids)?;
        }
        if !self.aia_ocsp_servers.is_empty() {
            state.serialize_entry("aiaOcspServers", &self.aia_ocsp_servers)?;
        }
        if self.name_constraints.is_some() {
            state.serialize_entry("nameConstraints", &self.name_constraints)?;
        }
        if !self.additional_extensions.is_empty() {
            state.serialize_entry("additionalExtensions", &self.additional_extensions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [X509Parameters].
pub mod x_509_parameters {
    #[allow(unused_imports)]
    use super::*;

    /// Describes values that are relevant in a CA certificate.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CaOptions {
        /// Optional. Refers to the "CA" X.509 extension, which is a boolean value.
        /// When this value is missing, the extension will be omitted from the CA
        /// certificate.
        pub is_ca: std::option::Option<bool>,

        /// Optional. Refers to the path length restriction X.509 extension. For a CA
        /// certificate, this value describes the depth of subordinate CA
        /// certificates that are allowed.
        /// If this value is less than 0, the request will fail.
        /// If this value is missing, the max path length will be omitted from the
        /// CA certificate.
        pub max_issuer_path_length: std::option::Option<i32>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CaOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [is_ca][crate::model::x_509_parameters::CaOptions::is_ca].
        pub fn set_is_ca<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.is_ca = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [is_ca][crate::model::x_509_parameters::CaOptions::is_ca].
        pub fn set_or_clear_is_ca<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.is_ca = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_issuer_path_length][crate::model::x_509_parameters::CaOptions::max_issuer_path_length].
        pub fn set_max_issuer_path_length<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.max_issuer_path_length = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_issuer_path_length][crate::model::x_509_parameters::CaOptions::max_issuer_path_length].
        pub fn set_or_clear_max_issuer_path_length<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.max_issuer_path_length = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for CaOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.security.privateca.v1.X509Parameters.CaOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CaOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __is_ca,
                __max_issuer_path_length,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CaOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "isCa" => Ok(__FieldTag::__is_ca),
                                "is_ca" => Ok(__FieldTag::__is_ca),
                                "maxIssuerPathLength" => Ok(__FieldTag::__max_issuer_path_length),
                                "max_issuer_path_length" => {
                                    Ok(__FieldTag::__max_issuer_path_length)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CaOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CaOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__is_ca => {
                                if !fields.insert(__FieldTag::__is_ca) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for is_ca",
                                    ));
                                }
                                result.is_ca = map.next_value::<std::option::Option<bool>>()?;
                            }
                            __FieldTag::__max_issuer_path_length => {
                                if !fields.insert(__FieldTag::__max_issuer_path_length) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_issuer_path_length",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.max_issuer_path_length = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CaOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.is_ca.is_some() {
                state.serialize_entry("isCa", &self.is_ca)?;
            }
            if self.max_issuer_path_length.is_some() {
                struct __With<'a>(&'a std::option::Option<i32>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry(
                    "maxIssuerPathLength",
                    &__With(&self.max_issuer_path_length),
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Describes the X.509 name constraints extension, per
    /// <https://tools.ietf.org/html/rfc5280#section-4.2.1.10>
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NameConstraints {
        /// Indicates whether or not the name constraints are marked critical.
        pub critical: bool,

        /// Contains permitted DNS names. Any DNS name that can be
        /// constructed by simply adding zero or more labels to
        /// the left-hand side of the name satisfies the name constraint.
        /// For example, `example.com`, `www.example.com`, `www.sub.example.com`
        /// would satisfy `example.com` while `example1.com` does not.
        pub permitted_dns_names: std::vec::Vec<std::string::String>,

        /// Contains excluded DNS names. Any DNS name that can be
        /// constructed by simply adding zero or more labels to
        /// the left-hand side of the name satisfies the name constraint.
        /// For example, `example.com`, `www.example.com`, `www.sub.example.com`
        /// would satisfy `example.com` while `example1.com` does not.
        pub excluded_dns_names: std::vec::Vec<std::string::String>,

        /// Contains the permitted IP ranges. For IPv4 addresses, the ranges
        /// are expressed using CIDR notation as specified in RFC 4632.
        /// For IPv6 addresses, the ranges are expressed in similar encoding as IPv4
        /// addresses.
        pub permitted_ip_ranges: std::vec::Vec<std::string::String>,

        /// Contains the excluded IP ranges. For IPv4 addresses, the ranges
        /// are expressed using CIDR notation as specified in RFC 4632.
        /// For IPv6 addresses, the ranges are expressed in similar encoding as IPv4
        /// addresses.
        pub excluded_ip_ranges: std::vec::Vec<std::string::String>,

        /// Contains the permitted email addresses. The value can be a particular
        /// email address, a hostname to indicate all email addresses on that host or
        /// a domain with a leading period (e.g. `.example.com`) to indicate
        /// all email addresses in that domain.
        pub permitted_email_addresses: std::vec::Vec<std::string::String>,

        /// Contains the excluded email addresses. The value can be a particular
        /// email address, a hostname to indicate all email addresses on that host or
        /// a domain with a leading period (e.g. `.example.com`) to indicate
        /// all email addresses in that domain.
        pub excluded_email_addresses: std::vec::Vec<std::string::String>,

        /// Contains the permitted URIs that apply to the host part of the name.
        /// The value can be a hostname or a domain with a
        /// leading period (like `.example.com`)
        pub permitted_uris: std::vec::Vec<std::string::String>,

        /// Contains the excluded URIs that apply to the host part of the name.
        /// The value can be a hostname or a domain with a
        /// leading period (like `.example.com`)
        pub excluded_uris: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NameConstraints {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [critical][crate::model::x_509_parameters::NameConstraints::critical].
        pub fn set_critical<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.critical = v.into();
            self
        }

        /// Sets the value of [permitted_dns_names][crate::model::x_509_parameters::NameConstraints::permitted_dns_names].
        pub fn set_permitted_dns_names<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.permitted_dns_names = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [excluded_dns_names][crate::model::x_509_parameters::NameConstraints::excluded_dns_names].
        pub fn set_excluded_dns_names<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.excluded_dns_names = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [permitted_ip_ranges][crate::model::x_509_parameters::NameConstraints::permitted_ip_ranges].
        pub fn set_permitted_ip_ranges<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.permitted_ip_ranges = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [excluded_ip_ranges][crate::model::x_509_parameters::NameConstraints::excluded_ip_ranges].
        pub fn set_excluded_ip_ranges<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.excluded_ip_ranges = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [permitted_email_addresses][crate::model::x_509_parameters::NameConstraints::permitted_email_addresses].
        pub fn set_permitted_email_addresses<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.permitted_email_addresses = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [excluded_email_addresses][crate::model::x_509_parameters::NameConstraints::excluded_email_addresses].
        pub fn set_excluded_email_addresses<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.excluded_email_addresses = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [permitted_uris][crate::model::x_509_parameters::NameConstraints::permitted_uris].
        pub fn set_permitted_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.permitted_uris = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [excluded_uris][crate::model::x_509_parameters::NameConstraints::excluded_uris].
        pub fn set_excluded_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.excluded_uris = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for NameConstraints {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.security.privateca.v1.X509Parameters.NameConstraints"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for NameConstraints {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __critical,
                __permitted_dns_names,
                __excluded_dns_names,
                __permitted_ip_ranges,
                __excluded_ip_ranges,
                __permitted_email_addresses,
                __excluded_email_addresses,
                __permitted_uris,
                __excluded_uris,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for NameConstraints")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "critical" => Ok(__FieldTag::__critical),
                                "permittedDnsNames" => Ok(__FieldTag::__permitted_dns_names),
                                "permitted_dns_names" => Ok(__FieldTag::__permitted_dns_names),
                                "excludedDnsNames" => Ok(__FieldTag::__excluded_dns_names),
                                "excluded_dns_names" => Ok(__FieldTag::__excluded_dns_names),
                                "permittedIpRanges" => Ok(__FieldTag::__permitted_ip_ranges),
                                "permitted_ip_ranges" => Ok(__FieldTag::__permitted_ip_ranges),
                                "excludedIpRanges" => Ok(__FieldTag::__excluded_ip_ranges),
                                "excluded_ip_ranges" => Ok(__FieldTag::__excluded_ip_ranges),
                                "permittedEmailAddresses" => {
                                    Ok(__FieldTag::__permitted_email_addresses)
                                }
                                "permitted_email_addresses" => {
                                    Ok(__FieldTag::__permitted_email_addresses)
                                }
                                "excludedEmailAddresses" => {
                                    Ok(__FieldTag::__excluded_email_addresses)
                                }
                                "excluded_email_addresses" => {
                                    Ok(__FieldTag::__excluded_email_addresses)
                                }
                                "permittedUris" => Ok(__FieldTag::__permitted_uris),
                                "permitted_uris" => Ok(__FieldTag::__permitted_uris),
                                "excludedUris" => Ok(__FieldTag::__excluded_uris),
                                "excluded_uris" => Ok(__FieldTag::__excluded_uris),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = NameConstraints;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct NameConstraints")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__critical => {
                                if !fields.insert(__FieldTag::__critical) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for critical",
                                    ));
                                }
                                result.critical = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__permitted_dns_names => {
                                if !fields.insert(__FieldTag::__permitted_dns_names) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for permitted_dns_names",
                                    ));
                                }
                                result.permitted_dns_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__excluded_dns_names => {
                                if !fields.insert(__FieldTag::__excluded_dns_names) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for excluded_dns_names",
                                    ));
                                }
                                result.excluded_dns_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__permitted_ip_ranges => {
                                if !fields.insert(__FieldTag::__permitted_ip_ranges) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for permitted_ip_ranges",
                                    ));
                                }
                                result.permitted_ip_ranges = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__excluded_ip_ranges => {
                                if !fields.insert(__FieldTag::__excluded_ip_ranges) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for excluded_ip_ranges",
                                    ));
                                }
                                result.excluded_ip_ranges = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__permitted_email_addresses => {
                                if !fields.insert(__FieldTag::__permitted_email_addresses) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for permitted_email_addresses",
                                    ));
                                }
                                result.permitted_email_addresses = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__excluded_email_addresses => {
                                if !fields.insert(__FieldTag::__excluded_email_addresses) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for excluded_email_addresses",
                                    ));
                                }
                                result.excluded_email_addresses = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__permitted_uris => {
                                if !fields.insert(__FieldTag::__permitted_uris) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for permitted_uris",
                                    ));
                                }
                                result.permitted_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__excluded_uris => {
                                if !fields.insert(__FieldTag::__excluded_uris) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for excluded_uris",
                                    ));
                                }
                                result.excluded_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for NameConstraints {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.critical) {
                state.serialize_entry("critical", &self.critical)?;
            }
            if !self.permitted_dns_names.is_empty() {
                state.serialize_entry("permittedDnsNames", &self.permitted_dns_names)?;
            }
            if !self.excluded_dns_names.is_empty() {
                state.serialize_entry("excludedDnsNames", &self.excluded_dns_names)?;
            }
            if !self.permitted_ip_ranges.is_empty() {
                state.serialize_entry("permittedIpRanges", &self.permitted_ip_ranges)?;
            }
            if !self.excluded_ip_ranges.is_empty() {
                state.serialize_entry("excludedIpRanges", &self.excluded_ip_ranges)?;
            }
            if !self.permitted_email_addresses.is_empty() {
                state
                    .serialize_entry("permittedEmailAddresses", &self.permitted_email_addresses)?;
            }
            if !self.excluded_email_addresses.is_empty() {
                state.serialize_entry("excludedEmailAddresses", &self.excluded_email_addresses)?;
            }
            if !self.permitted_uris.is_empty() {
                state.serialize_entry("permittedUris", &self.permitted_uris)?;
            }
            if !self.excluded_uris.is_empty() {
                state.serialize_entry("excludedUris", &self.excluded_uris)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Describes a subordinate CA's issuers. This is either a resource name to a
/// known issuing
/// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority],
/// or a PEM issuer certificate chain.
///
/// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SubordinateConfig {
    pub subordinate_config:
        std::option::Option<crate::model::subordinate_config::SubordinateConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubordinateConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subordinate_config][crate::model::SubordinateConfig::subordinate_config].
    ///
    /// Note that all the setters affecting `subordinate_config` are mutually
    /// exclusive.
    pub fn set_subordinate_config<
        T: std::convert::Into<
                std::option::Option<crate::model::subordinate_config::SubordinateConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.subordinate_config = v.into();
        self
    }

    /// The value of [subordinate_config][crate::model::SubordinateConfig::subordinate_config]
    /// if it holds a `CertificateAuthority`, `None` if the field is not set or
    /// holds a different branch.
    pub fn certificate_authority(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.subordinate_config.as_ref().and_then(|v| match v {
            crate::model::subordinate_config::SubordinateConfig::CertificateAuthority(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [subordinate_config][crate::model::SubordinateConfig::subordinate_config]
    /// to hold a `CertificateAuthority`.
    ///
    /// Note that all the setters affecting `subordinate_config` are
    /// mutually exclusive.
    pub fn set_certificate_authority<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.subordinate_config = std::option::Option::Some(
            crate::model::subordinate_config::SubordinateConfig::CertificateAuthority(v.into()),
        );
        self
    }

    /// The value of [subordinate_config][crate::model::SubordinateConfig::subordinate_config]
    /// if it holds a `PemIssuerChain`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pem_issuer_chain(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::subordinate_config::SubordinateConfigChain>,
    > {
        #[allow(unreachable_patterns)]
        self.subordinate_config.as_ref().and_then(|v| match v {
            crate::model::subordinate_config::SubordinateConfig::PemIssuerChain(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [subordinate_config][crate::model::SubordinateConfig::subordinate_config]
    /// to hold a `PemIssuerChain`.
    ///
    /// Note that all the setters affecting `subordinate_config` are
    /// mutually exclusive.
    pub fn set_pem_issuer_chain<
        T: std::convert::Into<
                std::boxed::Box<crate::model::subordinate_config::SubordinateConfigChain>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.subordinate_config = std::option::Option::Some(
            crate::model::subordinate_config::SubordinateConfig::PemIssuerChain(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SubordinateConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.SubordinateConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SubordinateConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certificate_authority,
            __pem_issuer_chain,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SubordinateConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certificateAuthority" => Ok(__FieldTag::__certificate_authority),
                            "certificate_authority" => Ok(__FieldTag::__certificate_authority),
                            "pemIssuerChain" => Ok(__FieldTag::__pem_issuer_chain),
                            "pem_issuer_chain" => Ok(__FieldTag::__pem_issuer_chain),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SubordinateConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SubordinateConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certificate_authority => {
                            if !fields.insert(__FieldTag::__certificate_authority) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_authority",
                                ));
                            }
                            if result.subordinate_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `subordinate_config`, a oneof with full ID .google.cloud.security.privateca.v1.SubordinateConfig.certificate_authority, latest field was certificateAuthority",
                                ));
                            }
                            result.subordinate_config = std::option::Option::Some(
                                crate::model::subordinate_config::SubordinateConfig::CertificateAuthority(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__pem_issuer_chain => {
                            if !fields.insert(__FieldTag::__pem_issuer_chain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pem_issuer_chain",
                                ));
                            }
                            if result.subordinate_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `subordinate_config`, a oneof with full ID .google.cloud.security.privateca.v1.SubordinateConfig.pem_issuer_chain, latest field was pemIssuerChain",
                                ));
                            }
                            result.subordinate_config = std::option::Option::Some(
                                crate::model::subordinate_config::SubordinateConfig::PemIssuerChain(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::subordinate_config::SubordinateConfigChain>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SubordinateConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.certificate_authority() {
            state.serialize_entry("certificateAuthority", value)?;
        }
        if let Some(value) = self.pem_issuer_chain() {
            state.serialize_entry("pemIssuerChain", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SubordinateConfig].
pub mod subordinate_config {
    #[allow(unused_imports)]
    use super::*;

    /// This message describes a subordinate CA's issuer certificate chain. This
    /// wrapper exists for compatibility reasons.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SubordinateConfigChain {
        /// Required. Expected to be in leaf-to-root order according to RFC 5246.
        pub pem_certificates: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SubordinateConfigChain {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [pem_certificates][crate::model::subordinate_config::SubordinateConfigChain::pem_certificates].
        pub fn set_pem_certificates<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.pem_certificates = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for SubordinateConfigChain {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.security.privateca.v1.SubordinateConfig.SubordinateConfigChain"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SubordinateConfigChain {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __pem_certificates,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SubordinateConfigChain")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "pemCertificates" => Ok(__FieldTag::__pem_certificates),
                                "pem_certificates" => Ok(__FieldTag::__pem_certificates),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SubordinateConfigChain;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SubordinateConfigChain")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__pem_certificates => {
                                if !fields.insert(__FieldTag::__pem_certificates) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for pem_certificates",
                                    ));
                                }
                                result.pem_certificates = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SubordinateConfigChain {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.pem_certificates.is_empty() {
                state.serialize_entry("pemCertificates", &self.pem_certificates)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SubordinateConfig {
        /// Required. This can refer to a
        /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
        /// that was used to create a subordinate
        /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority].
        /// This field is used for information and usability purposes only. The
        /// resource name is in the format
        /// `projects/*/locations/*/caPools/*/certificateAuthorities/*`.
        ///
        /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
        CertificateAuthority(std::string::String),
        /// Required. Contains the PEM certificate chain for the issuers of this
        /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority],
        /// but not pem certificate for this CA itself.
        ///
        /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
        PemIssuerChain(std::boxed::Box<crate::model::subordinate_config::SubordinateConfigChain>),
    }
}

/// A [PublicKey][google.cloud.security.privateca.v1.PublicKey] describes a
/// public key.
///
/// [google.cloud.security.privateca.v1.PublicKey]: crate::model::PublicKey
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PublicKey {
    /// Required. A public key. The padding and encoding
    /// must match with the `KeyFormat` value specified for the `format` field.
    pub key: ::bytes::Bytes,

    /// Required. The format of the public key.
    pub format: crate::model::public_key::KeyFormat,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PublicKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::PublicKey::key].
    pub fn set_key<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [format][crate::model::PublicKey::format].
    pub fn set_format<T: std::convert::Into<crate::model::public_key::KeyFormat>>(
        mut self,
        v: T,
    ) -> Self {
        self.format = v.into();
        self
    }
}

impl wkt::message::Message for PublicKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.PublicKey"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PublicKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            __format,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PublicKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            "format" => Ok(__FieldTag::__format),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PublicKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PublicKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.key = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__format => {
                            if !fields.insert(__FieldTag::__format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for format",
                                ));
                            }
                            result.format = map.next_value::<std::option::Option<crate::model::public_key::KeyFormat>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PublicKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("key", &__With(&self.key))?;
        }
        if !wkt::internal::is_default(&self.format) {
            state.serialize_entry("format", &self.format)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [PublicKey].
pub mod public_key {
    #[allow(unused_imports)]
    use super::*;

    /// Types of public keys formats that are supported. Currently, only `PEM`
    /// format is supported.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum KeyFormat {
        /// Default unspecified value.
        Unspecified,
        /// The key is PEM-encoded as defined in [RFC
        /// 7468](https://tools.ietf.org/html/rfc7468). It can be any of the
        /// following: a PEM-encoded PKCS#1/RFC 3447 RSAPublicKey
        /// structure, an RFC 5280
        /// [SubjectPublicKeyInfo](https://tools.ietf.org/html/rfc5280#section-4.1)
        /// or a PEM-encoded X.509 certificate signing request (CSR). If a
        /// [SubjectPublicKeyInfo](https://tools.ietf.org/html/rfc5280#section-4.1)
        /// is specified, it can contain a A PEM-encoded PKCS#1/RFC 3447 RSAPublicKey
        /// or a NIST P-256/secp256r1/prime256v1 or P-384 key. If a CSR is specified,
        /// it will used solely for the purpose of extracting the public key. When
        /// generated by the service, it will always be an RFC 5280
        /// [SubjectPublicKeyInfo](https://tools.ietf.org/html/rfc5280#section-4.1)
        /// structure containing an algorithm identifier and a key.
        Pem,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [KeyFormat::value] or
        /// [KeyFormat::name].
        UnknownValue(key_format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod key_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl KeyFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pem => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("KEY_FORMAT_UNSPECIFIED"),
                Self::Pem => std::option::Option::Some("PEM"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for KeyFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for KeyFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for KeyFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pem,
                _ => Self::UnknownValue(key_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for KeyFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "KEY_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "PEM" => Self::Pem,
                _ => Self::UnknownValue(key_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for KeyFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pem => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for KeyFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<KeyFormat>::new(
                ".google.cloud.security.privateca.v1.PublicKey.KeyFormat",
            ))
        }
    }
}

/// A [CertificateConfig][google.cloud.security.privateca.v1.CertificateConfig]
/// describes an X.509 certificate or CSR that is to be created, as an
/// alternative to using ASN.1.
///
/// [google.cloud.security.privateca.v1.CertificateConfig]: crate::model::CertificateConfig
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CertificateConfig {
    /// Required. Specifies some of the values in a certificate that are related to
    /// the subject.
    pub subject_config: std::option::Option<crate::model::certificate_config::SubjectConfig>,

    /// Required. Describes how some of the technical X.509 fields in a certificate
    /// should be populated.
    pub x509_config: std::option::Option<crate::model::X509Parameters>,

    /// Optional. The public key that corresponds to this config. This is, for
    /// example, used when issuing
    /// [Certificates][google.cloud.security.privateca.v1.Certificate], but not
    /// when creating a self-signed
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// or
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// CSR.
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub public_key: std::option::Option<crate::model::PublicKey>,

    /// Optional. When specified this provides a custom SKI to be used in the
    /// certificate. This should only be used to maintain a SKI of an existing CA
    /// originally created outside CA service, which was not generated using method
    /// (1) described in RFC 5280 section 4.2.1.2.
    pub subject_key_id: std::option::Option<crate::model::certificate_config::KeyId>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CertificateConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subject_config][crate::model::CertificateConfig::subject_config].
    pub fn set_subject_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::certificate_config::SubjectConfig>,
    {
        self.subject_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subject_config][crate::model::CertificateConfig::subject_config].
    pub fn set_or_clear_subject_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::certificate_config::SubjectConfig>,
    {
        self.subject_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [x509_config][crate::model::CertificateConfig::x509_config].
    pub fn set_x509_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::X509Parameters>,
    {
        self.x509_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [x509_config][crate::model::CertificateConfig::x509_config].
    pub fn set_or_clear_x509_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::X509Parameters>,
    {
        self.x509_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [public_key][crate::model::CertificateConfig::public_key].
    pub fn set_public_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PublicKey>,
    {
        self.public_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [public_key][crate::model::CertificateConfig::public_key].
    pub fn set_or_clear_public_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PublicKey>,
    {
        self.public_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [subject_key_id][crate::model::CertificateConfig::subject_key_id].
    pub fn set_subject_key_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::certificate_config::KeyId>,
    {
        self.subject_key_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subject_key_id][crate::model::CertificateConfig::subject_key_id].
    pub fn set_or_clear_subject_key_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::certificate_config::KeyId>,
    {
        self.subject_key_id = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CertificateConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.CertificateConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CertificateConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subject_config,
            __x509_config,
            __public_key,
            __subject_key_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CertificateConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subjectConfig" => Ok(__FieldTag::__subject_config),
                            "subject_config" => Ok(__FieldTag::__subject_config),
                            "x509Config" => Ok(__FieldTag::__x509_config),
                            "x509_config" => Ok(__FieldTag::__x509_config),
                            "publicKey" => Ok(__FieldTag::__public_key),
                            "public_key" => Ok(__FieldTag::__public_key),
                            "subjectKeyId" => Ok(__FieldTag::__subject_key_id),
                            "subject_key_id" => Ok(__FieldTag::__subject_key_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CertificateConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CertificateConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subject_config => {
                            if !fields.insert(__FieldTag::__subject_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_config",
                                ));
                            }
                            result.subject_config = map.next_value::<std::option::Option<
                                crate::model::certificate_config::SubjectConfig,
                            >>()?;
                        }
                        __FieldTag::__x509_config => {
                            if !fields.insert(__FieldTag::__x509_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for x509_config",
                                ));
                            }
                            result.x509_config = map
                                .next_value::<std::option::Option<crate::model::X509Parameters>>(
                                )?;
                        }
                        __FieldTag::__public_key => {
                            if !fields.insert(__FieldTag::__public_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_key",
                                ));
                            }
                            result.public_key =
                                map.next_value::<std::option::Option<crate::model::PublicKey>>()?;
                        }
                        __FieldTag::__subject_key_id => {
                            if !fields.insert(__FieldTag::__subject_key_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_key_id",
                                ));
                            }
                            result.subject_key_id = map.next_value::<std::option::Option<crate::model::certificate_config::KeyId>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CertificateConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.subject_config.is_some() {
            state.serialize_entry("subjectConfig", &self.subject_config)?;
        }
        if self.x509_config.is_some() {
            state.serialize_entry("x509Config", &self.x509_config)?;
        }
        if self.public_key.is_some() {
            state.serialize_entry("publicKey", &self.public_key)?;
        }
        if self.subject_key_id.is_some() {
            state.serialize_entry("subjectKeyId", &self.subject_key_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CertificateConfig].
pub mod certificate_config {
    #[allow(unused_imports)]
    use super::*;

    /// These values are used to create the distinguished name and subject
    /// alternative name fields in an X.509 certificate.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SubjectConfig {
        /// Optional. Contains distinguished name fields such as the common name,
        /// location and organization.
        pub subject: std::option::Option<crate::model::Subject>,

        /// Optional. The subject alternative name fields.
        pub subject_alt_name: std::option::Option<crate::model::SubjectAltNames>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SubjectConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [subject][crate::model::certificate_config::SubjectConfig::subject].
        pub fn set_subject<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Subject>,
        {
            self.subject = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [subject][crate::model::certificate_config::SubjectConfig::subject].
        pub fn set_or_clear_subject<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Subject>,
        {
            self.subject = v.map(|x| x.into());
            self
        }

        /// Sets the value of [subject_alt_name][crate::model::certificate_config::SubjectConfig::subject_alt_name].
        pub fn set_subject_alt_name<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::SubjectAltNames>,
        {
            self.subject_alt_name = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [subject_alt_name][crate::model::certificate_config::SubjectConfig::subject_alt_name].
        pub fn set_or_clear_subject_alt_name<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::SubjectAltNames>,
        {
            self.subject_alt_name = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SubjectConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.security.privateca.v1.CertificateConfig.SubjectConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SubjectConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __subject,
                __subject_alt_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SubjectConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "subject" => Ok(__FieldTag::__subject),
                                "subjectAltName" => Ok(__FieldTag::__subject_alt_name),
                                "subject_alt_name" => Ok(__FieldTag::__subject_alt_name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SubjectConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SubjectConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__subject => {
                                if !fields.insert(__FieldTag::__subject) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for subject",
                                    ));
                                }
                                result.subject =
                                    map.next_value::<std::option::Option<crate::model::Subject>>()?;
                            }
                            __FieldTag::__subject_alt_name => {
                                if !fields.insert(__FieldTag::__subject_alt_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for subject_alt_name",
                                    ));
                                }
                                result.subject_alt_name = map.next_value::<std::option::Option<crate::model::SubjectAltNames>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SubjectConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.subject.is_some() {
                state.serialize_entry("subject", &self.subject)?;
            }
            if self.subject_alt_name.is_some() {
                state.serialize_entry("subjectAltName", &self.subject_alt_name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A KeyId identifies a specific public key, usually by hashing the public
    /// key.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct KeyId {
        /// Required. The value of this KeyId encoded in lowercase hexadecimal. This
        /// is most likely the 160 bit SHA-1 hash of the public key.
        pub key_id: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl KeyId {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key_id][crate::model::certificate_config::KeyId::key_id].
        pub fn set_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key_id = v.into();
            self
        }
    }

    impl wkt::message::Message for KeyId {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.security.privateca.v1.CertificateConfig.KeyId"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for KeyId {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __key_id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for KeyId")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "keyId" => Ok(__FieldTag::__key_id),
                                "key_id" => Ok(__FieldTag::__key_id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = KeyId;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct KeyId")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__key_id => {
                                if !fields.insert(__FieldTag::__key_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for key_id",
                                    ));
                                }
                                result.key_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for KeyId {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.key_id.is_empty() {
                state.serialize_entry("keyId", &self.key_id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// A
/// [CertificateDescription][google.cloud.security.privateca.v1.CertificateDescription]
/// describes an X.509 certificate or CSR that has been issued, as an alternative
/// to using ASN.1 / X.509.
///
/// [google.cloud.security.privateca.v1.CertificateDescription]: crate::model::CertificateDescription
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CertificateDescription {
    /// Describes some of the values in a certificate that are related to the
    /// subject and lifetime.
    pub subject_description:
        std::option::Option<crate::model::certificate_description::SubjectDescription>,

    /// Describes some of the technical X.509 fields in a certificate.
    pub x509_description: std::option::Option<crate::model::X509Parameters>,

    /// The public key that corresponds to an issued certificate.
    pub public_key: std::option::Option<crate::model::PublicKey>,

    /// Provides a means of identifiying certificates that contain a particular
    /// public key, per <https://tools.ietf.org/html/rfc5280#section-4.2.1.2>.
    pub subject_key_id: std::option::Option<crate::model::certificate_description::KeyId>,

    /// Identifies the subject_key_id of the parent certificate, per
    /// <https://tools.ietf.org/html/rfc5280#section-4.2.1.1>
    pub authority_key_id: std::option::Option<crate::model::certificate_description::KeyId>,

    /// Describes a list of locations to obtain CRL information, i.e.
    /// the DistributionPoint.fullName described by
    /// <https://tools.ietf.org/html/rfc5280#section-4.2.1.13>
    pub crl_distribution_points: std::vec::Vec<std::string::String>,

    /// Describes lists of issuer CA certificate URLs that appear in the
    /// "Authority Information Access" extension in the certificate.
    pub aia_issuing_certificate_urls: std::vec::Vec<std::string::String>,

    /// The hash of the x.509 certificate.
    pub cert_fingerprint:
        std::option::Option<crate::model::certificate_description::CertificateFingerprint>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CertificateDescription {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subject_description][crate::model::CertificateDescription::subject_description].
    pub fn set_subject_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::certificate_description::SubjectDescription>,
    {
        self.subject_description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subject_description][crate::model::CertificateDescription::subject_description].
    pub fn set_or_clear_subject_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::certificate_description::SubjectDescription>,
    {
        self.subject_description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [x509_description][crate::model::CertificateDescription::x509_description].
    pub fn set_x509_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::X509Parameters>,
    {
        self.x509_description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [x509_description][crate::model::CertificateDescription::x509_description].
    pub fn set_or_clear_x509_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::X509Parameters>,
    {
        self.x509_description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [public_key][crate::model::CertificateDescription::public_key].
    pub fn set_public_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PublicKey>,
    {
        self.public_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [public_key][crate::model::CertificateDescription::public_key].
    pub fn set_or_clear_public_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PublicKey>,
    {
        self.public_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [subject_key_id][crate::model::CertificateDescription::subject_key_id].
    pub fn set_subject_key_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::certificate_description::KeyId>,
    {
        self.subject_key_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subject_key_id][crate::model::CertificateDescription::subject_key_id].
    pub fn set_or_clear_subject_key_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::certificate_description::KeyId>,
    {
        self.subject_key_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [authority_key_id][crate::model::CertificateDescription::authority_key_id].
    pub fn set_authority_key_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::certificate_description::KeyId>,
    {
        self.authority_key_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authority_key_id][crate::model::CertificateDescription::authority_key_id].
    pub fn set_or_clear_authority_key_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::certificate_description::KeyId>,
    {
        self.authority_key_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [crl_distribution_points][crate::model::CertificateDescription::crl_distribution_points].
    pub fn set_crl_distribution_points<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.crl_distribution_points = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [aia_issuing_certificate_urls][crate::model::CertificateDescription::aia_issuing_certificate_urls].
    pub fn set_aia_issuing_certificate_urls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.aia_issuing_certificate_urls = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cert_fingerprint][crate::model::CertificateDescription::cert_fingerprint].
    pub fn set_cert_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::certificate_description::CertificateFingerprint>,
    {
        self.cert_fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cert_fingerprint][crate::model::CertificateDescription::cert_fingerprint].
    pub fn set_or_clear_cert_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::certificate_description::CertificateFingerprint>,
    {
        self.cert_fingerprint = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CertificateDescription {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.CertificateDescription"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CertificateDescription {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subject_description,
            __x509_description,
            __public_key,
            __subject_key_id,
            __authority_key_id,
            __crl_distribution_points,
            __aia_issuing_certificate_urls,
            __cert_fingerprint,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CertificateDescription")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subjectDescription" => Ok(__FieldTag::__subject_description),
                            "subject_description" => Ok(__FieldTag::__subject_description),
                            "x509Description" => Ok(__FieldTag::__x509_description),
                            "x509_description" => Ok(__FieldTag::__x509_description),
                            "publicKey" => Ok(__FieldTag::__public_key),
                            "public_key" => Ok(__FieldTag::__public_key),
                            "subjectKeyId" => Ok(__FieldTag::__subject_key_id),
                            "subject_key_id" => Ok(__FieldTag::__subject_key_id),
                            "authorityKeyId" => Ok(__FieldTag::__authority_key_id),
                            "authority_key_id" => Ok(__FieldTag::__authority_key_id),
                            "crlDistributionPoints" => Ok(__FieldTag::__crl_distribution_points),
                            "crl_distribution_points" => Ok(__FieldTag::__crl_distribution_points),
                            "aiaIssuingCertificateUrls" => {
                                Ok(__FieldTag::__aia_issuing_certificate_urls)
                            }
                            "aia_issuing_certificate_urls" => {
                                Ok(__FieldTag::__aia_issuing_certificate_urls)
                            }
                            "certFingerprint" => Ok(__FieldTag::__cert_fingerprint),
                            "cert_fingerprint" => Ok(__FieldTag::__cert_fingerprint),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CertificateDescription;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CertificateDescription")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subject_description => {
                            if !fields.insert(__FieldTag::__subject_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_description",
                                ));
                            }
                            result.subject_description = map.next_value::<std::option::Option<
                                crate::model::certificate_description::SubjectDescription,
                            >>()?;
                        }
                        __FieldTag::__x509_description => {
                            if !fields.insert(__FieldTag::__x509_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for x509_description",
                                ));
                            }
                            result.x509_description = map
                                .next_value::<std::option::Option<crate::model::X509Parameters>>(
                                )?;
                        }
                        __FieldTag::__public_key => {
                            if !fields.insert(__FieldTag::__public_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_key",
                                ));
                            }
                            result.public_key =
                                map.next_value::<std::option::Option<crate::model::PublicKey>>()?;
                        }
                        __FieldTag::__subject_key_id => {
                            if !fields.insert(__FieldTag::__subject_key_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_key_id",
                                ));
                            }
                            result.subject_key_id =
                                map.next_value::<std::option::Option<
                                    crate::model::certificate_description::KeyId,
                                >>()?;
                        }
                        __FieldTag::__authority_key_id => {
                            if !fields.insert(__FieldTag::__authority_key_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authority_key_id",
                                ));
                            }
                            result.authority_key_id =
                                map.next_value::<std::option::Option<
                                    crate::model::certificate_description::KeyId,
                                >>()?;
                        }
                        __FieldTag::__crl_distribution_points => {
                            if !fields.insert(__FieldTag::__crl_distribution_points) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crl_distribution_points",
                                ));
                            }
                            result.crl_distribution_points = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__aia_issuing_certificate_urls => {
                            if !fields.insert(__FieldTag::__aia_issuing_certificate_urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aia_issuing_certificate_urls",
                                ));
                            }
                            result.aia_issuing_certificate_urls = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cert_fingerprint => {
                            if !fields.insert(__FieldTag::__cert_fingerprint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cert_fingerprint",
                                ));
                            }
                            result.cert_fingerprint = map.next_value::<std::option::Option<
                                crate::model::certificate_description::CertificateFingerprint,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CertificateDescription {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.subject_description.is_some() {
            state.serialize_entry("subjectDescription", &self.subject_description)?;
        }
        if self.x509_description.is_some() {
            state.serialize_entry("x509Description", &self.x509_description)?;
        }
        if self.public_key.is_some() {
            state.serialize_entry("publicKey", &self.public_key)?;
        }
        if self.subject_key_id.is_some() {
            state.serialize_entry("subjectKeyId", &self.subject_key_id)?;
        }
        if self.authority_key_id.is_some() {
            state.serialize_entry("authorityKeyId", &self.authority_key_id)?;
        }
        if !self.crl_distribution_points.is_empty() {
            state.serialize_entry("crlDistributionPoints", &self.crl_distribution_points)?;
        }
        if !self.aia_issuing_certificate_urls.is_empty() {
            state.serialize_entry(
                "aiaIssuingCertificateUrls",
                &self.aia_issuing_certificate_urls,
            )?;
        }
        if self.cert_fingerprint.is_some() {
            state.serialize_entry("certFingerprint", &self.cert_fingerprint)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CertificateDescription].
pub mod certificate_description {
    #[allow(unused_imports)]
    use super::*;

    /// These values describe fields in an issued X.509 certificate such as the
    /// distinguished name, subject alternative names, serial number, and lifetime.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SubjectDescription {
        /// Contains distinguished name fields such as the common name, location and
        /// / organization.
        pub subject: std::option::Option<crate::model::Subject>,

        /// The subject alternative name fields.
        pub subject_alt_name: std::option::Option<crate::model::SubjectAltNames>,

        /// The serial number encoded in lowercase hexadecimal.
        pub hex_serial_number: std::string::String,

        /// For convenience, the actual lifetime of an issued certificate.
        pub lifetime: std::option::Option<wkt::Duration>,

        /// The time at which the certificate becomes valid.
        pub not_before_time: std::option::Option<wkt::Timestamp>,

        /// The time after which the certificate is expired.
        /// Per RFC 5280, the validity period for a certificate is the period of time
        /// from not_before_time through not_after_time, inclusive.
        /// Corresponds to 'not_before_time' + 'lifetime' - 1 second.
        pub not_after_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SubjectDescription {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [subject][crate::model::certificate_description::SubjectDescription::subject].
        pub fn set_subject<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Subject>,
        {
            self.subject = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [subject][crate::model::certificate_description::SubjectDescription::subject].
        pub fn set_or_clear_subject<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Subject>,
        {
            self.subject = v.map(|x| x.into());
            self
        }

        /// Sets the value of [subject_alt_name][crate::model::certificate_description::SubjectDescription::subject_alt_name].
        pub fn set_subject_alt_name<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::SubjectAltNames>,
        {
            self.subject_alt_name = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [subject_alt_name][crate::model::certificate_description::SubjectDescription::subject_alt_name].
        pub fn set_or_clear_subject_alt_name<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::SubjectAltNames>,
        {
            self.subject_alt_name = v.map(|x| x.into());
            self
        }

        /// Sets the value of [hex_serial_number][crate::model::certificate_description::SubjectDescription::hex_serial_number].
        pub fn set_hex_serial_number<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.hex_serial_number = v.into();
            self
        }

        /// Sets the value of [lifetime][crate::model::certificate_description::SubjectDescription::lifetime].
        pub fn set_lifetime<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.lifetime = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [lifetime][crate::model::certificate_description::SubjectDescription::lifetime].
        pub fn set_or_clear_lifetime<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.lifetime = v.map(|x| x.into());
            self
        }

        /// Sets the value of [not_before_time][crate::model::certificate_description::SubjectDescription::not_before_time].
        pub fn set_not_before_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.not_before_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [not_before_time][crate::model::certificate_description::SubjectDescription::not_before_time].
        pub fn set_or_clear_not_before_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.not_before_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [not_after_time][crate::model::certificate_description::SubjectDescription::not_after_time].
        pub fn set_not_after_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.not_after_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [not_after_time][crate::model::certificate_description::SubjectDescription::not_after_time].
        pub fn set_or_clear_not_after_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.not_after_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SubjectDescription {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.security.privateca.v1.CertificateDescription.SubjectDescription"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SubjectDescription {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __subject,
                __subject_alt_name,
                __hex_serial_number,
                __lifetime,
                __not_before_time,
                __not_after_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SubjectDescription")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "subject" => Ok(__FieldTag::__subject),
                                "subjectAltName" => Ok(__FieldTag::__subject_alt_name),
                                "subject_alt_name" => Ok(__FieldTag::__subject_alt_name),
                                "hexSerialNumber" => Ok(__FieldTag::__hex_serial_number),
                                "hex_serial_number" => Ok(__FieldTag::__hex_serial_number),
                                "lifetime" => Ok(__FieldTag::__lifetime),
                                "notBeforeTime" => Ok(__FieldTag::__not_before_time),
                                "not_before_time" => Ok(__FieldTag::__not_before_time),
                                "notAfterTime" => Ok(__FieldTag::__not_after_time),
                                "not_after_time" => Ok(__FieldTag::__not_after_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SubjectDescription;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SubjectDescription")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__subject => {
                                if !fields.insert(__FieldTag::__subject) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for subject",
                                    ));
                                }
                                result.subject =
                                    map.next_value::<std::option::Option<crate::model::Subject>>()?;
                            }
                            __FieldTag::__subject_alt_name => {
                                if !fields.insert(__FieldTag::__subject_alt_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for subject_alt_name",
                                    ));
                                }
                                result.subject_alt_name = map.next_value::<std::option::Option<crate::model::SubjectAltNames>>()?
                                    ;
                            }
                            __FieldTag::__hex_serial_number => {
                                if !fields.insert(__FieldTag::__hex_serial_number) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for hex_serial_number",
                                    ));
                                }
                                result.hex_serial_number = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__lifetime => {
                                if !fields.insert(__FieldTag::__lifetime) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for lifetime",
                                    ));
                                }
                                result.lifetime =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::__not_before_time => {
                                if !fields.insert(__FieldTag::__not_before_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for not_before_time",
                                    ));
                                }
                                result.not_before_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__not_after_time => {
                                if !fields.insert(__FieldTag::__not_after_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for not_after_time",
                                    ));
                                }
                                result.not_after_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SubjectDescription {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.subject.is_some() {
                state.serialize_entry("subject", &self.subject)?;
            }
            if self.subject_alt_name.is_some() {
                state.serialize_entry("subjectAltName", &self.subject_alt_name)?;
            }
            if !self.hex_serial_number.is_empty() {
                state.serialize_entry("hexSerialNumber", &self.hex_serial_number)?;
            }
            if self.lifetime.is_some() {
                state.serialize_entry("lifetime", &self.lifetime)?;
            }
            if self.not_before_time.is_some() {
                state.serialize_entry("notBeforeTime", &self.not_before_time)?;
            }
            if self.not_after_time.is_some() {
                state.serialize_entry("notAfterTime", &self.not_after_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A KeyId identifies a specific public key, usually by hashing the public
    /// key.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct KeyId {
        /// Optional. The value of this KeyId encoded in lowercase hexadecimal. This
        /// is most likely the 160 bit SHA-1 hash of the public key.
        pub key_id: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl KeyId {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key_id][crate::model::certificate_description::KeyId::key_id].
        pub fn set_key_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key_id = v.into();
            self
        }
    }

    impl wkt::message::Message for KeyId {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.security.privateca.v1.CertificateDescription.KeyId"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for KeyId {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __key_id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for KeyId")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "keyId" => Ok(__FieldTag::__key_id),
                                "key_id" => Ok(__FieldTag::__key_id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = KeyId;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct KeyId")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__key_id => {
                                if !fields.insert(__FieldTag::__key_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for key_id",
                                    ));
                                }
                                result.key_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for KeyId {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.key_id.is_empty() {
                state.serialize_entry("keyId", &self.key_id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A group of fingerprints for the x509 certificate.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CertificateFingerprint {
        /// The SHA 256 hash, encoded in hexadecimal, of the DER x509 certificate.
        pub sha256_hash: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CertificateFingerprint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sha256_hash][crate::model::certificate_description::CertificateFingerprint::sha256_hash].
        pub fn set_sha256_hash<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.sha256_hash = v.into();
            self
        }
    }

    impl wkt::message::Message for CertificateFingerprint {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.security.privateca.v1.CertificateDescription.CertificateFingerprint"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CertificateFingerprint {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __sha256_hash,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CertificateFingerprint")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sha256Hash" => Ok(__FieldTag::__sha256_hash),
                                "sha256_hash" => Ok(__FieldTag::__sha256_hash),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CertificateFingerprint;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CertificateFingerprint")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__sha256_hash => {
                                if !fields.insert(__FieldTag::__sha256_hash) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sha256_hash",
                                    ));
                                }
                                result.sha256_hash = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CertificateFingerprint {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.sha256_hash.is_empty() {
                state.serialize_entry("sha256Hash", &self.sha256_hash)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// An [ObjectId][google.cloud.security.privateca.v1.ObjectId] specifies an
/// object identifier (OID). These provide context and describe types in ASN.1
/// messages.
///
/// [google.cloud.security.privateca.v1.ObjectId]: crate::model::ObjectId
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ObjectId {
    /// Required. The parts of an OID path. The most significant parts of the path
    /// come first.
    pub object_id_path: std::vec::Vec<i32>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ObjectId {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [object_id_path][crate::model::ObjectId::object_id_path].
    pub fn set_object_id_path<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.object_id_path = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ObjectId {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.ObjectId"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ObjectId {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __object_id_path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ObjectId")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "objectIdPath" => Ok(__FieldTag::__object_id_path),
                            "object_id_path" => Ok(__FieldTag::__object_id_path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ObjectId;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ObjectId")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__object_id_path => {
                            if !fields.insert(__FieldTag::__object_id_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object_id_path",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.object_id_path =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ObjectId {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.object_id_path.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("objectIdPath", &__With(&self.object_id_path))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An [X509Extension][google.cloud.security.privateca.v1.X509Extension]
/// specifies an X.509 extension, which may be used in different parts of X.509
/// objects like certificates, CSRs, and CRLs.
///
/// [google.cloud.security.privateca.v1.X509Extension]: crate::model::X509Extension
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct X509Extension {
    /// Required. The OID for this X.509 extension.
    pub object_id: std::option::Option<crate::model::ObjectId>,

    /// Optional. Indicates whether or not this extension is critical (i.e., if the
    /// client does not know how to handle this extension, the client should
    /// consider this to be an error).
    pub critical: bool,

    /// Required. The value of this X.509 extension.
    pub value: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl X509Extension {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [object_id][crate::model::X509Extension::object_id].
    pub fn set_object_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ObjectId>,
    {
        self.object_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [object_id][crate::model::X509Extension::object_id].
    pub fn set_or_clear_object_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ObjectId>,
    {
        self.object_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [critical][crate::model::X509Extension::critical].
    pub fn set_critical<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.critical = v.into();
        self
    }

    /// Sets the value of [value][crate::model::X509Extension::value].
    pub fn set_value<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for X509Extension {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.X509Extension"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for X509Extension {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __object_id,
            __critical,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for X509Extension")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "objectId" => Ok(__FieldTag::__object_id),
                            "object_id" => Ok(__FieldTag::__object_id),
                            "critical" => Ok(__FieldTag::__critical),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = X509Extension;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct X509Extension")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__object_id => {
                            if !fields.insert(__FieldTag::__object_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for object_id",
                                ));
                            }
                            result.object_id =
                                map.next_value::<std::option::Option<crate::model::ObjectId>>()?;
                        }
                        __FieldTag::__critical => {
                            if !fields.insert(__FieldTag::__critical) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for critical",
                                ));
                            }
                            result.critical = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for X509Extension {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.object_id.is_some() {
            state.serialize_entry("objectId", &self.object_id)?;
        }
        if !wkt::internal::is_default(&self.critical) {
            state.serialize_entry("critical", &self.critical)?;
        }
        if !self.value.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("value", &__With(&self.value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A [KeyUsage][google.cloud.security.privateca.v1.KeyUsage] describes key usage
/// values that may appear in an X.509 certificate.
///
/// [google.cloud.security.privateca.v1.KeyUsage]: crate::model::KeyUsage
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct KeyUsage {
    /// Describes high-level ways in which a key may be used.
    pub base_key_usage: std::option::Option<crate::model::key_usage::KeyUsageOptions>,

    /// Detailed scenarios in which a key may be used.
    pub extended_key_usage: std::option::Option<crate::model::key_usage::ExtendedKeyUsageOptions>,

    /// Used to describe extended key usages that are not listed in the
    /// [KeyUsage.ExtendedKeyUsageOptions][google.cloud.security.privateca.v1.KeyUsage.ExtendedKeyUsageOptions]
    /// message.
    ///
    /// [google.cloud.security.privateca.v1.KeyUsage.ExtendedKeyUsageOptions]: crate::model::key_usage::ExtendedKeyUsageOptions
    pub unknown_extended_key_usages: std::vec::Vec<crate::model::ObjectId>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KeyUsage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [base_key_usage][crate::model::KeyUsage::base_key_usage].
    pub fn set_base_key_usage<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::key_usage::KeyUsageOptions>,
    {
        self.base_key_usage = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [base_key_usage][crate::model::KeyUsage::base_key_usage].
    pub fn set_or_clear_base_key_usage<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::key_usage::KeyUsageOptions>,
    {
        self.base_key_usage = v.map(|x| x.into());
        self
    }

    /// Sets the value of [extended_key_usage][crate::model::KeyUsage::extended_key_usage].
    pub fn set_extended_key_usage<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::key_usage::ExtendedKeyUsageOptions>,
    {
        self.extended_key_usage = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [extended_key_usage][crate::model::KeyUsage::extended_key_usage].
    pub fn set_or_clear_extended_key_usage<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::key_usage::ExtendedKeyUsageOptions>,
    {
        self.extended_key_usage = v.map(|x| x.into());
        self
    }

    /// Sets the value of [unknown_extended_key_usages][crate::model::KeyUsage::unknown_extended_key_usages].
    pub fn set_unknown_extended_key_usages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ObjectId>,
    {
        use std::iter::Iterator;
        self.unknown_extended_key_usages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for KeyUsage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.KeyUsage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for KeyUsage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __base_key_usage,
            __extended_key_usage,
            __unknown_extended_key_usages,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KeyUsage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "baseKeyUsage" => Ok(__FieldTag::__base_key_usage),
                            "base_key_usage" => Ok(__FieldTag::__base_key_usage),
                            "extendedKeyUsage" => Ok(__FieldTag::__extended_key_usage),
                            "extended_key_usage" => Ok(__FieldTag::__extended_key_usage),
                            "unknownExtendedKeyUsages" => {
                                Ok(__FieldTag::__unknown_extended_key_usages)
                            }
                            "unknown_extended_key_usages" => {
                                Ok(__FieldTag::__unknown_extended_key_usages)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = KeyUsage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KeyUsage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__base_key_usage => {
                            if !fields.insert(__FieldTag::__base_key_usage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_key_usage",
                                ));
                            }
                            result.base_key_usage = map.next_value::<std::option::Option<crate::model::key_usage::KeyUsageOptions>>()?
                                ;
                        }
                        __FieldTag::__extended_key_usage => {
                            if !fields.insert(__FieldTag::__extended_key_usage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for extended_key_usage",
                                ));
                            }
                            result.extended_key_usage = map.next_value::<std::option::Option<
                                crate::model::key_usage::ExtendedKeyUsageOptions,
                            >>()?;
                        }
                        __FieldTag::__unknown_extended_key_usages => {
                            if !fields.insert(__FieldTag::__unknown_extended_key_usages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unknown_extended_key_usages",
                                ));
                            }
                            result.unknown_extended_key_usages = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ObjectId>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for KeyUsage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.base_key_usage.is_some() {
            state.serialize_entry("baseKeyUsage", &self.base_key_usage)?;
        }
        if self.extended_key_usage.is_some() {
            state.serialize_entry("extendedKeyUsage", &self.extended_key_usage)?;
        }
        if !self.unknown_extended_key_usages.is_empty() {
            state.serialize_entry(
                "unknownExtendedKeyUsages",
                &self.unknown_extended_key_usages,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [KeyUsage].
pub mod key_usage {
    #[allow(unused_imports)]
    use super::*;

    /// [KeyUsage.KeyUsageOptions][google.cloud.security.privateca.v1.KeyUsage.KeyUsageOptions]
    /// corresponds to the key usage values described in
    /// <https://tools.ietf.org/html/rfc5280#section-4.2.1.3>.
    ///
    /// [google.cloud.security.privateca.v1.KeyUsage.KeyUsageOptions]: crate::model::key_usage::KeyUsageOptions
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct KeyUsageOptions {
        /// The key may be used for digital signatures.
        pub digital_signature: bool,

        /// The key may be used for cryptographic commitments. Note that this may
        /// also be referred to as "non-repudiation".
        pub content_commitment: bool,

        /// The key may be used to encipher other keys.
        pub key_encipherment: bool,

        /// The key may be used to encipher data.
        pub data_encipherment: bool,

        /// The key may be used in a key agreement protocol.
        pub key_agreement: bool,

        /// The key may be used to sign certificates.
        pub cert_sign: bool,

        /// The key may be used sign certificate revocation lists.
        pub crl_sign: bool,

        /// The key may be used to encipher only.
        pub encipher_only: bool,

        /// The key may be used to decipher only.
        pub decipher_only: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl KeyUsageOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [digital_signature][crate::model::key_usage::KeyUsageOptions::digital_signature].
        pub fn set_digital_signature<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.digital_signature = v.into();
            self
        }

        /// Sets the value of [content_commitment][crate::model::key_usage::KeyUsageOptions::content_commitment].
        pub fn set_content_commitment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.content_commitment = v.into();
            self
        }

        /// Sets the value of [key_encipherment][crate::model::key_usage::KeyUsageOptions::key_encipherment].
        pub fn set_key_encipherment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.key_encipherment = v.into();
            self
        }

        /// Sets the value of [data_encipherment][crate::model::key_usage::KeyUsageOptions::data_encipherment].
        pub fn set_data_encipherment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.data_encipherment = v.into();
            self
        }

        /// Sets the value of [key_agreement][crate::model::key_usage::KeyUsageOptions::key_agreement].
        pub fn set_key_agreement<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.key_agreement = v.into();
            self
        }

        /// Sets the value of [cert_sign][crate::model::key_usage::KeyUsageOptions::cert_sign].
        pub fn set_cert_sign<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.cert_sign = v.into();
            self
        }

        /// Sets the value of [crl_sign][crate::model::key_usage::KeyUsageOptions::crl_sign].
        pub fn set_crl_sign<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.crl_sign = v.into();
            self
        }

        /// Sets the value of [encipher_only][crate::model::key_usage::KeyUsageOptions::encipher_only].
        pub fn set_encipher_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.encipher_only = v.into();
            self
        }

        /// Sets the value of [decipher_only][crate::model::key_usage::KeyUsageOptions::decipher_only].
        pub fn set_decipher_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.decipher_only = v.into();
            self
        }
    }

    impl wkt::message::Message for KeyUsageOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.security.privateca.v1.KeyUsage.KeyUsageOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for KeyUsageOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __digital_signature,
                __content_commitment,
                __key_encipherment,
                __data_encipherment,
                __key_agreement,
                __cert_sign,
                __crl_sign,
                __encipher_only,
                __decipher_only,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for KeyUsageOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "digitalSignature" => Ok(__FieldTag::__digital_signature),
                                "digital_signature" => Ok(__FieldTag::__digital_signature),
                                "contentCommitment" => Ok(__FieldTag::__content_commitment),
                                "content_commitment" => Ok(__FieldTag::__content_commitment),
                                "keyEncipherment" => Ok(__FieldTag::__key_encipherment),
                                "key_encipherment" => Ok(__FieldTag::__key_encipherment),
                                "dataEncipherment" => Ok(__FieldTag::__data_encipherment),
                                "data_encipherment" => Ok(__FieldTag::__data_encipherment),
                                "keyAgreement" => Ok(__FieldTag::__key_agreement),
                                "key_agreement" => Ok(__FieldTag::__key_agreement),
                                "certSign" => Ok(__FieldTag::__cert_sign),
                                "cert_sign" => Ok(__FieldTag::__cert_sign),
                                "crlSign" => Ok(__FieldTag::__crl_sign),
                                "crl_sign" => Ok(__FieldTag::__crl_sign),
                                "encipherOnly" => Ok(__FieldTag::__encipher_only),
                                "encipher_only" => Ok(__FieldTag::__encipher_only),
                                "decipherOnly" => Ok(__FieldTag::__decipher_only),
                                "decipher_only" => Ok(__FieldTag::__decipher_only),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = KeyUsageOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct KeyUsageOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__digital_signature => {
                                if !fields.insert(__FieldTag::__digital_signature) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for digital_signature",
                                    ));
                                }
                                result.digital_signature = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__content_commitment => {
                                if !fields.insert(__FieldTag::__content_commitment) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for content_commitment",
                                    ));
                                }
                                result.content_commitment = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__key_encipherment => {
                                if !fields.insert(__FieldTag::__key_encipherment) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for key_encipherment",
                                    ));
                                }
                                result.key_encipherment = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__data_encipherment => {
                                if !fields.insert(__FieldTag::__data_encipherment) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for data_encipherment",
                                    ));
                                }
                                result.data_encipherment = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__key_agreement => {
                                if !fields.insert(__FieldTag::__key_agreement) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for key_agreement",
                                    ));
                                }
                                result.key_agreement = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__cert_sign => {
                                if !fields.insert(__FieldTag::__cert_sign) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cert_sign",
                                    ));
                                }
                                result.cert_sign = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__crl_sign => {
                                if !fields.insert(__FieldTag::__crl_sign) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for crl_sign",
                                    ));
                                }
                                result.crl_sign = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__encipher_only => {
                                if !fields.insert(__FieldTag::__encipher_only) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for encipher_only",
                                    ));
                                }
                                result.encipher_only = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__decipher_only => {
                                if !fields.insert(__FieldTag::__decipher_only) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for decipher_only",
                                    ));
                                }
                                result.decipher_only = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for KeyUsageOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.digital_signature) {
                state.serialize_entry("digitalSignature", &self.digital_signature)?;
            }
            if !wkt::internal::is_default(&self.content_commitment) {
                state.serialize_entry("contentCommitment", &self.content_commitment)?;
            }
            if !wkt::internal::is_default(&self.key_encipherment) {
                state.serialize_entry("keyEncipherment", &self.key_encipherment)?;
            }
            if !wkt::internal::is_default(&self.data_encipherment) {
                state.serialize_entry("dataEncipherment", &self.data_encipherment)?;
            }
            if !wkt::internal::is_default(&self.key_agreement) {
                state.serialize_entry("keyAgreement", &self.key_agreement)?;
            }
            if !wkt::internal::is_default(&self.cert_sign) {
                state.serialize_entry("certSign", &self.cert_sign)?;
            }
            if !wkt::internal::is_default(&self.crl_sign) {
                state.serialize_entry("crlSign", &self.crl_sign)?;
            }
            if !wkt::internal::is_default(&self.encipher_only) {
                state.serialize_entry("encipherOnly", &self.encipher_only)?;
            }
            if !wkt::internal::is_default(&self.decipher_only) {
                state.serialize_entry("decipherOnly", &self.decipher_only)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// [KeyUsage.ExtendedKeyUsageOptions][google.cloud.security.privateca.v1.KeyUsage.ExtendedKeyUsageOptions]
    /// has fields that correspond to certain common OIDs that could be specified
    /// as an extended key usage value.
    ///
    /// [google.cloud.security.privateca.v1.KeyUsage.ExtendedKeyUsageOptions]: crate::model::key_usage::ExtendedKeyUsageOptions
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ExtendedKeyUsageOptions {
        /// Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as "TLS WWW
        /// server authentication", though regularly used for non-WWW TLS.
        pub server_auth: bool,

        /// Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as "TLS WWW
        /// client authentication", though regularly used for non-WWW TLS.
        pub client_auth: bool,

        /// Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as "Signing of
        /// downloadable executable code client authentication".
        pub code_signing: bool,

        /// Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as "Email
        /// protection".
        pub email_protection: bool,

        /// Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as "Binding
        /// the hash of an object to a time".
        pub time_stamping: bool,

        /// Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as "Signing
        /// OCSP responses".
        pub ocsp_signing: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ExtendedKeyUsageOptions {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [server_auth][crate::model::key_usage::ExtendedKeyUsageOptions::server_auth].
        pub fn set_server_auth<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.server_auth = v.into();
            self
        }

        /// Sets the value of [client_auth][crate::model::key_usage::ExtendedKeyUsageOptions::client_auth].
        pub fn set_client_auth<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.client_auth = v.into();
            self
        }

        /// Sets the value of [code_signing][crate::model::key_usage::ExtendedKeyUsageOptions::code_signing].
        pub fn set_code_signing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.code_signing = v.into();
            self
        }

        /// Sets the value of [email_protection][crate::model::key_usage::ExtendedKeyUsageOptions::email_protection].
        pub fn set_email_protection<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.email_protection = v.into();
            self
        }

        /// Sets the value of [time_stamping][crate::model::key_usage::ExtendedKeyUsageOptions::time_stamping].
        pub fn set_time_stamping<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.time_stamping = v.into();
            self
        }

        /// Sets the value of [ocsp_signing][crate::model::key_usage::ExtendedKeyUsageOptions::ocsp_signing].
        pub fn set_ocsp_signing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.ocsp_signing = v.into();
            self
        }
    }

    impl wkt::message::Message for ExtendedKeyUsageOptions {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.security.privateca.v1.KeyUsage.ExtendedKeyUsageOptions"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ExtendedKeyUsageOptions {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __server_auth,
                __client_auth,
                __code_signing,
                __email_protection,
                __time_stamping,
                __ocsp_signing,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ExtendedKeyUsageOptions")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "serverAuth" => Ok(__FieldTag::__server_auth),
                                "server_auth" => Ok(__FieldTag::__server_auth),
                                "clientAuth" => Ok(__FieldTag::__client_auth),
                                "client_auth" => Ok(__FieldTag::__client_auth),
                                "codeSigning" => Ok(__FieldTag::__code_signing),
                                "code_signing" => Ok(__FieldTag::__code_signing),
                                "emailProtection" => Ok(__FieldTag::__email_protection),
                                "email_protection" => Ok(__FieldTag::__email_protection),
                                "timeStamping" => Ok(__FieldTag::__time_stamping),
                                "time_stamping" => Ok(__FieldTag::__time_stamping),
                                "ocspSigning" => Ok(__FieldTag::__ocsp_signing),
                                "ocsp_signing" => Ok(__FieldTag::__ocsp_signing),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ExtendedKeyUsageOptions;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ExtendedKeyUsageOptions")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__server_auth => {
                                if !fields.insert(__FieldTag::__server_auth) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for server_auth",
                                    ));
                                }
                                result.server_auth = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__client_auth => {
                                if !fields.insert(__FieldTag::__client_auth) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for client_auth",
                                    ));
                                }
                                result.client_auth = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__code_signing => {
                                if !fields.insert(__FieldTag::__code_signing) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for code_signing",
                                    ));
                                }
                                result.code_signing = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__email_protection => {
                                if !fields.insert(__FieldTag::__email_protection) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for email_protection",
                                    ));
                                }
                                result.email_protection = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__time_stamping => {
                                if !fields.insert(__FieldTag::__time_stamping) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for time_stamping",
                                    ));
                                }
                                result.time_stamping = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__ocsp_signing => {
                                if !fields.insert(__FieldTag::__ocsp_signing) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ocsp_signing",
                                    ));
                                }
                                result.ocsp_signing = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ExtendedKeyUsageOptions {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.server_auth) {
                state.serialize_entry("serverAuth", &self.server_auth)?;
            }
            if !wkt::internal::is_default(&self.client_auth) {
                state.serialize_entry("clientAuth", &self.client_auth)?;
            }
            if !wkt::internal::is_default(&self.code_signing) {
                state.serialize_entry("codeSigning", &self.code_signing)?;
            }
            if !wkt::internal::is_default(&self.email_protection) {
                state.serialize_entry("emailProtection", &self.email_protection)?;
            }
            if !wkt::internal::is_default(&self.time_stamping) {
                state.serialize_entry("timeStamping", &self.time_stamping)?;
            }
            if !wkt::internal::is_default(&self.ocsp_signing) {
                state.serialize_entry("ocspSigning", &self.ocsp_signing)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// [Subject][google.cloud.security.privateca.v1.Subject] describes parts of a
/// distinguished name that, in turn, describes the subject of the certificate.
///
/// [google.cloud.security.privateca.v1.Subject]: crate::model::Subject
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Subject {
    /// The "common name" of the subject.
    pub common_name: std::string::String,

    /// The country code of the subject.
    pub country_code: std::string::String,

    /// The organization of the subject.
    pub organization: std::string::String,

    /// The organizational_unit of the subject.
    pub organizational_unit: std::string::String,

    /// The locality or city of the subject.
    pub locality: std::string::String,

    /// The province, territory, or regional state of the subject.
    pub province: std::string::String,

    /// The street address of the subject.
    pub street_address: std::string::String,

    /// The postal code of the subject.
    pub postal_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Subject {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [common_name][crate::model::Subject::common_name].
    pub fn set_common_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.common_name = v.into();
        self
    }

    /// Sets the value of [country_code][crate::model::Subject::country_code].
    pub fn set_country_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.country_code = v.into();
        self
    }

    /// Sets the value of [organization][crate::model::Subject::organization].
    pub fn set_organization<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.organization = v.into();
        self
    }

    /// Sets the value of [organizational_unit][crate::model::Subject::organizational_unit].
    pub fn set_organizational_unit<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.organizational_unit = v.into();
        self
    }

    /// Sets the value of [locality][crate::model::Subject::locality].
    pub fn set_locality<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.locality = v.into();
        self
    }

    /// Sets the value of [province][crate::model::Subject::province].
    pub fn set_province<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.province = v.into();
        self
    }

    /// Sets the value of [street_address][crate::model::Subject::street_address].
    pub fn set_street_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.street_address = v.into();
        self
    }

    /// Sets the value of [postal_code][crate::model::Subject::postal_code].
    pub fn set_postal_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.postal_code = v.into();
        self
    }
}

impl wkt::message::Message for Subject {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.Subject"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Subject {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __common_name,
            __country_code,
            __organization,
            __organizational_unit,
            __locality,
            __province,
            __street_address,
            __postal_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Subject")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "commonName" => Ok(__FieldTag::__common_name),
                            "common_name" => Ok(__FieldTag::__common_name),
                            "countryCode" => Ok(__FieldTag::__country_code),
                            "country_code" => Ok(__FieldTag::__country_code),
                            "organization" => Ok(__FieldTag::__organization),
                            "organizationalUnit" => Ok(__FieldTag::__organizational_unit),
                            "organizational_unit" => Ok(__FieldTag::__organizational_unit),
                            "locality" => Ok(__FieldTag::__locality),
                            "province" => Ok(__FieldTag::__province),
                            "streetAddress" => Ok(__FieldTag::__street_address),
                            "street_address" => Ok(__FieldTag::__street_address),
                            "postalCode" => Ok(__FieldTag::__postal_code),
                            "postal_code" => Ok(__FieldTag::__postal_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Subject;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Subject")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__common_name => {
                            if !fields.insert(__FieldTag::__common_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for common_name",
                                ));
                            }
                            result.common_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__country_code => {
                            if !fields.insert(__FieldTag::__country_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for country_code",
                                ));
                            }
                            result.country_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__organization => {
                            if !fields.insert(__FieldTag::__organization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for organization",
                                ));
                            }
                            result.organization = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__organizational_unit => {
                            if !fields.insert(__FieldTag::__organizational_unit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for organizational_unit",
                                ));
                            }
                            result.organizational_unit = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__locality => {
                            if !fields.insert(__FieldTag::__locality) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locality",
                                ));
                            }
                            result.locality = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__province => {
                            if !fields.insert(__FieldTag::__province) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for province",
                                ));
                            }
                            result.province = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__street_address => {
                            if !fields.insert(__FieldTag::__street_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for street_address",
                                ));
                            }
                            result.street_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__postal_code => {
                            if !fields.insert(__FieldTag::__postal_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for postal_code",
                                ));
                            }
                            result.postal_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Subject {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.common_name.is_empty() {
            state.serialize_entry("commonName", &self.common_name)?;
        }
        if !self.country_code.is_empty() {
            state.serialize_entry("countryCode", &self.country_code)?;
        }
        if !self.organization.is_empty() {
            state.serialize_entry("organization", &self.organization)?;
        }
        if !self.organizational_unit.is_empty() {
            state.serialize_entry("organizationalUnit", &self.organizational_unit)?;
        }
        if !self.locality.is_empty() {
            state.serialize_entry("locality", &self.locality)?;
        }
        if !self.province.is_empty() {
            state.serialize_entry("province", &self.province)?;
        }
        if !self.street_address.is_empty() {
            state.serialize_entry("streetAddress", &self.street_address)?;
        }
        if !self.postal_code.is_empty() {
            state.serialize_entry("postalCode", &self.postal_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames]
/// corresponds to a more modern way of listing what the asserted identity is in
/// a certificate (i.e., compared to the "common name" in the distinguished
/// name).
///
/// [google.cloud.security.privateca.v1.SubjectAltNames]: crate::model::SubjectAltNames
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SubjectAltNames {
    /// Contains only valid, fully-qualified host names.
    pub dns_names: std::vec::Vec<std::string::String>,

    /// Contains only valid RFC 3986 URIs.
    pub uris: std::vec::Vec<std::string::String>,

    /// Contains only valid RFC 2822 E-mail addresses.
    pub email_addresses: std::vec::Vec<std::string::String>,

    /// Contains only valid 32-bit IPv4 addresses or RFC 4291 IPv6 addresses.
    pub ip_addresses: std::vec::Vec<std::string::String>,

    /// Contains additional subject alternative name values.
    /// For each custom_san, the `value` field must contain an ASN.1 encoded
    /// UTF8String.
    pub custom_sans: std::vec::Vec<crate::model::X509Extension>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubjectAltNames {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dns_names][crate::model::SubjectAltNames::dns_names].
    pub fn set_dns_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dns_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [uris][crate::model::SubjectAltNames::uris].
    pub fn set_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [email_addresses][crate::model::SubjectAltNames::email_addresses].
    pub fn set_email_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.email_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ip_addresses][crate::model::SubjectAltNames::ip_addresses].
    pub fn set_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [custom_sans][crate::model::SubjectAltNames::custom_sans].
    pub fn set_custom_sans<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::X509Extension>,
    {
        use std::iter::Iterator;
        self.custom_sans = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SubjectAltNames {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.SubjectAltNames"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SubjectAltNames {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dns_names,
            __uris,
            __email_addresses,
            __ip_addresses,
            __custom_sans,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SubjectAltNames")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dnsNames" => Ok(__FieldTag::__dns_names),
                            "dns_names" => Ok(__FieldTag::__dns_names),
                            "uris" => Ok(__FieldTag::__uris),
                            "emailAddresses" => Ok(__FieldTag::__email_addresses),
                            "email_addresses" => Ok(__FieldTag::__email_addresses),
                            "ipAddresses" => Ok(__FieldTag::__ip_addresses),
                            "ip_addresses" => Ok(__FieldTag::__ip_addresses),
                            "customSans" => Ok(__FieldTag::__custom_sans),
                            "custom_sans" => Ok(__FieldTag::__custom_sans),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SubjectAltNames;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SubjectAltNames")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dns_names => {
                            if !fields.insert(__FieldTag::__dns_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dns_names",
                                ));
                            }
                            result.dns_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__uris => {
                            if !fields.insert(__FieldTag::__uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uris",
                                ));
                            }
                            result.uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__email_addresses => {
                            if !fields.insert(__FieldTag::__email_addresses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email_addresses",
                                ));
                            }
                            result.email_addresses = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__ip_addresses => {
                            if !fields.insert(__FieldTag::__ip_addresses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_addresses",
                                ));
                            }
                            result.ip_addresses = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__custom_sans => {
                            if !fields.insert(__FieldTag::__custom_sans) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_sans",
                                ));
                            }
                            result.custom_sans = map.next_value::<std::option::Option<std::vec::Vec<crate::model::X509Extension>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SubjectAltNames {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dns_names.is_empty() {
            state.serialize_entry("dnsNames", &self.dns_names)?;
        }
        if !self.uris.is_empty() {
            state.serialize_entry("uris", &self.uris)?;
        }
        if !self.email_addresses.is_empty() {
            state.serialize_entry("emailAddresses", &self.email_addresses)?;
        }
        if !self.ip_addresses.is_empty() {
            state.serialize_entry("ipAddresses", &self.ip_addresses)?;
        }
        if !self.custom_sans.is_empty() {
            state.serialize_entry("customSans", &self.custom_sans)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes constraints on a
/// [Certificate][google.cloud.security.privateca.v1.Certificate]'s
/// [Subject][google.cloud.security.privateca.v1.Subject] and
/// [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames].
///
/// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
/// [google.cloud.security.privateca.v1.Subject]: crate::model::Subject
/// [google.cloud.security.privateca.v1.SubjectAltNames]: crate::model::SubjectAltNames
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CertificateIdentityConstraints {
    /// Optional. A CEL expression that may be used to validate the resolved X.509
    /// Subject and/or Subject Alternative Name before a certificate is signed. To
    /// see the full allowed syntax and some examples, see
    /// <https://cloud.google.com/certificate-authority-service/docs/using-cel>
    pub cel_expression: std::option::Option<gtype::model::Expr>,

    /// Required. If this is true, the
    /// [Subject][google.cloud.security.privateca.v1.Subject] field may be copied
    /// from a certificate request into the signed certificate. Otherwise, the
    /// requested [Subject][google.cloud.security.privateca.v1.Subject] will be
    /// discarded.
    ///
    /// [google.cloud.security.privateca.v1.Subject]: crate::model::Subject
    pub allow_subject_passthrough: std::option::Option<bool>,

    /// Required. If this is true, the
    /// [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames]
    /// extension may be copied from a certificate request into the signed
    /// certificate. Otherwise, the requested
    /// [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames] will
    /// be discarded.
    ///
    /// [google.cloud.security.privateca.v1.SubjectAltNames]: crate::model::SubjectAltNames
    pub allow_subject_alt_names_passthrough: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CertificateIdentityConstraints {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cel_expression][crate::model::CertificateIdentityConstraints::cel_expression].
    pub fn set_cel_expression<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Expr>,
    {
        self.cel_expression = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cel_expression][crate::model::CertificateIdentityConstraints::cel_expression].
    pub fn set_or_clear_cel_expression<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Expr>,
    {
        self.cel_expression = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_subject_passthrough][crate::model::CertificateIdentityConstraints::allow_subject_passthrough].
    pub fn set_allow_subject_passthrough<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.allow_subject_passthrough = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [allow_subject_passthrough][crate::model::CertificateIdentityConstraints::allow_subject_passthrough].
    pub fn set_or_clear_allow_subject_passthrough<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.allow_subject_passthrough = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_subject_alt_names_passthrough][crate::model::CertificateIdentityConstraints::allow_subject_alt_names_passthrough].
    pub fn set_allow_subject_alt_names_passthrough<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.allow_subject_alt_names_passthrough = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [allow_subject_alt_names_passthrough][crate::model::CertificateIdentityConstraints::allow_subject_alt_names_passthrough].
    pub fn set_or_clear_allow_subject_alt_names_passthrough<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.allow_subject_alt_names_passthrough = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CertificateIdentityConstraints {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.CertificateIdentityConstraints"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CertificateIdentityConstraints {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cel_expression,
            __allow_subject_passthrough,
            __allow_subject_alt_names_passthrough,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CertificateIdentityConstraints")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "celExpression" => Ok(__FieldTag::__cel_expression),
                            "cel_expression" => Ok(__FieldTag::__cel_expression),
                            "allowSubjectPassthrough" => {
                                Ok(__FieldTag::__allow_subject_passthrough)
                            }
                            "allow_subject_passthrough" => {
                                Ok(__FieldTag::__allow_subject_passthrough)
                            }
                            "allowSubjectAltNamesPassthrough" => {
                                Ok(__FieldTag::__allow_subject_alt_names_passthrough)
                            }
                            "allow_subject_alt_names_passthrough" => {
                                Ok(__FieldTag::__allow_subject_alt_names_passthrough)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CertificateIdentityConstraints;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CertificateIdentityConstraints")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cel_expression => {
                            if !fields.insert(__FieldTag::__cel_expression) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cel_expression",
                                ));
                            }
                            result.cel_expression =
                                map.next_value::<std::option::Option<gtype::model::Expr>>()?;
                        }
                        __FieldTag::__allow_subject_passthrough => {
                            if !fields.insert(__FieldTag::__allow_subject_passthrough) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_subject_passthrough",
                                ));
                            }
                            result.allow_subject_passthrough =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__allow_subject_alt_names_passthrough => {
                            if !fields.insert(__FieldTag::__allow_subject_alt_names_passthrough) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_subject_alt_names_passthrough",
                                ));
                            }
                            result.allow_subject_alt_names_passthrough =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CertificateIdentityConstraints {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.cel_expression.is_some() {
            state.serialize_entry("celExpression", &self.cel_expression)?;
        }
        if self.allow_subject_passthrough.is_some() {
            state.serialize_entry("allowSubjectPassthrough", &self.allow_subject_passthrough)?;
        }
        if self.allow_subject_alt_names_passthrough.is_some() {
            state.serialize_entry(
                "allowSubjectAltNamesPassthrough",
                &self.allow_subject_alt_names_passthrough,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes a set of X.509 extensions that may be part of some certificate
/// issuance controls.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CertificateExtensionConstraints {
    /// Optional. A set of named X.509 extensions. Will be combined with
    /// [additional_extensions][google.cloud.security.privateca.v1.CertificateExtensionConstraints.additional_extensions]
    /// to determine the full set of X.509 extensions.
    ///
    /// [google.cloud.security.privateca.v1.CertificateExtensionConstraints.additional_extensions]: crate::model::CertificateExtensionConstraints::additional_extensions
    pub known_extensions:
        std::vec::Vec<crate::model::certificate_extension_constraints::KnownCertificateExtension>,

    /// Optional. A set of [ObjectIds][google.cloud.security.privateca.v1.ObjectId]
    /// identifying custom X.509 extensions. Will be combined with
    /// [known_extensions][google.cloud.security.privateca.v1.CertificateExtensionConstraints.known_extensions]
    /// to determine the full set of X.509 extensions.
    ///
    /// [google.cloud.security.privateca.v1.CertificateExtensionConstraints.known_extensions]: crate::model::CertificateExtensionConstraints::known_extensions
    /// [google.cloud.security.privateca.v1.ObjectId]: crate::model::ObjectId
    pub additional_extensions: std::vec::Vec<crate::model::ObjectId>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CertificateExtensionConstraints {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [known_extensions][crate::model::CertificateExtensionConstraints::known_extensions].
    pub fn set_known_extensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
                crate::model::certificate_extension_constraints::KnownCertificateExtension,
            >,
    {
        use std::iter::Iterator;
        self.known_extensions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [additional_extensions][crate::model::CertificateExtensionConstraints::additional_extensions].
    pub fn set_additional_extensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ObjectId>,
    {
        use std::iter::Iterator;
        self.additional_extensions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CertificateExtensionConstraints {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.CertificateExtensionConstraints"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CertificateExtensionConstraints {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __known_extensions,
            __additional_extensions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CertificateExtensionConstraints")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "knownExtensions" => Ok(__FieldTag::__known_extensions),
                            "known_extensions" => Ok(__FieldTag::__known_extensions),
                            "additionalExtensions" => Ok(__FieldTag::__additional_extensions),
                            "additional_extensions" => Ok(__FieldTag::__additional_extensions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CertificateExtensionConstraints;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CertificateExtensionConstraints")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__known_extensions => {
                            if !fields.insert(__FieldTag::__known_extensions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for known_extensions",
                                ));
                            }
                            result.known_extensions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::certificate_extension_constraints::KnownCertificateExtension>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__additional_extensions => {
                            if !fields.insert(__FieldTag::__additional_extensions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_extensions",
                                ));
                            }
                            result.additional_extensions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ObjectId>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CertificateExtensionConstraints {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.known_extensions.is_empty() {
            state.serialize_entry("knownExtensions", &self.known_extensions)?;
        }
        if !self.additional_extensions.is_empty() {
            state.serialize_entry("additionalExtensions", &self.additional_extensions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CertificateExtensionConstraints].
pub mod certificate_extension_constraints {
    #[allow(unused_imports)]
    use super::*;

    /// Describes well-known X.509 extensions that can appear in a
    /// [Certificate][google.cloud.security.privateca.v1.Certificate], not
    /// including the
    /// [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames]
    /// extension.
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    /// [google.cloud.security.privateca.v1.SubjectAltNames]: crate::model::SubjectAltNames
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum KnownCertificateExtension {
        /// Not specified.
        Unspecified,
        /// Refers to a certificate's Key Usage extension, as described in [RFC 5280
        /// section 4.2.1.3](https://tools.ietf.org/html/rfc5280#section-4.2.1.3).
        /// This corresponds to the
        /// [KeyUsage.base_key_usage][google.cloud.security.privateca.v1.KeyUsage.base_key_usage]
        /// field.
        ///
        /// [google.cloud.security.privateca.v1.KeyUsage.base_key_usage]: crate::model::KeyUsage::base_key_usage
        BaseKeyUsage,
        /// Refers to a certificate's Extended Key Usage extension, as described in
        /// [RFC 5280
        /// section 4.2.1.12](https://tools.ietf.org/html/rfc5280#section-4.2.1.12).
        /// This corresponds to the
        /// [KeyUsage.extended_key_usage][google.cloud.security.privateca.v1.KeyUsage.extended_key_usage]
        /// message.
        ///
        /// [google.cloud.security.privateca.v1.KeyUsage.extended_key_usage]: crate::model::KeyUsage::extended_key_usage
        ExtendedKeyUsage,
        /// Refers to a certificate's Basic Constraints extension, as described in
        /// [RFC 5280
        /// section 4.2.1.9](https://tools.ietf.org/html/rfc5280#section-4.2.1.9).
        /// This corresponds to the
        /// [X509Parameters.ca_options][google.cloud.security.privateca.v1.X509Parameters.ca_options]
        /// field.
        ///
        /// [google.cloud.security.privateca.v1.X509Parameters.ca_options]: crate::model::X509Parameters::ca_options
        CaOptions,
        /// Refers to a certificate's Policy object identifiers, as described in
        /// [RFC 5280
        /// section 4.2.1.4](https://tools.ietf.org/html/rfc5280#section-4.2.1.4).
        /// This corresponds to the
        /// [X509Parameters.policy_ids][google.cloud.security.privateca.v1.X509Parameters.policy_ids]
        /// field.
        ///
        /// [google.cloud.security.privateca.v1.X509Parameters.policy_ids]: crate::model::X509Parameters::policy_ids
        PolicyIds,
        /// Refers to OCSP servers in a certificate's Authority Information Access
        /// extension, as described in
        /// [RFC 5280
        /// section 4.2.2.1](https://tools.ietf.org/html/rfc5280#section-4.2.2.1),
        /// This corresponds to the
        /// [X509Parameters.aia_ocsp_servers][google.cloud.security.privateca.v1.X509Parameters.aia_ocsp_servers]
        /// field.
        ///
        /// [google.cloud.security.privateca.v1.X509Parameters.aia_ocsp_servers]: crate::model::X509Parameters::aia_ocsp_servers
        AiaOcspServers,
        /// Refers to Name Constraints extension as described in
        /// [RFC 5280
        /// section 4.2.1.10](https://tools.ietf.org/html/rfc5280#section-4.2.1.10)
        NameConstraints,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [KnownCertificateExtension::value] or
        /// [KnownCertificateExtension::name].
        UnknownValue(known_certificate_extension::UnknownValue),
    }

    #[doc(hidden)]
    pub mod known_certificate_extension {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl KnownCertificateExtension {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::BaseKeyUsage => std::option::Option::Some(1),
                Self::ExtendedKeyUsage => std::option::Option::Some(2),
                Self::CaOptions => std::option::Option::Some(3),
                Self::PolicyIds => std::option::Option::Some(4),
                Self::AiaOcspServers => std::option::Option::Some(5),
                Self::NameConstraints => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("KNOWN_CERTIFICATE_EXTENSION_UNSPECIFIED")
                }
                Self::BaseKeyUsage => std::option::Option::Some("BASE_KEY_USAGE"),
                Self::ExtendedKeyUsage => std::option::Option::Some("EXTENDED_KEY_USAGE"),
                Self::CaOptions => std::option::Option::Some("CA_OPTIONS"),
                Self::PolicyIds => std::option::Option::Some("POLICY_IDS"),
                Self::AiaOcspServers => std::option::Option::Some("AIA_OCSP_SERVERS"),
                Self::NameConstraints => std::option::Option::Some("NAME_CONSTRAINTS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for KnownCertificateExtension {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for KnownCertificateExtension {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for KnownCertificateExtension {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::BaseKeyUsage,
                2 => Self::ExtendedKeyUsage,
                3 => Self::CaOptions,
                4 => Self::PolicyIds,
                5 => Self::AiaOcspServers,
                6 => Self::NameConstraints,
                _ => Self::UnknownValue(known_certificate_extension::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for KnownCertificateExtension {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "KNOWN_CERTIFICATE_EXTENSION_UNSPECIFIED" => Self::Unspecified,
                "BASE_KEY_USAGE" => Self::BaseKeyUsage,
                "EXTENDED_KEY_USAGE" => Self::ExtendedKeyUsage,
                "CA_OPTIONS" => Self::CaOptions,
                "POLICY_IDS" => Self::PolicyIds,
                "AIA_OCSP_SERVERS" => Self::AiaOcspServers,
                "NAME_CONSTRAINTS" => Self::NameConstraints,
                _ => Self::UnknownValue(known_certificate_extension::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for KnownCertificateExtension {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::BaseKeyUsage => serializer.serialize_i32(1),
                Self::ExtendedKeyUsage => serializer.serialize_i32(2),
                Self::CaOptions => serializer.serialize_i32(3),
                Self::PolicyIds => serializer.serialize_i32(4),
                Self::AiaOcspServers => serializer.serialize_i32(5),
                Self::NameConstraints => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for KnownCertificateExtension {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<KnownCertificateExtension>::new(
                ".google.cloud.security.privateca.v1.CertificateExtensionConstraints.KnownCertificateExtension"))
        }
    }
}

/// Request message for
/// [CertificateAuthorityService.CreateCertificate][google.cloud.security.privateca.v1.CertificateAuthorityService.CreateCertificate].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.CreateCertificate]: crate::client::CertificateAuthorityService::create_certificate
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCertificateRequest {
    /// Required. The resource name of the
    /// [CaPool][google.cloud.security.privateca.v1.CaPool] associated with the
    /// [Certificate][google.cloud.security.privateca.v1.Certificate], in the
    /// format `projects/*/locations/*/caPools/*`.
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    pub parent: std::string::String,

    /// Optional. It must be unique within a location and match the regular
    /// expression `[a-zA-Z0-9_-]{1,63}`. This field is required when using a
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// in the Enterprise [CertificateAuthority.Tier][], but is optional and its
    /// value is ignored otherwise.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub certificate_id: std::string::String,

    /// Required. A [Certificate][google.cloud.security.privateca.v1.Certificate]
    /// with initial field values.
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    pub certificate: std::option::Option<crate::model::Certificate>,

    /// Optional. An ID to identify requests. Specify a unique request ID so that
    /// if you must retry your request, the server will know to ignore the request
    /// if it has already been completed. The server will guarantee that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request ID,
    /// the server can check if original operation with the same request ID was
    /// received, and if so, will ignore the second request. This prevents clients
    /// from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If this is true, no
    /// [Certificate][google.cloud.security.privateca.v1.Certificate] resource will
    /// be persisted regardless of the
    /// [CaPool][google.cloud.security.privateca.v1.CaPool]'s
    /// [tier][google.cloud.security.privateca.v1.CaPool.tier], and the returned
    /// [Certificate][google.cloud.security.privateca.v1.Certificate] will not
    /// contain the
    /// [pem_certificate][google.cloud.security.privateca.v1.Certificate.pem_certificate]
    /// field.
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    /// [google.cloud.security.privateca.v1.CaPool.tier]: crate::model::CaPool::tier
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    /// [google.cloud.security.privateca.v1.Certificate.pem_certificate]: crate::model::Certificate::pem_certificate
    pub validate_only: bool,

    /// Optional. The resource ID of the
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// that should issue the certificate.  This optional field will ignore the
    /// load-balancing scheme of the Pool and directly issue the certificate from
    /// the CA with the specified ID, contained in the same
    /// [CaPool][google.cloud.security.privateca.v1.CaPool] referenced by `parent`.
    /// Per-CA quota rules apply. If left empty, a
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// will be chosen from the [CaPool][google.cloud.security.privateca.v1.CaPool]
    /// by the service. For example, to issue a
    /// [Certificate][google.cloud.security.privateca.v1.Certificate] from a
    /// Certificate Authority with resource name
    /// "projects/my-project/locations/us-central1/caPools/my-pool/certificateAuthorities/my-ca",
    /// you can set the
    /// [parent][google.cloud.security.privateca.v1.CreateCertificateRequest.parent]
    /// to "projects/my-project/locations/us-central1/caPools/my-pool" and the
    /// [issuing_certificate_authority_id][google.cloud.security.privateca.v1.CreateCertificateRequest.issuing_certificate_authority_id]
    /// to "my-ca".
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    /// [google.cloud.security.privateca.v1.CreateCertificateRequest.issuing_certificate_authority_id]: crate::model::CreateCertificateRequest::issuing_certificate_authority_id
    /// [google.cloud.security.privateca.v1.CreateCertificateRequest.parent]: crate::model::CreateCertificateRequest::parent
    pub issuing_certificate_authority_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCertificateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCertificateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [certificate_id][crate::model::CreateCertificateRequest::certificate_id].
    pub fn set_certificate_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.certificate_id = v.into();
        self
    }

    /// Sets the value of [certificate][crate::model::CreateCertificateRequest::certificate].
    pub fn set_certificate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Certificate>,
    {
        self.certificate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [certificate][crate::model::CreateCertificateRequest::certificate].
    pub fn set_or_clear_certificate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Certificate>,
    {
        self.certificate = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateCertificateRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateCertificateRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [issuing_certificate_authority_id][crate::model::CreateCertificateRequest::issuing_certificate_authority_id].
    pub fn set_issuing_certificate_authority_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.issuing_certificate_authority_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateCertificateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.CreateCertificateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateCertificateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __certificate_id,
            __certificate,
            __request_id,
            __validate_only,
            __issuing_certificate_authority_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCertificateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "certificateId" => Ok(__FieldTag::__certificate_id),
                            "certificate_id" => Ok(__FieldTag::__certificate_id),
                            "certificate" => Ok(__FieldTag::__certificate),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "issuingCertificateAuthorityId" => {
                                Ok(__FieldTag::__issuing_certificate_authority_id)
                            }
                            "issuing_certificate_authority_id" => {
                                Ok(__FieldTag::__issuing_certificate_authority_id)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateCertificateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCertificateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__certificate_id => {
                            if !fields.insert(__FieldTag::__certificate_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_id",
                                ));
                            }
                            result.certificate_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__certificate => {
                            if !fields.insert(__FieldTag::__certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate",
                                ));
                            }
                            result.certificate =
                                map.next_value::<std::option::Option<crate::model::Certificate>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__issuing_certificate_authority_id => {
                            if !fields.insert(__FieldTag::__issuing_certificate_authority_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issuing_certificate_authority_id",
                                ));
                            }
                            result.issuing_certificate_authority_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateCertificateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.certificate_id.is_empty() {
            state.serialize_entry("certificateId", &self.certificate_id)?;
        }
        if self.certificate.is_some() {
            state.serialize_entry("certificate", &self.certificate)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.issuing_certificate_authority_id.is_empty() {
            state.serialize_entry(
                "issuingCertificateAuthorityId",
                &self.issuing_certificate_authority_id,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.GetCertificate][google.cloud.security.privateca.v1.CertificateAuthorityService.GetCertificate].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.GetCertificate]: crate::client::CertificateAuthorityService::get_certificate
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCertificateRequest {
    /// Required. The [name][google.cloud.security.privateca.v1.Certificate.name]
    /// of the [Certificate][google.cloud.security.privateca.v1.Certificate] to
    /// get.
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    /// [google.cloud.security.privateca.v1.Certificate.name]: crate::model::Certificate::name
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCertificateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCertificateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCertificateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.GetCertificateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCertificateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCertificateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCertificateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCertificateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCertificateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.ListCertificates][google.cloud.security.privateca.v1.CertificateAuthorityService.ListCertificates].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.ListCertificates]: crate::client::CertificateAuthorityService::list_certificates
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCertificatesRequest {
    /// Required. The resource name of the location associated with the
    /// [Certificates][google.cloud.security.privateca.v1.Certificate], in the
    /// format `projects/*/locations/*/caPools/*`.
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    pub parent: std::string::String,

    /// Optional. Limit on the number of
    /// [Certificates][google.cloud.security.privateca.v1.Certificate] to include
    /// in the response. Further
    /// [Certificates][google.cloud.security.privateca.v1.Certificate] can
    /// subsequently be obtained by including the
    /// [ListCertificatesResponse.next_page_token][google.cloud.security.privateca.v1.ListCertificatesResponse.next_page_token]
    /// in a subsequent request. If unspecified, the server will pick an
    /// appropriate default.
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    /// [google.cloud.security.privateca.v1.ListCertificatesResponse.next_page_token]: crate::model::ListCertificatesResponse::next_page_token
    pub page_size: i32,

    /// Optional. Pagination token, returned earlier via
    /// [ListCertificatesResponse.next_page_token][google.cloud.security.privateca.v1.ListCertificatesResponse.next_page_token].
    ///
    /// [google.cloud.security.privateca.v1.ListCertificatesResponse.next_page_token]: crate::model::ListCertificatesResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Only include resources that match the filter in the response. For
    /// details on supported filters and syntax, see [Certificates Filtering
    /// documentation](https://cloud.google.com/certificate-authority-service/docs/sorting-filtering-certificates#filtering_support).
    pub filter: std::string::String,

    /// Optional. Specify how the results should be sorted. For details on
    /// supported fields and syntax, see [Certificates Sorting
    /// documentation](https://cloud.google.com/certificate-authority-service/docs/sorting-filtering-certificates#sorting_support).
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCertificatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCertificatesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCertificatesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCertificatesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCertificatesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCertificatesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCertificatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.ListCertificatesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCertificatesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCertificatesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCertificatesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCertificatesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCertificatesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [CertificateAuthorityService.ListCertificates][google.cloud.security.privateca.v1.CertificateAuthorityService.ListCertificates].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.ListCertificates]: crate::client::CertificateAuthorityService::list_certificates
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCertificatesResponse {
    /// The list of [Certificates][google.cloud.security.privateca.v1.Certificate].
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    pub certificates: std::vec::Vec<crate::model::Certificate>,

    /// A token to retrieve next page of results. Pass this value in
    /// [ListCertificatesRequest.next_page_token][] to retrieve the
    /// next page of results.
    pub next_page_token: std::string::String,

    /// A list of locations (e.g. "us-west1") that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCertificatesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [certificates][crate::model::ListCertificatesResponse::certificates].
    pub fn set_certificates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Certificate>,
    {
        use std::iter::Iterator;
        self.certificates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCertificatesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCertificatesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCertificatesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.ListCertificatesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCertificatesResponse {
    type PageItem = crate::model::Certificate;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.certificates
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCertificatesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certificates,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCertificatesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certificates" => Ok(__FieldTag::__certificates),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCertificatesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCertificatesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certificates => {
                            if !fields.insert(__FieldTag::__certificates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificates",
                                ));
                            }
                            result.certificates = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Certificate>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCertificatesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.certificates.is_empty() {
            state.serialize_entry("certificates", &self.certificates)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.RevokeCertificate][google.cloud.security.privateca.v1.CertificateAuthorityService.RevokeCertificate].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.RevokeCertificate]: crate::client::CertificateAuthorityService::revoke_certificate
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RevokeCertificateRequest {
    /// Required. The resource name for this
    /// [Certificate][google.cloud.security.privateca.v1.Certificate] in the format
    /// `projects/*/locations/*/caPools/*/certificates/*`.
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    pub name: std::string::String,

    /// Required. The
    /// [RevocationReason][google.cloud.security.privateca.v1.RevocationReason] for
    /// revoking this certificate.
    ///
    /// [google.cloud.security.privateca.v1.RevocationReason]: crate::model::RevocationReason
    pub reason: crate::model::RevocationReason,

    /// Optional. An ID to identify requests. Specify a unique request ID so that
    /// if you must retry your request, the server will know to ignore the request
    /// if it has already been completed. The server will guarantee that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RevokeCertificateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RevokeCertificateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [reason][crate::model::RevokeCertificateRequest::reason].
    pub fn set_reason<T: std::convert::Into<crate::model::RevocationReason>>(
        mut self,
        v: T,
    ) -> Self {
        self.reason = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::RevokeCertificateRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for RevokeCertificateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.RevokeCertificateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RevokeCertificateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __reason,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RevokeCertificateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "reason" => Ok(__FieldTag::__reason),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RevokeCertificateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RevokeCertificateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reason => {
                            if !fields.insert(__FieldTag::__reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reason",
                                ));
                            }
                            result.reason = map
                                .next_value::<std::option::Option<crate::model::RevocationReason>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RevokeCertificateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.reason) {
            state.serialize_entry("reason", &self.reason)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.UpdateCertificate][google.cloud.security.privateca.v1.CertificateAuthorityService.UpdateCertificate].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.UpdateCertificate]: crate::client::CertificateAuthorityService::update_certificate
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateCertificateRequest {
    /// Required. [Certificate][google.cloud.security.privateca.v1.Certificate]
    /// with updated values.
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    pub certificate: std::option::Option<crate::model::Certificate>,

    /// Required. A list of fields to be updated in this request.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. An ID to identify requests. Specify a unique request ID so that
    /// if you must retry your request, the server will know to ignore the request
    /// if it has already been completed. The server will guarantee that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCertificateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [certificate][crate::model::UpdateCertificateRequest::certificate].
    pub fn set_certificate<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Certificate>,
    {
        self.certificate = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [certificate][crate::model::UpdateCertificateRequest::certificate].
    pub fn set_or_clear_certificate<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Certificate>,
    {
        self.certificate = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCertificateRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateCertificateRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateCertificateRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateCertificateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.UpdateCertificateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateCertificateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certificate,
            __update_mask,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateCertificateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certificate" => Ok(__FieldTag::__certificate),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateCertificateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCertificateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certificate => {
                            if !fields.insert(__FieldTag::__certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate",
                                ));
                            }
                            result.certificate =
                                map.next_value::<std::option::Option<crate::model::Certificate>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateCertificateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.certificate.is_some() {
            state.serialize_entry("certificate", &self.certificate)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.ActivateCertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthorityService.ActivateCertificateAuthority].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.ActivateCertificateAuthority]: crate::client::CertificateAuthorityService::activate_certificate_authority
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ActivateCertificateAuthorityRequest {
    /// Required. The resource name for this
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// in the format `projects/*/locations/*/caPools/*/certificateAuthorities/*`.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub name: std::string::String,

    /// Required. The signed CA certificate issued from
    /// [FetchCertificateAuthorityCsrResponse.pem_csr][google.cloud.security.privateca.v1.FetchCertificateAuthorityCsrResponse.pem_csr].
    ///
    /// [google.cloud.security.privateca.v1.FetchCertificateAuthorityCsrResponse.pem_csr]: crate::model::FetchCertificateAuthorityCsrResponse::pem_csr
    pub pem_ca_certificate: std::string::String,

    /// Required. Must include information about the issuer of
    /// 'pem_ca_certificate', and any further issuers until the self-signed CA.
    pub subordinate_config: std::option::Option<crate::model::SubordinateConfig>,

    /// Optional. An ID to identify requests. Specify a unique request ID so that
    /// if you must retry your request, the server will know to ignore the request
    /// if it has already been completed. The server will guarantee that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ActivateCertificateAuthorityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ActivateCertificateAuthorityRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [pem_ca_certificate][crate::model::ActivateCertificateAuthorityRequest::pem_ca_certificate].
    pub fn set_pem_ca_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.pem_ca_certificate = v.into();
        self
    }

    /// Sets the value of [subordinate_config][crate::model::ActivateCertificateAuthorityRequest::subordinate_config].
    pub fn set_subordinate_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SubordinateConfig>,
    {
        self.subordinate_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subordinate_config][crate::model::ActivateCertificateAuthorityRequest::subordinate_config].
    pub fn set_or_clear_subordinate_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SubordinateConfig>,
    {
        self.subordinate_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::ActivateCertificateAuthorityRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for ActivateCertificateAuthorityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.ActivateCertificateAuthorityRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ActivateCertificateAuthorityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __pem_ca_certificate,
            __subordinate_config,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ActivateCertificateAuthorityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "pemCaCertificate" => Ok(__FieldTag::__pem_ca_certificate),
                            "pem_ca_certificate" => Ok(__FieldTag::__pem_ca_certificate),
                            "subordinateConfig" => Ok(__FieldTag::__subordinate_config),
                            "subordinate_config" => Ok(__FieldTag::__subordinate_config),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ActivateCertificateAuthorityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ActivateCertificateAuthorityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pem_ca_certificate => {
                            if !fields.insert(__FieldTag::__pem_ca_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pem_ca_certificate",
                                ));
                            }
                            result.pem_ca_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subordinate_config => {
                            if !fields.insert(__FieldTag::__subordinate_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subordinate_config",
                                ));
                            }
                            result.subordinate_config = map
                                .next_value::<std::option::Option<crate::model::SubordinateConfig>>(
                                )?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ActivateCertificateAuthorityRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.pem_ca_certificate.is_empty() {
            state.serialize_entry("pemCaCertificate", &self.pem_ca_certificate)?;
        }
        if self.subordinate_config.is_some() {
            state.serialize_entry("subordinateConfig", &self.subordinate_config)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.CreateCertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthorityService.CreateCertificateAuthority].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.CreateCertificateAuthority]: crate::client::CertificateAuthorityService::create_certificate_authority
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCertificateAuthorityRequest {
    /// Required. The resource name of the
    /// [CaPool][google.cloud.security.privateca.v1.CaPool] associated with the
    /// [CertificateAuthorities][google.cloud.security.privateca.v1.CertificateAuthority],
    /// in the format `projects/*/locations/*/caPools/*`.
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub parent: std::string::String,

    /// Required. It must be unique within a location and match the regular
    /// expression `[a-zA-Z0-9_-]{1,63}`
    pub certificate_authority_id: std::string::String,

    /// Required. A
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// with initial field values.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub certificate_authority: std::option::Option<crate::model::CertificateAuthority>,

    /// Optional. An ID to identify requests. Specify a unique request ID so that
    /// if you must retry your request, the server will know to ignore the request
    /// if it has already been completed. The server will guarantee that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCertificateAuthorityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCertificateAuthorityRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [certificate_authority_id][crate::model::CreateCertificateAuthorityRequest::certificate_authority_id].
    pub fn set_certificate_authority_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.certificate_authority_id = v.into();
        self
    }

    /// Sets the value of [certificate_authority][crate::model::CreateCertificateAuthorityRequest::certificate_authority].
    pub fn set_certificate_authority<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CertificateAuthority>,
    {
        self.certificate_authority = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [certificate_authority][crate::model::CreateCertificateAuthorityRequest::certificate_authority].
    pub fn set_or_clear_certificate_authority<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CertificateAuthority>,
    {
        self.certificate_authority = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateCertificateAuthorityRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateCertificateAuthorityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.CreateCertificateAuthorityRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateCertificateAuthorityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __certificate_authority_id,
            __certificate_authority,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCertificateAuthorityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "certificateAuthorityId" => Ok(__FieldTag::__certificate_authority_id),
                            "certificate_authority_id" => {
                                Ok(__FieldTag::__certificate_authority_id)
                            }
                            "certificateAuthority" => Ok(__FieldTag::__certificate_authority),
                            "certificate_authority" => Ok(__FieldTag::__certificate_authority),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateCertificateAuthorityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCertificateAuthorityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__certificate_authority_id => {
                            if !fields.insert(__FieldTag::__certificate_authority_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_authority_id",
                                ));
                            }
                            result.certificate_authority_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__certificate_authority => {
                            if !fields.insert(__FieldTag::__certificate_authority) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_authority",
                                ));
                            }
                            result.certificate_authority = map.next_value::<std::option::Option<crate::model::CertificateAuthority>>()?
                                ;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateCertificateAuthorityRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.certificate_authority_id.is_empty() {
            state.serialize_entry("certificateAuthorityId", &self.certificate_authority_id)?;
        }
        if self.certificate_authority.is_some() {
            state.serialize_entry("certificateAuthority", &self.certificate_authority)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.DisableCertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthorityService.DisableCertificateAuthority].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.DisableCertificateAuthority]: crate::client::CertificateAuthorityService::disable_certificate_authority
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DisableCertificateAuthorityRequest {
    /// Required. The resource name for this
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// in the format `projects/*/locations/*/caPools/*/certificateAuthorities/*`.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub name: std::string::String,

    /// Optional. An ID to identify requests. Specify a unique request ID so that
    /// if you must retry your request, the server will know to ignore the request
    /// if it has already been completed. The server will guarantee that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. This field allows this CA to be disabled even if it's being
    /// depended on by another resource. However, doing so may result in unintended
    /// and unrecoverable effects on any dependent resources since the CA will
    /// no longer be able to issue certificates.
    pub ignore_dependent_resources: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisableCertificateAuthorityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DisableCertificateAuthorityRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DisableCertificateAuthorityRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [ignore_dependent_resources][crate::model::DisableCertificateAuthorityRequest::ignore_dependent_resources].
    pub fn set_ignore_dependent_resources<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_dependent_resources = v.into();
        self
    }
}

impl wkt::message::Message for DisableCertificateAuthorityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.DisableCertificateAuthorityRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DisableCertificateAuthorityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __ignore_dependent_resources,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DisableCertificateAuthorityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "ignoreDependentResources" => {
                                Ok(__FieldTag::__ignore_dependent_resources)
                            }
                            "ignore_dependent_resources" => {
                                Ok(__FieldTag::__ignore_dependent_resources)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DisableCertificateAuthorityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DisableCertificateAuthorityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore_dependent_resources => {
                            if !fields.insert(__FieldTag::__ignore_dependent_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_dependent_resources",
                                ));
                            }
                            result.ignore_dependent_resources = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DisableCertificateAuthorityRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.ignore_dependent_resources) {
            state.serialize_entry("ignoreDependentResources", &self.ignore_dependent_resources)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.EnableCertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthorityService.EnableCertificateAuthority].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.EnableCertificateAuthority]: crate::client::CertificateAuthorityService::enable_certificate_authority
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EnableCertificateAuthorityRequest {
    /// Required. The resource name for this
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// in the format `projects/*/locations/*/caPools/*/certificateAuthorities/*`.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub name: std::string::String,

    /// Optional. An ID to identify requests. Specify a unique request ID so that
    /// if you must retry your request, the server will know to ignore the request
    /// if it has already been completed. The server will guarantee that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnableCertificateAuthorityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EnableCertificateAuthorityRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::EnableCertificateAuthorityRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for EnableCertificateAuthorityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.EnableCertificateAuthorityRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnableCertificateAuthorityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnableCertificateAuthorityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnableCertificateAuthorityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnableCertificateAuthorityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnableCertificateAuthorityRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.FetchCertificateAuthorityCsr][google.cloud.security.privateca.v1.CertificateAuthorityService.FetchCertificateAuthorityCsr].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.FetchCertificateAuthorityCsr]: crate::client::CertificateAuthorityService::fetch_certificate_authority_csr
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchCertificateAuthorityCsrRequest {
    /// Required. The resource name for this
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// in the format `projects/*/locations/*/caPools/*/certificateAuthorities/*`.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchCertificateAuthorityCsrRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FetchCertificateAuthorityCsrRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for FetchCertificateAuthorityCsrRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.FetchCertificateAuthorityCsrRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchCertificateAuthorityCsrRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchCertificateAuthorityCsrRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchCertificateAuthorityCsrRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchCertificateAuthorityCsrRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchCertificateAuthorityCsrRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [CertificateAuthorityService.FetchCertificateAuthorityCsr][google.cloud.security.privateca.v1.CertificateAuthorityService.FetchCertificateAuthorityCsr].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.FetchCertificateAuthorityCsr]: crate::client::CertificateAuthorityService::fetch_certificate_authority_csr
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchCertificateAuthorityCsrResponse {
    /// Output only. The PEM-encoded signed certificate signing request (CSR).
    pub pem_csr: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchCertificateAuthorityCsrResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pem_csr][crate::model::FetchCertificateAuthorityCsrResponse::pem_csr].
    pub fn set_pem_csr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pem_csr = v.into();
        self
    }
}

impl wkt::message::Message for FetchCertificateAuthorityCsrResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.FetchCertificateAuthorityCsrResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchCertificateAuthorityCsrResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pem_csr,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchCertificateAuthorityCsrResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pemCsr" => Ok(__FieldTag::__pem_csr),
                            "pem_csr" => Ok(__FieldTag::__pem_csr),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchCertificateAuthorityCsrResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchCertificateAuthorityCsrResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pem_csr => {
                            if !fields.insert(__FieldTag::__pem_csr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pem_csr",
                                ));
                            }
                            result.pem_csr = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchCertificateAuthorityCsrResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.pem_csr.is_empty() {
            state.serialize_entry("pemCsr", &self.pem_csr)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.GetCertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthorityService.GetCertificateAuthority].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.GetCertificateAuthority]: crate::client::CertificateAuthorityService::get_certificate_authority
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCertificateAuthorityRequest {
    /// Required. The
    /// [name][google.cloud.security.privateca.v1.CertificateAuthority.name] of the
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// to get.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    /// [google.cloud.security.privateca.v1.CertificateAuthority.name]: crate::model::CertificateAuthority::name
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCertificateAuthorityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCertificateAuthorityRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCertificateAuthorityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.GetCertificateAuthorityRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCertificateAuthorityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCertificateAuthorityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCertificateAuthorityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCertificateAuthorityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCertificateAuthorityRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.ListCertificateAuthorities][google.cloud.security.privateca.v1.CertificateAuthorityService.ListCertificateAuthorities].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.ListCertificateAuthorities]: crate::client::CertificateAuthorityService::list_certificate_authorities
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCertificateAuthoritiesRequest {
    /// Required. The resource name of the
    /// [CaPool][google.cloud.security.privateca.v1.CaPool] associated with the
    /// [CertificateAuthorities][google.cloud.security.privateca.v1.CertificateAuthority],
    /// in the format `projects/*/locations/*/caPools/*`.
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub parent: std::string::String,

    /// Optional. Limit on the number of
    /// [CertificateAuthorities][google.cloud.security.privateca.v1.CertificateAuthority]
    /// to include in the response. Further
    /// [CertificateAuthorities][google.cloud.security.privateca.v1.CertificateAuthority]
    /// can subsequently be obtained by including the
    /// [ListCertificateAuthoritiesResponse.next_page_token][google.cloud.security.privateca.v1.ListCertificateAuthoritiesResponse.next_page_token]
    /// in a subsequent request. If unspecified, the server will pick an
    /// appropriate default.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    /// [google.cloud.security.privateca.v1.ListCertificateAuthoritiesResponse.next_page_token]: crate::model::ListCertificateAuthoritiesResponse::next_page_token
    pub page_size: i32,

    /// Optional. Pagination token, returned earlier via
    /// [ListCertificateAuthoritiesResponse.next_page_token][google.cloud.security.privateca.v1.ListCertificateAuthoritiesResponse.next_page_token].
    ///
    /// [google.cloud.security.privateca.v1.ListCertificateAuthoritiesResponse.next_page_token]: crate::model::ListCertificateAuthoritiesResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Only include resources that match the filter in the response.
    pub filter: std::string::String,

    /// Optional. Specify how the results should be sorted.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCertificateAuthoritiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCertificateAuthoritiesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCertificateAuthoritiesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCertificateAuthoritiesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCertificateAuthoritiesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCertificateAuthoritiesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCertificateAuthoritiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.ListCertificateAuthoritiesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCertificateAuthoritiesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCertificateAuthoritiesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCertificateAuthoritiesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCertificateAuthoritiesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCertificateAuthoritiesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [CertificateAuthorityService.ListCertificateAuthorities][google.cloud.security.privateca.v1.CertificateAuthorityService.ListCertificateAuthorities].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.ListCertificateAuthorities]: crate::client::CertificateAuthorityService::list_certificate_authorities
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCertificateAuthoritiesResponse {
    /// The list of
    /// [CertificateAuthorities][google.cloud.security.privateca.v1.CertificateAuthority].
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub certificate_authorities: std::vec::Vec<crate::model::CertificateAuthority>,

    /// A token to retrieve next page of results. Pass this value in
    /// [ListCertificateAuthoritiesRequest.next_page_token][] to retrieve the next
    /// page of results.
    pub next_page_token: std::string::String,

    /// A list of locations (e.g. "us-west1") that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCertificateAuthoritiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [certificate_authorities][crate::model::ListCertificateAuthoritiesResponse::certificate_authorities].
    pub fn set_certificate_authorities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CertificateAuthority>,
    {
        use std::iter::Iterator;
        self.certificate_authorities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCertificateAuthoritiesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCertificateAuthoritiesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCertificateAuthoritiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.ListCertificateAuthoritiesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCertificateAuthoritiesResponse {
    type PageItem = crate::model::CertificateAuthority;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.certificate_authorities
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCertificateAuthoritiesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certificate_authorities,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCertificateAuthoritiesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certificateAuthorities" => Ok(__FieldTag::__certificate_authorities),
                            "certificate_authorities" => Ok(__FieldTag::__certificate_authorities),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCertificateAuthoritiesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCertificateAuthoritiesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certificate_authorities => {
                            if !fields.insert(__FieldTag::__certificate_authorities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_authorities",
                                ));
                            }
                            result.certificate_authorities = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CertificateAuthority>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCertificateAuthoritiesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.certificate_authorities.is_empty() {
            state.serialize_entry("certificateAuthorities", &self.certificate_authorities)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.UndeleteCertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthorityService.UndeleteCertificateAuthority].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.UndeleteCertificateAuthority]: crate::client::CertificateAuthorityService::undelete_certificate_authority
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UndeleteCertificateAuthorityRequest {
    /// Required. The resource name for this
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// in the format `projects/*/locations/*/caPools/*/certificateAuthorities/*`.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub name: std::string::String,

    /// Optional. An ID to identify requests. Specify a unique request ID so that
    /// if you must retry your request, the server will know to ignore the request
    /// if it has already been completed. The server will guarantee that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeleteCertificateAuthorityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UndeleteCertificateAuthorityRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UndeleteCertificateAuthorityRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UndeleteCertificateAuthorityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.UndeleteCertificateAuthorityRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UndeleteCertificateAuthorityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UndeleteCertificateAuthorityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UndeleteCertificateAuthorityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UndeleteCertificateAuthorityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UndeleteCertificateAuthorityRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.DeleteCertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthorityService.DeleteCertificateAuthority].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.DeleteCertificateAuthority]: crate::client::CertificateAuthorityService::delete_certificate_authority
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteCertificateAuthorityRequest {
    /// Required. The resource name for this
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// in the format `projects/*/locations/*/caPools/*/certificateAuthorities/*`.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub name: std::string::String,

    /// Optional. An ID to identify requests. Specify a unique request ID so that
    /// if you must retry your request, the server will know to ignore the request
    /// if it has already been completed. The server will guarantee that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. This field allows the CA to be deleted even if the CA has
    /// active certs. Active certs include both unrevoked and unexpired certs.
    pub ignore_active_certificates: bool,

    /// Optional. If this flag is set, the Certificate Authority will be deleted as
    /// soon as possible without a 30-day grace period where undeletion would have
    /// been allowed. If you proceed, there will be no way to recover this CA.
    pub skip_grace_period: bool,

    /// Optional. This field allows this CA to be deleted even if it's being
    /// depended on by another resource. However, doing so may result in unintended
    /// and unrecoverable effects on any dependent resources since the CA will
    /// no longer be able to issue certificates.
    pub ignore_dependent_resources: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCertificateAuthorityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCertificateAuthorityRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteCertificateAuthorityRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [ignore_active_certificates][crate::model::DeleteCertificateAuthorityRequest::ignore_active_certificates].
    pub fn set_ignore_active_certificates<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_active_certificates = v.into();
        self
    }

    /// Sets the value of [skip_grace_period][crate::model::DeleteCertificateAuthorityRequest::skip_grace_period].
    pub fn set_skip_grace_period<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_grace_period = v.into();
        self
    }

    /// Sets the value of [ignore_dependent_resources][crate::model::DeleteCertificateAuthorityRequest::ignore_dependent_resources].
    pub fn set_ignore_dependent_resources<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_dependent_resources = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCertificateAuthorityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.DeleteCertificateAuthorityRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteCertificateAuthorityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __ignore_active_certificates,
            __skip_grace_period,
            __ignore_dependent_resources,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteCertificateAuthorityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "ignoreActiveCertificates" => {
                                Ok(__FieldTag::__ignore_active_certificates)
                            }
                            "ignore_active_certificates" => {
                                Ok(__FieldTag::__ignore_active_certificates)
                            }
                            "skipGracePeriod" => Ok(__FieldTag::__skip_grace_period),
                            "skip_grace_period" => Ok(__FieldTag::__skip_grace_period),
                            "ignoreDependentResources" => {
                                Ok(__FieldTag::__ignore_dependent_resources)
                            }
                            "ignore_dependent_resources" => {
                                Ok(__FieldTag::__ignore_dependent_resources)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteCertificateAuthorityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteCertificateAuthorityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore_active_certificates => {
                            if !fields.insert(__FieldTag::__ignore_active_certificates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_active_certificates",
                                ));
                            }
                            result.ignore_active_certificates = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__skip_grace_period => {
                            if !fields.insert(__FieldTag::__skip_grace_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_grace_period",
                                ));
                            }
                            result.skip_grace_period = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore_dependent_resources => {
                            if !fields.insert(__FieldTag::__ignore_dependent_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_dependent_resources",
                                ));
                            }
                            result.ignore_dependent_resources = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteCertificateAuthorityRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.ignore_active_certificates) {
            state.serialize_entry("ignoreActiveCertificates", &self.ignore_active_certificates)?;
        }
        if !wkt::internal::is_default(&self.skip_grace_period) {
            state.serialize_entry("skipGracePeriod", &self.skip_grace_period)?;
        }
        if !wkt::internal::is_default(&self.ignore_dependent_resources) {
            state.serialize_entry("ignoreDependentResources", &self.ignore_dependent_resources)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.UpdateCertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthorityService.UpdateCertificateAuthority].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.UpdateCertificateAuthority]: crate::client::CertificateAuthorityService::update_certificate_authority
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateCertificateAuthorityRequest {
    /// Required.
    /// [CertificateAuthority][google.cloud.security.privateca.v1.CertificateAuthority]
    /// with updated values.
    ///
    /// [google.cloud.security.privateca.v1.CertificateAuthority]: crate::model::CertificateAuthority
    pub certificate_authority: std::option::Option<crate::model::CertificateAuthority>,

    /// Required. A list of fields to be updated in this request.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. An ID to identify requests. Specify a unique request ID so that
    /// if you must retry your request, the server will know to ignore the request
    /// if it has already been completed. The server will guarantee that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCertificateAuthorityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [certificate_authority][crate::model::UpdateCertificateAuthorityRequest::certificate_authority].
    pub fn set_certificate_authority<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CertificateAuthority>,
    {
        self.certificate_authority = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [certificate_authority][crate::model::UpdateCertificateAuthorityRequest::certificate_authority].
    pub fn set_or_clear_certificate_authority<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CertificateAuthority>,
    {
        self.certificate_authority = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCertificateAuthorityRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateCertificateAuthorityRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateCertificateAuthorityRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateCertificateAuthorityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.UpdateCertificateAuthorityRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateCertificateAuthorityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certificate_authority,
            __update_mask,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateCertificateAuthorityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certificateAuthority" => Ok(__FieldTag::__certificate_authority),
                            "certificate_authority" => Ok(__FieldTag::__certificate_authority),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateCertificateAuthorityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCertificateAuthorityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certificate_authority => {
                            if !fields.insert(__FieldTag::__certificate_authority) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_authority",
                                ));
                            }
                            result.certificate_authority = map.next_value::<std::option::Option<crate::model::CertificateAuthority>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateCertificateAuthorityRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.certificate_authority.is_some() {
            state.serialize_entry("certificateAuthority", &self.certificate_authority)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.CreateCaPool][google.cloud.security.privateca.v1.CertificateAuthorityService.CreateCaPool].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.CreateCaPool]: crate::client::CertificateAuthorityService::create_ca_pool
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCaPoolRequest {
    /// Required. The resource name of the location associated with the
    /// [CaPool][google.cloud.security.privateca.v1.CaPool], in the format
    /// `projects/*/locations/*`.
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    pub parent: std::string::String,

    /// Required. It must be unique within a location and match the regular
    /// expression `[a-zA-Z0-9_-]{1,63}`
    pub ca_pool_id: std::string::String,

    /// Required. A [CaPool][google.cloud.security.privateca.v1.CaPool] with
    /// initial field values.
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    pub ca_pool: std::option::Option<crate::model::CaPool>,

    /// Optional. An ID to identify requests. Specify a unique request ID so that
    /// if you must retry your request, the server will know to ignore the request
    /// if it has already been completed. The server will guarantee that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCaPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCaPoolRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [ca_pool_id][crate::model::CreateCaPoolRequest::ca_pool_id].
    pub fn set_ca_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ca_pool_id = v.into();
        self
    }

    /// Sets the value of [ca_pool][crate::model::CreateCaPoolRequest::ca_pool].
    pub fn set_ca_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CaPool>,
    {
        self.ca_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ca_pool][crate::model::CreateCaPoolRequest::ca_pool].
    pub fn set_or_clear_ca_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CaPool>,
    {
        self.ca_pool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateCaPoolRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateCaPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.CreateCaPoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateCaPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __ca_pool_id,
            __ca_pool,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCaPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "caPoolId" => Ok(__FieldTag::__ca_pool_id),
                            "ca_pool_id" => Ok(__FieldTag::__ca_pool_id),
                            "caPool" => Ok(__FieldTag::__ca_pool),
                            "ca_pool" => Ok(__FieldTag::__ca_pool),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateCaPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCaPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ca_pool_id => {
                            if !fields.insert(__FieldTag::__ca_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_pool_id",
                                ));
                            }
                            result.ca_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ca_pool => {
                            if !fields.insert(__FieldTag::__ca_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_pool",
                                ));
                            }
                            result.ca_pool =
                                map.next_value::<std::option::Option<crate::model::CaPool>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateCaPoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.ca_pool_id.is_empty() {
            state.serialize_entry("caPoolId", &self.ca_pool_id)?;
        }
        if self.ca_pool.is_some() {
            state.serialize_entry("caPool", &self.ca_pool)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.UpdateCaPool][google.cloud.security.privateca.v1.CertificateAuthorityService.UpdateCaPool].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.UpdateCaPool]: crate::client::CertificateAuthorityService::update_ca_pool
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateCaPoolRequest {
    /// Required. [CaPool][google.cloud.security.privateca.v1.CaPool] with updated
    /// values.
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    pub ca_pool: std::option::Option<crate::model::CaPool>,

    /// Required. A list of fields to be updated in this request.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. An ID to identify requests. Specify a unique request ID so that
    /// if you must retry your request, the server will know to ignore the request
    /// if it has already been completed. The server will guarantee that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCaPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ca_pool][crate::model::UpdateCaPoolRequest::ca_pool].
    pub fn set_ca_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CaPool>,
    {
        self.ca_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ca_pool][crate::model::UpdateCaPoolRequest::ca_pool].
    pub fn set_or_clear_ca_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CaPool>,
    {
        self.ca_pool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCaPoolRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateCaPoolRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateCaPoolRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateCaPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.UpdateCaPoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateCaPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ca_pool,
            __update_mask,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateCaPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "caPool" => Ok(__FieldTag::__ca_pool),
                            "ca_pool" => Ok(__FieldTag::__ca_pool),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateCaPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCaPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ca_pool => {
                            if !fields.insert(__FieldTag::__ca_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_pool",
                                ));
                            }
                            result.ca_pool =
                                map.next_value::<std::option::Option<crate::model::CaPool>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateCaPoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.ca_pool.is_some() {
            state.serialize_entry("caPool", &self.ca_pool)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.DeleteCaPool][google.cloud.security.privateca.v1.CertificateAuthorityService.DeleteCaPool].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.DeleteCaPool]: crate::client::CertificateAuthorityService::delete_ca_pool
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteCaPoolRequest {
    /// Required. The resource name for this
    /// [CaPool][google.cloud.security.privateca.v1.CaPool] in the format
    /// `projects/*/locations/*/caPools/*`.
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    pub name: std::string::String,

    /// Optional. An ID to identify requests. Specify a unique request ID so that
    /// if you must retry your request, the server will know to ignore the request
    /// if it has already been completed. The server will guarantee that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. This field allows this pool to be deleted even if it's being
    /// depended on by another resource. However, doing so may result in unintended
    /// and unrecoverable effects on any dependent resources since the pool will
    /// no longer be able to issue certificates.
    pub ignore_dependent_resources: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCaPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCaPoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteCaPoolRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [ignore_dependent_resources][crate::model::DeleteCaPoolRequest::ignore_dependent_resources].
    pub fn set_ignore_dependent_resources<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_dependent_resources = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCaPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.DeleteCaPoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteCaPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __ignore_dependent_resources,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteCaPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "ignoreDependentResources" => {
                                Ok(__FieldTag::__ignore_dependent_resources)
                            }
                            "ignore_dependent_resources" => {
                                Ok(__FieldTag::__ignore_dependent_resources)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteCaPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteCaPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore_dependent_resources => {
                            if !fields.insert(__FieldTag::__ignore_dependent_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_dependent_resources",
                                ));
                            }
                            result.ignore_dependent_resources = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteCaPoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.ignore_dependent_resources) {
            state.serialize_entry("ignoreDependentResources", &self.ignore_dependent_resources)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.FetchCaCerts][google.cloud.security.privateca.v1.CertificateAuthorityService.FetchCaCerts].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.FetchCaCerts]: crate::client::CertificateAuthorityService::fetch_ca_certs
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchCaCertsRequest {
    /// Required. The resource name for the
    /// [CaPool][google.cloud.security.privateca.v1.CaPool] in the format
    /// `projects/*/locations/*/caPools/*`.
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    pub ca_pool: std::string::String,

    /// Optional. An ID to identify requests. Specify a unique request ID so that
    /// if you must retry your request, the server will know to ignore the request
    /// if it has already been completed. The server will guarantee that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchCaCertsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ca_pool][crate::model::FetchCaCertsRequest::ca_pool].
    pub fn set_ca_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ca_pool = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::FetchCaCertsRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for FetchCaCertsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.FetchCaCertsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchCaCertsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ca_pool,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchCaCertsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "caPool" => Ok(__FieldTag::__ca_pool),
                            "ca_pool" => Ok(__FieldTag::__ca_pool),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchCaCertsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchCaCertsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ca_pool => {
                            if !fields.insert(__FieldTag::__ca_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_pool",
                                ));
                            }
                            result.ca_pool = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchCaCertsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ca_pool.is_empty() {
            state.serialize_entry("caPool", &self.ca_pool)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [CertificateAuthorityService.FetchCaCerts][google.cloud.security.privateca.v1.CertificateAuthorityService.FetchCaCerts].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.FetchCaCerts]: crate::client::CertificateAuthorityService::fetch_ca_certs
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchCaCertsResponse {
    /// The PEM encoded CA certificate chains of all certificate authorities in
    /// this [CaPool][google.cloud.security.privateca.v1.CaPool] in the ENABLED,
    /// DISABLED, or STAGED states.
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    pub ca_certs: std::vec::Vec<crate::model::fetch_ca_certs_response::CertChain>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchCaCertsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ca_certs][crate::model::FetchCaCertsResponse::ca_certs].
    pub fn set_ca_certs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::fetch_ca_certs_response::CertChain>,
    {
        use std::iter::Iterator;
        self.ca_certs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FetchCaCertsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.FetchCaCertsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchCaCertsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ca_certs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchCaCertsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "caCerts" => Ok(__FieldTag::__ca_certs),
                            "ca_certs" => Ok(__FieldTag::__ca_certs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchCaCertsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchCaCertsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ca_certs => {
                            if !fields.insert(__FieldTag::__ca_certs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_certs",
                                ));
                            }
                            result.ca_certs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::fetch_ca_certs_response::CertChain>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchCaCertsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ca_certs.is_empty() {
            state.serialize_entry("caCerts", &self.ca_certs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [FetchCaCertsResponse].
pub mod fetch_ca_certs_response {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CertChain {
        /// The certificates that form the CA chain, from leaf to root order.
        pub certificates: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CertChain {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [certificates][crate::model::fetch_ca_certs_response::CertChain::certificates].
        pub fn set_certificates<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.certificates = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for CertChain {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.security.privateca.v1.FetchCaCertsResponse.CertChain"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CertChain {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __certificates,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CertChain")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "certificates" => Ok(__FieldTag::__certificates),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CertChain;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CertChain")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__certificates => {
                                if !fields.insert(__FieldTag::__certificates) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for certificates",
                                    ));
                                }
                                result.certificates = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CertChain {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.certificates.is_empty() {
                state.serialize_entry("certificates", &self.certificates)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Request message for
/// [CertificateAuthorityService.GetCaPool][google.cloud.security.privateca.v1.CertificateAuthorityService.GetCaPool].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.GetCaPool]: crate::client::CertificateAuthorityService::get_ca_pool
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCaPoolRequest {
    /// Required. The [name][google.cloud.security.privateca.v1.CaPool.name] of the
    /// [CaPool][google.cloud.security.privateca.v1.CaPool] to get.
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    /// [google.cloud.security.privateca.v1.CaPool.name]: crate::model::CaPool::name
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCaPoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCaPoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCaPoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.GetCaPoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCaPoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCaPoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCaPoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCaPoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCaPoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.ListCaPools][google.cloud.security.privateca.v1.CertificateAuthorityService.ListCaPools].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.ListCaPools]: crate::client::CertificateAuthorityService::list_ca_pools
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCaPoolsRequest {
    /// Required. The resource name of the location associated with the
    /// [CaPools][google.cloud.security.privateca.v1.CaPool], in the format
    /// `projects/*/locations/*`.
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    pub parent: std::string::String,

    /// Optional. Limit on the number of
    /// [CaPools][google.cloud.security.privateca.v1.CaPool] to include in the
    /// response. Further [CaPools][google.cloud.security.privateca.v1.CaPool] can
    /// subsequently be obtained by including the
    /// [ListCaPoolsResponse.next_page_token][google.cloud.security.privateca.v1.ListCaPoolsResponse.next_page_token]
    /// in a subsequent request. If unspecified, the server will pick an
    /// appropriate default.
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    /// [google.cloud.security.privateca.v1.ListCaPoolsResponse.next_page_token]: crate::model::ListCaPoolsResponse::next_page_token
    pub page_size: i32,

    /// Optional. Pagination token, returned earlier via
    /// [ListCaPoolsResponse.next_page_token][google.cloud.security.privateca.v1.ListCaPoolsResponse.next_page_token].
    ///
    /// [google.cloud.security.privateca.v1.ListCaPoolsResponse.next_page_token]: crate::model::ListCaPoolsResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Only include resources that match the filter in the response.
    pub filter: std::string::String,

    /// Optional. Specify how the results should be sorted.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCaPoolsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCaPoolsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCaPoolsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCaPoolsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCaPoolsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCaPoolsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCaPoolsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.ListCaPoolsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCaPoolsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCaPoolsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCaPoolsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCaPoolsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCaPoolsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [CertificateAuthorityService.ListCaPools][google.cloud.security.privateca.v1.CertificateAuthorityService.ListCaPools].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.ListCaPools]: crate::client::CertificateAuthorityService::list_ca_pools
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCaPoolsResponse {
    /// The list of [CaPools][google.cloud.security.privateca.v1.CaPool].
    ///
    /// [google.cloud.security.privateca.v1.CaPool]: crate::model::CaPool
    pub ca_pools: std::vec::Vec<crate::model::CaPool>,

    /// A token to retrieve next page of results. Pass this value in
    /// [ListCertificateAuthoritiesRequest.next_page_token][] to retrieve the next
    /// page of results.
    pub next_page_token: std::string::String,

    /// A list of locations (e.g. "us-west1") that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCaPoolsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ca_pools][crate::model::ListCaPoolsResponse::ca_pools].
    pub fn set_ca_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CaPool>,
    {
        use std::iter::Iterator;
        self.ca_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCaPoolsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCaPoolsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCaPoolsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.ListCaPoolsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCaPoolsResponse {
    type PageItem = crate::model::CaPool;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.ca_pools
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCaPoolsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ca_pools,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCaPoolsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "caPools" => Ok(__FieldTag::__ca_pools),
                            "ca_pools" => Ok(__FieldTag::__ca_pools),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCaPoolsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCaPoolsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ca_pools => {
                            if !fields.insert(__FieldTag::__ca_pools) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ca_pools",
                                ));
                            }
                            result.ca_pools = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CaPool>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCaPoolsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ca_pools.is_empty() {
            state.serialize_entry("caPools", &self.ca_pools)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.GetCertificateRevocationList][google.cloud.security.privateca.v1.CertificateAuthorityService.GetCertificateRevocationList].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.GetCertificateRevocationList]: crate::client::CertificateAuthorityService::get_certificate_revocation_list
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCertificateRevocationListRequest {
    /// Required. The
    /// [name][google.cloud.security.privateca.v1.CertificateRevocationList.name]
    /// of the
    /// [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList]
    /// to get.
    ///
    /// [google.cloud.security.privateca.v1.CertificateRevocationList]: crate::model::CertificateRevocationList
    /// [google.cloud.security.privateca.v1.CertificateRevocationList.name]: crate::model::CertificateRevocationList::name
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCertificateRevocationListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCertificateRevocationListRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCertificateRevocationListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.GetCertificateRevocationListRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCertificateRevocationListRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCertificateRevocationListRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCertificateRevocationListRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCertificateRevocationListRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCertificateRevocationListRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.ListCertificateRevocationLists][google.cloud.security.privateca.v1.CertificateAuthorityService.ListCertificateRevocationLists].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.ListCertificateRevocationLists]: crate::client::CertificateAuthorityService::list_certificate_revocation_lists
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCertificateRevocationListsRequest {
    /// Required. The resource name of the location associated with the
    /// [CertificateRevocationLists][google.cloud.security.privateca.v1.CertificateRevocationList],
    /// in the format `projects/*/locations/*/caPools/*/certificateAuthorities/*`.
    ///
    /// [google.cloud.security.privateca.v1.CertificateRevocationList]: crate::model::CertificateRevocationList
    pub parent: std::string::String,

    /// Optional. Limit on the number of
    /// [CertificateRevocationLists][google.cloud.security.privateca.v1.CertificateRevocationList]
    /// to include in the response. Further
    /// [CertificateRevocationLists][google.cloud.security.privateca.v1.CertificateRevocationList]
    /// can subsequently be obtained by including the
    /// [ListCertificateRevocationListsResponse.next_page_token][google.cloud.security.privateca.v1.ListCertificateRevocationListsResponse.next_page_token]
    /// in a subsequent request. If unspecified, the server will pick an
    /// appropriate default.
    ///
    /// [google.cloud.security.privateca.v1.CertificateRevocationList]: crate::model::CertificateRevocationList
    /// [google.cloud.security.privateca.v1.ListCertificateRevocationListsResponse.next_page_token]: crate::model::ListCertificateRevocationListsResponse::next_page_token
    pub page_size: i32,

    /// Optional. Pagination token, returned earlier via
    /// [ListCertificateRevocationListsResponse.next_page_token][google.cloud.security.privateca.v1.ListCertificateRevocationListsResponse.next_page_token].
    ///
    /// [google.cloud.security.privateca.v1.ListCertificateRevocationListsResponse.next_page_token]: crate::model::ListCertificateRevocationListsResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Only include resources that match the filter in the response.
    pub filter: std::string::String,

    /// Optional. Specify how the results should be sorted.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCertificateRevocationListsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCertificateRevocationListsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCertificateRevocationListsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCertificateRevocationListsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCertificateRevocationListsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCertificateRevocationListsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCertificateRevocationListsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.ListCertificateRevocationListsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCertificateRevocationListsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListCertificateRevocationListsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCertificateRevocationListsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCertificateRevocationListsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCertificateRevocationListsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [CertificateAuthorityService.ListCertificateRevocationLists][google.cloud.security.privateca.v1.CertificateAuthorityService.ListCertificateRevocationLists].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.ListCertificateRevocationLists]: crate::client::CertificateAuthorityService::list_certificate_revocation_lists
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCertificateRevocationListsResponse {
    /// The list of
    /// [CertificateRevocationLists][google.cloud.security.privateca.v1.CertificateRevocationList].
    ///
    /// [google.cloud.security.privateca.v1.CertificateRevocationList]: crate::model::CertificateRevocationList
    pub certificate_revocation_lists: std::vec::Vec<crate::model::CertificateRevocationList>,

    /// A token to retrieve next page of results. Pass this value in
    /// [ListCertificateRevocationListsRequest.next_page_token][] to retrieve the
    /// next page of results.
    pub next_page_token: std::string::String,

    /// A list of locations (e.g. "us-west1") that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCertificateRevocationListsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [certificate_revocation_lists][crate::model::ListCertificateRevocationListsResponse::certificate_revocation_lists].
    pub fn set_certificate_revocation_lists<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CertificateRevocationList>,
    {
        use std::iter::Iterator;
        self.certificate_revocation_lists = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCertificateRevocationListsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCertificateRevocationListsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCertificateRevocationListsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.ListCertificateRevocationListsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCertificateRevocationListsResponse {
    type PageItem = crate::model::CertificateRevocationList;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.certificate_revocation_lists
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCertificateRevocationListsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certificate_revocation_lists,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListCertificateRevocationListsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certificateRevocationLists" => {
                                Ok(__FieldTag::__certificate_revocation_lists)
                            }
                            "certificate_revocation_lists" => {
                                Ok(__FieldTag::__certificate_revocation_lists)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCertificateRevocationListsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCertificateRevocationListsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certificate_revocation_lists => {
                            if !fields.insert(__FieldTag::__certificate_revocation_lists) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_revocation_lists",
                                ));
                            }
                            result.certificate_revocation_lists = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CertificateRevocationList>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCertificateRevocationListsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.certificate_revocation_lists.is_empty() {
            state.serialize_entry(
                "certificateRevocationLists",
                &self.certificate_revocation_lists,
            )?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.UpdateCertificateRevocationList][google.cloud.security.privateca.v1.CertificateAuthorityService.UpdateCertificateRevocationList].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.UpdateCertificateRevocationList]: crate::client::CertificateAuthorityService::update_certificate_revocation_list
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateCertificateRevocationListRequest {
    /// Required.
    /// [CertificateRevocationList][google.cloud.security.privateca.v1.CertificateRevocationList]
    /// with updated values.
    ///
    /// [google.cloud.security.privateca.v1.CertificateRevocationList]: crate::model::CertificateRevocationList
    pub certificate_revocation_list: std::option::Option<crate::model::CertificateRevocationList>,

    /// Required. A list of fields to be updated in this request.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. An ID to identify requests. Specify a unique request ID so that
    /// if you must retry your request, the server will know to ignore the request
    /// if it has already been completed. The server will guarantee that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCertificateRevocationListRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [certificate_revocation_list][crate::model::UpdateCertificateRevocationListRequest::certificate_revocation_list].
    pub fn set_certificate_revocation_list<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CertificateRevocationList>,
    {
        self.certificate_revocation_list = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [certificate_revocation_list][crate::model::UpdateCertificateRevocationListRequest::certificate_revocation_list].
    pub fn set_or_clear_certificate_revocation_list<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CertificateRevocationList>,
    {
        self.certificate_revocation_list = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCertificateRevocationListRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateCertificateRevocationListRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateCertificateRevocationListRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateCertificateRevocationListRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.UpdateCertificateRevocationListRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateCertificateRevocationListRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certificate_revocation_list,
            __update_mask,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for UpdateCertificateRevocationListRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certificateRevocationList" => {
                                Ok(__FieldTag::__certificate_revocation_list)
                            }
                            "certificate_revocation_list" => {
                                Ok(__FieldTag::__certificate_revocation_list)
                            }
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateCertificateRevocationListRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCertificateRevocationListRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certificate_revocation_list => {
                            if !fields.insert(__FieldTag::__certificate_revocation_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_revocation_list",
                                ));
                            }
                            result.certificate_revocation_list = map.next_value::<std::option::Option<crate::model::CertificateRevocationList>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateCertificateRevocationListRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.certificate_revocation_list.is_some() {
            state.serialize_entry(
                "certificateRevocationList",
                &self.certificate_revocation_list,
            )?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.CreateCertificateTemplate][google.cloud.security.privateca.v1.CertificateAuthorityService.CreateCertificateTemplate].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.CreateCertificateTemplate]: crate::client::CertificateAuthorityService::create_certificate_template
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCertificateTemplateRequest {
    /// Required. The resource name of the location associated with the
    /// [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate],
    /// in the format `projects/*/locations/*`.
    ///
    /// [google.cloud.security.privateca.v1.CertificateTemplate]: crate::model::CertificateTemplate
    pub parent: std::string::String,

    /// Required. It must be unique within a location and match the regular
    /// expression `[a-zA-Z0-9_-]{1,63}`
    pub certificate_template_id: std::string::String,

    /// Required. A
    /// [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate]
    /// with initial field values.
    ///
    /// [google.cloud.security.privateca.v1.CertificateTemplate]: crate::model::CertificateTemplate
    pub certificate_template: std::option::Option<crate::model::CertificateTemplate>,

    /// Optional. An ID to identify requests. Specify a unique request ID so that
    /// if you must retry your request, the server will know to ignore the request
    /// if it has already been completed. The server will guarantee that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCertificateTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCertificateTemplateRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [certificate_template_id][crate::model::CreateCertificateTemplateRequest::certificate_template_id].
    pub fn set_certificate_template_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.certificate_template_id = v.into();
        self
    }

    /// Sets the value of [certificate_template][crate::model::CreateCertificateTemplateRequest::certificate_template].
    pub fn set_certificate_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CertificateTemplate>,
    {
        self.certificate_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [certificate_template][crate::model::CreateCertificateTemplateRequest::certificate_template].
    pub fn set_or_clear_certificate_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CertificateTemplate>,
    {
        self.certificate_template = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateCertificateTemplateRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateCertificateTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.CreateCertificateTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateCertificateTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __certificate_template_id,
            __certificate_template,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCertificateTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "certificateTemplateId" => Ok(__FieldTag::__certificate_template_id),
                            "certificate_template_id" => Ok(__FieldTag::__certificate_template_id),
                            "certificateTemplate" => Ok(__FieldTag::__certificate_template),
                            "certificate_template" => Ok(__FieldTag::__certificate_template),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateCertificateTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCertificateTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__certificate_template_id => {
                            if !fields.insert(__FieldTag::__certificate_template_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_template_id",
                                ));
                            }
                            result.certificate_template_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__certificate_template => {
                            if !fields.insert(__FieldTag::__certificate_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_template",
                                ));
                            }
                            result.certificate_template = map.next_value::<std::option::Option<crate::model::CertificateTemplate>>()?
                                ;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateCertificateTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.certificate_template_id.is_empty() {
            state.serialize_entry("certificateTemplateId", &self.certificate_template_id)?;
        }
        if self.certificate_template.is_some() {
            state.serialize_entry("certificateTemplate", &self.certificate_template)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.DeleteCertificateTemplate][google.cloud.security.privateca.v1.CertificateAuthorityService.DeleteCertificateTemplate].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.DeleteCertificateTemplate]: crate::client::CertificateAuthorityService::delete_certificate_template
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteCertificateTemplateRequest {
    /// Required. The resource name for this
    /// [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate]
    /// in the format `projects/*/locations/*/certificateTemplates/*`.
    ///
    /// [google.cloud.security.privateca.v1.CertificateTemplate]: crate::model::CertificateTemplate
    pub name: std::string::String,

    /// Optional. An ID to identify requests. Specify a unique request ID so that
    /// if you must retry your request, the server will know to ignore the request
    /// if it has already been completed. The server will guarantee that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteCertificateTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteCertificateTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteCertificateTemplateRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteCertificateTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.DeleteCertificateTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteCertificateTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteCertificateTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteCertificateTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteCertificateTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteCertificateTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.GetCertificateTemplate][google.cloud.security.privateca.v1.CertificateAuthorityService.GetCertificateTemplate].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.GetCertificateTemplate]: crate::client::CertificateAuthorityService::get_certificate_template
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCertificateTemplateRequest {
    /// Required. The
    /// [name][google.cloud.security.privateca.v1.CertificateTemplate.name] of the
    /// [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate]
    /// to get.
    ///
    /// [google.cloud.security.privateca.v1.CertificateTemplate]: crate::model::CertificateTemplate
    /// [google.cloud.security.privateca.v1.CertificateTemplate.name]: crate::model::CertificateTemplate::name
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCertificateTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCertificateTemplateRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCertificateTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.GetCertificateTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCertificateTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCertificateTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCertificateTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCertificateTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCertificateTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.ListCertificateTemplates][google.cloud.security.privateca.v1.CertificateAuthorityService.ListCertificateTemplates].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.ListCertificateTemplates]: crate::client::CertificateAuthorityService::list_certificate_templates
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCertificateTemplatesRequest {
    /// Required. The resource name of the location associated with the
    /// [CertificateTemplates][google.cloud.security.privateca.v1.CertificateTemplate],
    /// in the format `projects/*/locations/*`.
    ///
    /// [google.cloud.security.privateca.v1.CertificateTemplate]: crate::model::CertificateTemplate
    pub parent: std::string::String,

    /// Optional. Limit on the number of
    /// [CertificateTemplates][google.cloud.security.privateca.v1.CertificateTemplate]
    /// to include in the response. Further
    /// [CertificateTemplates][google.cloud.security.privateca.v1.CertificateTemplate]
    /// can subsequently be obtained by including the
    /// [ListCertificateTemplatesResponse.next_page_token][google.cloud.security.privateca.v1.ListCertificateTemplatesResponse.next_page_token]
    /// in a subsequent request. If unspecified, the server will pick an
    /// appropriate default.
    ///
    /// [google.cloud.security.privateca.v1.CertificateTemplate]: crate::model::CertificateTemplate
    /// [google.cloud.security.privateca.v1.ListCertificateTemplatesResponse.next_page_token]: crate::model::ListCertificateTemplatesResponse::next_page_token
    pub page_size: i32,

    /// Optional. Pagination token, returned earlier via
    /// [ListCertificateTemplatesResponse.next_page_token][google.cloud.security.privateca.v1.ListCertificateTemplatesResponse.next_page_token].
    ///
    /// [google.cloud.security.privateca.v1.ListCertificateTemplatesResponse.next_page_token]: crate::model::ListCertificateTemplatesResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Only include resources that match the filter in the response.
    pub filter: std::string::String,

    /// Optional. Specify how the results should be sorted.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCertificateTemplatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCertificateTemplatesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCertificateTemplatesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCertificateTemplatesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCertificateTemplatesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCertificateTemplatesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCertificateTemplatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.ListCertificateTemplatesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCertificateTemplatesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCertificateTemplatesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCertificateTemplatesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCertificateTemplatesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCertificateTemplatesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [CertificateAuthorityService.ListCertificateTemplates][google.cloud.security.privateca.v1.CertificateAuthorityService.ListCertificateTemplates].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.ListCertificateTemplates]: crate::client::CertificateAuthorityService::list_certificate_templates
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCertificateTemplatesResponse {
    /// The list of
    /// [CertificateTemplates][google.cloud.security.privateca.v1.CertificateTemplate].
    ///
    /// [google.cloud.security.privateca.v1.CertificateTemplate]: crate::model::CertificateTemplate
    pub certificate_templates: std::vec::Vec<crate::model::CertificateTemplate>,

    /// A token to retrieve next page of results. Pass this value in
    /// [ListCertificateTemplatesRequest.next_page_token][] to retrieve
    /// the next page of results.
    pub next_page_token: std::string::String,

    /// A list of locations (e.g. "us-west1") that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCertificateTemplatesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [certificate_templates][crate::model::ListCertificateTemplatesResponse::certificate_templates].
    pub fn set_certificate_templates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CertificateTemplate>,
    {
        use std::iter::Iterator;
        self.certificate_templates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCertificateTemplatesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCertificateTemplatesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCertificateTemplatesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.ListCertificateTemplatesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCertificateTemplatesResponse {
    type PageItem = crate::model::CertificateTemplate;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.certificate_templates
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCertificateTemplatesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certificate_templates,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCertificateTemplatesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certificateTemplates" => Ok(__FieldTag::__certificate_templates),
                            "certificate_templates" => Ok(__FieldTag::__certificate_templates),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCertificateTemplatesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCertificateTemplatesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certificate_templates => {
                            if !fields.insert(__FieldTag::__certificate_templates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_templates",
                                ));
                            }
                            result.certificate_templates = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CertificateTemplate>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCertificateTemplatesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.certificate_templates.is_empty() {
            state.serialize_entry("certificateTemplates", &self.certificate_templates)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CertificateAuthorityService.UpdateCertificateTemplate][google.cloud.security.privateca.v1.CertificateAuthorityService.UpdateCertificateTemplate].
///
/// [google.cloud.security.privateca.v1.CertificateAuthorityService.UpdateCertificateTemplate]: crate::client::CertificateAuthorityService::update_certificate_template
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateCertificateTemplateRequest {
    /// Required.
    /// [CertificateTemplate][google.cloud.security.privateca.v1.CertificateTemplate]
    /// with updated values.
    ///
    /// [google.cloud.security.privateca.v1.CertificateTemplate]: crate::model::CertificateTemplate
    pub certificate_template: std::option::Option<crate::model::CertificateTemplate>,

    /// Required. A list of fields to be updated in this request.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. An ID to identify requests. Specify a unique request ID so that
    /// if you must retry your request, the server will know to ignore the request
    /// if it has already been completed. The server will guarantee that for at
    /// least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCertificateTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [certificate_template][crate::model::UpdateCertificateTemplateRequest::certificate_template].
    pub fn set_certificate_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CertificateTemplate>,
    {
        self.certificate_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [certificate_template][crate::model::UpdateCertificateTemplateRequest::certificate_template].
    pub fn set_or_clear_certificate_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CertificateTemplate>,
    {
        self.certificate_template = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCertificateTemplateRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateCertificateTemplateRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateCertificateTemplateRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateCertificateTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.UpdateCertificateTemplateRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateCertificateTemplateRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __certificate_template,
            __update_mask,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateCertificateTemplateRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "certificateTemplate" => Ok(__FieldTag::__certificate_template),
                            "certificate_template" => Ok(__FieldTag::__certificate_template),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateCertificateTemplateRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCertificateTemplateRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__certificate_template => {
                            if !fields.insert(__FieldTag::__certificate_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_template",
                                ));
                            }
                            result.certificate_template = map.next_value::<std::option::Option<crate::model::CertificateTemplate>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateCertificateTemplateRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.certificate_template.is_some() {
            state.serialize_entry("certificateTemplate", &self.certificate_template)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.security.privateca.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A [RevocationReason][google.cloud.security.privateca.v1.RevocationReason]
/// indicates whether a
/// [Certificate][google.cloud.security.privateca.v1.Certificate] has been
/// revoked, and the reason for revocation. These correspond to standard
/// revocation reasons from RFC 5280. Note that the enum labels and values in
/// this definition are not the same ASN.1 values defined in RFC 5280. These
/// values will be translated to the correct ASN.1 values when a CRL is created.
///
/// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
/// [google.cloud.security.privateca.v1.RevocationReason]: crate::model::RevocationReason
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum RevocationReason {
    /// Default unspecified value. This value does indicate that a
    /// [Certificate][google.cloud.security.privateca.v1.Certificate] has been
    /// revoked, but that a reason has not been recorded.
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    Unspecified,
    /// Key material for this
    /// [Certificate][google.cloud.security.privateca.v1.Certificate] may have
    /// leaked.
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    KeyCompromise,
    /// The key material for a certificate authority in the issuing path may have
    /// leaked.
    CertificateAuthorityCompromise,
    /// The subject or other attributes in this
    /// [Certificate][google.cloud.security.privateca.v1.Certificate] have changed.
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    AffiliationChanged,
    /// This [Certificate][google.cloud.security.privateca.v1.Certificate] has been
    /// superseded.
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    Superseded,
    /// This [Certificate][google.cloud.security.privateca.v1.Certificate] or
    /// entities in the issuing path have ceased to operate.
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    CessationOfOperation,
    /// This [Certificate][google.cloud.security.privateca.v1.Certificate] should
    /// not be considered valid, it is expected that it may become valid in the
    /// future.
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    CertificateHold,
    /// This [Certificate][google.cloud.security.privateca.v1.Certificate] no
    /// longer has permission to assert the listed attributes.
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    PrivilegeWithdrawn,
    /// The authority which determines appropriate attributes for a
    /// [Certificate][google.cloud.security.privateca.v1.Certificate] may have been
    /// compromised.
    ///
    /// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
    AttributeAuthorityCompromise,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [RevocationReason::value] or
    /// [RevocationReason::name].
    UnknownValue(revocation_reason::UnknownValue),
}

#[doc(hidden)]
pub mod revocation_reason {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl RevocationReason {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::KeyCompromise => std::option::Option::Some(1),
            Self::CertificateAuthorityCompromise => std::option::Option::Some(2),
            Self::AffiliationChanged => std::option::Option::Some(3),
            Self::Superseded => std::option::Option::Some(4),
            Self::CessationOfOperation => std::option::Option::Some(5),
            Self::CertificateHold => std::option::Option::Some(6),
            Self::PrivilegeWithdrawn => std::option::Option::Some(7),
            Self::AttributeAuthorityCompromise => std::option::Option::Some(8),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("REVOCATION_REASON_UNSPECIFIED"),
            Self::KeyCompromise => std::option::Option::Some("KEY_COMPROMISE"),
            Self::CertificateAuthorityCompromise => {
                std::option::Option::Some("CERTIFICATE_AUTHORITY_COMPROMISE")
            }
            Self::AffiliationChanged => std::option::Option::Some("AFFILIATION_CHANGED"),
            Self::Superseded => std::option::Option::Some("SUPERSEDED"),
            Self::CessationOfOperation => std::option::Option::Some("CESSATION_OF_OPERATION"),
            Self::CertificateHold => std::option::Option::Some("CERTIFICATE_HOLD"),
            Self::PrivilegeWithdrawn => std::option::Option::Some("PRIVILEGE_WITHDRAWN"),
            Self::AttributeAuthorityCompromise => {
                std::option::Option::Some("ATTRIBUTE_AUTHORITY_COMPROMISE")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for RevocationReason {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for RevocationReason {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for RevocationReason {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::KeyCompromise,
            2 => Self::CertificateAuthorityCompromise,
            3 => Self::AffiliationChanged,
            4 => Self::Superseded,
            5 => Self::CessationOfOperation,
            6 => Self::CertificateHold,
            7 => Self::PrivilegeWithdrawn,
            8 => Self::AttributeAuthorityCompromise,
            _ => Self::UnknownValue(revocation_reason::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for RevocationReason {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "REVOCATION_REASON_UNSPECIFIED" => Self::Unspecified,
            "KEY_COMPROMISE" => Self::KeyCompromise,
            "CERTIFICATE_AUTHORITY_COMPROMISE" => Self::CertificateAuthorityCompromise,
            "AFFILIATION_CHANGED" => Self::AffiliationChanged,
            "SUPERSEDED" => Self::Superseded,
            "CESSATION_OF_OPERATION" => Self::CessationOfOperation,
            "CERTIFICATE_HOLD" => Self::CertificateHold,
            "PRIVILEGE_WITHDRAWN" => Self::PrivilegeWithdrawn,
            "ATTRIBUTE_AUTHORITY_COMPROMISE" => Self::AttributeAuthorityCompromise,
            _ => Self::UnknownValue(revocation_reason::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for RevocationReason {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::KeyCompromise => serializer.serialize_i32(1),
            Self::CertificateAuthorityCompromise => serializer.serialize_i32(2),
            Self::AffiliationChanged => serializer.serialize_i32(3),
            Self::Superseded => serializer.serialize_i32(4),
            Self::CessationOfOperation => serializer.serialize_i32(5),
            Self::CertificateHold => serializer.serialize_i32(6),
            Self::PrivilegeWithdrawn => serializer.serialize_i32(7),
            Self::AttributeAuthorityCompromise => serializer.serialize_i32(8),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for RevocationReason {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<RevocationReason>::new(
            ".google.cloud.security.privateca.v1.RevocationReason",
        ))
    }
}

/// Describes the way in which a
/// [Certificate][google.cloud.security.privateca.v1.Certificate]'s
/// [Subject][google.cloud.security.privateca.v1.Subject] and/or
/// [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames] will be
/// resolved.
///
/// [google.cloud.security.privateca.v1.Certificate]: crate::model::Certificate
/// [google.cloud.security.privateca.v1.Subject]: crate::model::Subject
/// [google.cloud.security.privateca.v1.SubjectAltNames]: crate::model::SubjectAltNames
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SubjectRequestMode {
    /// Not specified.
    Unspecified,
    /// The default mode used in most cases. Indicates that the certificate's
    /// [Subject][google.cloud.security.privateca.v1.Subject] and/or
    /// [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames] are
    /// specified in the certificate request. This mode requires the caller to have
    /// the `privateca.certificates.create` permission.
    ///
    /// [google.cloud.security.privateca.v1.Subject]: crate::model::Subject
    /// [google.cloud.security.privateca.v1.SubjectAltNames]: crate::model::SubjectAltNames
    Default,
    /// A mode reserved for special cases. Indicates that the certificate should
    /// have one SPIFFE
    /// [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames] set
    /// by the service based on the caller's identity. This mode will ignore any
    /// explicitly specified [Subject][google.cloud.security.privateca.v1.Subject]
    /// and/or
    /// [SubjectAltNames][google.cloud.security.privateca.v1.SubjectAltNames] in
    /// the certificate request. This mode requires the caller to have the
    /// `privateca.certificates.createForSelf` permission.
    ///
    /// [google.cloud.security.privateca.v1.Subject]: crate::model::Subject
    /// [google.cloud.security.privateca.v1.SubjectAltNames]: crate::model::SubjectAltNames
    ReflectedSpiffe,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SubjectRequestMode::value] or
    /// [SubjectRequestMode::name].
    UnknownValue(subject_request_mode::UnknownValue),
}

#[doc(hidden)]
pub mod subject_request_mode {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SubjectRequestMode {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Default => std::option::Option::Some(1),
            Self::ReflectedSpiffe => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SUBJECT_REQUEST_MODE_UNSPECIFIED"),
            Self::Default => std::option::Option::Some("DEFAULT"),
            Self::ReflectedSpiffe => std::option::Option::Some("REFLECTED_SPIFFE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SubjectRequestMode {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SubjectRequestMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SubjectRequestMode {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Default,
            2 => Self::ReflectedSpiffe,
            _ => Self::UnknownValue(subject_request_mode::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SubjectRequestMode {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SUBJECT_REQUEST_MODE_UNSPECIFIED" => Self::Unspecified,
            "DEFAULT" => Self::Default,
            "REFLECTED_SPIFFE" => Self::ReflectedSpiffe,
            _ => Self::UnknownValue(subject_request_mode::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SubjectRequestMode {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Default => serializer.serialize_i32(1),
            Self::ReflectedSpiffe => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SubjectRequestMode {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SubjectRequestMode>::new(
            ".google.cloud.security.privateca.v1.SubjectRequestMode",
        ))
    }
}
