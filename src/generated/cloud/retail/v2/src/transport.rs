// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

use crate::Result;
#[allow(unused_imports)]
use gax::error::Error;

/// Implements [AnalyticsService](super::stub::AnalyticsService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct AnalyticsService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for AnalyticsService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("AnalyticsService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl AnalyticsService {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::AnalyticsService for AnalyticsService {
    async fn export_analytics_metrics(
        &self,
        req: crate::model::ExportAnalyticsMetricsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}:exportAnalyticsMetrics", req.catalog),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}/operations", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [CatalogService](super::stub::CatalogService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct CatalogService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for CatalogService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("CatalogService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl CatalogService {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::CatalogService for CatalogService {
    async fn list_catalogs(
        &self,
        req: crate::model::ListCatalogsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListCatalogsResponse>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}/catalogs", req.parent))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_catalog(
        &self,
        req: crate::model::UpdateCatalogRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Catalog>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::PATCH.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::PATCH,
                format!(
                    "/v2/{}",
                    req.catalog
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("catalog"))?
                        .name
                ),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .iter()
            .flat_map(|p| p.paths.iter())
            .fold(builder, |builder, v| builder.query(&[("updateMask", v)]));
        self.inner
            .execute(builder, Some(req.catalog), options)
            .await
    }

    async fn set_default_branch(
        &self,
        req: crate::model::SetDefaultBranchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}:setDefaultBranch", req.catalog),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }

    async fn get_default_branch(
        &self,
        req: crate::model::GetDefaultBranchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GetDefaultBranchResponse>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v2/{}:getDefaultBranch", req.catalog),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_completion_config(
        &self,
        req: crate::model::GetCompletionConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CompletionConfig>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_completion_config(
        &self,
        req: crate::model::UpdateCompletionConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CompletionConfig>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::PATCH.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::PATCH,
                format!(
                    "/v2/{}",
                    req.completion_config
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("completion_config"))?
                        .name
                ),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .iter()
            .flat_map(|p| p.paths.iter())
            .fold(builder, |builder, v| builder.query(&[("updateMask", v)]));
        self.inner
            .execute(builder, Some(req.completion_config), options)
            .await
    }

    async fn get_attributes_config(
        &self,
        req: crate::model::GetAttributesConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AttributesConfig>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_attributes_config(
        &self,
        req: crate::model::UpdateAttributesConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AttributesConfig>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::PATCH.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::PATCH,
                format!(
                    "/v2/{}",
                    req.attributes_config
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("attributes_config"))?
                        .name
                ),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .iter()
            .flat_map(|p| p.paths.iter())
            .fold(builder, |builder, v| builder.query(&[("updateMask", v)]));
        self.inner
            .execute(builder, Some(req.attributes_config), options)
            .await
    }

    async fn add_catalog_attribute(
        &self,
        req: crate::model::AddCatalogAttributeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AttributesConfig>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}:addCatalogAttribute", req.attributes_config),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn remove_catalog_attribute(
        &self,
        req: crate::model::RemoveCatalogAttributeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AttributesConfig>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}:removeCatalogAttribute", req.attributes_config),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn replace_catalog_attribute(
        &self,
        req: crate::model::ReplaceCatalogAttributeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AttributesConfig>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}:replaceCatalogAttribute", req.attributes_config),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}/operations", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }
}

/// Implements [CompletionService](super::stub::CompletionService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct CompletionService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for CompletionService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("CompletionService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl CompletionService {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::CompletionService for CompletionService {
    async fn complete_query(
        &self,
        req: crate::model::CompleteQueryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CompleteQueryResponse>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v2/{}:completeQuery", req.catalog),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("query", &req.query)]);
        let builder = builder.query(&[("visitorId", &req.visitor_id)]);
        let builder = req
            .language_codes
            .iter()
            .fold(builder, |builder, p| builder.query(&[("languageCodes", p)]));
        let builder = builder.query(&[("deviceType", &req.device_type)]);
        let builder = builder.query(&[("dataset", &req.dataset)]);
        let builder = builder.query(&[("maxSuggestions", &req.max_suggestions)]);
        let builder = builder.query(&[(
            "enableAttributeSuggestions",
            &req.enable_attribute_suggestions,
        )]);
        let builder = builder.query(&[("entity", &req.entity)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn import_completion_data(
        &self,
        req: crate::model::ImportCompletionDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}/completionData:import", req.parent),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}/operations", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [ControlService](super::stub::ControlService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct ControlService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for ControlService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ControlService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl ControlService {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::ControlService for ControlService {
    async fn create_control(
        &self,
        req: crate::model::CreateControlRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Control>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}/controls", req.parent),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("controlId", &req.control_id)]);
        self.inner
            .execute(builder, Some(req.control), options)
            .await
    }

    async fn delete_control(
        &self,
        req: crate::model::DeleteControlRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::DELETE.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, format!("/v2/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn update_control(
        &self,
        req: crate::model::UpdateControlRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Control>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::PATCH.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::PATCH,
                format!(
                    "/v2/{}",
                    req.control
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("control"))?
                        .name
                ),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .iter()
            .flat_map(|p| p.paths.iter())
            .fold(builder, |builder, v| builder.query(&[("updateMask", v)]));
        self.inner
            .execute(builder, Some(req.control), options)
            .await
    }

    async fn get_control(
        &self,
        req: crate::model::GetControlRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Control>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_controls(
        &self,
        req: crate::model::ListControlsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListControlsResponse>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}/controls", req.parent))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}/operations", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }
}

/// Implements [GenerativeQuestionService](super::stub::GenerativeQuestionService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct GenerativeQuestionService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for GenerativeQuestionService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("GenerativeQuestionService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl GenerativeQuestionService {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::GenerativeQuestionService for GenerativeQuestionService {
    async fn update_generative_questions_feature_config(
        &self,
        req: crate::model::UpdateGenerativeQuestionsFeatureConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerativeQuestionsFeatureConfig>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::PATCH.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::PATCH,
                format!(
                    "/v2/{}/generativeQuestionFeature",
                    req.generative_questions_feature_config
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing(
                            "generative_questions_feature_config"
                        ))?
                        .catalog
                ),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .iter()
            .flat_map(|p| p.paths.iter())
            .fold(builder, |builder, v| builder.query(&[("updateMask", v)]));
        self.inner
            .execute(
                builder,
                Some(req.generative_questions_feature_config),
                options,
            )
            .await
    }

    async fn get_generative_questions_feature_config(
        &self,
        req: crate::model::GetGenerativeQuestionsFeatureConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerativeQuestionsFeatureConfig>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v2/{}/generativeQuestionFeature", req.catalog),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_generative_question_configs(
        &self,
        req: crate::model::ListGenerativeQuestionConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListGenerativeQuestionConfigsResponse>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v2/{}/generativeQuestions", req.parent),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_generative_question_config(
        &self,
        req: crate::model::UpdateGenerativeQuestionConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerativeQuestionConfig>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::PATCH.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::PATCH,
                format!(
                    "/v2/{}/generativeQuestion",
                    req.generative_question_config
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("generative_question_config"))?
                        .catalog
                ),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .iter()
            .flat_map(|p| p.paths.iter())
            .fold(builder, |builder, v| builder.query(&[("updateMask", v)]));
        self.inner
            .execute(builder, Some(req.generative_question_config), options)
            .await
    }

    async fn batch_update_generative_question_configs(
        &self,
        req: crate::model::BatchUpdateGenerativeQuestionConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BatchUpdateGenerativeQuestionConfigsResponse>>
    {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}/generativeQuestion:batchUpdate", req.parent),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}/operations", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }
}

/// Implements [ModelService](super::stub::ModelService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct ModelService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for ModelService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ModelService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl ModelService {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::ModelService for ModelService {
    async fn create_model(
        &self,
        req: crate::model::CreateModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, format!("/v2/{}/models", req.parent))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("dryRun", &req.dry_run)]);
        self.inner.execute(builder, Some(req.model), options).await
    }

    async fn get_model(
        &self,
        req: crate::model::GetModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Model>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn pause_model(
        &self,
        req: crate::model::PauseModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Model>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, format!("/v2/{}:pause", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn resume_model(
        &self,
        req: crate::model::ResumeModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Model>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, format!("/v2/{}:resume", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn delete_model(
        &self,
        req: crate::model::DeleteModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::DELETE.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, format!("/v2/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn list_models(
        &self,
        req: crate::model::ListModelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListModelsResponse>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}/models", req.parent))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_model(
        &self,
        req: crate::model::UpdateModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Model>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::PATCH.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::PATCH,
                format!(
                    "/v2/{}",
                    req.model
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("model"))?
                        .name
                ),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .iter()
            .flat_map(|p| p.paths.iter())
            .fold(builder, |builder, v| builder.query(&[("updateMask", v)]));
        self.inner.execute(builder, Some(req.model), options).await
    }

    async fn tune_model(
        &self,
        req: crate::model::TuneModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::POST, format!("/v2/{}:tune", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}/operations", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [PredictionService](super::stub::PredictionService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct PredictionService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for PredictionService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("PredictionService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl PredictionService {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::PredictionService for PredictionService {
    async fn predict(
        &self,
        req: crate::model::PredictRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PredictResponse>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}:predict", req.placement),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}/operations", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }
}

/// Implements [ProductService](super::stub::ProductService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct ProductService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for ProductService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ProductService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl ProductService {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::ProductService for ProductService {
    async fn create_product(
        &self,
        req: crate::model::CreateProductRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Product>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}/products", req.parent),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("productId", &req.product_id)]);
        self.inner
            .execute(builder, Some(req.product), options)
            .await
    }

    async fn get_product(
        &self,
        req: crate::model::GetProductRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Product>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_products(
        &self,
        req: crate::model::ListProductsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListProductsResponse>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}/products", req.parent))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = req
            .read_mask
            .as_ref()
            .iter()
            .flat_map(|p| p.paths.iter())
            .fold(builder, |builder, v| builder.query(&[("readMask", v)]));
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_product(
        &self,
        req: crate::model::UpdateProductRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Product>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::PATCH.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::PATCH,
                format!(
                    "/v2/{}",
                    req.product
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("product"))?
                        .name
                ),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .iter()
            .flat_map(|p| p.paths.iter())
            .fold(builder, |builder, v| builder.query(&[("updateMask", v)]));
        let builder = builder.query(&[("allowMissing", &req.allow_missing)]);
        self.inner
            .execute(builder, Some(req.product), options)
            .await
    }

    async fn delete_product(
        &self,
        req: crate::model::DeleteProductRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::DELETE.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, format!("/v2/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn purge_products(
        &self,
        req: crate::model::PurgeProductsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}/products:purge", req.parent),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn import_products(
        &self,
        req: crate::model::ImportProductsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}/products:import", req.parent),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn set_inventory(
        &self,
        req: crate::model::SetInventoryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!(
                    "/v2/{}:setInventory",
                    req.inventory
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("inventory"))?
                        .name
                ),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn add_fulfillment_places(
        &self,
        req: crate::model::AddFulfillmentPlacesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}:addFulfillmentPlaces", req.product),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn remove_fulfillment_places(
        &self,
        req: crate::model::RemoveFulfillmentPlacesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}:removeFulfillmentPlaces", req.product),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn add_local_inventories(
        &self,
        req: crate::model::AddLocalInventoriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}:addLocalInventories", req.product),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn remove_local_inventories(
        &self,
        req: crate::model::RemoveLocalInventoriesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}:removeLocalInventories", req.product),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}/operations", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [SearchService](super::stub::SearchService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SearchService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SearchService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SearchService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SearchService {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SearchService for SearchService {
    async fn search(
        &self,
        req: crate::model::SearchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchResponse>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}:search", req.placement),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}/operations", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }
}

/// Implements [ServingConfigService](super::stub::ServingConfigService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct ServingConfigService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for ServingConfigService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ServingConfigService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl ServingConfigService {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::ServingConfigService for ServingConfigService {
    async fn create_serving_config(
        &self,
        req: crate::model::CreateServingConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServingConfig>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}/servingConfigs", req.parent),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("servingConfigId", &req.serving_config_id)]);
        self.inner
            .execute(builder, Some(req.serving_config), options)
            .await
    }

    async fn delete_serving_config(
        &self,
        req: crate::model::DeleteServingConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::DELETE.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, format!("/v2/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn update_serving_config(
        &self,
        req: crate::model::UpdateServingConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServingConfig>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::PATCH.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::PATCH,
                format!(
                    "/v2/{}",
                    req.serving_config
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("serving_config"))?
                        .name
                ),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .iter()
            .flat_map(|p| p.paths.iter())
            .fold(builder, |builder, v| builder.query(&[("updateMask", v)]));
        self.inner
            .execute(builder, Some(req.serving_config), options)
            .await
    }

    async fn get_serving_config(
        &self,
        req: crate::model::GetServingConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServingConfig>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_serving_configs(
        &self,
        req: crate::model::ListServingConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListServingConfigsResponse>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v2/{}/servingConfigs", req.parent),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn add_control(
        &self,
        req: crate::model::AddControlRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServingConfig>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}:addControl", req.serving_config),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn remove_control(
        &self,
        req: crate::model::RemoveControlRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServingConfig>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}:removeControl", req.serving_config),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}/operations", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }
}

/// Implements [UserEventService](super::stub::UserEventService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct UserEventService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for UserEventService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("UserEventService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl UserEventService {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::UserEventService for UserEventService {
    async fn write_user_event(
        &self,
        req: crate::model::WriteUserEventRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UserEvent>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}/userEvents:write", req.parent),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("writeAsync", &req.write_async)]);
        self.inner
            .execute(builder, Some(req.user_event), options)
            .await
    }

    async fn collect_user_event(
        &self,
        req: crate::model::CollectUserEventRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<api::model::HttpBody>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v2/{}/userEvents:collect", req.parent),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .prebuilt_rule()
            .iter()
            .fold(builder, |builder, p| builder.query(&[("prebuiltRule", p)]));
        let builder = builder.query(&[("userEvent", &req.user_event)]);
        let builder = builder.query(&[("uri", &req.uri)]);
        let builder = builder.query(&[("ets", &req.ets)]);
        let builder = builder.query(&[("rawJson", &req.raw_json)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn purge_user_events(
        &self,
        req: crate::model::PurgeUserEventsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}/userEvents:purge", req.parent),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn import_user_events(
        &self,
        req: crate::model::ImportUserEventsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}/userEvents:import", req.parent),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn rejoin_user_events(
        &self,
        req: crate::model::RejoinUserEventsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::POST.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v2/{}/userEvents:rejoin", req.parent),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}/operations", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(
            options,
            reqwest::Method::GET.is_idempotent(),
        );
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v2/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}
