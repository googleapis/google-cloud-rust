// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
#![allow(rustdoc::broken_intra_doc_links)]

use crate::Result;
use std::sync::Arc;

/// Implements a client for the Vertex AI Search for Retail API.
///
/// # Service Description
///
/// Service for managing & accessing retail search business metric.
/// Retail recommendation business metric is currently not available.
///
/// # Configuration
///
/// `AnalyticsService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `AnalyticsService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `AnalyticsService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct AnalyticsService {
    inner: Arc<dyn crate::stubs::dynamic::AnalyticsService>,
}

impl AnalyticsService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::AnalyticsService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::AnalyticsService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::AnalyticsService> {
        crate::transport::AnalyticsService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::AnalyticsService> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::AnalyticsService::new)
    }

    /// Exports analytics metrics.
    ///
    /// `Operation.response` is of type `ExportAnalyticsMetricsResponse`.
    /// `Operation.metadata` is of type `ExportMetadata`.
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::ExportAnalyticsMetricsResponse, model::ExportMetadata>
    /// ) -> Result<model::ExportAnalyticsMetricsResponse> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::ExportAnalyticsMetricsResponse, model::ExportMetadata>
    /// ) -> Result<model::ExportAnalyticsMetricsResponse> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::ExportAnalyticsMetricsResponse] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::ExportMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::analytics_service::ExportAnalyticsMetrics::send
    /// [poller()]: crate::builders::analytics_service::ExportAnalyticsMetrics::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn export_analytics_metrics(
        &self,
        catalog: impl Into<std::string::String>,
    ) -> crate::builders::analytics_service::ExportAnalyticsMetrics {
        crate::builders::analytics_service::ExportAnalyticsMetrics::new(self.inner.clone())
            .set_catalog(catalog.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn list_operations(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::analytics_service::ListOperations {
        crate::builders::analytics_service::ListOperations::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::analytics_service::GetOperation {
        crate::builders::analytics_service::GetOperation::new(self.inner.clone())
            .set_name(name.into())
    }
}

/// Implements a client for the Vertex AI Search for Retail API.
///
/// # Service Description
///
/// Service for managing catalog configuration.
///
/// # Configuration
///
/// `CatalogService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `CatalogService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `CatalogService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct CatalogService {
    inner: Arc<dyn crate::stubs::dynamic::CatalogService>,
}

impl CatalogService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::CatalogService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::CatalogService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::CatalogService> {
        crate::transport::CatalogService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::CatalogService> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::CatalogService::new)
    }

    /// Lists all the [Catalog][google.cloud.retail.v2.Catalog]s associated with
    /// the project.
    ///
    /// [google.cloud.retail.v2.Catalog]: crate::model::Catalog
    pub fn list_catalogs(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::catalog_service::ListCatalogs {
        crate::builders::catalog_service::ListCatalogs::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Updates the [Catalog][google.cloud.retail.v2.Catalog]s.
    ///
    /// [google.cloud.retail.v2.Catalog]: crate::model::Catalog
    pub fn update_catalog(
        &self,
        catalog: impl Into<crate::model::Catalog>,
    ) -> crate::builders::catalog_service::UpdateCatalog {
        crate::builders::catalog_service::UpdateCatalog::new(self.inner.clone())
            .set_catalog(catalog.into())
    }

    /// Set a specified branch id as default branch. API methods such as
    /// [SearchService.Search][google.cloud.retail.v2.SearchService.Search],
    /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct],
    /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts]
    /// will treat requests using "default_branch" to the actual branch id set as
    /// default.
    ///
    /// For example, if `projects/*/locations/*/catalogs/*/branches/1` is set as
    /// default, setting
    /// [SearchRequest.branch][google.cloud.retail.v2.SearchRequest.branch] to
    /// `projects/*/locations/*/catalogs/*/branches/default_branch` is equivalent
    /// to setting
    /// [SearchRequest.branch][google.cloud.retail.v2.SearchRequest.branch] to
    /// `projects/*/locations/*/catalogs/*/branches/1`.
    ///
    /// Using multiple branches can be useful when developers would like
    /// to have a staging branch to test and verify for future usage. When it
    /// becomes ready, developers switch on the staging branch using this API while
    /// keeping using `projects/*/locations/*/catalogs/*/branches/default_branch`
    /// as [SearchRequest.branch][google.cloud.retail.v2.SearchRequest.branch] to
    /// route the traffic to this staging branch.
    ///
    /// CAUTION: If you have live predict/search traffic, switching the default
    /// branch could potentially cause outages if the ID space of the new branch is
    /// very different from the old one.
    ///
    /// More specifically:
    ///
    /// * PredictionService will only return product IDs from branch {newBranch}.
    /// * SearchService will only return product IDs from branch {newBranch}
    ///   (if branch is not explicitly set).
    /// * UserEventService will only join events with products from branch
    ///   {newBranch}.
    ///
    /// [google.cloud.retail.v2.ProductService.GetProduct]: crate::client::ProductService::get_product
    /// [google.cloud.retail.v2.ProductService.ListProducts]: crate::client::ProductService::list_products
    /// [google.cloud.retail.v2.SearchRequest.branch]: crate::model::SearchRequest::branch
    /// [google.cloud.retail.v2.SearchService.Search]: crate::client::SearchService::search
    pub fn set_default_branch(
        &self,
        catalog: impl Into<std::string::String>,
    ) -> crate::builders::catalog_service::SetDefaultBranch {
        crate::builders::catalog_service::SetDefaultBranch::new(self.inner.clone())
            .set_catalog(catalog.into())
    }

    /// Get which branch is currently default branch set by
    /// [CatalogService.SetDefaultBranch][google.cloud.retail.v2.CatalogService.SetDefaultBranch]
    /// method under a specified parent catalog.
    ///
    /// [google.cloud.retail.v2.CatalogService.SetDefaultBranch]: crate::client::CatalogService::set_default_branch
    pub fn get_default_branch(
        &self,
        catalog: impl Into<std::string::String>,
    ) -> crate::builders::catalog_service::GetDefaultBranch {
        crate::builders::catalog_service::GetDefaultBranch::new(self.inner.clone())
            .set_catalog(catalog.into())
    }

    /// Gets a [CompletionConfig][google.cloud.retail.v2.CompletionConfig].
    ///
    /// [google.cloud.retail.v2.CompletionConfig]: crate::model::CompletionConfig
    pub fn get_completion_config(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::catalog_service::GetCompletionConfig {
        crate::builders::catalog_service::GetCompletionConfig::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Updates the [CompletionConfig][google.cloud.retail.v2.CompletionConfig]s.
    ///
    /// [google.cloud.retail.v2.CompletionConfig]: crate::model::CompletionConfig
    pub fn update_completion_config(
        &self,
        completion_config: impl Into<crate::model::CompletionConfig>,
    ) -> crate::builders::catalog_service::UpdateCompletionConfig {
        crate::builders::catalog_service::UpdateCompletionConfig::new(self.inner.clone())
            .set_completion_config(completion_config.into())
    }

    /// Gets an [AttributesConfig][google.cloud.retail.v2.AttributesConfig].
    ///
    /// [google.cloud.retail.v2.AttributesConfig]: crate::model::AttributesConfig
    pub fn get_attributes_config(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::catalog_service::GetAttributesConfig {
        crate::builders::catalog_service::GetAttributesConfig::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Updates the [AttributesConfig][google.cloud.retail.v2.AttributesConfig].
    ///
    /// The catalog attributes in the request will be updated in the catalog, or
    /// inserted if they do not exist. Existing catalog attributes not included in
    /// the request will remain unchanged. Attributes that are assigned to
    /// products, but do not exist at the catalog level, are always included in the
    /// response. The product attribute is assigned default values for missing
    /// catalog attribute fields, e.g., searchable and dynamic facetable options.
    ///
    /// [google.cloud.retail.v2.AttributesConfig]: crate::model::AttributesConfig
    pub fn update_attributes_config(
        &self,
        attributes_config: impl Into<crate::model::AttributesConfig>,
    ) -> crate::builders::catalog_service::UpdateAttributesConfig {
        crate::builders::catalog_service::UpdateAttributesConfig::new(self.inner.clone())
            .set_attributes_config(attributes_config.into())
    }

    /// Adds the specified
    /// [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] to the
    /// [AttributesConfig][google.cloud.retail.v2.AttributesConfig].
    ///
    /// If the [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] to add
    /// already exists, an ALREADY_EXISTS error is returned.
    ///
    /// [google.cloud.retail.v2.AttributesConfig]: crate::model::AttributesConfig
    /// [google.cloud.retail.v2.CatalogAttribute]: crate::model::CatalogAttribute
    pub fn add_catalog_attribute(
        &self,
        attributes_config: impl Into<std::string::String>,
    ) -> crate::builders::catalog_service::AddCatalogAttribute {
        crate::builders::catalog_service::AddCatalogAttribute::new(self.inner.clone())
            .set_attributes_config(attributes_config.into())
    }

    /// Removes the specified
    /// [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] from the
    /// [AttributesConfig][google.cloud.retail.v2.AttributesConfig].
    ///
    /// If the [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] to
    /// remove does not exist, a NOT_FOUND error is returned.
    ///
    /// [google.cloud.retail.v2.AttributesConfig]: crate::model::AttributesConfig
    /// [google.cloud.retail.v2.CatalogAttribute]: crate::model::CatalogAttribute
    pub fn remove_catalog_attribute(
        &self,
        attributes_config: impl Into<std::string::String>,
    ) -> crate::builders::catalog_service::RemoveCatalogAttribute {
        crate::builders::catalog_service::RemoveCatalogAttribute::new(self.inner.clone())
            .set_attributes_config(attributes_config.into())
    }

    /// Replaces the specified
    /// [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] in the
    /// [AttributesConfig][google.cloud.retail.v2.AttributesConfig] by updating the
    /// catalog attribute with the same
    /// [CatalogAttribute.key][google.cloud.retail.v2.CatalogAttribute.key].
    ///
    /// If the [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] to
    /// replace does not exist, a NOT_FOUND error is returned.
    ///
    /// [google.cloud.retail.v2.AttributesConfig]: crate::model::AttributesConfig
    /// [google.cloud.retail.v2.CatalogAttribute]: crate::model::CatalogAttribute
    /// [google.cloud.retail.v2.CatalogAttribute.key]: crate::model::CatalogAttribute::key
    pub fn replace_catalog_attribute(
        &self,
        attributes_config: impl Into<std::string::String>,
    ) -> crate::builders::catalog_service::ReplaceCatalogAttribute {
        crate::builders::catalog_service::ReplaceCatalogAttribute::new(self.inner.clone())
            .set_attributes_config(attributes_config.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn list_operations(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::catalog_service::ListOperations {
        crate::builders::catalog_service::ListOperations::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::catalog_service::GetOperation {
        crate::builders::catalog_service::GetOperation::new(self.inner.clone())
            .set_name(name.into())
    }
}

/// Implements a client for the Vertex AI Search for Retail API.
///
/// # Service Description
///
/// Autocomplete service for retail.
///
/// This feature is only available for users who have Retail Search enabled.
/// Enable Retail Search on Cloud Console before using this feature.
///
/// # Configuration
///
/// `CompletionService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `CompletionService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `CompletionService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct CompletionService {
    inner: Arc<dyn crate::stubs::dynamic::CompletionService>,
}

impl CompletionService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::CompletionService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::CompletionService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::CompletionService> {
        crate::transport::CompletionService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::CompletionService> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::CompletionService::new)
    }

    /// Completes the specified prefix with keyword suggestions.
    ///
    /// This feature is only available for users who have Retail Search enabled.
    /// Enable Retail Search on Cloud Console before using this feature.
    pub fn complete_query(
        &self,
        catalog: impl Into<std::string::String>,
    ) -> crate::builders::completion_service::CompleteQuery {
        crate::builders::completion_service::CompleteQuery::new(self.inner.clone())
            .set_catalog(catalog.into())
    }

    /// Bulk import of processed completion dataset.
    ///
    /// Request processing is asynchronous. Partial updating is not supported.
    ///
    /// The operation is successfully finished only after the imported suggestions
    /// are indexed successfully and ready for serving. The process takes hours.
    ///
    /// This feature is only available for users who have Retail Search enabled.
    /// Enable Retail Search on Cloud Console before using this feature.
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::ImportCompletionDataResponse, model::ImportMetadata>
    /// ) -> Result<model::ImportCompletionDataResponse> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::ImportCompletionDataResponse, model::ImportMetadata>
    /// ) -> Result<model::ImportCompletionDataResponse> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::ImportCompletionDataResponse] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::ImportMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::completion_service::ImportCompletionData::send
    /// [poller()]: crate::builders::completion_service::ImportCompletionData::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn import_completion_data(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::completion_service::ImportCompletionData {
        crate::builders::completion_service::ImportCompletionData::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn list_operations(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::completion_service::ListOperations {
        crate::builders::completion_service::ListOperations::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::completion_service::GetOperation {
        crate::builders::completion_service::GetOperation::new(self.inner.clone())
            .set_name(name.into())
    }
}

/// Implements a client for the Vertex AI Search for Retail API.
///
/// # Service Description
///
/// Service for modifying Control.
///
/// # Configuration
///
/// `ControlService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `ControlService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ControlService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct ControlService {
    inner: Arc<dyn crate::stubs::dynamic::ControlService>,
}

impl ControlService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::ControlService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::ControlService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::ControlService> {
        crate::transport::ControlService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::ControlService> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::ControlService::new)
    }

    /// Creates a Control.
    ///
    /// If the [Control][google.cloud.retail.v2.Control] to create already exists,
    /// an ALREADY_EXISTS error is returned.
    ///
    /// [google.cloud.retail.v2.Control]: crate::model::Control
    pub fn create_control(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::control_service::CreateControl {
        crate::builders::control_service::CreateControl::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Deletes a Control.
    ///
    /// If the [Control][google.cloud.retail.v2.Control] to delete does not exist,
    /// a NOT_FOUND error is returned.
    ///
    /// [google.cloud.retail.v2.Control]: crate::model::Control
    pub fn delete_control(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::control_service::DeleteControl {
        crate::builders::control_service::DeleteControl::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Updates a Control.
    ///
    /// [Control][google.cloud.retail.v2.Control] cannot be set to a different
    /// oneof field, if so an INVALID_ARGUMENT is returned. If the
    /// [Control][google.cloud.retail.v2.Control] to update does not exist, a
    /// NOT_FOUND error is returned.
    ///
    /// [google.cloud.retail.v2.Control]: crate::model::Control
    pub fn update_control(
        &self,
        control: impl Into<crate::model::Control>,
    ) -> crate::builders::control_service::UpdateControl {
        crate::builders::control_service::UpdateControl::new(self.inner.clone())
            .set_control(control.into())
    }

    /// Gets a Control.
    pub fn get_control(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::control_service::GetControl {
        crate::builders::control_service::GetControl::new(self.inner.clone()).set_name(name.into())
    }

    /// Lists all Controls by their parent
    /// [Catalog][google.cloud.retail.v2.Catalog].
    ///
    /// [google.cloud.retail.v2.Catalog]: crate::model::Catalog
    pub fn list_controls(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::control_service::ListControls {
        crate::builders::control_service::ListControls::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn list_operations(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::control_service::ListOperations {
        crate::builders::control_service::ListOperations::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::control_service::GetOperation {
        crate::builders::control_service::GetOperation::new(self.inner.clone())
            .set_name(name.into())
    }
}

/// Implements a client for the Vertex AI Search for Retail API.
///
/// # Service Description
///
/// Service for managing LLM generated questions in search serving.
///
/// # Configuration
///
/// `GenerativeQuestionService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `GenerativeQuestionService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `GenerativeQuestionService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct GenerativeQuestionService {
    inner: Arc<dyn crate::stubs::dynamic::GenerativeQuestionService>,
}

impl GenerativeQuestionService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::GenerativeQuestionService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::GenerativeQuestionService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::GenerativeQuestionService> {
        crate::transport::GenerativeQuestionService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::GenerativeQuestionService> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::GenerativeQuestionService::new)
    }

    /// Manages overal generative question feature state -- enables toggling
    /// feature on and off.
    pub fn update_generative_questions_feature_config(
        &self,
        generative_questions_feature_config: impl Into<crate::model::GenerativeQuestionsFeatureConfig>,
    ) -> crate::builders::generative_question_service::UpdateGenerativeQuestionsFeatureConfig {
        crate::builders::generative_question_service::UpdateGenerativeQuestionsFeatureConfig::new(
            self.inner.clone(),
        )
        .set_generative_questions_feature_config(generative_questions_feature_config.into())
    }

    /// Manages overal generative question feature state -- enables toggling
    /// feature on and off.
    pub fn get_generative_questions_feature_config(
        &self,
        catalog: impl Into<std::string::String>,
    ) -> crate::builders::generative_question_service::GetGenerativeQuestionsFeatureConfig {
        crate::builders::generative_question_service::GetGenerativeQuestionsFeatureConfig::new(
            self.inner.clone(),
        )
        .set_catalog(catalog.into())
    }

    /// Returns all questions for a given catalog.
    pub fn list_generative_question_configs(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::generative_question_service::ListGenerativeQuestionConfigs {
        crate::builders::generative_question_service::ListGenerativeQuestionConfigs::new(
            self.inner.clone(),
        )
        .set_parent(parent.into())
    }

    /// Allows management of individual questions.
    pub fn update_generative_question_config(
        &self,
        generative_question_config: impl Into<crate::model::GenerativeQuestionConfig>,
    ) -> crate::builders::generative_question_service::UpdateGenerativeQuestionConfig {
        crate::builders::generative_question_service::UpdateGenerativeQuestionConfig::new(
            self.inner.clone(),
        )
        .set_generative_question_config(generative_question_config.into())
    }

    /// Allows management of multiple questions.
    pub fn batch_update_generative_question_configs(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::generative_question_service::BatchUpdateGenerativeQuestionConfigs {
        crate::builders::generative_question_service::BatchUpdateGenerativeQuestionConfigs::new(
            self.inner.clone(),
        )
        .set_parent(parent.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn list_operations(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::generative_question_service::ListOperations {
        crate::builders::generative_question_service::ListOperations::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::generative_question_service::GetOperation {
        crate::builders::generative_question_service::GetOperation::new(self.inner.clone())
            .set_name(name.into())
    }
}

/// Implements a client for the Vertex AI Search for Retail API.
///
/// # Service Description
///
/// Service for performing CRUD operations on models.
/// Recommendation models contain all the metadata necessary to generate a set of
/// models for the `Predict()` API. A model is queried
/// indirectly via a ServingConfig, which associates a model with a
/// given Placement (e.g. Frequently Bought Together on Home Page).
///
/// This service allows you to do the following:
///
/// * Initiate training of a model.
/// * Pause training of an existing model.
/// * List all the available models along with their metadata.
/// * Control their tuning schedule.
///
/// # Configuration
///
/// `ModelService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `ModelService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ModelService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct ModelService {
    inner: Arc<dyn crate::stubs::dynamic::ModelService>,
}

impl ModelService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::ModelService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::ModelService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::ModelService> {
        crate::transport::ModelService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::ModelService> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::ModelService::new)
    }

    /// Creates a new model.
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::Model, model::CreateModelMetadata>
    /// ) -> Result<model::Model> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::Model, model::CreateModelMetadata>
    /// ) -> Result<model::Model> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::Model] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::CreateModelMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::model_service::CreateModel::send
    /// [poller()]: crate::builders::model_service::CreateModel::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn create_model(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::model_service::CreateModel {
        crate::builders::model_service::CreateModel::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Gets a model.
    pub fn get_model(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::model_service::GetModel {
        crate::builders::model_service::GetModel::new(self.inner.clone()).set_name(name.into())
    }

    /// Pauses the training of an existing model.
    pub fn pause_model(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::model_service::PauseModel {
        crate::builders::model_service::PauseModel::new(self.inner.clone()).set_name(name.into())
    }

    /// Resumes the training of an existing model.
    pub fn resume_model(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::model_service::ResumeModel {
        crate::builders::model_service::ResumeModel::new(self.inner.clone()).set_name(name.into())
    }

    /// Deletes an existing model.
    pub fn delete_model(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::model_service::DeleteModel {
        crate::builders::model_service::DeleteModel::new(self.inner.clone()).set_name(name.into())
    }

    /// Lists all the models linked to this event store.
    pub fn list_models(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::model_service::ListModels {
        crate::builders::model_service::ListModels::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Update of model metadata. Only fields that
    /// currently can be updated are: `filtering_option` and
    /// `periodic_tuning_state`.
    /// If other values are provided, this API method ignores them.
    pub fn update_model(
        &self,
        model: impl Into<crate::model::Model>,
    ) -> crate::builders::model_service::UpdateModel {
        crate::builders::model_service::UpdateModel::new(self.inner.clone()).set_model(model.into())
    }

    /// Tunes an existing model.
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::TuneModelResponse, model::TuneModelMetadata>
    /// ) -> Result<model::TuneModelResponse> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::TuneModelResponse, model::TuneModelMetadata>
    /// ) -> Result<model::TuneModelResponse> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::TuneModelResponse] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::TuneModelMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::model_service::TuneModel::send
    /// [poller()]: crate::builders::model_service::TuneModel::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn tune_model(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::model_service::TuneModel {
        crate::builders::model_service::TuneModel::new(self.inner.clone()).set_name(name.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn list_operations(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::model_service::ListOperations {
        crate::builders::model_service::ListOperations::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::model_service::GetOperation {
        crate::builders::model_service::GetOperation::new(self.inner.clone()).set_name(name.into())
    }
}

/// Implements a client for the Vertex AI Search for Retail API.
///
/// # Service Description
///
/// Service for making recommendation prediction.
///
/// # Configuration
///
/// `PredictionService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `PredictionService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `PredictionService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct PredictionService {
    inner: Arc<dyn crate::stubs::dynamic::PredictionService>,
}

impl PredictionService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::PredictionService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::PredictionService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::PredictionService> {
        crate::transport::PredictionService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::PredictionService> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::PredictionService::new)
    }

    /// Makes a recommendation prediction.
    pub fn predict(
        &self,
        placement: impl Into<std::string::String>,
    ) -> crate::builders::prediction_service::Predict {
        crate::builders::prediction_service::Predict::new(self.inner.clone())
            .set_placement(placement.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn list_operations(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::prediction_service::ListOperations {
        crate::builders::prediction_service::ListOperations::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::prediction_service::GetOperation {
        crate::builders::prediction_service::GetOperation::new(self.inner.clone())
            .set_name(name.into())
    }
}

/// Implements a client for the Vertex AI Search for Retail API.
///
/// # Service Description
///
/// Service for ingesting [Product][google.cloud.retail.v2.Product] information
/// of the customer's website.
///
/// [google.cloud.retail.v2.Product]: crate::model::Product
///
/// # Configuration
///
/// `ProductService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `ProductService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ProductService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct ProductService {
    inner: Arc<dyn crate::stubs::dynamic::ProductService>,
}

impl ProductService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::ProductService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::ProductService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::ProductService> {
        crate::transport::ProductService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::ProductService> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::ProductService::new)
    }

    /// Creates a [Product][google.cloud.retail.v2.Product].
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub fn create_product(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::product_service::CreateProduct {
        crate::builders::product_service::CreateProduct::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Gets a [Product][google.cloud.retail.v2.Product].
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub fn get_product(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::product_service::GetProduct {
        crate::builders::product_service::GetProduct::new(self.inner.clone()).set_name(name.into())
    }

    /// Gets a list of [Product][google.cloud.retail.v2.Product]s.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub fn list_products(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::product_service::ListProducts {
        crate::builders::product_service::ListProducts::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Updates a [Product][google.cloud.retail.v2.Product].
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub fn update_product(
        &self,
        product: impl Into<crate::model::Product>,
    ) -> crate::builders::product_service::UpdateProduct {
        crate::builders::product_service::UpdateProduct::new(self.inner.clone())
            .set_product(product.into())
    }

    /// Deletes a [Product][google.cloud.retail.v2.Product].
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub fn delete_product(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::product_service::DeleteProduct {
        crate::builders::product_service::DeleteProduct::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Permanently deletes all selected [Product][google.cloud.retail.v2.Product]s
    /// under a branch.
    ///
    /// This process is asynchronous. If the request is valid, the removal will be
    /// enqueued and processed offline. Depending on the number of
    /// [Product][google.cloud.retail.v2.Product]s, this operation could take hours
    /// to complete. Before the operation completes, some
    /// [Product][google.cloud.retail.v2.Product]s may still be returned by
    /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct]
    /// or
    /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts].
    ///
    /// Depending on the number of [Product][google.cloud.retail.v2.Product]s, this
    /// operation could take hours to complete. To get a sample of
    /// [Product][google.cloud.retail.v2.Product]s that would be deleted, set
    /// [PurgeProductsRequest.force][google.cloud.retail.v2.PurgeProductsRequest.force]
    /// to false.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.ProductService.GetProduct]: crate::client::ProductService::get_product
    /// [google.cloud.retail.v2.ProductService.ListProducts]: crate::client::ProductService::list_products
    /// [google.cloud.retail.v2.PurgeProductsRequest.force]: crate::model::PurgeProductsRequest::force
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::PurgeProductsResponse, model::PurgeProductsMetadata>
    /// ) -> Result<model::PurgeProductsResponse> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::PurgeProductsResponse, model::PurgeProductsMetadata>
    /// ) -> Result<model::PurgeProductsResponse> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::PurgeProductsResponse] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::PurgeProductsMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::product_service::PurgeProducts::send
    /// [poller()]: crate::builders::product_service::PurgeProducts::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn purge_products(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::product_service::PurgeProducts {
        crate::builders::product_service::PurgeProducts::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Bulk import of multiple [Product][google.cloud.retail.v2.Product]s.
    ///
    /// Request processing may be synchronous.
    /// Non-existing items are created.
    ///
    /// Note that it is possible for a subset of the
    /// [Product][google.cloud.retail.v2.Product]s to be successfully updated.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::ImportProductsResponse, model::ImportMetadata>
    /// ) -> Result<model::ImportProductsResponse> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::ImportProductsResponse, model::ImportMetadata>
    /// ) -> Result<model::ImportProductsResponse> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::ImportProductsResponse] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::ImportMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::product_service::ImportProducts::send
    /// [poller()]: crate::builders::product_service::ImportProducts::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn import_products(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::product_service::ImportProducts {
        crate::builders::product_service::ImportProducts::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Updates inventory information for a
    /// [Product][google.cloud.retail.v2.Product] while respecting the last update
    /// timestamps of each inventory field.
    ///
    /// This process is asynchronous and does not require the
    /// [Product][google.cloud.retail.v2.Product] to exist before updating
    /// fulfillment information. If the request is valid, the update is enqueued
    /// and processed downstream. As a consequence, when a response is returned,
    /// updates are not immediately manifested in the
    /// [Product][google.cloud.retail.v2.Product] queried by
    /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct]
    /// or
    /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts].
    ///
    /// When inventory is updated with
    /// [ProductService.CreateProduct][google.cloud.retail.v2.ProductService.CreateProduct]
    /// and
    /// [ProductService.UpdateProduct][google.cloud.retail.v2.ProductService.UpdateProduct],
    /// the specified inventory field value(s) overwrite any existing value(s)
    /// while ignoring the last update time for this field. Furthermore, the last
    /// update times for the specified inventory fields are overwritten by the
    /// times of the
    /// [ProductService.CreateProduct][google.cloud.retail.v2.ProductService.CreateProduct]
    /// or
    /// [ProductService.UpdateProduct][google.cloud.retail.v2.ProductService.UpdateProduct]
    /// request.
    ///
    /// If no inventory fields are set in
    /// [CreateProductRequest.product][google.cloud.retail.v2.CreateProductRequest.product],
    /// then any pre-existing inventory information for this product is used.
    ///
    /// If no inventory fields are set in
    /// [SetInventoryRequest.set_mask][google.cloud.retail.v2.SetInventoryRequest.set_mask],
    /// then any existing inventory information is preserved.
    ///
    /// Pre-existing inventory information can only be updated with
    /// [ProductService.SetInventory][google.cloud.retail.v2.ProductService.SetInventory],
    /// [ProductService.AddFulfillmentPlaces][google.cloud.retail.v2.ProductService.AddFulfillmentPlaces],
    /// and
    /// [ProductService.RemoveFulfillmentPlaces][google.cloud.retail.v2.ProductService.RemoveFulfillmentPlaces].
    ///
    /// The returned [Operation][google.longrunning.Operation]s is obsolete after
    /// one day, and the [GetOperation][google.longrunning.Operations.GetOperation]
    /// API returns `NOT_FOUND` afterwards.
    ///
    /// If conflicting updates are issued, the
    /// [Operation][google.longrunning.Operation]s associated with the stale
    /// updates are not marked as [done][google.longrunning.Operation.done] until
    /// they are obsolete.
    ///
    /// [google.cloud.retail.v2.CreateProductRequest.product]: crate::model::CreateProductRequest::product
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.ProductService.AddFulfillmentPlaces]: crate::client::ProductService::add_fulfillment_places
    /// [google.cloud.retail.v2.ProductService.CreateProduct]: crate::client::ProductService::create_product
    /// [google.cloud.retail.v2.ProductService.GetProduct]: crate::client::ProductService::get_product
    /// [google.cloud.retail.v2.ProductService.ListProducts]: crate::client::ProductService::list_products
    /// [google.cloud.retail.v2.ProductService.RemoveFulfillmentPlaces]: crate::client::ProductService::remove_fulfillment_places
    /// [google.cloud.retail.v2.ProductService.SetInventory]: crate::client::ProductService::set_inventory
    /// [google.cloud.retail.v2.ProductService.UpdateProduct]: crate::client::ProductService::update_product
    /// [google.cloud.retail.v2.SetInventoryRequest.set_mask]: crate::model::SetInventoryRequest::set_mask
    /// [google.longrunning.Operation]: longrunning::model::Operation
    /// [google.longrunning.Operation.done]: longrunning::model::Operation::done
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::SetInventoryResponse, model::SetInventoryMetadata>
    /// ) -> Result<model::SetInventoryResponse> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::SetInventoryResponse, model::SetInventoryMetadata>
    /// ) -> Result<model::SetInventoryResponse> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::SetInventoryResponse] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::SetInventoryMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::product_service::SetInventory::send
    /// [poller()]: crate::builders::product_service::SetInventory::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn set_inventory(
        &self,
        inventory: impl Into<crate::model::Product>,
    ) -> crate::builders::product_service::SetInventory {
        crate::builders::product_service::SetInventory::new(self.inner.clone())
            .set_inventory(inventory.into())
    }

    /// We recommend that you use the
    /// [ProductService.AddLocalInventories][google.cloud.retail.v2.ProductService.AddLocalInventories]
    /// method instead of the
    /// [ProductService.AddFulfillmentPlaces][google.cloud.retail.v2.ProductService.AddFulfillmentPlaces]
    /// method.
    /// [ProductService.AddLocalInventories][google.cloud.retail.v2.ProductService.AddLocalInventories]
    /// achieves the same results but provides more fine-grained control over
    /// ingesting local inventory data.
    ///
    /// Incrementally adds place IDs to
    /// [Product.fulfillment_info.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids].
    ///
    /// This process is asynchronous and does not require the
    /// [Product][google.cloud.retail.v2.Product] to exist before updating
    /// fulfillment information. If the request is valid, the update will be
    /// enqueued and processed downstream. As a consequence, when a response is
    /// returned, the added place IDs are not immediately manifested in the
    /// [Product][google.cloud.retail.v2.Product] queried by
    /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct]
    /// or
    /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts].
    ///
    /// The returned [Operation][google.longrunning.Operation]s will be obsolete
    /// after 1 day, and [GetOperation][google.longrunning.Operations.GetOperation]
    /// API will return NOT_FOUND afterwards.
    ///
    /// If conflicting updates are issued, the
    /// [Operation][google.longrunning.Operation]s associated with the stale
    /// updates will not be marked as [done][google.longrunning.Operation.done]
    /// until being obsolete.
    ///
    /// [google.cloud.retail.v2.FulfillmentInfo.place_ids]: crate::model::FulfillmentInfo::place_ids
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.ProductService.AddFulfillmentPlaces]: crate::client::ProductService::add_fulfillment_places
    /// [google.cloud.retail.v2.ProductService.AddLocalInventories]: crate::client::ProductService::add_local_inventories
    /// [google.cloud.retail.v2.ProductService.GetProduct]: crate::client::ProductService::get_product
    /// [google.cloud.retail.v2.ProductService.ListProducts]: crate::client::ProductService::list_products
    /// [google.longrunning.Operation]: longrunning::model::Operation
    /// [google.longrunning.Operation.done]: longrunning::model::Operation::done
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::AddFulfillmentPlacesResponse, model::AddFulfillmentPlacesMetadata>
    /// ) -> Result<model::AddFulfillmentPlacesResponse> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::AddFulfillmentPlacesResponse, model::AddFulfillmentPlacesMetadata>
    /// ) -> Result<model::AddFulfillmentPlacesResponse> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::AddFulfillmentPlacesResponse] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::AddFulfillmentPlacesMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::product_service::AddFulfillmentPlaces::send
    /// [poller()]: crate::builders::product_service::AddFulfillmentPlaces::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn add_fulfillment_places(
        &self,
        product: impl Into<std::string::String>,
    ) -> crate::builders::product_service::AddFulfillmentPlaces {
        crate::builders::product_service::AddFulfillmentPlaces::new(self.inner.clone())
            .set_product(product.into())
    }

    /// We recommend that you use the
    /// [ProductService.RemoveLocalInventories][google.cloud.retail.v2.ProductService.RemoveLocalInventories]
    /// method instead of the
    /// [ProductService.RemoveFulfillmentPlaces][google.cloud.retail.v2.ProductService.RemoveFulfillmentPlaces]
    /// method.
    /// [ProductService.RemoveLocalInventories][google.cloud.retail.v2.ProductService.RemoveLocalInventories]
    /// achieves the same results but provides more fine-grained control over
    /// ingesting local inventory data.
    ///
    /// Incrementally removes place IDs from a
    /// [Product.fulfillment_info.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids].
    ///
    /// This process is asynchronous and does not require the
    /// [Product][google.cloud.retail.v2.Product] to exist before updating
    /// fulfillment information. If the request is valid, the update will be
    /// enqueued and processed downstream. As a consequence, when a response is
    /// returned, the removed place IDs are not immediately manifested in the
    /// [Product][google.cloud.retail.v2.Product] queried by
    /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct]
    /// or
    /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts].
    ///
    /// The returned [Operation][google.longrunning.Operation]s will be obsolete
    /// after 1 day, and [GetOperation][google.longrunning.Operations.GetOperation]
    /// API will return NOT_FOUND afterwards.
    ///
    /// If conflicting updates are issued, the
    /// [Operation][google.longrunning.Operation]s associated with the stale
    /// updates will not be marked as [done][google.longrunning.Operation.done]
    /// until being obsolete.
    ///
    /// [google.cloud.retail.v2.FulfillmentInfo.place_ids]: crate::model::FulfillmentInfo::place_ids
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.ProductService.GetProduct]: crate::client::ProductService::get_product
    /// [google.cloud.retail.v2.ProductService.ListProducts]: crate::client::ProductService::list_products
    /// [google.cloud.retail.v2.ProductService.RemoveFulfillmentPlaces]: crate::client::ProductService::remove_fulfillment_places
    /// [google.cloud.retail.v2.ProductService.RemoveLocalInventories]: crate::client::ProductService::remove_local_inventories
    /// [google.longrunning.Operation]: longrunning::model::Operation
    /// [google.longrunning.Operation.done]: longrunning::model::Operation::done
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::RemoveFulfillmentPlacesResponse, model::RemoveFulfillmentPlacesMetadata>
    /// ) -> Result<model::RemoveFulfillmentPlacesResponse> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::RemoveFulfillmentPlacesResponse, model::RemoveFulfillmentPlacesMetadata>
    /// ) -> Result<model::RemoveFulfillmentPlacesResponse> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::RemoveFulfillmentPlacesResponse] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::RemoveFulfillmentPlacesMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::product_service::RemoveFulfillmentPlaces::send
    /// [poller()]: crate::builders::product_service::RemoveFulfillmentPlaces::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn remove_fulfillment_places(
        &self,
        product: impl Into<std::string::String>,
    ) -> crate::builders::product_service::RemoveFulfillmentPlaces {
        crate::builders::product_service::RemoveFulfillmentPlaces::new(self.inner.clone())
            .set_product(product.into())
    }

    /// Updates local inventory information for a
    /// [Product][google.cloud.retail.v2.Product] at a list of places, while
    /// respecting the last update timestamps of each inventory field.
    ///
    /// This process is asynchronous and does not require the
    /// [Product][google.cloud.retail.v2.Product] to exist before updating
    /// inventory information. If the request is valid, the update will be enqueued
    /// and processed downstream. As a consequence, when a response is returned,
    /// updates are not immediately manifested in the
    /// [Product][google.cloud.retail.v2.Product] queried by
    /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct]
    /// or
    /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts].
    ///
    /// Local inventory information can only be modified using this method.
    /// [ProductService.CreateProduct][google.cloud.retail.v2.ProductService.CreateProduct]
    /// and
    /// [ProductService.UpdateProduct][google.cloud.retail.v2.ProductService.UpdateProduct]
    /// has no effect on local inventories.
    ///
    /// The returned [Operation][google.longrunning.Operation]s will be obsolete
    /// after 1 day, and [GetOperation][google.longrunning.Operations.GetOperation]
    /// API will return NOT_FOUND afterwards.
    ///
    /// If conflicting updates are issued, the
    /// [Operation][google.longrunning.Operation]s associated with the stale
    /// updates will not be marked as [done][google.longrunning.Operation.done]
    /// until being obsolete.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.ProductService.CreateProduct]: crate::client::ProductService::create_product
    /// [google.cloud.retail.v2.ProductService.GetProduct]: crate::client::ProductService::get_product
    /// [google.cloud.retail.v2.ProductService.ListProducts]: crate::client::ProductService::list_products
    /// [google.cloud.retail.v2.ProductService.UpdateProduct]: crate::client::ProductService::update_product
    /// [google.longrunning.Operation]: longrunning::model::Operation
    /// [google.longrunning.Operation.done]: longrunning::model::Operation::done
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::AddLocalInventoriesResponse, model::AddLocalInventoriesMetadata>
    /// ) -> Result<model::AddLocalInventoriesResponse> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::AddLocalInventoriesResponse, model::AddLocalInventoriesMetadata>
    /// ) -> Result<model::AddLocalInventoriesResponse> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::AddLocalInventoriesResponse] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::AddLocalInventoriesMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::product_service::AddLocalInventories::send
    /// [poller()]: crate::builders::product_service::AddLocalInventories::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn add_local_inventories(
        &self,
        product: impl Into<std::string::String>,
    ) -> crate::builders::product_service::AddLocalInventories {
        crate::builders::product_service::AddLocalInventories::new(self.inner.clone())
            .set_product(product.into())
    }

    /// Remove local inventory information for a
    /// [Product][google.cloud.retail.v2.Product] at a list of places at a removal
    /// timestamp.
    ///
    /// This process is asynchronous. If the request is valid, the removal will be
    /// enqueued and processed downstream. As a consequence, when a response is
    /// returned, removals are not immediately manifested in the
    /// [Product][google.cloud.retail.v2.Product] queried by
    /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct]
    /// or
    /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts].
    ///
    /// Local inventory information can only be removed using this method.
    /// [ProductService.CreateProduct][google.cloud.retail.v2.ProductService.CreateProduct]
    /// and
    /// [ProductService.UpdateProduct][google.cloud.retail.v2.ProductService.UpdateProduct]
    /// has no effect on local inventories.
    ///
    /// The returned [Operation][google.longrunning.Operation]s will be obsolete
    /// after 1 day, and [GetOperation][google.longrunning.Operations.GetOperation]
    /// API will return NOT_FOUND afterwards.
    ///
    /// If conflicting updates are issued, the
    /// [Operation][google.longrunning.Operation]s associated with the stale
    /// updates will not be marked as [done][google.longrunning.Operation.done]
    /// until being obsolete.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.ProductService.CreateProduct]: crate::client::ProductService::create_product
    /// [google.cloud.retail.v2.ProductService.GetProduct]: crate::client::ProductService::get_product
    /// [google.cloud.retail.v2.ProductService.ListProducts]: crate::client::ProductService::list_products
    /// [google.cloud.retail.v2.ProductService.UpdateProduct]: crate::client::ProductService::update_product
    /// [google.longrunning.Operation]: longrunning::model::Operation
    /// [google.longrunning.Operation.done]: longrunning::model::Operation::done
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::RemoveLocalInventoriesResponse, model::RemoveLocalInventoriesMetadata>
    /// ) -> Result<model::RemoveLocalInventoriesResponse> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::RemoveLocalInventoriesResponse, model::RemoveLocalInventoriesMetadata>
    /// ) -> Result<model::RemoveLocalInventoriesResponse> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::RemoveLocalInventoriesResponse] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::RemoveLocalInventoriesMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::product_service::RemoveLocalInventories::send
    /// [poller()]: crate::builders::product_service::RemoveLocalInventories::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn remove_local_inventories(
        &self,
        product: impl Into<std::string::String>,
    ) -> crate::builders::product_service::RemoveLocalInventories {
        crate::builders::product_service::RemoveLocalInventories::new(self.inner.clone())
            .set_product(product.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn list_operations(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::product_service::ListOperations {
        crate::builders::product_service::ListOperations::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::product_service::GetOperation {
        crate::builders::product_service::GetOperation::new(self.inner.clone())
            .set_name(name.into())
    }
}

/// Implements a client for the Vertex AI Search for Retail API.
///
/// # Service Description
///
/// Service for search.
///
/// This feature is only available for users who have Retail Search enabled.
/// Enable Retail Search on Cloud Console before using this feature.
///
/// # Configuration
///
/// `SearchService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `SearchService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `SearchService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct SearchService {
    inner: Arc<dyn crate::stubs::dynamic::SearchService>,
}

impl SearchService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::SearchService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::SearchService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::SearchService> {
        crate::transport::SearchService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::SearchService> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::SearchService::new)
    }

    /// Performs a search.
    ///
    /// This feature is only available for users who have Retail Search enabled.
    /// Enable Retail Search on Cloud Console before using this feature.
    pub fn search(
        &self,
        placement: impl Into<std::string::String>,
    ) -> crate::builders::search_service::Search {
        crate::builders::search_service::Search::new(self.inner.clone())
            .set_placement(placement.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn list_operations(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::search_service::ListOperations {
        crate::builders::search_service::ListOperations::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::search_service::GetOperation {
        crate::builders::search_service::GetOperation::new(self.inner.clone()).set_name(name.into())
    }
}

/// Implements a client for the Vertex AI Search for Retail API.
///
/// # Service Description
///
/// Service for modifying ServingConfig.
///
/// # Configuration
///
/// `ServingConfigService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `ServingConfigService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ServingConfigService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct ServingConfigService {
    inner: Arc<dyn crate::stubs::dynamic::ServingConfigService>,
}

impl ServingConfigService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::ServingConfigService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::ServingConfigService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::ServingConfigService> {
        crate::transport::ServingConfigService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::ServingConfigService> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::ServingConfigService::new)
    }

    /// Creates a ServingConfig.
    ///
    /// A maximum of 100 [ServingConfig][google.cloud.retail.v2.ServingConfig]s are
    /// allowed in a [Catalog][google.cloud.retail.v2.Catalog], otherwise a
    /// FAILED_PRECONDITION error is returned.
    ///
    /// [google.cloud.retail.v2.Catalog]: crate::model::Catalog
    /// [google.cloud.retail.v2.ServingConfig]: crate::model::ServingConfig
    pub fn create_serving_config(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::serving_config_service::CreateServingConfig {
        crate::builders::serving_config_service::CreateServingConfig::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Deletes a ServingConfig.
    ///
    /// Returns a NotFound error if the ServingConfig does not exist.
    pub fn delete_serving_config(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::serving_config_service::DeleteServingConfig {
        crate::builders::serving_config_service::DeleteServingConfig::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Updates a ServingConfig.
    pub fn update_serving_config(
        &self,
        serving_config: impl Into<crate::model::ServingConfig>,
    ) -> crate::builders::serving_config_service::UpdateServingConfig {
        crate::builders::serving_config_service::UpdateServingConfig::new(self.inner.clone())
            .set_serving_config(serving_config.into())
    }

    /// Gets a ServingConfig.
    ///
    /// Returns a NotFound error if the ServingConfig does not exist.
    pub fn get_serving_config(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::serving_config_service::GetServingConfig {
        crate::builders::serving_config_service::GetServingConfig::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Lists all ServingConfigs linked to this catalog.
    pub fn list_serving_configs(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::serving_config_service::ListServingConfigs {
        crate::builders::serving_config_service::ListServingConfigs::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Enables a Control on the specified ServingConfig.
    /// The control is added in the last position of the list of controls
    /// it belongs to (e.g. if it's a facet spec control it will be applied
    /// in the last position of servingConfig.facetSpecIds)
    /// Returns a ALREADY_EXISTS error if the control has already been applied.
    /// Returns a FAILED_PRECONDITION error if the addition could exceed maximum
    /// number of control allowed for that type of control.
    pub fn add_control(
        &self,
        serving_config: impl Into<std::string::String>,
    ) -> crate::builders::serving_config_service::AddControl {
        crate::builders::serving_config_service::AddControl::new(self.inner.clone())
            .set_serving_config(serving_config.into())
    }

    /// Disables a Control on the specified ServingConfig.
    /// The control is removed from the ServingConfig.
    /// Returns a NOT_FOUND error if the Control is not enabled for the
    /// ServingConfig.
    pub fn remove_control(
        &self,
        serving_config: impl Into<std::string::String>,
    ) -> crate::builders::serving_config_service::RemoveControl {
        crate::builders::serving_config_service::RemoveControl::new(self.inner.clone())
            .set_serving_config(serving_config.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn list_operations(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::serving_config_service::ListOperations {
        crate::builders::serving_config_service::ListOperations::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::serving_config_service::GetOperation {
        crate::builders::serving_config_service::GetOperation::new(self.inner.clone())
            .set_name(name.into())
    }
}

/// Implements a client for the Vertex AI Search for Retail API.
///
/// # Service Description
///
/// Service for ingesting end user actions on the customer website.
///
/// # Configuration
///
/// `UserEventService` has various configuration parameters, the defaults should
/// work with most applications.
///
/// # Pooling and Cloning
///
/// `UserEventService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `UserEventService` in
/// an [Rc](std::rc::Rc) or [Arc] to reuse it, because it already uses an `Arc`
/// internally.
#[derive(Clone, Debug)]
pub struct UserEventService {
    inner: Arc<dyn crate::stubs::dynamic::UserEventService>,
}

impl UserEventService {
    /// Creates a new client with the default configuration.
    pub async fn new() -> Result<Self> {
        Self::new_with_config(gax::options::ClientConfig::default()).await
    }

    /// Creates a new client with the specified configuration.
    pub async fn new_with_config(conf: gax::options::ClientConfig) -> Result<Self> {
        let inner = Self::build_inner(conf).await?;
        Ok(Self { inner })
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is when mocking the
    /// client.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: crate::stubs::UserEventService + 'static,
    {
        Self {
            inner: Arc::new(stub),
        }
    }

    async fn build_inner(
        conf: gax::options::ClientConfig,
    ) -> Result<Arc<dyn crate::stubs::dynamic::UserEventService>> {
        if conf.tracing_enabled() {
            return Ok(Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::UserEventService> {
        crate::transport::UserEventService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gax::options::ClientConfig,
    ) -> Result<impl crate::stubs::UserEventService> {
        Self::build_transport(conf)
            .await
            .map(crate::tracing::UserEventService::new)
    }

    /// Writes a single user event.
    pub fn write_user_event(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::user_event_service::WriteUserEvent {
        crate::builders::user_event_service::WriteUserEvent::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Writes a single user event from the browser. This uses a GET request to
    /// due to browser restriction of POST-ing to a 3rd party domain.
    ///
    /// This method is used only by the Retail API JavaScript pixel and Google Tag
    /// Manager. Users should not call this method directly.
    pub fn collect_user_event(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::user_event_service::CollectUserEvent {
        crate::builders::user_event_service::CollectUserEvent::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Deletes permanently all user events specified by the filter provided.
    /// Depending on the number of events specified by the filter, this operation
    /// could take hours or days to complete. To test a filter, use the list
    /// command first.
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::PurgeUserEventsResponse, model::PurgeMetadata>
    /// ) -> Result<model::PurgeUserEventsResponse> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::PurgeUserEventsResponse, model::PurgeMetadata>
    /// ) -> Result<model::PurgeUserEventsResponse> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::PurgeUserEventsResponse] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::PurgeMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::user_event_service::PurgeUserEvents::send
    /// [poller()]: crate::builders::user_event_service::PurgeUserEvents::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn purge_user_events(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::user_event_service::PurgeUserEvents {
        crate::builders::user_event_service::PurgeUserEvents::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Bulk import of User events. Request processing might be
    /// synchronous. Events that already exist are skipped.
    /// Use this method for backfilling historical user events.
    ///
    /// `Operation.response` is of type `ImportResponse`. Note that it is
    /// possible for a subset of the items to be successfully inserted.
    /// `Operation.metadata` is of type `ImportMetadata`.
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::ImportUserEventsResponse, model::ImportMetadata>
    /// ) -> Result<model::ImportUserEventsResponse> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::ImportUserEventsResponse, model::ImportMetadata>
    /// ) -> Result<model::ImportUserEventsResponse> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::ImportUserEventsResponse] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::ImportMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::user_event_service::ImportUserEvents::send
    /// [poller()]: crate::builders::user_event_service::ImportUserEvents::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn import_user_events(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::user_event_service::ImportUserEvents {
        crate::builders::user_event_service::ImportUserEvents::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Starts a user-event rejoin operation with latest product catalog. Events
    /// are not annotated with detailed product information for products that are
    /// missing from the catalog when the user event is ingested. These
    /// events are stored as unjoined events with limited usage on training and
    /// serving. You can use this method to start a join operation on specified
    /// events with the latest version of product catalog. You can also use this
    /// method to correct events joined with the wrong product catalog. A rejoin
    /// operation can take hours or days to complete.
    ///
    /// # Long running operations
    ///
    /// Calling [poller()] on the resulting builder returns an implementation of
    /// the [lro::Poller] trait. You need to call `Poller::poll` on this
    /// `Poller` at least once to start the LRO. You may periodically poll this
    /// object to find the status of the operation. The poller automatically
    /// extract the final response value and any intermediate metadata values.
    ///
    /// Calling [send()] on the resulting builder starts a LRO (long-Running
    /// Operation). LROs run in the background, and the application may poll
    /// them periodically to find out if they have succeeded, or failed. See
    /// below for instructions on how to manually use the resulting [Operation].
    /// We recommend `poller()` in favor of `send()`.
    ///
    /// ## Polling until completion
    ///
    /// Applications that do not care about intermediate results in a
    /// long-running operation may use the [until_done()] function:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::RejoinUserEventsResponse, model::RejoinUserEventsMetadata>
    /// ) -> Result<model::RejoinUserEventsResponse> {
    ///     poller.until_done().await
    /// }
    /// ```
    ///
    /// This will wait until the LRO completes (successfully or with an error).
    /// Applications can set the [PollingPolicy] and [PollingBackoffPolicy] to
    /// control for how long the function runs.
    ///
    /// ## Polling with detailed metadata updates
    ///
    /// Using the result of [poller()] follows a common pattern:
    ///
    /// ```
    /// # use gax::Result;
    /// # use google_cloud_retail_v2::model;
    /// async fn wait(
    ///     mut poller: impl lro::Poller<model::RejoinUserEventsResponse, model::RejoinUserEventsMetadata>
    /// ) -> Result<model::RejoinUserEventsResponse> {
    ///     while let Some(p) = poller.poll().await {
    ///         match p {
    ///             lro::PollingResult::Completed(r) => { return r; },
    ///             lro::PollingResult::InProgress(m) => { println!("in progress {m:?}"); },
    ///             lro::PollingResult::PollingError(_) => { /* ignored */ },
    ///         }
    ///         tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    ///     }
    ///     Err(gax::error::Error::other("LRO never completed"))
    /// }
    /// ```
    ///
    /// ## Manually polling long-running operations
    ///
    /// If you call [send()], you need to examine the contents of the resulting
    /// [Operation][longrunning::model::Operation] to determine the result of
    /// the operation.
    ///
    /// If the `done` field is `true`, the operation has completed. The `result`
    /// field contains the final response, this will be a [crate::model::RejoinUserEventsResponse] (as
    /// an [Any]), or the error (as a `Status`).
    ///
    /// If the `done` field is `false`, the operation has not completed.  The
    /// operation may also include a [crate::model::RejoinUserEventsMetadata] value in the `metadata`
    /// field. This value would also be encoded as an [Any]. The metadata may
    /// include information about how much progress the LRO has made.
    ///
    /// To find out if the operation has completed, use the [get_operation]
    /// method and repeat the steps outlined above.
    ///
    /// Note that most errors on [get_operation] do not indicate that the
    /// long-running operation failed. Long-running operation failures return
    /// the error status in the [result] field.
    ///
    /// [send()]: crate::builders::user_event_service::RejoinUserEvents::send
    /// [poller()]: crate::builders::user_event_service::RejoinUserEvents::poller
    /// [until_done()]: lro::Poller::until_done
    /// [PollingPolicy]: gax::polling_policy::PollingPolicy
    /// [PollingBackoffPolicy]: gax::polling_backoff_policy::PollingBackoffPolicy
    /// [get_operation]: Self::get_operation
    /// [metadata]: longrunning::model::Operation::result
    /// [name]: longrunning::model::Operation::name
    /// [Operation]: longrunning::model::Operation
    /// [result]: longrunning::model::Operation::result
    /// [Any]: wkt::Any
    pub fn rejoin_user_events(
        &self,
        parent: impl Into<std::string::String>,
    ) -> crate::builders::user_event_service::RejoinUserEvents {
        crate::builders::user_event_service::RejoinUserEvents::new(self.inner.clone())
            .set_parent(parent.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn list_operations(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::user_event_service::ListOperations {
        crate::builders::user_event_service::ListOperations::new(self.inner.clone())
            .set_name(name.into())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(
        &self,
        name: impl Into<std::string::String>,
    ) -> crate::builders::user_event_service::GetOperation {
        crate::builders::user_event_service::GetOperation::new(self.inner.clone())
            .set_name(name.into())
    }
}
