// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]

/// Implements a client for the Vertex AI Search for commerce API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_retail_v2::client::AnalyticsService;
/// let client = AnalyticsService::builder().build().await?;
/// // use `client` to make requests to the Vertex AI Search for commerce API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// Service for managing & accessing retail search business metric.
/// Retail recommendation business metric is currently not available.
///
/// # Configuration
///
/// To configure `AnalyticsService` use the `with_*` methods in the type returned
/// by [builder()][AnalyticsService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://retail.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::analytics_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::analytics_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `AnalyticsService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `AnalyticsService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct AnalyticsService {
    inner: std::sync::Arc<dyn super::stub::dynamic::AnalyticsService>,
}

impl AnalyticsService {
    /// Returns a builder for [AnalyticsService].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_retail_v2::client::AnalyticsService;
    /// let client = AnalyticsService::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::analytics_service::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::analytics_service::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::AnalyticsService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::AnalyticsService>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::AnalyticsService> {
        super::transport::AnalyticsService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::AnalyticsService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::AnalyticsService::new)
    }

    /// Exports analytics metrics.
    ///
    /// `Operation.response` is of type `ExportAnalyticsMetricsResponse`.
    /// `Operation.metadata` is of type `ExportMetadata`.
    ///
    /// # Long running operations
    ///
    /// This method is used to start, and/or poll a [long-running Operation].
    /// The [Working with long-running operations] chapter in the [user guide]
    /// covers these operations in detail.
    ///
    /// [long-running operation]: https://google.aip.dev/151
    /// [user guide]: https://googleapis.github.io/google-cloud-rust/
    /// [working with long-running operations]: https://googleapis.github.io/google-cloud-rust/working_with_long_running_operations.html
    pub fn export_analytics_metrics(
        &self,
    ) -> super::builder::analytics_service::ExportAnalyticsMetrics {
        super::builder::analytics_service::ExportAnalyticsMetrics::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn list_operations(&self) -> super::builder::analytics_service::ListOperations {
        super::builder::analytics_service::ListOperations::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(&self) -> super::builder::analytics_service::GetOperation {
        super::builder::analytics_service::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Vertex AI Search for commerce API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_retail_v2::client::CatalogService;
/// let client = CatalogService::builder().build().await?;
/// // use `client` to make requests to the Vertex AI Search for commerce API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// Service for managing catalog configuration.
///
/// # Configuration
///
/// To configure `CatalogService` use the `with_*` methods in the type returned
/// by [builder()][CatalogService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://retail.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::catalog_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::catalog_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `CatalogService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `CatalogService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct CatalogService {
    inner: std::sync::Arc<dyn super::stub::dynamic::CatalogService>,
}

impl CatalogService {
    /// Returns a builder for [CatalogService].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_retail_v2::client::CatalogService;
    /// let client = CatalogService::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::catalog_service::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::catalog_service::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::CatalogService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::CatalogService>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::CatalogService> {
        super::transport::CatalogService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::CatalogService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::CatalogService::new)
    }

    /// Lists all the [Catalog][google.cloud.retail.v2.Catalog]s associated with
    /// the project.
    ///
    /// [google.cloud.retail.v2.Catalog]: crate::model::Catalog
    pub fn list_catalogs(&self) -> super::builder::catalog_service::ListCatalogs {
        super::builder::catalog_service::ListCatalogs::new(self.inner.clone())
    }

    /// Updates the [Catalog][google.cloud.retail.v2.Catalog]s.
    ///
    /// [google.cloud.retail.v2.Catalog]: crate::model::Catalog
    pub fn update_catalog(&self) -> super::builder::catalog_service::UpdateCatalog {
        super::builder::catalog_service::UpdateCatalog::new(self.inner.clone())
    }

    /// Set a specified branch id as default branch. API methods such as
    /// [SearchService.Search][google.cloud.retail.v2.SearchService.Search],
    /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct],
    /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts]
    /// will treat requests using "default_branch" to the actual branch id set as
    /// default.
    ///
    /// For example, if `projects/*/locations/*/catalogs/*/branches/1` is set as
    /// default, setting
    /// [SearchRequest.branch][google.cloud.retail.v2.SearchRequest.branch] to
    /// `projects/*/locations/*/catalogs/*/branches/default_branch` is equivalent
    /// to setting
    /// [SearchRequest.branch][google.cloud.retail.v2.SearchRequest.branch] to
    /// `projects/*/locations/*/catalogs/*/branches/1`.
    ///
    /// Using multiple branches can be useful when developers would like
    /// to have a staging branch to test and verify for future usage. When it
    /// becomes ready, developers switch on the staging branch using this API
    /// while keeping using
    /// `projects/*/locations/*/catalogs/*/branches/default_branch` as
    /// [SearchRequest.branch][google.cloud.retail.v2.SearchRequest.branch] to
    /// route the traffic to this staging branch.
    ///
    /// CAUTION: If you have live predict/search traffic, switching the default
    /// branch could potentially cause outages if the ID space of the new branch
    /// is very different from the old one.
    ///
    /// More specifically:
    ///
    /// * PredictionService will only return product IDs from branch {newBranch}.
    /// * SearchService will only return product IDs from branch {newBranch}
    ///   (if branch is not explicitly set).
    /// * UserEventService will only join events with products from branch
    ///   {newBranch}.
    ///
    /// [google.cloud.retail.v2.ProductService.GetProduct]: crate::client::ProductService::get_product
    /// [google.cloud.retail.v2.ProductService.ListProducts]: crate::client::ProductService::list_products
    /// [google.cloud.retail.v2.SearchRequest.branch]: crate::model::SearchRequest::branch
    /// [google.cloud.retail.v2.SearchService.Search]: crate::client::SearchService::search
    pub fn set_default_branch(&self) -> super::builder::catalog_service::SetDefaultBranch {
        super::builder::catalog_service::SetDefaultBranch::new(self.inner.clone())
    }

    /// Get which branch is currently default branch set by
    /// [CatalogService.SetDefaultBranch][google.cloud.retail.v2.CatalogService.SetDefaultBranch]
    /// method under a specified parent catalog.
    ///
    /// [google.cloud.retail.v2.CatalogService.SetDefaultBranch]: crate::client::CatalogService::set_default_branch
    pub fn get_default_branch(&self) -> super::builder::catalog_service::GetDefaultBranch {
        super::builder::catalog_service::GetDefaultBranch::new(self.inner.clone())
    }

    /// Gets a [CompletionConfig][google.cloud.retail.v2.CompletionConfig].
    ///
    /// [google.cloud.retail.v2.CompletionConfig]: crate::model::CompletionConfig
    pub fn get_completion_config(&self) -> super::builder::catalog_service::GetCompletionConfig {
        super::builder::catalog_service::GetCompletionConfig::new(self.inner.clone())
    }

    /// Updates the [CompletionConfig][google.cloud.retail.v2.CompletionConfig]s.
    ///
    /// [google.cloud.retail.v2.CompletionConfig]: crate::model::CompletionConfig
    pub fn update_completion_config(
        &self,
    ) -> super::builder::catalog_service::UpdateCompletionConfig {
        super::builder::catalog_service::UpdateCompletionConfig::new(self.inner.clone())
    }

    /// Gets an [AttributesConfig][google.cloud.retail.v2.AttributesConfig].
    ///
    /// [google.cloud.retail.v2.AttributesConfig]: crate::model::AttributesConfig
    pub fn get_attributes_config(&self) -> super::builder::catalog_service::GetAttributesConfig {
        super::builder::catalog_service::GetAttributesConfig::new(self.inner.clone())
    }

    /// Updates the [AttributesConfig][google.cloud.retail.v2.AttributesConfig].
    ///
    /// The catalog attributes in the request will be updated in the catalog, or
    /// inserted if they do not exist. Existing catalog attributes not included in
    /// the request will remain unchanged. Attributes that are assigned to
    /// products, but do not exist at the catalog level, are always included in the
    /// response. The product attribute is assigned default values for missing
    /// catalog attribute fields, e.g., searchable and dynamic facetable options.
    ///
    /// [google.cloud.retail.v2.AttributesConfig]: crate::model::AttributesConfig
    pub fn update_attributes_config(
        &self,
    ) -> super::builder::catalog_service::UpdateAttributesConfig {
        super::builder::catalog_service::UpdateAttributesConfig::new(self.inner.clone())
    }

    /// Adds the specified
    /// [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] to the
    /// [AttributesConfig][google.cloud.retail.v2.AttributesConfig].
    ///
    /// If the [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] to add
    /// already exists, an ALREADY_EXISTS error is returned.
    ///
    /// [google.cloud.retail.v2.AttributesConfig]: crate::model::AttributesConfig
    /// [google.cloud.retail.v2.CatalogAttribute]: crate::model::CatalogAttribute
    pub fn add_catalog_attribute(&self) -> super::builder::catalog_service::AddCatalogAttribute {
        super::builder::catalog_service::AddCatalogAttribute::new(self.inner.clone())
    }

    /// Removes the specified
    /// [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] from the
    /// [AttributesConfig][google.cloud.retail.v2.AttributesConfig].
    ///
    /// If the [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] to
    /// remove does not exist, a NOT_FOUND error is returned.
    ///
    /// [google.cloud.retail.v2.AttributesConfig]: crate::model::AttributesConfig
    /// [google.cloud.retail.v2.CatalogAttribute]: crate::model::CatalogAttribute
    pub fn remove_catalog_attribute(
        &self,
    ) -> super::builder::catalog_service::RemoveCatalogAttribute {
        super::builder::catalog_service::RemoveCatalogAttribute::new(self.inner.clone())
    }

    /// Replaces the specified
    /// [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] in the
    /// [AttributesConfig][google.cloud.retail.v2.AttributesConfig] by updating the
    /// catalog attribute with the same
    /// [CatalogAttribute.key][google.cloud.retail.v2.CatalogAttribute.key].
    ///
    /// If the [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] to
    /// replace does not exist, a NOT_FOUND error is returned.
    ///
    /// [google.cloud.retail.v2.AttributesConfig]: crate::model::AttributesConfig
    /// [google.cloud.retail.v2.CatalogAttribute]: crate::model::CatalogAttribute
    /// [google.cloud.retail.v2.CatalogAttribute.key]: crate::model::CatalogAttribute::key
    pub fn replace_catalog_attribute(
        &self,
    ) -> super::builder::catalog_service::ReplaceCatalogAttribute {
        super::builder::catalog_service::ReplaceCatalogAttribute::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn list_operations(&self) -> super::builder::catalog_service::ListOperations {
        super::builder::catalog_service::ListOperations::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(&self) -> super::builder::catalog_service::GetOperation {
        super::builder::catalog_service::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Vertex AI Search for commerce API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_retail_v2::client::CompletionService;
/// let client = CompletionService::builder().build().await?;
/// // use `client` to make requests to the Vertex AI Search for commerce API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// Autocomplete service for retail.
///
/// This feature is only available for users who have Retail Search enabled.
/// Enable Retail Search on Cloud Console before using this feature.
///
/// # Configuration
///
/// To configure `CompletionService` use the `with_*` methods in the type returned
/// by [builder()][CompletionService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://retail.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::completion_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::completion_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `CompletionService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `CompletionService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct CompletionService {
    inner: std::sync::Arc<dyn super::stub::dynamic::CompletionService>,
}

impl CompletionService {
    /// Returns a builder for [CompletionService].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_retail_v2::client::CompletionService;
    /// let client = CompletionService::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::completion_service::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::completion_service::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::CompletionService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::CompletionService>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::CompletionService> {
        super::transport::CompletionService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::CompletionService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::CompletionService::new)
    }

    /// Completes the specified prefix with keyword suggestions.
    ///
    /// This feature is only available for users who have Retail Search enabled.
    /// Enable Retail Search on Cloud Console before using this feature.
    pub fn complete_query(&self) -> super::builder::completion_service::CompleteQuery {
        super::builder::completion_service::CompleteQuery::new(self.inner.clone())
    }

    /// Bulk import of processed completion dataset.
    ///
    /// Request processing is asynchronous. Partial updating is not supported.
    ///
    /// The operation is successfully finished only after the imported suggestions
    /// are indexed successfully and ready for serving. The process takes hours.
    ///
    /// This feature is only available for users who have Retail Search enabled.
    /// Enable Retail Search on Cloud Console before using this feature.
    ///
    /// # Long running operations
    ///
    /// This method is used to start, and/or poll a [long-running Operation].
    /// The [Working with long-running operations] chapter in the [user guide]
    /// covers these operations in detail.
    ///
    /// [long-running operation]: https://google.aip.dev/151
    /// [user guide]: https://googleapis.github.io/google-cloud-rust/
    /// [working with long-running operations]: https://googleapis.github.io/google-cloud-rust/working_with_long_running_operations.html
    pub fn import_completion_data(
        &self,
    ) -> super::builder::completion_service::ImportCompletionData {
        super::builder::completion_service::ImportCompletionData::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn list_operations(&self) -> super::builder::completion_service::ListOperations {
        super::builder::completion_service::ListOperations::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(&self) -> super::builder::completion_service::GetOperation {
        super::builder::completion_service::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Vertex AI Search for commerce API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_retail_v2::client::ControlService;
/// let client = ControlService::builder().build().await?;
/// // use `client` to make requests to the Vertex AI Search for commerce API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// Service for modifying Control.
///
/// # Configuration
///
/// To configure `ControlService` use the `with_*` methods in the type returned
/// by [builder()][ControlService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://retail.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::control_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::control_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `ControlService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ControlService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct ControlService {
    inner: std::sync::Arc<dyn super::stub::dynamic::ControlService>,
}

impl ControlService {
    /// Returns a builder for [ControlService].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_retail_v2::client::ControlService;
    /// let client = ControlService::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::control_service::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::control_service::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::ControlService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::ControlService>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ControlService> {
        super::transport::ControlService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ControlService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::ControlService::new)
    }

    /// Creates a Control.
    ///
    /// If the [Control][google.cloud.retail.v2.Control] to create already exists,
    /// an ALREADY_EXISTS error is returned.
    ///
    /// [google.cloud.retail.v2.Control]: crate::model::Control
    pub fn create_control(&self) -> super::builder::control_service::CreateControl {
        super::builder::control_service::CreateControl::new(self.inner.clone())
    }

    /// Deletes a Control.
    ///
    /// If the [Control][google.cloud.retail.v2.Control] to delete does not exist,
    /// a NOT_FOUND error is returned.
    ///
    /// [google.cloud.retail.v2.Control]: crate::model::Control
    pub fn delete_control(&self) -> super::builder::control_service::DeleteControl {
        super::builder::control_service::DeleteControl::new(self.inner.clone())
    }

    /// Updates a Control.
    ///
    /// [Control][google.cloud.retail.v2.Control] cannot be set to a different
    /// oneof field, if so an INVALID_ARGUMENT is returned. If the
    /// [Control][google.cloud.retail.v2.Control] to update does not exist, a
    /// NOT_FOUND error is returned.
    ///
    /// [google.cloud.retail.v2.Control]: crate::model::Control
    pub fn update_control(&self) -> super::builder::control_service::UpdateControl {
        super::builder::control_service::UpdateControl::new(self.inner.clone())
    }

    /// Gets a Control.
    pub fn get_control(&self) -> super::builder::control_service::GetControl {
        super::builder::control_service::GetControl::new(self.inner.clone())
    }

    /// Lists all Controls by their parent
    /// [Catalog][google.cloud.retail.v2.Catalog].
    ///
    /// [google.cloud.retail.v2.Catalog]: crate::model::Catalog
    pub fn list_controls(&self) -> super::builder::control_service::ListControls {
        super::builder::control_service::ListControls::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn list_operations(&self) -> super::builder::control_service::ListOperations {
        super::builder::control_service::ListOperations::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(&self) -> super::builder::control_service::GetOperation {
        super::builder::control_service::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Vertex AI Search for commerce API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_retail_v2::client::ConversationalSearchService;
/// let client = ConversationalSearchService::builder().build().await?;
/// // use `client` to make requests to the Vertex AI Search for commerce API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// Service for retail conversational search.
///
/// This feature is only available for users who have Retail Conversational
/// Search enabled. Enable Retail Conversational Search on Cloud Console
/// before using this feature.
///
/// # Configuration
///
/// To configure `ConversationalSearchService` use the `with_*` methods in the type returned
/// by [builder()][ConversationalSearchService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://retail.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::conversational_search_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::conversational_search_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `ConversationalSearchService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ConversationalSearchService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct ConversationalSearchService {
    inner: std::sync::Arc<dyn super::stub::dynamic::ConversationalSearchService>,
}

impl ConversationalSearchService {
    /// Returns a builder for [ConversationalSearchService].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_retail_v2::client::ConversationalSearchService;
    /// let client = ConversationalSearchService::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::conversational_search_service::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::conversational_search_service::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::ConversationalSearchService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::ConversationalSearchService>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ConversationalSearchService> {
        super::transport::ConversationalSearchService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ConversationalSearchService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::ConversationalSearchService::new)
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn list_operations(&self) -> super::builder::conversational_search_service::ListOperations {
        super::builder::conversational_search_service::ListOperations::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(&self) -> super::builder::conversational_search_service::GetOperation {
        super::builder::conversational_search_service::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Vertex AI Search for commerce API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_retail_v2::client::GenerativeQuestionService;
/// let client = GenerativeQuestionService::builder().build().await?;
/// // use `client` to make requests to the Vertex AI Search for commerce API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// Service for managing LLM generated questions in search serving.
///
/// # Configuration
///
/// To configure `GenerativeQuestionService` use the `with_*` methods in the type returned
/// by [builder()][GenerativeQuestionService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://retail.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::generative_question_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::generative_question_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `GenerativeQuestionService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `GenerativeQuestionService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct GenerativeQuestionService {
    inner: std::sync::Arc<dyn super::stub::dynamic::GenerativeQuestionService>,
}

impl GenerativeQuestionService {
    /// Returns a builder for [GenerativeQuestionService].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_retail_v2::client::GenerativeQuestionService;
    /// let client = GenerativeQuestionService::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::generative_question_service::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::generative_question_service::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::GenerativeQuestionService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::GenerativeQuestionService>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::GenerativeQuestionService> {
        super::transport::GenerativeQuestionService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::GenerativeQuestionService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::GenerativeQuestionService::new)
    }

    /// Manages overal generative question feature state -- enables toggling
    /// feature on and off.
    pub fn update_generative_questions_feature_config(
        &self,
    ) -> super::builder::generative_question_service::UpdateGenerativeQuestionsFeatureConfig {
        super::builder::generative_question_service::UpdateGenerativeQuestionsFeatureConfig::new(
            self.inner.clone(),
        )
    }

    /// Manages overal generative question feature state -- enables toggling
    /// feature on and off.
    pub fn get_generative_questions_feature_config(
        &self,
    ) -> super::builder::generative_question_service::GetGenerativeQuestionsFeatureConfig {
        super::builder::generative_question_service::GetGenerativeQuestionsFeatureConfig::new(
            self.inner.clone(),
        )
    }

    /// Returns all questions for a given catalog.
    pub fn list_generative_question_configs(
        &self,
    ) -> super::builder::generative_question_service::ListGenerativeQuestionConfigs {
        super::builder::generative_question_service::ListGenerativeQuestionConfigs::new(
            self.inner.clone(),
        )
    }

    /// Allows management of individual questions.
    pub fn update_generative_question_config(
        &self,
    ) -> super::builder::generative_question_service::UpdateGenerativeQuestionConfig {
        super::builder::generative_question_service::UpdateGenerativeQuestionConfig::new(
            self.inner.clone(),
        )
    }

    /// Allows management of multiple questions.
    pub fn batch_update_generative_question_configs(
        &self,
    ) -> super::builder::generative_question_service::BatchUpdateGenerativeQuestionConfigs {
        super::builder::generative_question_service::BatchUpdateGenerativeQuestionConfigs::new(
            self.inner.clone(),
        )
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn list_operations(&self) -> super::builder::generative_question_service::ListOperations {
        super::builder::generative_question_service::ListOperations::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(&self) -> super::builder::generative_question_service::GetOperation {
        super::builder::generative_question_service::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Vertex AI Search for commerce API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_retail_v2::client::ModelService;
/// let client = ModelService::builder().build().await?;
/// // use `client` to make requests to the Vertex AI Search for commerce API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// Service for performing CRUD operations on models.
/// Recommendation models contain all the metadata necessary to generate a set of
/// models for the `Predict()` API. A model is queried
/// indirectly via a ServingConfig, which associates a model with a
/// given Placement (e.g. Frequently Bought Together on Home Page).
///
/// This service allows you to do the following:
///
/// * Initiate training of a model.
/// * Pause training of an existing model.
/// * List all the available models along with their metadata.
/// * Control their tuning schedule.
///
/// # Configuration
///
/// To configure `ModelService` use the `with_*` methods in the type returned
/// by [builder()][ModelService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://retail.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::model_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::model_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `ModelService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ModelService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct ModelService {
    inner: std::sync::Arc<dyn super::stub::dynamic::ModelService>,
}

impl ModelService {
    /// Returns a builder for [ModelService].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_retail_v2::client::ModelService;
    /// let client = ModelService::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::model_service::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::model_service::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::ModelService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::ModelService>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ModelService> {
        super::transport::ModelService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ModelService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::ModelService::new)
    }

    /// Creates a new model.
    ///
    /// # Long running operations
    ///
    /// This method is used to start, and/or poll a [long-running Operation].
    /// The [Working with long-running operations] chapter in the [user guide]
    /// covers these operations in detail.
    ///
    /// [long-running operation]: https://google.aip.dev/151
    /// [user guide]: https://googleapis.github.io/google-cloud-rust/
    /// [working with long-running operations]: https://googleapis.github.io/google-cloud-rust/working_with_long_running_operations.html
    pub fn create_model(&self) -> super::builder::model_service::CreateModel {
        super::builder::model_service::CreateModel::new(self.inner.clone())
    }

    /// Gets a model.
    pub fn get_model(&self) -> super::builder::model_service::GetModel {
        super::builder::model_service::GetModel::new(self.inner.clone())
    }

    /// Pauses the training of an existing model.
    pub fn pause_model(&self) -> super::builder::model_service::PauseModel {
        super::builder::model_service::PauseModel::new(self.inner.clone())
    }

    /// Resumes the training of an existing model.
    pub fn resume_model(&self) -> super::builder::model_service::ResumeModel {
        super::builder::model_service::ResumeModel::new(self.inner.clone())
    }

    /// Deletes an existing model.
    pub fn delete_model(&self) -> super::builder::model_service::DeleteModel {
        super::builder::model_service::DeleteModel::new(self.inner.clone())
    }

    /// Lists all the models linked to this event store.
    pub fn list_models(&self) -> super::builder::model_service::ListModels {
        super::builder::model_service::ListModels::new(self.inner.clone())
    }

    /// Update of model metadata. Only fields that
    /// currently can be updated are: `filtering_option` and
    /// `periodic_tuning_state`.
    /// If other values are provided, this API method ignores them.
    pub fn update_model(&self) -> super::builder::model_service::UpdateModel {
        super::builder::model_service::UpdateModel::new(self.inner.clone())
    }

    /// Tunes an existing model.
    ///
    /// # Long running operations
    ///
    /// This method is used to start, and/or poll a [long-running Operation].
    /// The [Working with long-running operations] chapter in the [user guide]
    /// covers these operations in detail.
    ///
    /// [long-running operation]: https://google.aip.dev/151
    /// [user guide]: https://googleapis.github.io/google-cloud-rust/
    /// [working with long-running operations]: https://googleapis.github.io/google-cloud-rust/working_with_long_running_operations.html
    pub fn tune_model(&self) -> super::builder::model_service::TuneModel {
        super::builder::model_service::TuneModel::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn list_operations(&self) -> super::builder::model_service::ListOperations {
        super::builder::model_service::ListOperations::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(&self) -> super::builder::model_service::GetOperation {
        super::builder::model_service::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Vertex AI Search for commerce API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_retail_v2::client::PredictionService;
/// let client = PredictionService::builder().build().await?;
/// // use `client` to make requests to the Vertex AI Search for commerce API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// Service for making recommendation prediction.
///
/// # Configuration
///
/// To configure `PredictionService` use the `with_*` methods in the type returned
/// by [builder()][PredictionService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://retail.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::prediction_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::prediction_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `PredictionService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `PredictionService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct PredictionService {
    inner: std::sync::Arc<dyn super::stub::dynamic::PredictionService>,
}

impl PredictionService {
    /// Returns a builder for [PredictionService].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_retail_v2::client::PredictionService;
    /// let client = PredictionService::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::prediction_service::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::prediction_service::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::PredictionService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::PredictionService>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::PredictionService> {
        super::transport::PredictionService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::PredictionService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::PredictionService::new)
    }

    /// Makes a recommendation prediction.
    pub fn predict(&self) -> super::builder::prediction_service::Predict {
        super::builder::prediction_service::Predict::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn list_operations(&self) -> super::builder::prediction_service::ListOperations {
        super::builder::prediction_service::ListOperations::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(&self) -> super::builder::prediction_service::GetOperation {
        super::builder::prediction_service::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Vertex AI Search for commerce API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_retail_v2::client::ProductService;
/// let client = ProductService::builder().build().await?;
/// // use `client` to make requests to the Vertex AI Search for commerce API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// Service for ingesting [Product][google.cloud.retail.v2.Product] information
/// of the customer's website.
///
/// [google.cloud.retail.v2.Product]: crate::model::Product
///
/// # Configuration
///
/// To configure `ProductService` use the `with_*` methods in the type returned
/// by [builder()][ProductService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://retail.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::product_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::product_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `ProductService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ProductService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct ProductService {
    inner: std::sync::Arc<dyn super::stub::dynamic::ProductService>,
}

impl ProductService {
    /// Returns a builder for [ProductService].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_retail_v2::client::ProductService;
    /// let client = ProductService::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::product_service::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::product_service::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::ProductService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::ProductService>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ProductService> {
        super::transport::ProductService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ProductService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::ProductService::new)
    }

    /// Creates a [Product][google.cloud.retail.v2.Product].
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub fn create_product(&self) -> super::builder::product_service::CreateProduct {
        super::builder::product_service::CreateProduct::new(self.inner.clone())
    }

    /// Gets a [Product][google.cloud.retail.v2.Product].
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub fn get_product(&self) -> super::builder::product_service::GetProduct {
        super::builder::product_service::GetProduct::new(self.inner.clone())
    }

    /// Gets a list of [Product][google.cloud.retail.v2.Product]s.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub fn list_products(&self) -> super::builder::product_service::ListProducts {
        super::builder::product_service::ListProducts::new(self.inner.clone())
    }

    /// Updates a [Product][google.cloud.retail.v2.Product].
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub fn update_product(&self) -> super::builder::product_service::UpdateProduct {
        super::builder::product_service::UpdateProduct::new(self.inner.clone())
    }

    /// Deletes a [Product][google.cloud.retail.v2.Product].
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub fn delete_product(&self) -> super::builder::product_service::DeleteProduct {
        super::builder::product_service::DeleteProduct::new(self.inner.clone())
    }

    /// Permanently deletes all selected [Product][google.cloud.retail.v2.Product]s
    /// under a branch.
    ///
    /// This process is asynchronous. If the request is valid, the removal will be
    /// enqueued and processed offline. Depending on the number of
    /// [Product][google.cloud.retail.v2.Product]s, this operation could take hours
    /// to complete. Before the operation completes, some
    /// [Product][google.cloud.retail.v2.Product]s may still be returned by
    /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct]
    /// or
    /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts].
    ///
    /// Depending on the number of [Product][google.cloud.retail.v2.Product]s, this
    /// operation could take hours to complete. To get a sample of
    /// [Product][google.cloud.retail.v2.Product]s that would be deleted, set
    /// [PurgeProductsRequest.force][google.cloud.retail.v2.PurgeProductsRequest.force]
    /// to false.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.ProductService.GetProduct]: crate::client::ProductService::get_product
    /// [google.cloud.retail.v2.ProductService.ListProducts]: crate::client::ProductService::list_products
    /// [google.cloud.retail.v2.PurgeProductsRequest.force]: crate::model::PurgeProductsRequest::force
    ///
    /// # Long running operations
    ///
    /// This method is used to start, and/or poll a [long-running Operation].
    /// The [Working with long-running operations] chapter in the [user guide]
    /// covers these operations in detail.
    ///
    /// [long-running operation]: https://google.aip.dev/151
    /// [user guide]: https://googleapis.github.io/google-cloud-rust/
    /// [working with long-running operations]: https://googleapis.github.io/google-cloud-rust/working_with_long_running_operations.html
    pub fn purge_products(&self) -> super::builder::product_service::PurgeProducts {
        super::builder::product_service::PurgeProducts::new(self.inner.clone())
    }

    /// Bulk import of multiple [Product][google.cloud.retail.v2.Product]s.
    ///
    /// Request processing may be synchronous.
    /// Non-existing items are created.
    ///
    /// Note that it is possible for a subset of the
    /// [Product][google.cloud.retail.v2.Product]s to be successfully updated.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    ///
    /// # Long running operations
    ///
    /// This method is used to start, and/or poll a [long-running Operation].
    /// The [Working with long-running operations] chapter in the [user guide]
    /// covers these operations in detail.
    ///
    /// [long-running operation]: https://google.aip.dev/151
    /// [user guide]: https://googleapis.github.io/google-cloud-rust/
    /// [working with long-running operations]: https://googleapis.github.io/google-cloud-rust/working_with_long_running_operations.html
    pub fn import_products(&self) -> super::builder::product_service::ImportProducts {
        super::builder::product_service::ImportProducts::new(self.inner.clone())
    }

    /// Updates inventory information for a
    /// [Product][google.cloud.retail.v2.Product] while respecting the last update
    /// timestamps of each inventory field.
    ///
    /// This process is asynchronous and does not require the
    /// [Product][google.cloud.retail.v2.Product] to exist before updating
    /// fulfillment information. If the request is valid, the update is enqueued
    /// and processed downstream. As a consequence, when a response is returned,
    /// updates are not immediately manifested in the
    /// [Product][google.cloud.retail.v2.Product] queried by
    /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct]
    /// or
    /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts].
    ///
    /// When inventory is updated with
    /// [ProductService.CreateProduct][google.cloud.retail.v2.ProductService.CreateProduct]
    /// and
    /// [ProductService.UpdateProduct][google.cloud.retail.v2.ProductService.UpdateProduct],
    /// the specified inventory field value(s) overwrite any existing value(s)
    /// while ignoring the last update time for this field. Furthermore, the last
    /// update times for the specified inventory fields are overwritten by the
    /// times of the
    /// [ProductService.CreateProduct][google.cloud.retail.v2.ProductService.CreateProduct]
    /// or
    /// [ProductService.UpdateProduct][google.cloud.retail.v2.ProductService.UpdateProduct]
    /// request.
    ///
    /// If no inventory fields are set in
    /// [CreateProductRequest.product][google.cloud.retail.v2.CreateProductRequest.product],
    /// then any pre-existing inventory information for this product is used.
    ///
    /// If no inventory fields are set in
    /// [SetInventoryRequest.set_mask][google.cloud.retail.v2.SetInventoryRequest.set_mask],
    /// then any existing inventory information is preserved.
    ///
    /// Pre-existing inventory information can only be updated with
    /// [ProductService.SetInventory][google.cloud.retail.v2.ProductService.SetInventory],
    /// [ProductService.AddFulfillmentPlaces][google.cloud.retail.v2.ProductService.AddFulfillmentPlaces],
    /// and
    /// [ProductService.RemoveFulfillmentPlaces][google.cloud.retail.v2.ProductService.RemoveFulfillmentPlaces].
    ///
    /// The returned [Operation][google.longrunning.Operation]s is obsolete after
    /// one day, and the [GetOperation][google.longrunning.Operations.GetOperation]
    /// API returns `NOT_FOUND` afterwards.
    ///
    /// If conflicting updates are issued, the
    /// [Operation][google.longrunning.Operation]s associated with the stale
    /// updates are not marked as [done][google.longrunning.Operation.done] until
    /// they are obsolete.
    ///
    /// [google.cloud.retail.v2.CreateProductRequest.product]: crate::model::CreateProductRequest::product
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.ProductService.AddFulfillmentPlaces]: crate::client::ProductService::add_fulfillment_places
    /// [google.cloud.retail.v2.ProductService.CreateProduct]: crate::client::ProductService::create_product
    /// [google.cloud.retail.v2.ProductService.GetProduct]: crate::client::ProductService::get_product
    /// [google.cloud.retail.v2.ProductService.ListProducts]: crate::client::ProductService::list_products
    /// [google.cloud.retail.v2.ProductService.RemoveFulfillmentPlaces]: crate::client::ProductService::remove_fulfillment_places
    /// [google.cloud.retail.v2.ProductService.SetInventory]: crate::client::ProductService::set_inventory
    /// [google.cloud.retail.v2.ProductService.UpdateProduct]: crate::client::ProductService::update_product
    /// [google.cloud.retail.v2.SetInventoryRequest.set_mask]: crate::model::SetInventoryRequest::set_mask
    /// [google.longrunning.Operation]: longrunning::model::Operation
    /// [google.longrunning.Operation.done]: longrunning::model::Operation::done
    ///
    /// # Long running operations
    ///
    /// This method is used to start, and/or poll a [long-running Operation].
    /// The [Working with long-running operations] chapter in the [user guide]
    /// covers these operations in detail.
    ///
    /// [long-running operation]: https://google.aip.dev/151
    /// [user guide]: https://googleapis.github.io/google-cloud-rust/
    /// [working with long-running operations]: https://googleapis.github.io/google-cloud-rust/working_with_long_running_operations.html
    pub fn set_inventory(&self) -> super::builder::product_service::SetInventory {
        super::builder::product_service::SetInventory::new(self.inner.clone())
    }

    /// We recommend that you use the
    /// [ProductService.AddLocalInventories][google.cloud.retail.v2.ProductService.AddLocalInventories]
    /// method instead of the
    /// [ProductService.AddFulfillmentPlaces][google.cloud.retail.v2.ProductService.AddFulfillmentPlaces]
    /// method.
    /// [ProductService.AddLocalInventories][google.cloud.retail.v2.ProductService.AddLocalInventories]
    /// achieves the same results but provides more fine-grained control over
    /// ingesting local inventory data.
    ///
    /// Incrementally adds place IDs to
    /// [Product.fulfillment_info.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids].
    ///
    /// This process is asynchronous and does not require the
    /// [Product][google.cloud.retail.v2.Product] to exist before updating
    /// fulfillment information. If the request is valid, the update will be
    /// enqueued and processed downstream. As a consequence, when a response is
    /// returned, the added place IDs are not immediately manifested in the
    /// [Product][google.cloud.retail.v2.Product] queried by
    /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct]
    /// or
    /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts].
    ///
    /// The returned [Operation][google.longrunning.Operation]s will be obsolete
    /// after 1 day, and [GetOperation][google.longrunning.Operations.GetOperation]
    /// API will return NOT_FOUND afterwards.
    ///
    /// If conflicting updates are issued, the
    /// [Operation][google.longrunning.Operation]s associated with the stale
    /// updates will not be marked as [done][google.longrunning.Operation.done]
    /// until being obsolete.
    ///
    /// [google.cloud.retail.v2.FulfillmentInfo.place_ids]: crate::model::FulfillmentInfo::place_ids
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.ProductService.AddFulfillmentPlaces]: crate::client::ProductService::add_fulfillment_places
    /// [google.cloud.retail.v2.ProductService.AddLocalInventories]: crate::client::ProductService::add_local_inventories
    /// [google.cloud.retail.v2.ProductService.GetProduct]: crate::client::ProductService::get_product
    /// [google.cloud.retail.v2.ProductService.ListProducts]: crate::client::ProductService::list_products
    /// [google.longrunning.Operation]: longrunning::model::Operation
    /// [google.longrunning.Operation.done]: longrunning::model::Operation::done
    ///
    /// # Long running operations
    ///
    /// This method is used to start, and/or poll a [long-running Operation].
    /// The [Working with long-running operations] chapter in the [user guide]
    /// covers these operations in detail.
    ///
    /// [long-running operation]: https://google.aip.dev/151
    /// [user guide]: https://googleapis.github.io/google-cloud-rust/
    /// [working with long-running operations]: https://googleapis.github.io/google-cloud-rust/working_with_long_running_operations.html
    pub fn add_fulfillment_places(&self) -> super::builder::product_service::AddFulfillmentPlaces {
        super::builder::product_service::AddFulfillmentPlaces::new(self.inner.clone())
    }

    /// We recommend that you use the
    /// [ProductService.RemoveLocalInventories][google.cloud.retail.v2.ProductService.RemoveLocalInventories]
    /// method instead of the
    /// [ProductService.RemoveFulfillmentPlaces][google.cloud.retail.v2.ProductService.RemoveFulfillmentPlaces]
    /// method.
    /// [ProductService.RemoveLocalInventories][google.cloud.retail.v2.ProductService.RemoveLocalInventories]
    /// achieves the same results but provides more fine-grained control over
    /// ingesting local inventory data.
    ///
    /// Incrementally removes place IDs from a
    /// [Product.fulfillment_info.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids].
    ///
    /// This process is asynchronous and does not require the
    /// [Product][google.cloud.retail.v2.Product] to exist before updating
    /// fulfillment information. If the request is valid, the update will be
    /// enqueued and processed downstream. As a consequence, when a response is
    /// returned, the removed place IDs are not immediately manifested in the
    /// [Product][google.cloud.retail.v2.Product] queried by
    /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct]
    /// or
    /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts].
    ///
    /// The returned [Operation][google.longrunning.Operation]s will be obsolete
    /// after 1 day, and [GetOperation][google.longrunning.Operations.GetOperation]
    /// API will return NOT_FOUND afterwards.
    ///
    /// If conflicting updates are issued, the
    /// [Operation][google.longrunning.Operation]s associated with the stale
    /// updates will not be marked as [done][google.longrunning.Operation.done]
    /// until being obsolete.
    ///
    /// [google.cloud.retail.v2.FulfillmentInfo.place_ids]: crate::model::FulfillmentInfo::place_ids
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.ProductService.GetProduct]: crate::client::ProductService::get_product
    /// [google.cloud.retail.v2.ProductService.ListProducts]: crate::client::ProductService::list_products
    /// [google.cloud.retail.v2.ProductService.RemoveFulfillmentPlaces]: crate::client::ProductService::remove_fulfillment_places
    /// [google.cloud.retail.v2.ProductService.RemoveLocalInventories]: crate::client::ProductService::remove_local_inventories
    /// [google.longrunning.Operation]: longrunning::model::Operation
    /// [google.longrunning.Operation.done]: longrunning::model::Operation::done
    ///
    /// # Long running operations
    ///
    /// This method is used to start, and/or poll a [long-running Operation].
    /// The [Working with long-running operations] chapter in the [user guide]
    /// covers these operations in detail.
    ///
    /// [long-running operation]: https://google.aip.dev/151
    /// [user guide]: https://googleapis.github.io/google-cloud-rust/
    /// [working with long-running operations]: https://googleapis.github.io/google-cloud-rust/working_with_long_running_operations.html
    pub fn remove_fulfillment_places(
        &self,
    ) -> super::builder::product_service::RemoveFulfillmentPlaces {
        super::builder::product_service::RemoveFulfillmentPlaces::new(self.inner.clone())
    }

    /// Updates local inventory information for a
    /// [Product][google.cloud.retail.v2.Product] at a list of places, while
    /// respecting the last update timestamps of each inventory field.
    ///
    /// This process is asynchronous and does not require the
    /// [Product][google.cloud.retail.v2.Product] to exist before updating
    /// inventory information. If the request is valid, the update will be enqueued
    /// and processed downstream. As a consequence, when a response is returned,
    /// updates are not immediately manifested in the
    /// [Product][google.cloud.retail.v2.Product] queried by
    /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct]
    /// or
    /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts].
    ///
    /// Local inventory information can only be modified using this method.
    /// [ProductService.CreateProduct][google.cloud.retail.v2.ProductService.CreateProduct]
    /// and
    /// [ProductService.UpdateProduct][google.cloud.retail.v2.ProductService.UpdateProduct]
    /// has no effect on local inventories.
    ///
    /// The returned [Operation][google.longrunning.Operation]s will be obsolete
    /// after 1 day, and [GetOperation][google.longrunning.Operations.GetOperation]
    /// API will return NOT_FOUND afterwards.
    ///
    /// If conflicting updates are issued, the
    /// [Operation][google.longrunning.Operation]s associated with the stale
    /// updates will not be marked as [done][google.longrunning.Operation.done]
    /// until being obsolete.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.ProductService.CreateProduct]: crate::client::ProductService::create_product
    /// [google.cloud.retail.v2.ProductService.GetProduct]: crate::client::ProductService::get_product
    /// [google.cloud.retail.v2.ProductService.ListProducts]: crate::client::ProductService::list_products
    /// [google.cloud.retail.v2.ProductService.UpdateProduct]: crate::client::ProductService::update_product
    /// [google.longrunning.Operation]: longrunning::model::Operation
    /// [google.longrunning.Operation.done]: longrunning::model::Operation::done
    ///
    /// # Long running operations
    ///
    /// This method is used to start, and/or poll a [long-running Operation].
    /// The [Working with long-running operations] chapter in the [user guide]
    /// covers these operations in detail.
    ///
    /// [long-running operation]: https://google.aip.dev/151
    /// [user guide]: https://googleapis.github.io/google-cloud-rust/
    /// [working with long-running operations]: https://googleapis.github.io/google-cloud-rust/working_with_long_running_operations.html
    pub fn add_local_inventories(&self) -> super::builder::product_service::AddLocalInventories {
        super::builder::product_service::AddLocalInventories::new(self.inner.clone())
    }

    /// Remove local inventory information for a
    /// [Product][google.cloud.retail.v2.Product] at a list of places at a removal
    /// timestamp.
    ///
    /// This process is asynchronous. If the request is valid, the removal will be
    /// enqueued and processed downstream. As a consequence, when a response is
    /// returned, removals are not immediately manifested in the
    /// [Product][google.cloud.retail.v2.Product] queried by
    /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct]
    /// or
    /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts].
    ///
    /// Local inventory information can only be removed using this method.
    /// [ProductService.CreateProduct][google.cloud.retail.v2.ProductService.CreateProduct]
    /// and
    /// [ProductService.UpdateProduct][google.cloud.retail.v2.ProductService.UpdateProduct]
    /// has no effect on local inventories.
    ///
    /// The returned [Operation][google.longrunning.Operation]s will be obsolete
    /// after 1 day, and [GetOperation][google.longrunning.Operations.GetOperation]
    /// API will return NOT_FOUND afterwards.
    ///
    /// If conflicting updates are issued, the
    /// [Operation][google.longrunning.Operation]s associated with the stale
    /// updates will not be marked as [done][google.longrunning.Operation.done]
    /// until being obsolete.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.ProductService.CreateProduct]: crate::client::ProductService::create_product
    /// [google.cloud.retail.v2.ProductService.GetProduct]: crate::client::ProductService::get_product
    /// [google.cloud.retail.v2.ProductService.ListProducts]: crate::client::ProductService::list_products
    /// [google.cloud.retail.v2.ProductService.UpdateProduct]: crate::client::ProductService::update_product
    /// [google.longrunning.Operation]: longrunning::model::Operation
    /// [google.longrunning.Operation.done]: longrunning::model::Operation::done
    ///
    /// # Long running operations
    ///
    /// This method is used to start, and/or poll a [long-running Operation].
    /// The [Working with long-running operations] chapter in the [user guide]
    /// covers these operations in detail.
    ///
    /// [long-running operation]: https://google.aip.dev/151
    /// [user guide]: https://googleapis.github.io/google-cloud-rust/
    /// [working with long-running operations]: https://googleapis.github.io/google-cloud-rust/working_with_long_running_operations.html
    pub fn remove_local_inventories(
        &self,
    ) -> super::builder::product_service::RemoveLocalInventories {
        super::builder::product_service::RemoveLocalInventories::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn list_operations(&self) -> super::builder::product_service::ListOperations {
        super::builder::product_service::ListOperations::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(&self) -> super::builder::product_service::GetOperation {
        super::builder::product_service::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Vertex AI Search for commerce API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_retail_v2::client::SearchService;
/// let client = SearchService::builder().build().await?;
/// // use `client` to make requests to the Vertex AI Search for commerce API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// Service for search.
///
/// This feature is only available for users who have Retail Search enabled.
/// Enable Retail Search on Cloud Console before using this feature.
///
/// # Configuration
///
/// To configure `SearchService` use the `with_*` methods in the type returned
/// by [builder()][SearchService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://retail.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::search_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::search_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `SearchService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `SearchService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct SearchService {
    inner: std::sync::Arc<dyn super::stub::dynamic::SearchService>,
}

impl SearchService {
    /// Returns a builder for [SearchService].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_retail_v2::client::SearchService;
    /// let client = SearchService::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::search_service::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::search_service::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::SearchService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::SearchService>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::SearchService> {
        super::transport::SearchService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::SearchService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::SearchService::new)
    }

    /// Performs a search.
    ///
    /// This feature is only available for users who have Retail Search enabled.
    /// Enable Retail Search on Cloud Console before using this feature.
    pub fn search(&self) -> super::builder::search_service::Search {
        super::builder::search_service::Search::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn list_operations(&self) -> super::builder::search_service::ListOperations {
        super::builder::search_service::ListOperations::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(&self) -> super::builder::search_service::GetOperation {
        super::builder::search_service::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Vertex AI Search for commerce API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_retail_v2::client::ServingConfigService;
/// let client = ServingConfigService::builder().build().await?;
/// // use `client` to make requests to the Vertex AI Search for commerce API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// Service for modifying ServingConfig.
///
/// # Configuration
///
/// To configure `ServingConfigService` use the `with_*` methods in the type returned
/// by [builder()][ServingConfigService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://retail.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::serving_config_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::serving_config_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `ServingConfigService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ServingConfigService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct ServingConfigService {
    inner: std::sync::Arc<dyn super::stub::dynamic::ServingConfigService>,
}

impl ServingConfigService {
    /// Returns a builder for [ServingConfigService].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_retail_v2::client::ServingConfigService;
    /// let client = ServingConfigService::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::serving_config_service::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::serving_config_service::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::ServingConfigService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::ServingConfigService>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ServingConfigService> {
        super::transport::ServingConfigService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ServingConfigService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::ServingConfigService::new)
    }

    /// Creates a ServingConfig.
    ///
    /// A maximum of 100 [ServingConfig][google.cloud.retail.v2.ServingConfig]s are
    /// allowed in a [Catalog][google.cloud.retail.v2.Catalog], otherwise a
    /// FAILED_PRECONDITION error is returned.
    ///
    /// [google.cloud.retail.v2.Catalog]: crate::model::Catalog
    /// [google.cloud.retail.v2.ServingConfig]: crate::model::ServingConfig
    pub fn create_serving_config(
        &self,
    ) -> super::builder::serving_config_service::CreateServingConfig {
        super::builder::serving_config_service::CreateServingConfig::new(self.inner.clone())
    }

    /// Deletes a ServingConfig.
    ///
    /// Returns a NotFound error if the ServingConfig does not exist.
    pub fn delete_serving_config(
        &self,
    ) -> super::builder::serving_config_service::DeleteServingConfig {
        super::builder::serving_config_service::DeleteServingConfig::new(self.inner.clone())
    }

    /// Updates a ServingConfig.
    pub fn update_serving_config(
        &self,
    ) -> super::builder::serving_config_service::UpdateServingConfig {
        super::builder::serving_config_service::UpdateServingConfig::new(self.inner.clone())
    }

    /// Gets a ServingConfig.
    ///
    /// Returns a NotFound error if the ServingConfig does not exist.
    pub fn get_serving_config(&self) -> super::builder::serving_config_service::GetServingConfig {
        super::builder::serving_config_service::GetServingConfig::new(self.inner.clone())
    }

    /// Lists all ServingConfigs linked to this catalog.
    pub fn list_serving_configs(
        &self,
    ) -> super::builder::serving_config_service::ListServingConfigs {
        super::builder::serving_config_service::ListServingConfigs::new(self.inner.clone())
    }

    /// Enables a Control on the specified ServingConfig.
    /// The control is added in the last position of the list of controls
    /// it belongs to (e.g. if it's a facet spec control it will be applied
    /// in the last position of servingConfig.facetSpecIds)
    /// Returns a ALREADY_EXISTS error if the control has already been applied.
    /// Returns a FAILED_PRECONDITION error if the addition could exceed maximum
    /// number of control allowed for that type of control.
    pub fn add_control(&self) -> super::builder::serving_config_service::AddControl {
        super::builder::serving_config_service::AddControl::new(self.inner.clone())
    }

    /// Disables a Control on the specified ServingConfig.
    /// The control is removed from the ServingConfig.
    /// Returns a NOT_FOUND error if the Control is not enabled for the
    /// ServingConfig.
    pub fn remove_control(&self) -> super::builder::serving_config_service::RemoveControl {
        super::builder::serving_config_service::RemoveControl::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn list_operations(&self) -> super::builder::serving_config_service::ListOperations {
        super::builder::serving_config_service::ListOperations::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(&self) -> super::builder::serving_config_service::GetOperation {
        super::builder::serving_config_service::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Vertex AI Search for commerce API.
///
/// # Example
/// ```
/// # async fn sample() -> gax::client_builder::Result<()> {
/// # use google_cloud_retail_v2::client::UserEventService;
/// let client = UserEventService::builder().build().await?;
/// // use `client` to make requests to the Vertex AI Search for commerce API.
/// # Ok(()) }
/// ```
///
/// # Service Description
///
/// Service for ingesting end user actions on the customer website.
///
/// # Configuration
///
/// To configure `UserEventService` use the `with_*` methods in the type returned
/// by [builder()][UserEventService::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://retail.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::user_event_service::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::user_event_service::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `UserEventService` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `UserEventService` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[derive(Clone, Debug)]
pub struct UserEventService {
    inner: std::sync::Arc<dyn super::stub::dynamic::UserEventService>,
}

impl UserEventService {
    /// Returns a builder for [UserEventService].
    ///
    /// ```
    /// # async fn sample() -> gax::client_builder::Result<()> {
    /// # use google_cloud_retail_v2::client::UserEventService;
    /// let client = UserEventService::builder().build().await?;
    /// # Ok(()) }
    /// ```
    pub fn builder() -> super::builder::user_event_service::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::user_event_service::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::UserEventService + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::UserEventService>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::UserEventService> {
        super::transport::UserEventService::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::UserEventService> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::UserEventService::new)
    }

    /// Writes a single user event.
    pub fn write_user_event(&self) -> super::builder::user_event_service::WriteUserEvent {
        super::builder::user_event_service::WriteUserEvent::new(self.inner.clone())
    }

    /// Writes a single user event from the browser.
    ///
    /// For larger user event payload over 16 KB, the POST method should be used
    /// instead, otherwise a 400 Bad Request error is returned.
    ///
    /// This method is used only by the Retail API JavaScript pixel and Google Tag
    /// Manager. Users should not call this method directly.
    pub fn collect_user_event(&self) -> super::builder::user_event_service::CollectUserEvent {
        super::builder::user_event_service::CollectUserEvent::new(self.inner.clone())
    }

    /// Deletes permanently all user events specified by the filter provided.
    /// Depending on the number of events specified by the filter, this operation
    /// could take hours or days to complete. To test a filter, use the list
    /// command first.
    ///
    /// # Long running operations
    ///
    /// This method is used to start, and/or poll a [long-running Operation].
    /// The [Working with long-running operations] chapter in the [user guide]
    /// covers these operations in detail.
    ///
    /// [long-running operation]: https://google.aip.dev/151
    /// [user guide]: https://googleapis.github.io/google-cloud-rust/
    /// [working with long-running operations]: https://googleapis.github.io/google-cloud-rust/working_with_long_running_operations.html
    pub fn purge_user_events(&self) -> super::builder::user_event_service::PurgeUserEvents {
        super::builder::user_event_service::PurgeUserEvents::new(self.inner.clone())
    }

    /// Bulk import of User events. Request processing might be
    /// synchronous. Events that already exist are skipped.
    /// Use this method for backfilling historical user events.
    ///
    /// `Operation.response` is of type `ImportResponse`. Note that it is
    /// possible for a subset of the items to be successfully inserted.
    /// `Operation.metadata` is of type `ImportMetadata`.
    ///
    /// # Long running operations
    ///
    /// This method is used to start, and/or poll a [long-running Operation].
    /// The [Working with long-running operations] chapter in the [user guide]
    /// covers these operations in detail.
    ///
    /// [long-running operation]: https://google.aip.dev/151
    /// [user guide]: https://googleapis.github.io/google-cloud-rust/
    /// [working with long-running operations]: https://googleapis.github.io/google-cloud-rust/working_with_long_running_operations.html
    pub fn import_user_events(&self) -> super::builder::user_event_service::ImportUserEvents {
        super::builder::user_event_service::ImportUserEvents::new(self.inner.clone())
    }

    /// Starts a user-event rejoin operation with latest product catalog. Events
    /// are not annotated with detailed product information for products that are
    /// missing from the catalog when the user event is ingested. These
    /// events are stored as unjoined events with limited usage on training and
    /// serving. You can use this method to start a join operation on specified
    /// events with the latest version of product catalog. You can also use this
    /// method to correct events joined with the wrong product catalog. A rejoin
    /// operation can take hours or days to complete.
    ///
    /// # Long running operations
    ///
    /// This method is used to start, and/or poll a [long-running Operation].
    /// The [Working with long-running operations] chapter in the [user guide]
    /// covers these operations in detail.
    ///
    /// [long-running operation]: https://google.aip.dev/151
    /// [user guide]: https://googleapis.github.io/google-cloud-rust/
    /// [working with long-running operations]: https://googleapis.github.io/google-cloud-rust/working_with_long_running_operations.html
    pub fn rejoin_user_events(&self) -> super::builder::user_event_service::RejoinUserEvents {
        super::builder::user_event_service::RejoinUserEvents::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn list_operations(&self) -> super::builder::user_event_service::ListOperations {
        super::builder::user_event_service::ListOperations::new(self.inner.clone())
    }

    /// Provides the [Operations][google.longrunning.Operations] service functionality in this service.
    ///
    /// [google.longrunning.Operations]: longrunning::client::Operations
    pub fn get_operation(&self) -> super::builder::user_event_service::GetOperation {
        super::builder::user_event_service::GetOperation::new(self.inner.clone())
    }
}
