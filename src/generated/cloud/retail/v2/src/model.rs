// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Configures what level the product should be uploaded with regards to
/// how users will be send events and how predictions will be made.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProductLevelConfig {
    /// The type of [Product][google.cloud.retail.v2.Product]s allowed to be
    /// ingested into the catalog. Acceptable values are:
    ///
    /// * `primary` (default): You can ingest
    ///   [Product][google.cloud.retail.v2.Product]s of all types. When
    ///   ingesting a [Product][google.cloud.retail.v2.Product], its type will
    ///   default to
    ///   [Product.Type.PRIMARY][google.cloud.retail.v2.Product.Type.PRIMARY] if
    ///   unset.
    /// * `variant` (incompatible with Retail Search): You can only
    ///   ingest
    ///   [Product.Type.VARIANT][google.cloud.retail.v2.Product.Type.VARIANT]
    ///   [Product][google.cloud.retail.v2.Product]s. This means
    ///   [Product.primary_product_id][google.cloud.retail.v2.Product.primary_product_id]
    ///   cannot be empty.
    ///
    /// If this field is set to an invalid value other than these, an
    /// INVALID_ARGUMENT error is returned.
    ///
    /// If this field is `variant` and
    /// [merchant_center_product_id_field][google.cloud.retail.v2.ProductLevelConfig.merchant_center_product_id_field]
    /// is `itemGroupId`, an INVALID_ARGUMENT error is returned.
    ///
    /// See [Product
    /// levels](https://cloud.google.com/retail/docs/catalog#product-levels)
    /// for more details.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.Product.Type.PRIMARY]: crate::model::product::Type::Primary
    /// [google.cloud.retail.v2.Product.Type.VARIANT]: crate::model::product::Type::Variant
    /// [google.cloud.retail.v2.Product.primary_product_id]: crate::model::Product::primary_product_id
    /// [google.cloud.retail.v2.ProductLevelConfig.merchant_center_product_id_field]: crate::model::ProductLevelConfig::merchant_center_product_id_field
    pub ingestion_product_type: std::string::String,

    /// Which field of [Merchant Center
    /// Product](/bigquery-transfer/docs/merchant-center-products-schema) should be
    /// imported as [Product.id][google.cloud.retail.v2.Product.id]. Acceptable
    /// values are:
    ///
    /// * `offerId` (default): Import `offerId` as the product ID.
    /// * `itemGroupId`: Import `itemGroupId` as the product ID. Notice that Retail
    ///   API will choose one item from the ones with the same `itemGroupId`, and
    ///   use it to represent the item group.
    ///
    /// If this field is set to an invalid value other than these, an
    /// INVALID_ARGUMENT error is returned.
    ///
    /// If this field is `itemGroupId` and
    /// [ingestion_product_type][google.cloud.retail.v2.ProductLevelConfig.ingestion_product_type]
    /// is `variant`, an INVALID_ARGUMENT error is returned.
    ///
    /// See [Product
    /// levels](https://cloud.google.com/retail/docs/catalog#product-levels)
    /// for more details.
    ///
    /// [google.cloud.retail.v2.Product.id]: crate::model::Product::id
    /// [google.cloud.retail.v2.ProductLevelConfig.ingestion_product_type]: crate::model::ProductLevelConfig::ingestion_product_type
    pub merchant_center_product_id_field: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProductLevelConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ingestion_product_type][crate::model::ProductLevelConfig::ingestion_product_type].
    pub fn set_ingestion_product_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.ingestion_product_type = v.into();
        self
    }

    /// Sets the value of [merchant_center_product_id_field][crate::model::ProductLevelConfig::merchant_center_product_id_field].
    pub fn set_merchant_center_product_id_field<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.merchant_center_product_id_field = v.into();
        self
    }
}

impl wkt::message::Message for ProductLevelConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ProductLevelConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProductLevelConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ingestion_product_type,
            __merchant_center_product_id_field,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProductLevelConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ingestionProductType" => Ok(__FieldTag::__ingestion_product_type),
                            "ingestion_product_type" => Ok(__FieldTag::__ingestion_product_type),
                            "merchantCenterProductIdField" => {
                                Ok(__FieldTag::__merchant_center_product_id_field)
                            }
                            "merchant_center_product_id_field" => {
                                Ok(__FieldTag::__merchant_center_product_id_field)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProductLevelConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProductLevelConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ingestion_product_type => {
                            if !fields.insert(__FieldTag::__ingestion_product_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ingestion_product_type",
                                ));
                            }
                            result.ingestion_product_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__merchant_center_product_id_field => {
                            if !fields.insert(__FieldTag::__merchant_center_product_id_field) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for merchant_center_product_id_field",
                                ));
                            }
                            result.merchant_center_product_id_field = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProductLevelConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ingestion_product_type.is_empty() {
            state.serialize_entry("ingestionProductType", &self.ingestion_product_type)?;
        }
        if !self.merchant_center_product_id_field.is_empty() {
            state.serialize_entry(
                "merchantCenterProductIdField",
                &self.merchant_center_product_id_field,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ProductLevelConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProductLevelConfig");
        debug_struct.field("ingestion_product_type", &self.ingestion_product_type);
        debug_struct.field(
            "merchant_center_product_id_field",
            &self.merchant_center_product_id_field,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Catalog level attribute config for an attribute. For example, if customers
/// want to enable/disable facet for a specific attribute.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CatalogAttribute {
    /// Required. Attribute name.
    /// For example: `color`, `brands`, `attributes.custom_attribute`, such as
    /// `attributes.xyz`.
    /// To be indexable, the attribute name can contain only alpha-numeric
    /// characters and underscores. For example, an attribute named
    /// `attributes.abc_xyz` can be indexed, but an attribute named
    /// `attributes.abc-xyz` cannot be indexed.
    ///
    /// If the attribute key starts with `attributes.`, then the attribute is a
    /// custom attribute. Attributes such as `brands`, `patterns`, and `title` are
    /// built-in and called system attributes.
    pub key: std::string::String,

    /// Output only. Indicates whether this attribute has been used by any
    /// products. `True` if at least one [Product][google.cloud.retail.v2.Product]
    /// is using this attribute in
    /// [Product.attributes][google.cloud.retail.v2.Product.attributes]. Otherwise,
    /// this field is `False`.
    ///
    /// [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] can be
    /// pre-loaded by using
    /// [CatalogService.AddCatalogAttribute][google.cloud.retail.v2.CatalogService.AddCatalogAttribute]
    /// or
    /// [CatalogService.UpdateAttributesConfig][google.cloud.retail.v2.CatalogService.UpdateAttributesConfig]
    /// APIs. This field is `False` for pre-loaded
    /// [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute]s.
    ///
    /// Only pre-loaded [catalog
    /// attributes][google.cloud.retail.v2.CatalogAttribute] that are neither in
    /// use by products nor predefined can be deleted. [Catalog
    /// attributes][google.cloud.retail.v2.CatalogAttribute] that are
    /// either in use by products or are predefined attributes cannot be deleted;
    /// however, their configuration properties will reset to default values upon
    /// removal request.
    ///
    /// After catalog changes, it takes about 10 minutes for this field to update.
    ///
    /// [google.cloud.retail.v2.CatalogAttribute]: crate::model::CatalogAttribute
    /// [google.cloud.retail.v2.CatalogService.AddCatalogAttribute]: crate::client::CatalogService::add_catalog_attribute
    /// [google.cloud.retail.v2.CatalogService.UpdateAttributesConfig]: crate::client::CatalogService::update_attributes_config
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.Product.attributes]: crate::model::Product::attributes
    pub in_use: bool,

    /// Output only. The type of this attribute. This is derived from the attribute
    /// in [Product.attributes][google.cloud.retail.v2.Product.attributes].
    ///
    /// [google.cloud.retail.v2.Product.attributes]: crate::model::Product::attributes
    pub r#type: crate::model::catalog_attribute::AttributeType,

    /// When
    /// [AttributesConfig.attribute_config_level][google.cloud.retail.v2.AttributesConfig.attribute_config_level]
    /// is CATALOG_LEVEL_ATTRIBUTE_CONFIG, if INDEXABLE_ENABLED attribute values
    /// are indexed so that it can be filtered, faceted, or boosted in
    /// [SearchService.Search][google.cloud.retail.v2.SearchService.Search].
    ///
    /// Must be specified when
    /// [AttributesConfig.attribute_config_level][google.cloud.retail.v2.AttributesConfig.attribute_config_level]
    /// is CATALOG_LEVEL_ATTRIBUTE_CONFIG, otherwise throws INVALID_FORMAT error.
    ///
    /// [google.cloud.retail.v2.AttributesConfig.attribute_config_level]: crate::model::AttributesConfig::attribute_config_level
    /// [google.cloud.retail.v2.SearchService.Search]: crate::client::SearchService::search
    pub indexable_option: crate::model::catalog_attribute::IndexableOption,

    /// If DYNAMIC_FACETABLE_ENABLED, attribute values are available for dynamic
    /// facet. Could only be DYNAMIC_FACETABLE_DISABLED if
    /// [CatalogAttribute.indexable_option][google.cloud.retail.v2.CatalogAttribute.indexable_option]
    /// is INDEXABLE_DISABLED. Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// Must be specified, otherwise throws INVALID_FORMAT error.
    ///
    /// [google.cloud.retail.v2.CatalogAttribute.indexable_option]: crate::model::CatalogAttribute::indexable_option
    pub dynamic_facetable_option: crate::model::catalog_attribute::DynamicFacetableOption,

    /// When
    /// [AttributesConfig.attribute_config_level][google.cloud.retail.v2.AttributesConfig.attribute_config_level]
    /// is CATALOG_LEVEL_ATTRIBUTE_CONFIG, if SEARCHABLE_ENABLED, attribute values
    /// are searchable by text queries in
    /// [SearchService.Search][google.cloud.retail.v2.SearchService.Search].
    ///
    /// If SEARCHABLE_ENABLED but attribute type is numerical, attribute values
    /// will not be searchable by text queries in
    /// [SearchService.Search][google.cloud.retail.v2.SearchService.Search], as
    /// there are no text values associated to numerical attributes.
    ///
    /// Must be specified, when
    /// [AttributesConfig.attribute_config_level][google.cloud.retail.v2.AttributesConfig.attribute_config_level]
    /// is CATALOG_LEVEL_ATTRIBUTE_CONFIG, otherwise throws INVALID_FORMAT error.
    ///
    /// [google.cloud.retail.v2.AttributesConfig.attribute_config_level]: crate::model::AttributesConfig::attribute_config_level
    /// [google.cloud.retail.v2.SearchService.Search]: crate::client::SearchService::search
    pub searchable_option: crate::model::catalog_attribute::SearchableOption,

    /// If EXACT_SEARCHABLE_ENABLED, attribute values will be exact searchable.
    /// This property only applies to textual custom attributes and requires
    /// indexable set to enabled to enable exact-searchable. If unset, the server
    /// behavior defaults to
    /// [EXACT_SEARCHABLE_DISABLED][google.cloud.retail.v2.CatalogAttribute.ExactSearchableOption.EXACT_SEARCHABLE_DISABLED].
    ///
    /// [google.cloud.retail.v2.CatalogAttribute.ExactSearchableOption.EXACT_SEARCHABLE_DISABLED]: crate::model::catalog_attribute::ExactSearchableOption::ExactSearchableDisabled
    pub exact_searchable_option: crate::model::catalog_attribute::ExactSearchableOption,

    /// If RETRIEVABLE_ENABLED, attribute values are retrievable in the search
    /// results. If unset, the server behavior defaults to
    /// [RETRIEVABLE_DISABLED][google.cloud.retail.v2.CatalogAttribute.RetrievableOption.RETRIEVABLE_DISABLED].
    ///
    /// [google.cloud.retail.v2.CatalogAttribute.RetrievableOption.RETRIEVABLE_DISABLED]: crate::model::catalog_attribute::RetrievableOption::RetrievableDisabled
    pub retrievable_option: crate::model::catalog_attribute::RetrievableOption,

    /// Contains facet options.
    pub facet_config: std::option::Option<crate::model::catalog_attribute::FacetConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CatalogAttribute {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::CatalogAttribute::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [in_use][crate::model::CatalogAttribute::in_use].
    pub fn set_in_use<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.in_use = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::CatalogAttribute::type].
    pub fn set_type<T: std::convert::Into<crate::model::catalog_attribute::AttributeType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [indexable_option][crate::model::CatalogAttribute::indexable_option].
    pub fn set_indexable_option<
        T: std::convert::Into<crate::model::catalog_attribute::IndexableOption>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.indexable_option = v.into();
        self
    }

    /// Sets the value of [dynamic_facetable_option][crate::model::CatalogAttribute::dynamic_facetable_option].
    pub fn set_dynamic_facetable_option<
        T: std::convert::Into<crate::model::catalog_attribute::DynamicFacetableOption>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dynamic_facetable_option = v.into();
        self
    }

    /// Sets the value of [searchable_option][crate::model::CatalogAttribute::searchable_option].
    pub fn set_searchable_option<
        T: std::convert::Into<crate::model::catalog_attribute::SearchableOption>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.searchable_option = v.into();
        self
    }

    /// Sets the value of [exact_searchable_option][crate::model::CatalogAttribute::exact_searchable_option].
    pub fn set_exact_searchable_option<
        T: std::convert::Into<crate::model::catalog_attribute::ExactSearchableOption>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.exact_searchable_option = v.into();
        self
    }

    /// Sets the value of [retrievable_option][crate::model::CatalogAttribute::retrievable_option].
    pub fn set_retrievable_option<
        T: std::convert::Into<crate::model::catalog_attribute::RetrievableOption>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.retrievable_option = v.into();
        self
    }

    /// Sets the value of [facet_config][crate::model::CatalogAttribute::facet_config].
    pub fn set_facet_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::catalog_attribute::FacetConfig>,
    {
        self.facet_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [facet_config][crate::model::CatalogAttribute::facet_config].
    pub fn set_or_clear_facet_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::catalog_attribute::FacetConfig>,
    {
        self.facet_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CatalogAttribute {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.CatalogAttribute"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CatalogAttribute {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            __in_use,
            __type,
            __indexable_option,
            __dynamic_facetable_option,
            __searchable_option,
            __exact_searchable_option,
            __retrievable_option,
            __facet_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CatalogAttribute")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            "inUse" => Ok(__FieldTag::__in_use),
                            "in_use" => Ok(__FieldTag::__in_use),
                            "type" => Ok(__FieldTag::__type),
                            "indexableOption" => Ok(__FieldTag::__indexable_option),
                            "indexable_option" => Ok(__FieldTag::__indexable_option),
                            "dynamicFacetableOption" => Ok(__FieldTag::__dynamic_facetable_option),
                            "dynamic_facetable_option" => {
                                Ok(__FieldTag::__dynamic_facetable_option)
                            }
                            "searchableOption" => Ok(__FieldTag::__searchable_option),
                            "searchable_option" => Ok(__FieldTag::__searchable_option),
                            "exactSearchableOption" => Ok(__FieldTag::__exact_searchable_option),
                            "exact_searchable_option" => Ok(__FieldTag::__exact_searchable_option),
                            "retrievableOption" => Ok(__FieldTag::__retrievable_option),
                            "retrievable_option" => Ok(__FieldTag::__retrievable_option),
                            "facetConfig" => Ok(__FieldTag::__facet_config),
                            "facet_config" => Ok(__FieldTag::__facet_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CatalogAttribute;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CatalogAttribute")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__in_use => {
                            if !fields.insert(__FieldTag::__in_use) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for in_use",
                                ));
                            }
                            result.in_use = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type =
                                map.next_value::<std::option::Option<
                                    crate::model::catalog_attribute::AttributeType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__indexable_option => {
                            if !fields.insert(__FieldTag::__indexable_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for indexable_option",
                                ));
                            }
                            result.indexable_option = map
                                .next_value::<std::option::Option<
                                    crate::model::catalog_attribute::IndexableOption,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dynamic_facetable_option => {
                            if !fields.insert(__FieldTag::__dynamic_facetable_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dynamic_facetable_option",
                                ));
                            }
                            result.dynamic_facetable_option = map
                                .next_value::<std::option::Option<
                                    crate::model::catalog_attribute::DynamicFacetableOption,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__searchable_option => {
                            if !fields.insert(__FieldTag::__searchable_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for searchable_option",
                                ));
                            }
                            result.searchable_option = map
                                .next_value::<std::option::Option<
                                    crate::model::catalog_attribute::SearchableOption,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__exact_searchable_option => {
                            if !fields.insert(__FieldTag::__exact_searchable_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exact_searchable_option",
                                ));
                            }
                            result.exact_searchable_option = map
                                .next_value::<std::option::Option<
                                    crate::model::catalog_attribute::ExactSearchableOption,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__retrievable_option => {
                            if !fields.insert(__FieldTag::__retrievable_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retrievable_option",
                                ));
                            }
                            result.retrievable_option = map
                                .next_value::<std::option::Option<
                                    crate::model::catalog_attribute::RetrievableOption,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__facet_config => {
                            if !fields.insert(__FieldTag::__facet_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for facet_config",
                                ));
                            }
                            result.facet_config =
                                map.next_value::<std::option::Option<
                                    crate::model::catalog_attribute::FacetConfig,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CatalogAttribute {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !wkt::internal::is_default(&self.in_use) {
            state.serialize_entry("inUse", &self.in_use)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.indexable_option) {
            state.serialize_entry("indexableOption", &self.indexable_option)?;
        }
        if !wkt::internal::is_default(&self.dynamic_facetable_option) {
            state.serialize_entry("dynamicFacetableOption", &self.dynamic_facetable_option)?;
        }
        if !wkt::internal::is_default(&self.searchable_option) {
            state.serialize_entry("searchableOption", &self.searchable_option)?;
        }
        if !wkt::internal::is_default(&self.exact_searchable_option) {
            state.serialize_entry("exactSearchableOption", &self.exact_searchable_option)?;
        }
        if !wkt::internal::is_default(&self.retrievable_option) {
            state.serialize_entry("retrievableOption", &self.retrievable_option)?;
        }
        if self.facet_config.is_some() {
            state.serialize_entry("facetConfig", &self.facet_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CatalogAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CatalogAttribute");
        debug_struct.field("key", &self.key);
        debug_struct.field("in_use", &self.in_use);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("indexable_option", &self.indexable_option);
        debug_struct.field("dynamic_facetable_option", &self.dynamic_facetable_option);
        debug_struct.field("searchable_option", &self.searchable_option);
        debug_struct.field("exact_searchable_option", &self.exact_searchable_option);
        debug_struct.field("retrievable_option", &self.retrievable_option);
        debug_struct.field("facet_config", &self.facet_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CatalogAttribute].
pub mod catalog_attribute {
    #[allow(unused_imports)]
    use super::*;

    /// Possible options for the facet that corresponds to the current attribute
    /// config.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FacetConfig {
        /// If you don't set the facet
        /// [SearchRequest.FacetSpec.FacetKey.intervals][google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.intervals]
        /// in the request to a numerical attribute, then we use the computed
        /// intervals with rounded bounds obtained from all its product numerical
        /// attribute values. The computed intervals might not be ideal for some
        /// attributes. Therefore, we give you the option to overwrite them with the
        /// facet_intervals field. The maximum of facet intervals per
        /// [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] is 40. Each
        /// interval must have a lower bound or an upper bound. If both bounds are
        /// provided, then the lower bound must be smaller or equal than the upper
        /// bound.
        ///
        /// [google.cloud.retail.v2.CatalogAttribute]: crate::model::CatalogAttribute
        /// [google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.intervals]: crate::model::search_request::facet_spec::FacetKey::intervals
        pub facet_intervals: std::vec::Vec<crate::model::Interval>,

        /// Each instance represents a list of attribute values to ignore as facet
        /// values for a specific time range. The maximum number of instances per
        /// [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] is 25.
        ///
        /// [google.cloud.retail.v2.CatalogAttribute]: crate::model::CatalogAttribute
        pub ignored_facet_values:
            std::vec::Vec<crate::model::catalog_attribute::facet_config::IgnoredFacetValues>,

        /// Each instance replaces a list of facet values by a merged facet
        /// value. If a facet value is not in any list, then it will stay the same.
        /// To avoid conflicts, only paths of length 1 are accepted. In other words,
        /// if "dark_blue" merged into "BLUE", then the latter can't merge into
        /// "blues" because this would create a path of length 2. The maximum number
        /// of instances of MergedFacetValue per
        /// [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] is 100. This
        /// feature is available only for textual custom attributes.
        ///
        /// [google.cloud.retail.v2.CatalogAttribute]: crate::model::CatalogAttribute
        pub merged_facet_values:
            std::vec::Vec<crate::model::catalog_attribute::facet_config::MergedFacetValue>,

        /// Use this field only if you want to merge a facet key into another facet
        /// key.
        pub merged_facet:
            std::option::Option<crate::model::catalog_attribute::facet_config::MergedFacet>,

        /// Set this field only if you want to rerank based on facet values engaged
        /// by the user for the current key. This option is only possible for custom
        /// facetable textual keys.
        pub rerank_config:
            std::option::Option<crate::model::catalog_attribute::facet_config::RerankConfig>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FacetConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [facet_intervals][crate::model::catalog_attribute::FacetConfig::facet_intervals].
        pub fn set_facet_intervals<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Interval>,
        {
            use std::iter::Iterator;
            self.facet_intervals = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [ignored_facet_values][crate::model::catalog_attribute::FacetConfig::ignored_facet_values].
        pub fn set_ignored_facet_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::catalog_attribute::facet_config::IgnoredFacetValues,
                >,
        {
            use std::iter::Iterator;
            self.ignored_facet_values = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [merged_facet_values][crate::model::catalog_attribute::FacetConfig::merged_facet_values].
        pub fn set_merged_facet_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::catalog_attribute::facet_config::MergedFacetValue>,
        {
            use std::iter::Iterator;
            self.merged_facet_values = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [merged_facet][crate::model::catalog_attribute::FacetConfig::merged_facet].
        pub fn set_merged_facet<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::catalog_attribute::facet_config::MergedFacet>,
        {
            self.merged_facet = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [merged_facet][crate::model::catalog_attribute::FacetConfig::merged_facet].
        pub fn set_or_clear_merged_facet<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::catalog_attribute::facet_config::MergedFacet>,
        {
            self.merged_facet = v.map(|x| x.into());
            self
        }

        /// Sets the value of [rerank_config][crate::model::catalog_attribute::FacetConfig::rerank_config].
        pub fn set_rerank_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::catalog_attribute::facet_config::RerankConfig>,
        {
            self.rerank_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [rerank_config][crate::model::catalog_attribute::FacetConfig::rerank_config].
        pub fn set_or_clear_rerank_config<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::catalog_attribute::facet_config::RerankConfig>,
        {
            self.rerank_config = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for FacetConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.CatalogAttribute.FacetConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FacetConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __facet_intervals,
                __ignored_facet_values,
                __merged_facet_values,
                __merged_facet,
                __rerank_config,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for FacetConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "facetIntervals" => Ok(__FieldTag::__facet_intervals),
                                "facet_intervals" => Ok(__FieldTag::__facet_intervals),
                                "ignoredFacetValues" => Ok(__FieldTag::__ignored_facet_values),
                                "ignored_facet_values" => Ok(__FieldTag::__ignored_facet_values),
                                "mergedFacetValues" => Ok(__FieldTag::__merged_facet_values),
                                "merged_facet_values" => Ok(__FieldTag::__merged_facet_values),
                                "mergedFacet" => Ok(__FieldTag::__merged_facet),
                                "merged_facet" => Ok(__FieldTag::__merged_facet),
                                "rerankConfig" => Ok(__FieldTag::__rerank_config),
                                "rerank_config" => Ok(__FieldTag::__rerank_config),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FacetConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FacetConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__facet_intervals => {
                                if !fields.insert(__FieldTag::__facet_intervals) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for facet_intervals",
                                    ));
                                }
                                result.facet_intervals = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Interval>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__ignored_facet_values => {
                                if !fields.insert(__FieldTag::__ignored_facet_values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ignored_facet_values",
                                    ));
                                }
                                result.ignored_facet_values = map.next_value::<std::option::Option<std::vec::Vec<crate::model::catalog_attribute::facet_config::IgnoredFacetValues>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__merged_facet_values => {
                                if !fields.insert(__FieldTag::__merged_facet_values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for merged_facet_values",
                                    ));
                                }
                                result.merged_facet_values = map.next_value::<std::option::Option<std::vec::Vec<crate::model::catalog_attribute::facet_config::MergedFacetValue>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__merged_facet => {
                                if !fields.insert(__FieldTag::__merged_facet) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for merged_facet",
                                    ));
                                }
                                result.merged_facet = map.next_value::<std::option::Option<
                                    crate::model::catalog_attribute::facet_config::MergedFacet,
                                >>()?;
                            }
                            __FieldTag::__rerank_config => {
                                if !fields.insert(__FieldTag::__rerank_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for rerank_config",
                                    ));
                                }
                                result.rerank_config = map.next_value::<std::option::Option<
                                    crate::model::catalog_attribute::facet_config::RerankConfig,
                                >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for FacetConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.facet_intervals.is_empty() {
                state.serialize_entry("facetIntervals", &self.facet_intervals)?;
            }
            if !self.ignored_facet_values.is_empty() {
                state.serialize_entry("ignoredFacetValues", &self.ignored_facet_values)?;
            }
            if !self.merged_facet_values.is_empty() {
                state.serialize_entry("mergedFacetValues", &self.merged_facet_values)?;
            }
            if self.merged_facet.is_some() {
                state.serialize_entry("mergedFacet", &self.merged_facet)?;
            }
            if self.rerank_config.is_some() {
                state.serialize_entry("rerankConfig", &self.rerank_config)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for FacetConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("FacetConfig");
            debug_struct.field("facet_intervals", &self.facet_intervals);
            debug_struct.field("ignored_facet_values", &self.ignored_facet_values);
            debug_struct.field("merged_facet_values", &self.merged_facet_values);
            debug_struct.field("merged_facet", &self.merged_facet);
            debug_struct.field("rerank_config", &self.rerank_config);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [FacetConfig].
    pub mod facet_config {
        #[allow(unused_imports)]
        use super::*;

        /// [Facet values][google.cloud.retail.v2.SearchResponse.Facet.values] to
        /// ignore on [facets][google.cloud.retail.v2.SearchResponse.Facet] during
        /// the specified time range for the given
        /// [SearchResponse.Facet.key][google.cloud.retail.v2.SearchResponse.Facet.key]
        /// attribute.
        ///
        /// [google.cloud.retail.v2.SearchResponse.Facet]: crate::model::search_response::Facet
        /// [google.cloud.retail.v2.SearchResponse.Facet.key]: crate::model::search_response::Facet::key
        /// [google.cloud.retail.v2.SearchResponse.Facet.values]: crate::model::search_response::Facet::values
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct IgnoredFacetValues {
            /// List of facet values to ignore for the following time range. The facet
            /// values are the same as the attribute values. There is a limit of 10
            /// values per instance of IgnoredFacetValues. Each value can have at most
            /// 128 characters.
            pub values: std::vec::Vec<std::string::String>,

            /// Time range for the current list of facet values to ignore.
            /// If multiple time ranges are specified for an facet value for the
            /// current attribute, consider all of them. If both are empty, ignore
            /// always. If start time and end time are set, then start time
            /// must be before end time.
            /// If start time is not empty and end time is empty, then will ignore
            /// these facet values after the start time.
            pub start_time: std::option::Option<wkt::Timestamp>,

            /// If start time is empty and end time is not empty, then ignore these
            /// facet values before end time.
            pub end_time: std::option::Option<wkt::Timestamp>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl IgnoredFacetValues {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [values][crate::model::catalog_attribute::facet_config::IgnoredFacetValues::values].
            pub fn set_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [start_time][crate::model::catalog_attribute::facet_config::IgnoredFacetValues::start_time].
            pub fn set_start_time<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.start_time = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [start_time][crate::model::catalog_attribute::facet_config::IgnoredFacetValues::start_time].
            pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.start_time = v.map(|x| x.into());
                self
            }

            /// Sets the value of [end_time][crate::model::catalog_attribute::facet_config::IgnoredFacetValues::end_time].
            pub fn set_end_time<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.end_time = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [end_time][crate::model::catalog_attribute::facet_config::IgnoredFacetValues::end_time].
            pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.end_time = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for IgnoredFacetValues {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.retail.v2.CatalogAttribute.FacetConfig.IgnoredFacetValues"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for IgnoredFacetValues {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __values,
                    __start_time,
                    __end_time,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for IgnoredFacetValues")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "values" => Ok(__FieldTag::__values),
                                    "startTime" => Ok(__FieldTag::__start_time),
                                    "start_time" => Ok(__FieldTag::__start_time),
                                    "endTime" => Ok(__FieldTag::__end_time),
                                    "end_time" => Ok(__FieldTag::__end_time),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = IgnoredFacetValues;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct IgnoredFacetValues")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__values => {
                                    if !fields.insert(__FieldTag::__values) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for values"),
                                        );
                                    }
                                    result.values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__start_time => {
                                    if !fields.insert(__FieldTag::__start_time) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for start_time",
                                            ),
                                        );
                                    }
                                    result.start_time =
                                        map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                                }
                                __FieldTag::__end_time => {
                                    if !fields.insert(__FieldTag::__end_time) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for end_time",
                                            ),
                                        );
                                    }
                                    result.end_time =
                                        map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for IgnoredFacetValues {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.values.is_empty() {
                    state.serialize_entry("values", &self.values)?;
                }
                if self.start_time.is_some() {
                    state.serialize_entry("startTime", &self.start_time)?;
                }
                if self.end_time.is_some() {
                    state.serialize_entry("endTime", &self.end_time)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for IgnoredFacetValues {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("IgnoredFacetValues");
                debug_struct.field("values", &self.values);
                debug_struct.field("start_time", &self.start_time);
                debug_struct.field("end_time", &self.end_time);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Replaces a set of textual facet values by the same (possibly different)
        /// merged facet value. Each facet value should appear at most once as a
        /// value per [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute].
        /// This feature is available only for textual custom attributes.
        ///
        /// [google.cloud.retail.v2.CatalogAttribute]: crate::model::CatalogAttribute
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct MergedFacetValue {
            /// All the facet values that are replaces by the same
            /// [merged_value][google.cloud.retail.v2.CatalogAttribute.FacetConfig.MergedFacetValue.merged_value]
            /// that follows. The maximum number of values per MergedFacetValue is 25.
            /// Each value can have up to 128 characters.
            ///
            /// [google.cloud.retail.v2.CatalogAttribute.FacetConfig.MergedFacetValue.merged_value]: crate::model::catalog_attribute::facet_config::MergedFacetValue::merged_value
            pub values: std::vec::Vec<std::string::String>,

            /// All the previous values are replaced by this merged facet value.
            /// This merged_value must be non-empty and can have up to 128 characters.
            pub merged_value: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl MergedFacetValue {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [values][crate::model::catalog_attribute::facet_config::MergedFacetValue::values].
            pub fn set_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [merged_value][crate::model::catalog_attribute::facet_config::MergedFacetValue::merged_value].
            pub fn set_merged_value<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.merged_value = v.into();
                self
            }
        }

        impl wkt::message::Message for MergedFacetValue {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.retail.v2.CatalogAttribute.FacetConfig.MergedFacetValue"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for MergedFacetValue {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __values,
                    __merged_value,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for MergedFacetValue")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "values" => Ok(__FieldTag::__values),
                                    "mergedValue" => Ok(__FieldTag::__merged_value),
                                    "merged_value" => Ok(__FieldTag::__merged_value),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = MergedFacetValue;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct MergedFacetValue")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__values => {
                                    if !fields.insert(__FieldTag::__values) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for values"),
                                        );
                                    }
                                    result.values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__merged_value => {
                                    if !fields.insert(__FieldTag::__merged_value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for merged_value",
                                            ),
                                        );
                                    }
                                    result.merged_value = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for MergedFacetValue {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.values.is_empty() {
                    state.serialize_entry("values", &self.values)?;
                }
                if !self.merged_value.is_empty() {
                    state.serialize_entry("mergedValue", &self.merged_value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for MergedFacetValue {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("MergedFacetValue");
                debug_struct.field("values", &self.values);
                debug_struct.field("merged_value", &self.merged_value);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// The current facet key (i.e. attribute config) maps into the
        /// [merged_facet_key][google.cloud.retail.v2.CatalogAttribute.FacetConfig.MergedFacet.merged_facet_key].
        /// A facet key can have at most one child. The current facet key and the
        /// merged facet key need both to be textual custom attributes or both
        /// numerical custom attributes (same type).
        ///
        /// [google.cloud.retail.v2.CatalogAttribute.FacetConfig.MergedFacet.merged_facet_key]: crate::model::catalog_attribute::facet_config::MergedFacet::merged_facet_key
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct MergedFacet {
            /// The merged facet key should be a valid facet key that is different than
            /// the facet key of the current catalog attribute. We refer this is
            /// merged facet key as the child of the current catalog attribute. This
            /// merged facet key can't be a parent of another facet key (i.e. no
            /// directed path of length 2). This merged facet key needs to be either a
            /// textual custom attribute or a numerical custom attribute.
            pub merged_facet_key: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl MergedFacet {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [merged_facet_key][crate::model::catalog_attribute::facet_config::MergedFacet::merged_facet_key].
            pub fn set_merged_facet_key<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.merged_facet_key = v.into();
                self
            }
        }

        impl wkt::message::Message for MergedFacet {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.retail.v2.CatalogAttribute.FacetConfig.MergedFacet"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for MergedFacet {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __merged_facet_key,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for MergedFacet")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "mergedFacetKey" => Ok(__FieldTag::__merged_facet_key),
                                    "merged_facet_key" => Ok(__FieldTag::__merged_facet_key),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = MergedFacet;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct MergedFacet")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__merged_facet_key => {
                                    if !fields.insert(__FieldTag::__merged_facet_key) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for merged_facet_key",
                                            ),
                                        );
                                    }
                                    result.merged_facet_key = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for MergedFacet {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.merged_facet_key.is_empty() {
                    state.serialize_entry("mergedFacetKey", &self.merged_facet_key)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for MergedFacet {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("MergedFacet");
                debug_struct.field("merged_facet_key", &self.merged_facet_key);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Options to rerank based on facet values engaged by the user for the
        /// current key. That key needs to be a custom textual key and facetable.
        /// To use this control, you also need to pass all the facet keys engaged by
        /// the user in the request using the field [SearchRequest.FacetSpec]. In
        /// particular, if you don't pass the facet keys engaged that you want to
        /// rerank on, this control won't be effective. Moreover, to obtain better
        /// results, the facet values that you want to rerank on should be close to
        /// English (ideally made of words, underscores, and spaces).
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct RerankConfig {
            /// If set to true, then we also rerank the dynamic facets based on the
            /// facet values engaged by the user for the current attribute key during
            /// serving.
            pub rerank_facet: bool,

            /// If empty, rerank on all facet values for the current key. Otherwise,
            /// will rerank on the facet values from this list only.
            pub facet_values: std::vec::Vec<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl RerankConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [rerank_facet][crate::model::catalog_attribute::facet_config::RerankConfig::rerank_facet].
            pub fn set_rerank_facet<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.rerank_facet = v.into();
                self
            }

            /// Sets the value of [facet_values][crate::model::catalog_attribute::facet_config::RerankConfig::facet_values].
            pub fn set_facet_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.facet_values = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for RerankConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.retail.v2.CatalogAttribute.FacetConfig.RerankConfig"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for RerankConfig {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __rerank_facet,
                    __facet_values,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for RerankConfig")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "rerankFacet" => Ok(__FieldTag::__rerank_facet),
                                    "rerank_facet" => Ok(__FieldTag::__rerank_facet),
                                    "facetValues" => Ok(__FieldTag::__facet_values),
                                    "facet_values" => Ok(__FieldTag::__facet_values),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = RerankConfig;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct RerankConfig")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__rerank_facet => {
                                    if !fields.insert(__FieldTag::__rerank_facet) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for rerank_facet",
                                            ),
                                        );
                                    }
                                    result.rerank_facet = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__facet_values => {
                                    if !fields.insert(__FieldTag::__facet_values) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for facet_values",
                                            ),
                                        );
                                    }
                                    result.facet_values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for RerankConfig {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.rerank_facet) {
                    state.serialize_entry("rerankFacet", &self.rerank_facet)?;
                }
                if !self.facet_values.is_empty() {
                    state.serialize_entry("facetValues", &self.facet_values)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for RerankConfig {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("RerankConfig");
                debug_struct.field("rerank_facet", &self.rerank_facet);
                debug_struct.field("facet_values", &self.facet_values);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    /// The type of an attribute.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AttributeType {
        /// The type of the attribute is unknown.
        ///
        /// Used when type cannot be derived from attribute that is not
        /// [in_use][google.cloud.retail.v2.CatalogAttribute.in_use].
        ///
        /// [google.cloud.retail.v2.CatalogAttribute.in_use]: crate::model::CatalogAttribute::in_use
        Unknown,
        /// Textual attribute.
        Textual,
        /// Numerical attribute.
        Numerical,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AttributeType::value] or
        /// [AttributeType::name].
        UnknownValue(attribute_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod attribute_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AttributeType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Textual => std::option::Option::Some(1),
                Self::Numerical => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Textual => std::option::Option::Some("TEXTUAL"),
                Self::Numerical => std::option::Option::Some("NUMERICAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AttributeType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AttributeType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AttributeType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Textual,
                2 => Self::Numerical,
                _ => Self::UnknownValue(attribute_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AttributeType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "TEXTUAL" => Self::Textual,
                "NUMERICAL" => Self::Numerical,
                _ => Self::UnknownValue(attribute_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AttributeType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Textual => serializer.serialize_i32(1),
                Self::Numerical => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AttributeType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttributeType>::new(
                ".google.cloud.retail.v2.CatalogAttribute.AttributeType",
            ))
        }
    }

    /// The status of the indexable option of a catalog attribute.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IndexableOption {
        /// Value used when unset.
        Unspecified,
        /// Indexable option enabled for an attribute.
        IndexableEnabled,
        /// Indexable option disabled for an attribute.
        IndexableDisabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [IndexableOption::value] or
        /// [IndexableOption::name].
        UnknownValue(indexable_option::UnknownValue),
    }

    #[doc(hidden)]
    pub mod indexable_option {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl IndexableOption {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::IndexableEnabled => std::option::Option::Some(1),
                Self::IndexableDisabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INDEXABLE_OPTION_UNSPECIFIED"),
                Self::IndexableEnabled => std::option::Option::Some("INDEXABLE_ENABLED"),
                Self::IndexableDisabled => std::option::Option::Some("INDEXABLE_DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for IndexableOption {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for IndexableOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for IndexableOption {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::IndexableEnabled,
                2 => Self::IndexableDisabled,
                _ => Self::UnknownValue(indexable_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for IndexableOption {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INDEXABLE_OPTION_UNSPECIFIED" => Self::Unspecified,
                "INDEXABLE_ENABLED" => Self::IndexableEnabled,
                "INDEXABLE_DISABLED" => Self::IndexableDisabled,
                _ => Self::UnknownValue(indexable_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for IndexableOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::IndexableEnabled => serializer.serialize_i32(1),
                Self::IndexableDisabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for IndexableOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<IndexableOption>::new(
                ".google.cloud.retail.v2.CatalogAttribute.IndexableOption",
            ))
        }
    }

    /// The status of the dynamic facetable option of a catalog attribute.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DynamicFacetableOption {
        /// Value used when unset.
        Unspecified,
        /// Dynamic facetable option enabled for an attribute.
        DynamicFacetableEnabled,
        /// Dynamic facetable option disabled for an attribute.
        DynamicFacetableDisabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DynamicFacetableOption::value] or
        /// [DynamicFacetableOption::name].
        UnknownValue(dynamic_facetable_option::UnknownValue),
    }

    #[doc(hidden)]
    pub mod dynamic_facetable_option {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DynamicFacetableOption {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::DynamicFacetableEnabled => std::option::Option::Some(1),
                Self::DynamicFacetableDisabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("DYNAMIC_FACETABLE_OPTION_UNSPECIFIED")
                }
                Self::DynamicFacetableEnabled => {
                    std::option::Option::Some("DYNAMIC_FACETABLE_ENABLED")
                }
                Self::DynamicFacetableDisabled => {
                    std::option::Option::Some("DYNAMIC_FACETABLE_DISABLED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DynamicFacetableOption {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DynamicFacetableOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DynamicFacetableOption {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::DynamicFacetableEnabled,
                2 => Self::DynamicFacetableDisabled,
                _ => Self::UnknownValue(dynamic_facetable_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DynamicFacetableOption {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DYNAMIC_FACETABLE_OPTION_UNSPECIFIED" => Self::Unspecified,
                "DYNAMIC_FACETABLE_ENABLED" => Self::DynamicFacetableEnabled,
                "DYNAMIC_FACETABLE_DISABLED" => Self::DynamicFacetableDisabled,
                _ => Self::UnknownValue(dynamic_facetable_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DynamicFacetableOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::DynamicFacetableEnabled => serializer.serialize_i32(1),
                Self::DynamicFacetableDisabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DynamicFacetableOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DynamicFacetableOption>::new(
                ".google.cloud.retail.v2.CatalogAttribute.DynamicFacetableOption",
            ))
        }
    }

    /// The status of the searchable option of a catalog attribute.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SearchableOption {
        /// Value used when unset.
        Unspecified,
        /// Searchable option enabled for an attribute.
        SearchableEnabled,
        /// Searchable option disabled for an attribute.
        SearchableDisabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SearchableOption::value] or
        /// [SearchableOption::name].
        UnknownValue(searchable_option::UnknownValue),
    }

    #[doc(hidden)]
    pub mod searchable_option {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SearchableOption {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SearchableEnabled => std::option::Option::Some(1),
                Self::SearchableDisabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SEARCHABLE_OPTION_UNSPECIFIED"),
                Self::SearchableEnabled => std::option::Option::Some("SEARCHABLE_ENABLED"),
                Self::SearchableDisabled => std::option::Option::Some("SEARCHABLE_DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SearchableOption {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SearchableOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SearchableOption {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SearchableEnabled,
                2 => Self::SearchableDisabled,
                _ => Self::UnknownValue(searchable_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SearchableOption {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SEARCHABLE_OPTION_UNSPECIFIED" => Self::Unspecified,
                "SEARCHABLE_ENABLED" => Self::SearchableEnabled,
                "SEARCHABLE_DISABLED" => Self::SearchableDisabled,
                _ => Self::UnknownValue(searchable_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SearchableOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SearchableEnabled => serializer.serialize_i32(1),
                Self::SearchableDisabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SearchableOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SearchableOption>::new(
                ".google.cloud.retail.v2.CatalogAttribute.SearchableOption",
            ))
        }
    }

    /// The status of the exact-searchable option of a catalog attribute.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExactSearchableOption {
        /// Value used when unset.
        Unspecified,
        /// Exact searchable option enabled for an attribute.
        ExactSearchableEnabled,
        /// Exact searchable option disabled for an attribute.
        ExactSearchableDisabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ExactSearchableOption::value] or
        /// [ExactSearchableOption::name].
        UnknownValue(exact_searchable_option::UnknownValue),
    }

    #[doc(hidden)]
    pub mod exact_searchable_option {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ExactSearchableOption {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ExactSearchableEnabled => std::option::Option::Some(1),
                Self::ExactSearchableDisabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("EXACT_SEARCHABLE_OPTION_UNSPECIFIED")
                }
                Self::ExactSearchableEnabled => {
                    std::option::Option::Some("EXACT_SEARCHABLE_ENABLED")
                }
                Self::ExactSearchableDisabled => {
                    std::option::Option::Some("EXACT_SEARCHABLE_DISABLED")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ExactSearchableOption {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ExactSearchableOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ExactSearchableOption {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ExactSearchableEnabled,
                2 => Self::ExactSearchableDisabled,
                _ => Self::UnknownValue(exact_searchable_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ExactSearchableOption {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXACT_SEARCHABLE_OPTION_UNSPECIFIED" => Self::Unspecified,
                "EXACT_SEARCHABLE_ENABLED" => Self::ExactSearchableEnabled,
                "EXACT_SEARCHABLE_DISABLED" => Self::ExactSearchableDisabled,
                _ => Self::UnknownValue(exact_searchable_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ExactSearchableOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ExactSearchableEnabled => serializer.serialize_i32(1),
                Self::ExactSearchableDisabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ExactSearchableOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ExactSearchableOption>::new(
                ".google.cloud.retail.v2.CatalogAttribute.ExactSearchableOption",
            ))
        }
    }

    /// The status of the retrievable option of a catalog attribute.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RetrievableOption {
        /// Value used when unset.
        Unspecified,
        /// Retrievable option enabled for an attribute.
        RetrievableEnabled,
        /// Retrievable option disabled for an attribute.
        RetrievableDisabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RetrievableOption::value] or
        /// [RetrievableOption::name].
        UnknownValue(retrievable_option::UnknownValue),
    }

    #[doc(hidden)]
    pub mod retrievable_option {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RetrievableOption {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::RetrievableEnabled => std::option::Option::Some(1),
                Self::RetrievableDisabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RETRIEVABLE_OPTION_UNSPECIFIED"),
                Self::RetrievableEnabled => std::option::Option::Some("RETRIEVABLE_ENABLED"),
                Self::RetrievableDisabled => std::option::Option::Some("RETRIEVABLE_DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RetrievableOption {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RetrievableOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RetrievableOption {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::RetrievableEnabled,
                2 => Self::RetrievableDisabled,
                _ => Self::UnknownValue(retrievable_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RetrievableOption {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RETRIEVABLE_OPTION_UNSPECIFIED" => Self::Unspecified,
                "RETRIEVABLE_ENABLED" => Self::RetrievableEnabled,
                "RETRIEVABLE_DISABLED" => Self::RetrievableDisabled,
                _ => Self::UnknownValue(retrievable_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RetrievableOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::RetrievableEnabled => serializer.serialize_i32(1),
                Self::RetrievableDisabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RetrievableOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RetrievableOption>::new(
                ".google.cloud.retail.v2.CatalogAttribute.RetrievableOption",
            ))
        }
    }
}

/// Catalog level attribute config.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AttributesConfig {
    /// Required. Immutable. The fully qualified resource name of the attribute
    /// config. Format: `projects/*/locations/*/catalogs/*/attributesConfig`
    pub name: std::string::String,

    /// Enable attribute(s) config at catalog level.
    /// For example, indexable, dynamic_facetable, or searchable for each
    /// attribute.
    ///
    /// The key is catalog attribute's name.
    /// For example: `color`, `brands`, `attributes.custom_attribute`, such as
    /// `attributes.xyz`.
    ///
    /// The maximum number of catalog attributes allowed in a request is 1000.
    pub catalog_attributes:
        std::collections::HashMap<std::string::String, crate::model::CatalogAttribute>,

    /// Output only. The
    /// [AttributeConfigLevel][google.cloud.retail.v2.AttributeConfigLevel] used
    /// for this catalog.
    ///
    /// [google.cloud.retail.v2.AttributeConfigLevel]: crate::model::AttributeConfigLevel
    pub attribute_config_level: crate::model::AttributeConfigLevel,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttributesConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AttributesConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [catalog_attributes][crate::model::AttributesConfig::catalog_attributes].
    pub fn set_catalog_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::CatalogAttribute>,
    {
        use std::iter::Iterator;
        self.catalog_attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [attribute_config_level][crate::model::AttributesConfig::attribute_config_level].
    pub fn set_attribute_config_level<T: std::convert::Into<crate::model::AttributeConfigLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.attribute_config_level = v.into();
        self
    }
}

impl wkt::message::Message for AttributesConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.AttributesConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttributesConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __catalog_attributes,
            __attribute_config_level,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttributesConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "catalogAttributes" => Ok(__FieldTag::__catalog_attributes),
                            "catalog_attributes" => Ok(__FieldTag::__catalog_attributes),
                            "attributeConfigLevel" => Ok(__FieldTag::__attribute_config_level),
                            "attribute_config_level" => Ok(__FieldTag::__attribute_config_level),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttributesConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttributesConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__catalog_attributes => {
                            if !fields.insert(__FieldTag::__catalog_attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for catalog_attributes",
                                ));
                            }
                            result.catalog_attributes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::CatalogAttribute,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attribute_config_level => {
                            if !fields.insert(__FieldTag::__attribute_config_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attribute_config_level",
                                ));
                            }
                            result.attribute_config_level = map.next_value::<std::option::Option<crate::model::AttributeConfigLevel>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttributesConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.catalog_attributes.is_empty() {
            state.serialize_entry("catalogAttributes", &self.catalog_attributes)?;
        }
        if !wkt::internal::is_default(&self.attribute_config_level) {
            state.serialize_entry("attributeConfigLevel", &self.attribute_config_level)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AttributesConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AttributesConfig");
        debug_struct.field("name", &self.name);
        debug_struct.field("catalog_attributes", &self.catalog_attributes);
        debug_struct.field("attribute_config_level", &self.attribute_config_level);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Catalog level autocomplete config for customers to customize autocomplete
/// feature's settings.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CompletionConfig {
    /// Required. Immutable. Fully qualified name
    /// `projects/*/locations/*/catalogs/*/completionConfig`
    pub name: std::string::String,

    /// Specifies the matching order for autocomplete suggestions, e.g., a query
    /// consisting of 'sh' with 'out-of-order' specified would suggest "women's
    /// shoes", whereas a query of 'red s' with 'exact-prefix' specified would
    /// suggest "red shoes". Currently supported values:
    ///
    /// * 'out-of-order'
    /// * 'exact-prefix'
    ///
    /// Default value: 'exact-prefix'.
    pub matching_order: std::string::String,

    /// The maximum number of autocomplete suggestions returned per term. Default
    /// value is 20. If left unset or set to 0, then will fallback to default
    /// value.
    ///
    /// Value range is 1 to 20.
    pub max_suggestions: i32,

    /// The minimum number of characters needed to be typed in order to get
    /// suggestions. Default value is 2. If left unset or set to 0, then will
    /// fallback to default value.
    ///
    /// Value range is 1 to 20.
    pub min_prefix_length: i32,

    /// If set to true, the auto learning function is enabled. Auto learning uses
    /// user data to generate suggestions using ML techniques. Default value is
    /// false. Only after enabling auto learning can users use `cloud-retail`
    /// data in
    /// [CompleteQueryRequest][google.cloud.retail.v2.CompleteQueryRequest].
    ///
    /// [google.cloud.retail.v2.CompleteQueryRequest]: crate::model::CompleteQueryRequest
    pub auto_learning: bool,

    /// Output only. The source data for the latest import of the autocomplete
    /// suggestion phrases.
    pub suggestions_input_config: std::option::Option<crate::model::CompletionDataInputConfig>,

    /// Output only. Name of the LRO corresponding to the latest suggestion terms
    /// list import.
    ///
    /// Can use [GetOperation][google.longrunning.Operations.GetOperation] API
    /// method to retrieve the latest state of the Long Running Operation.
    pub last_suggestions_import_operation: std::string::String,

    /// Output only. The source data for the latest import of the autocomplete
    /// denylist phrases.
    pub denylist_input_config: std::option::Option<crate::model::CompletionDataInputConfig>,

    /// Output only. Name of the LRO corresponding to the latest denylist import.
    ///
    /// Can use [GetOperation][google.longrunning.Operations.GetOperation] API to
    /// retrieve the latest state of the Long Running Operation.
    pub last_denylist_import_operation: std::string::String,

    /// Output only. The source data for the latest import of the autocomplete
    /// allowlist phrases.
    pub allowlist_input_config: std::option::Option<crate::model::CompletionDataInputConfig>,

    /// Output only. Name of the LRO corresponding to the latest allowlist import.
    ///
    /// Can use [GetOperation][google.longrunning.Operations.GetOperation] API to
    /// retrieve the latest state of the Long Running Operation.
    pub last_allowlist_import_operation: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CompletionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CompletionConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [matching_order][crate::model::CompletionConfig::matching_order].
    pub fn set_matching_order<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.matching_order = v.into();
        self
    }

    /// Sets the value of [max_suggestions][crate::model::CompletionConfig::max_suggestions].
    pub fn set_max_suggestions<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_suggestions = v.into();
        self
    }

    /// Sets the value of [min_prefix_length][crate::model::CompletionConfig::min_prefix_length].
    pub fn set_min_prefix_length<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_prefix_length = v.into();
        self
    }

    /// Sets the value of [auto_learning][crate::model::CompletionConfig::auto_learning].
    pub fn set_auto_learning<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_learning = v.into();
        self
    }

    /// Sets the value of [suggestions_input_config][crate::model::CompletionConfig::suggestions_input_config].
    pub fn set_suggestions_input_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CompletionDataInputConfig>,
    {
        self.suggestions_input_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [suggestions_input_config][crate::model::CompletionConfig::suggestions_input_config].
    pub fn set_or_clear_suggestions_input_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CompletionDataInputConfig>,
    {
        self.suggestions_input_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_suggestions_import_operation][crate::model::CompletionConfig::last_suggestions_import_operation].
    pub fn set_last_suggestions_import_operation<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_suggestions_import_operation = v.into();
        self
    }

    /// Sets the value of [denylist_input_config][crate::model::CompletionConfig::denylist_input_config].
    pub fn set_denylist_input_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CompletionDataInputConfig>,
    {
        self.denylist_input_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [denylist_input_config][crate::model::CompletionConfig::denylist_input_config].
    pub fn set_or_clear_denylist_input_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CompletionDataInputConfig>,
    {
        self.denylist_input_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_denylist_import_operation][crate::model::CompletionConfig::last_denylist_import_operation].
    pub fn set_last_denylist_import_operation<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_denylist_import_operation = v.into();
        self
    }

    /// Sets the value of [allowlist_input_config][crate::model::CompletionConfig::allowlist_input_config].
    pub fn set_allowlist_input_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CompletionDataInputConfig>,
    {
        self.allowlist_input_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [allowlist_input_config][crate::model::CompletionConfig::allowlist_input_config].
    pub fn set_or_clear_allowlist_input_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CompletionDataInputConfig>,
    {
        self.allowlist_input_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_allowlist_import_operation][crate::model::CompletionConfig::last_allowlist_import_operation].
    pub fn set_last_allowlist_import_operation<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_allowlist_import_operation = v.into();
        self
    }
}

impl wkt::message::Message for CompletionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.CompletionConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CompletionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __matching_order,
            __max_suggestions,
            __min_prefix_length,
            __auto_learning,
            __suggestions_input_config,
            __last_suggestions_import_operation,
            __denylist_input_config,
            __last_denylist_import_operation,
            __allowlist_input_config,
            __last_allowlist_import_operation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompletionConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "matchingOrder" => Ok(__FieldTag::__matching_order),
                            "matching_order" => Ok(__FieldTag::__matching_order),
                            "maxSuggestions" => Ok(__FieldTag::__max_suggestions),
                            "max_suggestions" => Ok(__FieldTag::__max_suggestions),
                            "minPrefixLength" => Ok(__FieldTag::__min_prefix_length),
                            "min_prefix_length" => Ok(__FieldTag::__min_prefix_length),
                            "autoLearning" => Ok(__FieldTag::__auto_learning),
                            "auto_learning" => Ok(__FieldTag::__auto_learning),
                            "suggestionsInputConfig" => Ok(__FieldTag::__suggestions_input_config),
                            "suggestions_input_config" => {
                                Ok(__FieldTag::__suggestions_input_config)
                            }
                            "lastSuggestionsImportOperation" => {
                                Ok(__FieldTag::__last_suggestions_import_operation)
                            }
                            "last_suggestions_import_operation" => {
                                Ok(__FieldTag::__last_suggestions_import_operation)
                            }
                            "denylistInputConfig" => Ok(__FieldTag::__denylist_input_config),
                            "denylist_input_config" => Ok(__FieldTag::__denylist_input_config),
                            "lastDenylistImportOperation" => {
                                Ok(__FieldTag::__last_denylist_import_operation)
                            }
                            "last_denylist_import_operation" => {
                                Ok(__FieldTag::__last_denylist_import_operation)
                            }
                            "allowlistInputConfig" => Ok(__FieldTag::__allowlist_input_config),
                            "allowlist_input_config" => Ok(__FieldTag::__allowlist_input_config),
                            "lastAllowlistImportOperation" => {
                                Ok(__FieldTag::__last_allowlist_import_operation)
                            }
                            "last_allowlist_import_operation" => {
                                Ok(__FieldTag::__last_allowlist_import_operation)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CompletionConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompletionConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__matching_order => {
                            if !fields.insert(__FieldTag::__matching_order) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for matching_order",
                                ));
                            }
                            result.matching_order = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_suggestions => {
                            if !fields.insert(__FieldTag::__max_suggestions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_suggestions",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_suggestions =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__min_prefix_length => {
                            if !fields.insert(__FieldTag::__min_prefix_length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_prefix_length",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_prefix_length =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__auto_learning => {
                            if !fields.insert(__FieldTag::__auto_learning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_learning",
                                ));
                            }
                            result.auto_learning = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__suggestions_input_config => {
                            if !fields.insert(__FieldTag::__suggestions_input_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suggestions_input_config",
                                ));
                            }
                            result.suggestions_input_config = map.next_value::<std::option::Option<crate::model::CompletionDataInputConfig>>()?
                                ;
                        }
                        __FieldTag::__last_suggestions_import_operation => {
                            if !fields.insert(__FieldTag::__last_suggestions_import_operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_suggestions_import_operation",
                                ));
                            }
                            result.last_suggestions_import_operation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__denylist_input_config => {
                            if !fields.insert(__FieldTag::__denylist_input_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for denylist_input_config",
                                ));
                            }
                            result.denylist_input_config = map.next_value::<std::option::Option<crate::model::CompletionDataInputConfig>>()?
                                ;
                        }
                        __FieldTag::__last_denylist_import_operation => {
                            if !fields.insert(__FieldTag::__last_denylist_import_operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_denylist_import_operation",
                                ));
                            }
                            result.last_denylist_import_operation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allowlist_input_config => {
                            if !fields.insert(__FieldTag::__allowlist_input_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowlist_input_config",
                                ));
                            }
                            result.allowlist_input_config = map.next_value::<std::option::Option<crate::model::CompletionDataInputConfig>>()?
                                ;
                        }
                        __FieldTag::__last_allowlist_import_operation => {
                            if !fields.insert(__FieldTag::__last_allowlist_import_operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_allowlist_import_operation",
                                ));
                            }
                            result.last_allowlist_import_operation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CompletionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.matching_order.is_empty() {
            state.serialize_entry("matchingOrder", &self.matching_order)?;
        }
        if !wkt::internal::is_default(&self.max_suggestions) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxSuggestions", &__With(&self.max_suggestions))?;
        }
        if !wkt::internal::is_default(&self.min_prefix_length) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minPrefixLength", &__With(&self.min_prefix_length))?;
        }
        if !wkt::internal::is_default(&self.auto_learning) {
            state.serialize_entry("autoLearning", &self.auto_learning)?;
        }
        if self.suggestions_input_config.is_some() {
            state.serialize_entry("suggestionsInputConfig", &self.suggestions_input_config)?;
        }
        if !self.last_suggestions_import_operation.is_empty() {
            state.serialize_entry(
                "lastSuggestionsImportOperation",
                &self.last_suggestions_import_operation,
            )?;
        }
        if self.denylist_input_config.is_some() {
            state.serialize_entry("denylistInputConfig", &self.denylist_input_config)?;
        }
        if !self.last_denylist_import_operation.is_empty() {
            state.serialize_entry(
                "lastDenylistImportOperation",
                &self.last_denylist_import_operation,
            )?;
        }
        if self.allowlist_input_config.is_some() {
            state.serialize_entry("allowlistInputConfig", &self.allowlist_input_config)?;
        }
        if !self.last_allowlist_import_operation.is_empty() {
            state.serialize_entry(
                "lastAllowlistImportOperation",
                &self.last_allowlist_import_operation,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CompletionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CompletionConfig");
        debug_struct.field("name", &self.name);
        debug_struct.field("matching_order", &self.matching_order);
        debug_struct.field("max_suggestions", &self.max_suggestions);
        debug_struct.field("min_prefix_length", &self.min_prefix_length);
        debug_struct.field("auto_learning", &self.auto_learning);
        debug_struct.field("suggestions_input_config", &self.suggestions_input_config);
        debug_struct.field(
            "last_suggestions_import_operation",
            &self.last_suggestions_import_operation,
        );
        debug_struct.field("denylist_input_config", &self.denylist_input_config);
        debug_struct.field(
            "last_denylist_import_operation",
            &self.last_denylist_import_operation,
        );
        debug_struct.field("allowlist_input_config", &self.allowlist_input_config);
        debug_struct.field(
            "last_allowlist_import_operation",
            &self.last_allowlist_import_operation,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The catalog configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Catalog {
    /// Required. Immutable. The fully qualified resource name of the catalog.
    pub name: std::string::String,

    /// Required. Immutable. The catalog display name.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
    pub display_name: std::string::String,

    /// Required. The product level configuration.
    pub product_level_config: std::option::Option<crate::model::ProductLevelConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Catalog {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Catalog::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Catalog::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [product_level_config][crate::model::Catalog::product_level_config].
    pub fn set_product_level_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProductLevelConfig>,
    {
        self.product_level_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [product_level_config][crate::model::Catalog::product_level_config].
    pub fn set_or_clear_product_level_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProductLevelConfig>,
    {
        self.product_level_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Catalog {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.Catalog"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Catalog {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __product_level_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Catalog")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "productLevelConfig" => Ok(__FieldTag::__product_level_config),
                            "product_level_config" => Ok(__FieldTag::__product_level_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Catalog;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Catalog")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__product_level_config => {
                            if !fields.insert(__FieldTag::__product_level_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product_level_config",
                                ));
                            }
                            result.product_level_config = map.next_value::<std::option::Option<crate::model::ProductLevelConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Catalog {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.product_level_config.is_some() {
            state.serialize_entry("productLevelConfig", &self.product_level_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Catalog {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Catalog");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("product_level_config", &self.product_level_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for
/// [CatalogService.ListCatalogs][google.cloud.retail.v2.CatalogService.ListCatalogs]
/// method.
///
/// [google.cloud.retail.v2.CatalogService.ListCatalogs]: crate::client::CatalogService::list_catalogs
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCatalogsRequest {
    /// Required. The account resource name with an associated location.
    ///
    /// If the caller does not have permission to list
    /// [Catalog][google.cloud.retail.v2.Catalog]s under this location, regardless
    /// of whether or not this location exists, a PERMISSION_DENIED error is
    /// returned.
    ///
    /// [google.cloud.retail.v2.Catalog]: crate::model::Catalog
    pub parent: std::string::String,

    /// Maximum number of [Catalog][google.cloud.retail.v2.Catalog]s to return. If
    /// unspecified, defaults to 50. The maximum allowed value is 1000. Values
    /// above 1000 will be coerced to 1000.
    ///
    /// If this field is negative, an INVALID_ARGUMENT is returned.
    ///
    /// [google.cloud.retail.v2.Catalog]: crate::model::Catalog
    pub page_size: i32,

    /// A page token
    /// [ListCatalogsResponse.next_page_token][google.cloud.retail.v2.ListCatalogsResponse.next_page_token],
    /// received from a previous
    /// [CatalogService.ListCatalogs][google.cloud.retail.v2.CatalogService.ListCatalogs]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [CatalogService.ListCatalogs][google.cloud.retail.v2.CatalogService.ListCatalogs]
    /// must match the call that provided the page token. Otherwise, an
    /// INVALID_ARGUMENT error is returned.
    ///
    /// [google.cloud.retail.v2.CatalogService.ListCatalogs]: crate::client::CatalogService::list_catalogs
    /// [google.cloud.retail.v2.ListCatalogsResponse.next_page_token]: crate::model::ListCatalogsResponse::next_page_token
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCatalogsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCatalogsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCatalogsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCatalogsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCatalogsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ListCatalogsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCatalogsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCatalogsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCatalogsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCatalogsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCatalogsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCatalogsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCatalogsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for
/// [CatalogService.ListCatalogs][google.cloud.retail.v2.CatalogService.ListCatalogs]
/// method.
///
/// [google.cloud.retail.v2.CatalogService.ListCatalogs]: crate::client::CatalogService::list_catalogs
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCatalogsResponse {
    /// All the customer's [Catalog][google.cloud.retail.v2.Catalog]s.
    ///
    /// [google.cloud.retail.v2.Catalog]: crate::model::Catalog
    pub catalogs: std::vec::Vec<crate::model::Catalog>,

    /// A token that can be sent as
    /// [ListCatalogsRequest.page_token][google.cloud.retail.v2.ListCatalogsRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.retail.v2.ListCatalogsRequest.page_token]: crate::model::ListCatalogsRequest::page_token
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCatalogsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [catalogs][crate::model::ListCatalogsResponse::catalogs].
    pub fn set_catalogs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Catalog>,
    {
        use std::iter::Iterator;
        self.catalogs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCatalogsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListCatalogsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ListCatalogsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCatalogsResponse {
    type PageItem = crate::model::Catalog;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.catalogs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCatalogsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __catalogs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCatalogsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "catalogs" => Ok(__FieldTag::__catalogs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCatalogsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCatalogsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__catalogs => {
                            if !fields.insert(__FieldTag::__catalogs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for catalogs",
                                ));
                            }
                            result.catalogs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Catalog>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCatalogsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.catalogs.is_empty() {
            state.serialize_entry("catalogs", &self.catalogs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCatalogsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCatalogsResponse");
        debug_struct.field("catalogs", &self.catalogs);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for
/// [CatalogService.UpdateCatalog][google.cloud.retail.v2.CatalogService.UpdateCatalog]
/// method.
///
/// [google.cloud.retail.v2.CatalogService.UpdateCatalog]: crate::client::CatalogService::update_catalog
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateCatalogRequest {
    /// Required. The [Catalog][google.cloud.retail.v2.Catalog] to update.
    ///
    /// If the caller does not have permission to update the
    /// [Catalog][google.cloud.retail.v2.Catalog], regardless of whether or not it
    /// exists, a PERMISSION_DENIED error is returned.
    ///
    /// If the [Catalog][google.cloud.retail.v2.Catalog] to update does not exist,
    /// a NOT_FOUND error is returned.
    ///
    /// [google.cloud.retail.v2.Catalog]: crate::model::Catalog
    pub catalog: std::option::Option<crate::model::Catalog>,

    /// Indicates which fields in the provided
    /// [Catalog][google.cloud.retail.v2.Catalog] to update.
    ///
    /// If an unsupported or unknown field is provided, an INVALID_ARGUMENT error
    /// is returned.
    ///
    /// [google.cloud.retail.v2.Catalog]: crate::model::Catalog
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCatalogRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [catalog][crate::model::UpdateCatalogRequest::catalog].
    pub fn set_catalog<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Catalog>,
    {
        self.catalog = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [catalog][crate::model::UpdateCatalogRequest::catalog].
    pub fn set_or_clear_catalog<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Catalog>,
    {
        self.catalog = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCatalogRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateCatalogRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateCatalogRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.UpdateCatalogRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateCatalogRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __catalog,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateCatalogRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "catalog" => Ok(__FieldTag::__catalog),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateCatalogRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCatalogRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__catalog => {
                            if !fields.insert(__FieldTag::__catalog) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for catalog",
                                ));
                            }
                            result.catalog =
                                map.next_value::<std::option::Option<crate::model::Catalog>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateCatalogRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.catalog.is_some() {
            state.serialize_entry("catalog", &self.catalog)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateCatalogRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateCatalogRequest");
        debug_struct.field("catalog", &self.catalog);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message to set a specified branch as new default_branch.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetDefaultBranchRequest {
    /// Full resource name of the catalog, such as
    /// `projects/*/locations/global/catalogs/default_catalog`.
    pub catalog: std::string::String,

    /// The final component of the resource name of a branch.
    ///
    /// This field must be one of "0", "1" or "2". Otherwise, an INVALID_ARGUMENT
    /// error is returned.
    ///
    /// If there are no sufficient active products in the targeted branch and
    /// [force][google.cloud.retail.v2.SetDefaultBranchRequest.force] is not set, a
    /// FAILED_PRECONDITION error is returned.
    ///
    /// [google.cloud.retail.v2.SetDefaultBranchRequest.force]: crate::model::SetDefaultBranchRequest::force
    pub branch_id: std::string::String,

    /// Some note on this request, this can be retrieved by
    /// [CatalogService.GetDefaultBranch][google.cloud.retail.v2.CatalogService.GetDefaultBranch]
    /// before next valid default branch set occurs.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 1,000
    /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// [google.cloud.retail.v2.CatalogService.GetDefaultBranch]: crate::client::CatalogService::get_default_branch
    pub note: std::string::String,

    /// If set to true, it permits switching to a branch with
    /// [branch_id][google.cloud.retail.v2.SetDefaultBranchRequest.branch_id] even
    /// if it has no sufficient active products.
    ///
    /// [google.cloud.retail.v2.SetDefaultBranchRequest.branch_id]: crate::model::SetDefaultBranchRequest::branch_id
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetDefaultBranchRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [catalog][crate::model::SetDefaultBranchRequest::catalog].
    pub fn set_catalog<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.catalog = v.into();
        self
    }

    /// Sets the value of [branch_id][crate::model::SetDefaultBranchRequest::branch_id].
    pub fn set_branch_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.branch_id = v.into();
        self
    }

    /// Sets the value of [note][crate::model::SetDefaultBranchRequest::note].
    pub fn set_note<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.note = v.into();
        self
    }

    /// Sets the value of [force][crate::model::SetDefaultBranchRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for SetDefaultBranchRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.SetDefaultBranchRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetDefaultBranchRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __catalog,
            __branch_id,
            __note,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetDefaultBranchRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "catalog" => Ok(__FieldTag::__catalog),
                            "branchId" => Ok(__FieldTag::__branch_id),
                            "branch_id" => Ok(__FieldTag::__branch_id),
                            "note" => Ok(__FieldTag::__note),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetDefaultBranchRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetDefaultBranchRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__catalog => {
                            if !fields.insert(__FieldTag::__catalog) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for catalog",
                                ));
                            }
                            result.catalog = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__branch_id => {
                            if !fields.insert(__FieldTag::__branch_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for branch_id",
                                ));
                            }
                            result.branch_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__note => {
                            if !fields.insert(__FieldTag::__note) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for note",
                                ));
                            }
                            result.note = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SetDefaultBranchRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.catalog.is_empty() {
            state.serialize_entry("catalog", &self.catalog)?;
        }
        if !self.branch_id.is_empty() {
            state.serialize_entry("branchId", &self.branch_id)?;
        }
        if !self.note.is_empty() {
            state.serialize_entry("note", &self.note)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SetDefaultBranchRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetDefaultBranchRequest");
        debug_struct.field("catalog", &self.catalog);
        debug_struct.field("branch_id", &self.branch_id);
        debug_struct.field("note", &self.note);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message to show which branch is currently the default branch.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDefaultBranchRequest {
    /// The parent catalog resource name, such as
    /// `projects/*/locations/global/catalogs/default_catalog`.
    pub catalog: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDefaultBranchRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [catalog][crate::model::GetDefaultBranchRequest::catalog].
    pub fn set_catalog<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.catalog = v.into();
        self
    }
}

impl wkt::message::Message for GetDefaultBranchRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.GetDefaultBranchRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDefaultBranchRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __catalog,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDefaultBranchRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "catalog" => Ok(__FieldTag::__catalog),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDefaultBranchRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDefaultBranchRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__catalog => {
                            if !fields.insert(__FieldTag::__catalog) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for catalog",
                                ));
                            }
                            result.catalog = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDefaultBranchRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.catalog.is_empty() {
            state.serialize_entry("catalog", &self.catalog)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetDefaultBranchRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetDefaultBranchRequest");
        debug_struct.field("catalog", &self.catalog);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message of
/// [CatalogService.GetDefaultBranch][google.cloud.retail.v2.CatalogService.GetDefaultBranch].
///
/// [google.cloud.retail.v2.CatalogService.GetDefaultBranch]: crate::client::CatalogService::get_default_branch
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDefaultBranchResponse {
    /// Full resource name of the branch id currently set as default branch.
    pub branch: std::string::String,

    /// The time when this branch is set to default.
    pub set_time: std::option::Option<wkt::Timestamp>,

    /// This corresponds to
    /// [SetDefaultBranchRequest.note][google.cloud.retail.v2.SetDefaultBranchRequest.note]
    /// field, when this branch was set as default.
    ///
    /// [google.cloud.retail.v2.SetDefaultBranchRequest.note]: crate::model::SetDefaultBranchRequest::note
    pub note: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDefaultBranchResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [branch][crate::model::GetDefaultBranchResponse::branch].
    pub fn set_branch<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.branch = v.into();
        self
    }

    /// Sets the value of [set_time][crate::model::GetDefaultBranchResponse::set_time].
    pub fn set_set_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.set_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [set_time][crate::model::GetDefaultBranchResponse::set_time].
    pub fn set_or_clear_set_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.set_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [note][crate::model::GetDefaultBranchResponse::note].
    pub fn set_note<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.note = v.into();
        self
    }
}

impl wkt::message::Message for GetDefaultBranchResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.GetDefaultBranchResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDefaultBranchResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __branch,
            __set_time,
            __note,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDefaultBranchResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "branch" => Ok(__FieldTag::__branch),
                            "setTime" => Ok(__FieldTag::__set_time),
                            "set_time" => Ok(__FieldTag::__set_time),
                            "note" => Ok(__FieldTag::__note),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDefaultBranchResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDefaultBranchResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__branch => {
                            if !fields.insert(__FieldTag::__branch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for branch",
                                ));
                            }
                            result.branch = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__set_time => {
                            if !fields.insert(__FieldTag::__set_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for set_time",
                                ));
                            }
                            result.set_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__note => {
                            if !fields.insert(__FieldTag::__note) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for note",
                                ));
                            }
                            result.note = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDefaultBranchResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.branch.is_empty() {
            state.serialize_entry("branch", &self.branch)?;
        }
        if self.set_time.is_some() {
            state.serialize_entry("setTime", &self.set_time)?;
        }
        if !self.note.is_empty() {
            state.serialize_entry("note", &self.note)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetDefaultBranchResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetDefaultBranchResponse");
        debug_struct.field("branch", &self.branch);
        debug_struct.field("set_time", &self.set_time);
        debug_struct.field("note", &self.note);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for
/// [CatalogService.GetCompletionConfig][google.cloud.retail.v2.CatalogService.GetCompletionConfig]
/// method.
///
/// [google.cloud.retail.v2.CatalogService.GetCompletionConfig]: crate::client::CatalogService::get_completion_config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCompletionConfigRequest {
    /// Required. Full CompletionConfig resource name. Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}/completionConfig`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCompletionConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCompletionConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCompletionConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.GetCompletionConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCompletionConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCompletionConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCompletionConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCompletionConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCompletionConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetCompletionConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetCompletionConfigRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for
/// [CatalogService.UpdateCompletionConfig][google.cloud.retail.v2.CatalogService.UpdateCompletionConfig]
/// method.
///
/// [google.cloud.retail.v2.CatalogService.UpdateCompletionConfig]: crate::client::CatalogService::update_completion_config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateCompletionConfigRequest {
    /// Required. The [CompletionConfig][google.cloud.retail.v2.CompletionConfig]
    /// to update.
    ///
    /// If the caller does not have permission to update the
    /// [CompletionConfig][google.cloud.retail.v2.CompletionConfig], then a
    /// PERMISSION_DENIED error is returned.
    ///
    /// If the [CompletionConfig][google.cloud.retail.v2.CompletionConfig] to
    /// update does not exist, a NOT_FOUND error is returned.
    ///
    /// [google.cloud.retail.v2.CompletionConfig]: crate::model::CompletionConfig
    pub completion_config: std::option::Option<crate::model::CompletionConfig>,

    /// Indicates which fields in the provided
    /// [CompletionConfig][google.cloud.retail.v2.CompletionConfig] to update. The
    /// following are the only supported fields:
    ///
    /// * [CompletionConfig.matching_order][google.cloud.retail.v2.CompletionConfig.matching_order]
    /// * [CompletionConfig.max_suggestions][google.cloud.retail.v2.CompletionConfig.max_suggestions]
    /// * [CompletionConfig.min_prefix_length][google.cloud.retail.v2.CompletionConfig.min_prefix_length]
    /// * [CompletionConfig.auto_learning][google.cloud.retail.v2.CompletionConfig.auto_learning]
    ///
    /// If not set, all supported fields are updated.
    ///
    /// [google.cloud.retail.v2.CompletionConfig]: crate::model::CompletionConfig
    /// [google.cloud.retail.v2.CompletionConfig.auto_learning]: crate::model::CompletionConfig::auto_learning
    /// [google.cloud.retail.v2.CompletionConfig.matching_order]: crate::model::CompletionConfig::matching_order
    /// [google.cloud.retail.v2.CompletionConfig.max_suggestions]: crate::model::CompletionConfig::max_suggestions
    /// [google.cloud.retail.v2.CompletionConfig.min_prefix_length]: crate::model::CompletionConfig::min_prefix_length
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateCompletionConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [completion_config][crate::model::UpdateCompletionConfigRequest::completion_config].
    pub fn set_completion_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CompletionConfig>,
    {
        self.completion_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [completion_config][crate::model::UpdateCompletionConfigRequest::completion_config].
    pub fn set_or_clear_completion_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CompletionConfig>,
    {
        self.completion_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateCompletionConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateCompletionConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateCompletionConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.UpdateCompletionConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateCompletionConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __completion_config,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateCompletionConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "completionConfig" => Ok(__FieldTag::__completion_config),
                            "completion_config" => Ok(__FieldTag::__completion_config),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateCompletionConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateCompletionConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__completion_config => {
                            if !fields.insert(__FieldTag::__completion_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completion_config",
                                ));
                            }
                            result.completion_config = map
                                .next_value::<std::option::Option<crate::model::CompletionConfig>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateCompletionConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.completion_config.is_some() {
            state.serialize_entry("completionConfig", &self.completion_config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateCompletionConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateCompletionConfigRequest");
        debug_struct.field("completion_config", &self.completion_config);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for
/// [CatalogService.GetAttributesConfig][google.cloud.retail.v2.CatalogService.GetAttributesConfig]
/// method.
///
/// [google.cloud.retail.v2.CatalogService.GetAttributesConfig]: crate::client::CatalogService::get_attributes_config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAttributesConfigRequest {
    /// Required. Full AttributesConfig resource name. Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}/attributesConfig`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAttributesConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAttributesConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAttributesConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.GetAttributesConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAttributesConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAttributesConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAttributesConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAttributesConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAttributesConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetAttributesConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetAttributesConfigRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for
/// [CatalogService.UpdateAttributesConfig][google.cloud.retail.v2.CatalogService.UpdateAttributesConfig]
/// method.
///
/// [google.cloud.retail.v2.CatalogService.UpdateAttributesConfig]: crate::client::CatalogService::update_attributes_config
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAttributesConfigRequest {
    /// Required. The [AttributesConfig][google.cloud.retail.v2.AttributesConfig]
    /// to update.
    ///
    /// [google.cloud.retail.v2.AttributesConfig]: crate::model::AttributesConfig
    pub attributes_config: std::option::Option<crate::model::AttributesConfig>,

    /// Indicates which fields in the provided
    /// [AttributesConfig][google.cloud.retail.v2.AttributesConfig] to update. The
    /// following is the only supported field:
    ///
    /// * [AttributesConfig.catalog_attributes][google.cloud.retail.v2.AttributesConfig.catalog_attributes]
    ///
    /// If not set, all supported fields are updated.
    ///
    /// [google.cloud.retail.v2.AttributesConfig]: crate::model::AttributesConfig
    /// [google.cloud.retail.v2.AttributesConfig.catalog_attributes]: crate::model::AttributesConfig::catalog_attributes
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAttributesConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attributes_config][crate::model::UpdateAttributesConfigRequest::attributes_config].
    pub fn set_attributes_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttributesConfig>,
    {
        self.attributes_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [attributes_config][crate::model::UpdateAttributesConfigRequest::attributes_config].
    pub fn set_or_clear_attributes_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttributesConfig>,
    {
        self.attributes_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAttributesConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAttributesConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateAttributesConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.UpdateAttributesConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAttributesConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attributes_config,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAttributesConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attributesConfig" => Ok(__FieldTag::__attributes_config),
                            "attributes_config" => Ok(__FieldTag::__attributes_config),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAttributesConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAttributesConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attributes_config => {
                            if !fields.insert(__FieldTag::__attributes_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes_config",
                                ));
                            }
                            result.attributes_config = map
                                .next_value::<std::option::Option<crate::model::AttributesConfig>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAttributesConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.attributes_config.is_some() {
            state.serialize_entry("attributesConfig", &self.attributes_config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateAttributesConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateAttributesConfigRequest");
        debug_struct.field("attributes_config", &self.attributes_config);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for
/// [CatalogService.AddCatalogAttribute][google.cloud.retail.v2.CatalogService.AddCatalogAttribute]
/// method.
///
/// [google.cloud.retail.v2.CatalogService.AddCatalogAttribute]: crate::client::CatalogService::add_catalog_attribute
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AddCatalogAttributeRequest {
    /// Required. Full AttributesConfig resource name. Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}/attributesConfig`
    pub attributes_config: std::string::String,

    /// Required. The [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute]
    /// to add.
    ///
    /// [google.cloud.retail.v2.CatalogAttribute]: crate::model::CatalogAttribute
    pub catalog_attribute: std::option::Option<crate::model::CatalogAttribute>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddCatalogAttributeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attributes_config][crate::model::AddCatalogAttributeRequest::attributes_config].
    pub fn set_attributes_config<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.attributes_config = v.into();
        self
    }

    /// Sets the value of [catalog_attribute][crate::model::AddCatalogAttributeRequest::catalog_attribute].
    pub fn set_catalog_attribute<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CatalogAttribute>,
    {
        self.catalog_attribute = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [catalog_attribute][crate::model::AddCatalogAttributeRequest::catalog_attribute].
    pub fn set_or_clear_catalog_attribute<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CatalogAttribute>,
    {
        self.catalog_attribute = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AddCatalogAttributeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.AddCatalogAttributeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AddCatalogAttributeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attributes_config,
            __catalog_attribute,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AddCatalogAttributeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attributesConfig" => Ok(__FieldTag::__attributes_config),
                            "attributes_config" => Ok(__FieldTag::__attributes_config),
                            "catalogAttribute" => Ok(__FieldTag::__catalog_attribute),
                            "catalog_attribute" => Ok(__FieldTag::__catalog_attribute),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AddCatalogAttributeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AddCatalogAttributeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attributes_config => {
                            if !fields.insert(__FieldTag::__attributes_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes_config",
                                ));
                            }
                            result.attributes_config = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__catalog_attribute => {
                            if !fields.insert(__FieldTag::__catalog_attribute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for catalog_attribute",
                                ));
                            }
                            result.catalog_attribute = map
                                .next_value::<std::option::Option<crate::model::CatalogAttribute>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AddCatalogAttributeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.attributes_config.is_empty() {
            state.serialize_entry("attributesConfig", &self.attributes_config)?;
        }
        if self.catalog_attribute.is_some() {
            state.serialize_entry("catalogAttribute", &self.catalog_attribute)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AddCatalogAttributeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AddCatalogAttributeRequest");
        debug_struct.field("attributes_config", &self.attributes_config);
        debug_struct.field("catalog_attribute", &self.catalog_attribute);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for
/// [CatalogService.RemoveCatalogAttribute][google.cloud.retail.v2.CatalogService.RemoveCatalogAttribute]
/// method.
///
/// [google.cloud.retail.v2.CatalogService.RemoveCatalogAttribute]: crate::client::CatalogService::remove_catalog_attribute
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoveCatalogAttributeRequest {
    /// Required. Full AttributesConfig resource name. Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}/attributesConfig`
    pub attributes_config: std::string::String,

    /// Required. The attribute name key of the
    /// [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] to remove.
    ///
    /// [google.cloud.retail.v2.CatalogAttribute]: crate::model::CatalogAttribute
    pub key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveCatalogAttributeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attributes_config][crate::model::RemoveCatalogAttributeRequest::attributes_config].
    pub fn set_attributes_config<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.attributes_config = v.into();
        self
    }

    /// Sets the value of [key][crate::model::RemoveCatalogAttributeRequest::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }
}

impl wkt::message::Message for RemoveCatalogAttributeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.RemoveCatalogAttributeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RemoveCatalogAttributeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attributes_config,
            __key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RemoveCatalogAttributeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attributesConfig" => Ok(__FieldTag::__attributes_config),
                            "attributes_config" => Ok(__FieldTag::__attributes_config),
                            "key" => Ok(__FieldTag::__key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RemoveCatalogAttributeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RemoveCatalogAttributeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attributes_config => {
                            if !fields.insert(__FieldTag::__attributes_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes_config",
                                ));
                            }
                            result.attributes_config = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RemoveCatalogAttributeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.attributes_config.is_empty() {
            state.serialize_entry("attributesConfig", &self.attributes_config)?;
        }
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RemoveCatalogAttributeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RemoveCatalogAttributeRequest");
        debug_struct.field("attributes_config", &self.attributes_config);
        debug_struct.field("key", &self.key);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for
/// [CatalogService.ReplaceCatalogAttribute][google.cloud.retail.v2.CatalogService.ReplaceCatalogAttribute]
/// method.
///
/// [google.cloud.retail.v2.CatalogService.ReplaceCatalogAttribute]: crate::client::CatalogService::replace_catalog_attribute
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReplaceCatalogAttributeRequest {
    /// Required. Full AttributesConfig resource name. Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}/attributesConfig`
    pub attributes_config: std::string::String,

    /// Required. The updated
    /// [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute].
    ///
    /// [google.cloud.retail.v2.CatalogAttribute]: crate::model::CatalogAttribute
    pub catalog_attribute: std::option::Option<crate::model::CatalogAttribute>,

    /// Indicates which fields in the provided
    /// [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] to update. The
    /// following are NOT supported:
    ///
    /// * [CatalogAttribute.key][google.cloud.retail.v2.CatalogAttribute.key]
    ///
    /// If not set, all supported fields are updated.
    ///
    /// [google.cloud.retail.v2.CatalogAttribute]: crate::model::CatalogAttribute
    /// [google.cloud.retail.v2.CatalogAttribute.key]: crate::model::CatalogAttribute::key
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplaceCatalogAttributeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [attributes_config][crate::model::ReplaceCatalogAttributeRequest::attributes_config].
    pub fn set_attributes_config<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.attributes_config = v.into();
        self
    }

    /// Sets the value of [catalog_attribute][crate::model::ReplaceCatalogAttributeRequest::catalog_attribute].
    pub fn set_catalog_attribute<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CatalogAttribute>,
    {
        self.catalog_attribute = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [catalog_attribute][crate::model::ReplaceCatalogAttributeRequest::catalog_attribute].
    pub fn set_or_clear_catalog_attribute<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CatalogAttribute>,
    {
        self.catalog_attribute = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::ReplaceCatalogAttributeRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::ReplaceCatalogAttributeRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ReplaceCatalogAttributeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ReplaceCatalogAttributeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReplaceCatalogAttributeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __attributes_config,
            __catalog_attribute,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReplaceCatalogAttributeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "attributesConfig" => Ok(__FieldTag::__attributes_config),
                            "attributes_config" => Ok(__FieldTag::__attributes_config),
                            "catalogAttribute" => Ok(__FieldTag::__catalog_attribute),
                            "catalog_attribute" => Ok(__FieldTag::__catalog_attribute),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReplaceCatalogAttributeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReplaceCatalogAttributeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__attributes_config => {
                            if !fields.insert(__FieldTag::__attributes_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes_config",
                                ));
                            }
                            result.attributes_config = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__catalog_attribute => {
                            if !fields.insert(__FieldTag::__catalog_attribute) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for catalog_attribute",
                                ));
                            }
                            result.catalog_attribute = map
                                .next_value::<std::option::Option<crate::model::CatalogAttribute>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReplaceCatalogAttributeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.attributes_config.is_empty() {
            state.serialize_entry("attributesConfig", &self.attributes_config)?;
        }
        if self.catalog_attribute.is_some() {
            state.serialize_entry("catalogAttribute", &self.catalog_attribute)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReplaceCatalogAttributeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReplaceCatalogAttributeRequest");
        debug_struct.field("attributes_config", &self.attributes_config);
        debug_struct.field("catalog_attribute", &self.catalog_attribute);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata that is used to define a condition that triggers an action.
/// A valid condition must specify at least one of 'query_terms' or
/// 'products_filter'. If multiple fields are specified, the condition is met if
/// all the fields are satisfied e.g. if a set of query terms and product_filter
/// are set, then only items matching the product_filter for requests with a
/// query matching the query terms wil get boosted.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Condition {
    /// A list (up to 10 entries) of terms to match the query on. If not
    /// specified, match all queries.
    /// If many query terms are specified, the condition
    /// is matched if any of the terms is a match (i.e. using the OR operator).
    pub query_terms: std::vec::Vec<crate::model::condition::QueryTerm>,

    /// Range of time(s) specifying when Condition is active.
    /// Condition true if any time range matches.
    pub active_time_range: std::vec::Vec<crate::model::condition::TimeRange>,

    /// Used to support browse uses cases.
    /// A list (up to 10 entries) of categories or departments.
    /// The format should be the same as
    /// [UserEvent.page_categories][google.cloud.retail.v2.UserEvent.page_categories];
    ///
    /// [google.cloud.retail.v2.UserEvent.page_categories]: crate::model::UserEvent::page_categories
    pub page_categories: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Condition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query_terms][crate::model::Condition::query_terms].
    pub fn set_query_terms<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::condition::QueryTerm>,
    {
        use std::iter::Iterator;
        self.query_terms = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [active_time_range][crate::model::Condition::active_time_range].
    pub fn set_active_time_range<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::condition::TimeRange>,
    {
        use std::iter::Iterator;
        self.active_time_range = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [page_categories][crate::model::Condition::page_categories].
    pub fn set_page_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.page_categories = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Condition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.Condition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Condition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query_terms,
            __active_time_range,
            __page_categories,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Condition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "queryTerms" => Ok(__FieldTag::__query_terms),
                            "query_terms" => Ok(__FieldTag::__query_terms),
                            "activeTimeRange" => Ok(__FieldTag::__active_time_range),
                            "active_time_range" => Ok(__FieldTag::__active_time_range),
                            "pageCategories" => Ok(__FieldTag::__page_categories),
                            "page_categories" => Ok(__FieldTag::__page_categories),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Condition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Condition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query_terms => {
                            if !fields.insert(__FieldTag::__query_terms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_terms",
                                ));
                            }
                            result.query_terms = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::condition::QueryTerm>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__active_time_range => {
                            if !fields.insert(__FieldTag::__active_time_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for active_time_range",
                                ));
                            }
                            result.active_time_range = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::condition::TimeRange>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_categories => {
                            if !fields.insert(__FieldTag::__page_categories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_categories",
                                ));
                            }
                            result.page_categories = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Condition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.query_terms.is_empty() {
            state.serialize_entry("queryTerms", &self.query_terms)?;
        }
        if !self.active_time_range.is_empty() {
            state.serialize_entry("activeTimeRange", &self.active_time_range)?;
        }
        if !self.page_categories.is_empty() {
            state.serialize_entry("pageCategories", &self.page_categories)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Condition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Condition");
        debug_struct.field("query_terms", &self.query_terms);
        debug_struct.field("active_time_range", &self.active_time_range);
        debug_struct.field("page_categories", &self.page_categories);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Condition].
pub mod condition {
    #[allow(unused_imports)]
    use super::*;

    /// Query terms that we want to match on.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct QueryTerm {
        /// The value of the term to match on.
        /// Value cannot be empty.
        /// Value can have at most 3 terms if specified as a partial match. Each
        /// space separated string is considered as one term.
        /// For example, "a b c" is 3 terms and allowed, but " a b c d" is 4 terms
        /// and not allowed for a partial match.
        pub value: std::string::String,

        /// Whether this is supposed to be a full or partial match.
        pub full_match: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QueryTerm {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::condition::QueryTerm::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }

        /// Sets the value of [full_match][crate::model::condition::QueryTerm::full_match].
        pub fn set_full_match<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.full_match = v.into();
            self
        }
    }

    impl wkt::message::Message for QueryTerm {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.Condition.QueryTerm"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for QueryTerm {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __value,
                __full_match,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for QueryTerm")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "value" => Ok(__FieldTag::__value),
                                "fullMatch" => Ok(__FieldTag::__full_match),
                                "full_match" => Ok(__FieldTag::__full_match),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = QueryTerm;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct QueryTerm")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__value => {
                                if !fields.insert(__FieldTag::__value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for value",
                                    ));
                                }
                                result.value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__full_match => {
                                if !fields.insert(__FieldTag::__full_match) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for full_match",
                                    ));
                                }
                                result.full_match = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for QueryTerm {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.value.is_empty() {
                state.serialize_entry("value", &self.value)?;
            }
            if !wkt::internal::is_default(&self.full_match) {
                state.serialize_entry("fullMatch", &self.full_match)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for QueryTerm {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("QueryTerm");
            debug_struct.field("value", &self.value);
            debug_struct.field("full_match", &self.full_match);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Used for time-dependent conditions.
    /// Example: Want to have rule applied for week long sale.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TimeRange {
        /// Start of time range. Range is inclusive.
        pub start_time: std::option::Option<wkt::Timestamp>,

        /// End of time range. Range is inclusive.
        pub end_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TimeRange {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_time][crate::model::condition::TimeRange::start_time].
        pub fn set_start_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [start_time][crate::model::condition::TimeRange::start_time].
        pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [end_time][crate::model::condition::TimeRange::end_time].
        pub fn set_end_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.end_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [end_time][crate::model::condition::TimeRange::end_time].
        pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.end_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for TimeRange {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.Condition.TimeRange"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TimeRange {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __start_time,
                __end_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TimeRange")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "startTime" => Ok(__FieldTag::__start_time),
                                "start_time" => Ok(__FieldTag::__start_time),
                                "endTime" => Ok(__FieldTag::__end_time),
                                "end_time" => Ok(__FieldTag::__end_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TimeRange;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TimeRange")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__start_time => {
                                if !fields.insert(__FieldTag::__start_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for start_time",
                                    ));
                                }
                                result.start_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__end_time => {
                                if !fields.insert(__FieldTag::__end_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for end_time",
                                    ));
                                }
                                result.end_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TimeRange {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.start_time.is_some() {
                state.serialize_entry("startTime", &self.start_time)?;
            }
            if self.end_time.is_some() {
                state.serialize_entry("endTime", &self.end_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for TimeRange {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("TimeRange");
            debug_struct.field("start_time", &self.start_time);
            debug_struct.field("end_time", &self.end_time);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// A rule is a condition-action pair
///
/// * A condition defines when a rule is to be triggered.
/// * An action specifies what occurs on that trigger.
///   Currently rules only work for [controls][google.cloud.retail.v2.Control] with
///   [SOLUTION_TYPE_SEARCH][google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH].
///
/// [google.cloud.retail.v2.Control]: crate::model::Control
/// [google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH]: crate::model::SolutionType::Search
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Rule {
    /// Required. The condition that triggers the rule.
    /// If the condition is empty, the rule will always apply.
    pub condition: std::option::Option<crate::model::Condition>,

    /// An action must be provided.
    pub action: std::option::Option<crate::model::rule::Action>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Rule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [condition][crate::model::Rule::condition].
    pub fn set_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Condition>,
    {
        self.condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [condition][crate::model::Rule::condition].
    pub fn set_or_clear_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Condition>,
    {
        self.condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [action][crate::model::Rule::action].
    ///
    /// Note that all the setters affecting `action` are mutually
    /// exclusive.
    pub fn set_action<T: std::convert::Into<std::option::Option<crate::model::rule::Action>>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }

    /// The value of [action][crate::model::Rule::action]
    /// if it holds a `BoostAction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn boost_action(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::rule::BoostAction>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::rule::Action::BoostAction(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Rule::action]
    /// to hold a `BoostAction`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_boost_action<
        T: std::convert::Into<std::boxed::Box<crate::model::rule::BoostAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(crate::model::rule::Action::BoostAction(v.into()));
        self
    }

    /// The value of [action][crate::model::Rule::action]
    /// if it holds a `RedirectAction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn redirect_action(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::rule::RedirectAction>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::rule::Action::RedirectAction(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Rule::action]
    /// to hold a `RedirectAction`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_redirect_action<
        T: std::convert::Into<std::boxed::Box<crate::model::rule::RedirectAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action =
            std::option::Option::Some(crate::model::rule::Action::RedirectAction(v.into()));
        self
    }

    /// The value of [action][crate::model::Rule::action]
    /// if it holds a `OnewaySynonymsAction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn oneway_synonyms_action(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::rule::OnewaySynonymsAction>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::rule::Action::OnewaySynonymsAction(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Rule::action]
    /// to hold a `OnewaySynonymsAction`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_oneway_synonyms_action<
        T: std::convert::Into<std::boxed::Box<crate::model::rule::OnewaySynonymsAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action =
            std::option::Option::Some(crate::model::rule::Action::OnewaySynonymsAction(v.into()));
        self
    }

    /// The value of [action][crate::model::Rule::action]
    /// if it holds a `DoNotAssociateAction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn do_not_associate_action(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::rule::DoNotAssociateAction>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::rule::Action::DoNotAssociateAction(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Rule::action]
    /// to hold a `DoNotAssociateAction`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_do_not_associate_action<
        T: std::convert::Into<std::boxed::Box<crate::model::rule::DoNotAssociateAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action =
            std::option::Option::Some(crate::model::rule::Action::DoNotAssociateAction(v.into()));
        self
    }

    /// The value of [action][crate::model::Rule::action]
    /// if it holds a `ReplacementAction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn replacement_action(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::rule::ReplacementAction>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::rule::Action::ReplacementAction(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Rule::action]
    /// to hold a `ReplacementAction`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_replacement_action<
        T: std::convert::Into<std::boxed::Box<crate::model::rule::ReplacementAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action =
            std::option::Option::Some(crate::model::rule::Action::ReplacementAction(v.into()));
        self
    }

    /// The value of [action][crate::model::Rule::action]
    /// if it holds a `IgnoreAction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn ignore_action(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::rule::IgnoreAction>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::rule::Action::IgnoreAction(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Rule::action]
    /// to hold a `IgnoreAction`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_ignore_action<
        T: std::convert::Into<std::boxed::Box<crate::model::rule::IgnoreAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(crate::model::rule::Action::IgnoreAction(v.into()));
        self
    }

    /// The value of [action][crate::model::Rule::action]
    /// if it holds a `FilterAction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn filter_action(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::rule::FilterAction>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::rule::Action::FilterAction(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Rule::action]
    /// to hold a `FilterAction`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_filter_action<
        T: std::convert::Into<std::boxed::Box<crate::model::rule::FilterAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(crate::model::rule::Action::FilterAction(v.into()));
        self
    }

    /// The value of [action][crate::model::Rule::action]
    /// if it holds a `TwowaySynonymsAction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn twoway_synonyms_action(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::rule::TwowaySynonymsAction>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::rule::Action::TwowaySynonymsAction(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Rule::action]
    /// to hold a `TwowaySynonymsAction`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_twoway_synonyms_action<
        T: std::convert::Into<std::boxed::Box<crate::model::rule::TwowaySynonymsAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action =
            std::option::Option::Some(crate::model::rule::Action::TwowaySynonymsAction(v.into()));
        self
    }

    /// The value of [action][crate::model::Rule::action]
    /// if it holds a `ForceReturnFacetAction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn force_return_facet_action(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::rule::ForceReturnFacetAction>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::rule::Action::ForceReturnFacetAction(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Rule::action]
    /// to hold a `ForceReturnFacetAction`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_force_return_facet_action<
        T: std::convert::Into<std::boxed::Box<crate::model::rule::ForceReturnFacetAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action =
            std::option::Option::Some(crate::model::rule::Action::ForceReturnFacetAction(v.into()));
        self
    }

    /// The value of [action][crate::model::Rule::action]
    /// if it holds a `RemoveFacetAction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn remove_facet_action(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::rule::RemoveFacetAction>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::rule::Action::RemoveFacetAction(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Rule::action]
    /// to hold a `RemoveFacetAction`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_remove_facet_action<
        T: std::convert::Into<std::boxed::Box<crate::model::rule::RemoveFacetAction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action =
            std::option::Option::Some(crate::model::rule::Action::RemoveFacetAction(v.into()));
        self
    }

    /// The value of [action][crate::model::Rule::action]
    /// if it holds a `PinAction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn pin_action(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::rule::PinAction>> {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::rule::Action::PinAction(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::Rule::action]
    /// to hold a `PinAction`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_pin_action<T: std::convert::Into<std::boxed::Box<crate::model::rule::PinAction>>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(crate::model::rule::Action::PinAction(v.into()));
        self
    }
}

impl wkt::message::Message for Rule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.Rule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Rule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __boost_action,
            __redirect_action,
            __oneway_synonyms_action,
            __do_not_associate_action,
            __replacement_action,
            __ignore_action,
            __filter_action,
            __twoway_synonyms_action,
            __force_return_facet_action,
            __remove_facet_action,
            __pin_action,
            __condition,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Rule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "boostAction" => Ok(__FieldTag::__boost_action),
                            "boost_action" => Ok(__FieldTag::__boost_action),
                            "redirectAction" => Ok(__FieldTag::__redirect_action),
                            "redirect_action" => Ok(__FieldTag::__redirect_action),
                            "onewaySynonymsAction" => Ok(__FieldTag::__oneway_synonyms_action),
                            "oneway_synonyms_action" => Ok(__FieldTag::__oneway_synonyms_action),
                            "doNotAssociateAction" => Ok(__FieldTag::__do_not_associate_action),
                            "do_not_associate_action" => Ok(__FieldTag::__do_not_associate_action),
                            "replacementAction" => Ok(__FieldTag::__replacement_action),
                            "replacement_action" => Ok(__FieldTag::__replacement_action),
                            "ignoreAction" => Ok(__FieldTag::__ignore_action),
                            "ignore_action" => Ok(__FieldTag::__ignore_action),
                            "filterAction" => Ok(__FieldTag::__filter_action),
                            "filter_action" => Ok(__FieldTag::__filter_action),
                            "twowaySynonymsAction" => Ok(__FieldTag::__twoway_synonyms_action),
                            "twoway_synonyms_action" => Ok(__FieldTag::__twoway_synonyms_action),
                            "forceReturnFacetAction" => Ok(__FieldTag::__force_return_facet_action),
                            "force_return_facet_action" => {
                                Ok(__FieldTag::__force_return_facet_action)
                            }
                            "removeFacetAction" => Ok(__FieldTag::__remove_facet_action),
                            "remove_facet_action" => Ok(__FieldTag::__remove_facet_action),
                            "pinAction" => Ok(__FieldTag::__pin_action),
                            "pin_action" => Ok(__FieldTag::__pin_action),
                            "condition" => Ok(__FieldTag::__condition),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Rule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Rule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__boost_action => {
                            if !fields.insert(__FieldTag::__boost_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boost_action",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.cloud.retail.v2.Rule.boost_action, latest field was boostAction",
                                ));
                            }
                            result.action =
                                std::option::Option::Some(crate::model::rule::Action::BoostAction(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::rule::BoostAction>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__redirect_action => {
                            if !fields.insert(__FieldTag::__redirect_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redirect_action",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.cloud.retail.v2.Rule.redirect_action, latest field was redirectAction",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::rule::Action::RedirectAction(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::rule::RedirectAction>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__oneway_synonyms_action => {
                            if !fields.insert(__FieldTag::__oneway_synonyms_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oneway_synonyms_action",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.cloud.retail.v2.Rule.oneway_synonyms_action, latest field was onewaySynonymsAction",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::rule::Action::OnewaySynonymsAction(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::rule::OnewaySynonymsAction>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__do_not_associate_action => {
                            if !fields.insert(__FieldTag::__do_not_associate_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for do_not_associate_action",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.cloud.retail.v2.Rule.do_not_associate_action, latest field was doNotAssociateAction",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::rule::Action::DoNotAssociateAction(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::rule::DoNotAssociateAction>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__replacement_action => {
                            if !fields.insert(__FieldTag::__replacement_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replacement_action",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.cloud.retail.v2.Rule.replacement_action, latest field was replacementAction",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::rule::Action::ReplacementAction(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::rule::ReplacementAction>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__ignore_action => {
                            if !fields.insert(__FieldTag::__ignore_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_action",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.cloud.retail.v2.Rule.ignore_action, latest field was ignoreAction",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::rule::Action::IgnoreAction(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::rule::IgnoreAction>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__filter_action => {
                            if !fields.insert(__FieldTag::__filter_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter_action",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.cloud.retail.v2.Rule.filter_action, latest field was filterAction",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::rule::Action::FilterAction(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::rule::FilterAction>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__twoway_synonyms_action => {
                            if !fields.insert(__FieldTag::__twoway_synonyms_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for twoway_synonyms_action",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.cloud.retail.v2.Rule.twoway_synonyms_action, latest field was twowaySynonymsAction",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::rule::Action::TwowaySynonymsAction(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::rule::TwowaySynonymsAction>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__force_return_facet_action => {
                            if !fields.insert(__FieldTag::__force_return_facet_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force_return_facet_action",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.cloud.retail.v2.Rule.force_return_facet_action, latest field was forceReturnFacetAction",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::rule::Action::ForceReturnFacetAction(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::rule::ForceReturnFacetAction>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__remove_facet_action => {
                            if !fields.insert(__FieldTag::__remove_facet_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remove_facet_action",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.cloud.retail.v2.Rule.remove_facet_action, latest field was removeFacetAction",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::rule::Action::RemoveFacetAction(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::rule::RemoveFacetAction>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__pin_action => {
                            if !fields.insert(__FieldTag::__pin_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pin_action",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.cloud.retail.v2.Rule.pin_action, latest field was pinAction",
                                ));
                            }
                            result.action =
                                std::option::Option::Some(crate::model::rule::Action::PinAction(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::rule::PinAction>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition",
                                ));
                            }
                            result.condition =
                                map.next_value::<std::option::Option<crate::model::Condition>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Rule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.boost_action() {
            state.serialize_entry("boostAction", value)?;
        }
        if let Some(value) = self.redirect_action() {
            state.serialize_entry("redirectAction", value)?;
        }
        if let Some(value) = self.oneway_synonyms_action() {
            state.serialize_entry("onewaySynonymsAction", value)?;
        }
        if let Some(value) = self.do_not_associate_action() {
            state.serialize_entry("doNotAssociateAction", value)?;
        }
        if let Some(value) = self.replacement_action() {
            state.serialize_entry("replacementAction", value)?;
        }
        if let Some(value) = self.ignore_action() {
            state.serialize_entry("ignoreAction", value)?;
        }
        if let Some(value) = self.filter_action() {
            state.serialize_entry("filterAction", value)?;
        }
        if let Some(value) = self.twoway_synonyms_action() {
            state.serialize_entry("twowaySynonymsAction", value)?;
        }
        if let Some(value) = self.force_return_facet_action() {
            state.serialize_entry("forceReturnFacetAction", value)?;
        }
        if let Some(value) = self.remove_facet_action() {
            state.serialize_entry("removeFacetAction", value)?;
        }
        if let Some(value) = self.pin_action() {
            state.serialize_entry("pinAction", value)?;
        }
        if self.condition.is_some() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Rule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Rule");
        debug_struct.field("condition", &self.condition);
        debug_struct.field("action", &self.action);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Rule].
pub mod rule {
    #[allow(unused_imports)]
    use super::*;

    /// A boost action to apply to results matching condition specified above.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BoostAction {
        /// Strength of the condition boost, which must be in [-1, 1]. Negative
        /// boost means demotion. Default is 0.0.
        ///
        /// Setting to 1.0 gives the item a big promotion. However, it does not
        /// necessarily mean that the boosted item will be the top result at all
        /// times, nor that other items will be excluded. Results could still be
        /// shown even when none of them matches the condition. And results that
        /// are significantly more relevant to the search query can still trump
        /// your heavily favored but irrelevant items.
        ///
        /// Setting to -1.0 gives the item a big demotion. However, results that
        /// are deeply relevant might still be shown. The item will have an
        /// upstream battle to get a fairly high ranking, but it is not blocked out
        /// completely.
        ///
        /// Setting to 0.0 means no boost applied. The boosting condition is
        /// ignored.
        pub boost: f32,

        /// The filter can have a max size of 5000 characters.
        /// An expression which specifies which products to apply an action to.
        /// The syntax and supported fields are the same as a filter expression. See
        /// [SearchRequest.filter][google.cloud.retail.v2.SearchRequest.filter] for
        /// detail syntax and limitations.
        ///
        /// Examples:
        ///
        /// * To boost products with product ID "product_1" or "product_2", and
        ///   color
        ///   "Red" or "Blue":\<br\>
        ///   *(id: ANY("product_1", "product_2"))<br>*
        ///   *AND<br>*
        ///   *(colorFamilies: ANY("Red", "Blue"))<br>*
        ///
        /// [google.cloud.retail.v2.SearchRequest.filter]: crate::model::SearchRequest::filter
        pub products_filter: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BoostAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [boost][crate::model::rule::BoostAction::boost].
        pub fn set_boost<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.boost = v.into();
            self
        }

        /// Sets the value of [products_filter][crate::model::rule::BoostAction::products_filter].
        pub fn set_products_filter<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.products_filter = v.into();
            self
        }
    }

    impl wkt::message::Message for BoostAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.Rule.BoostAction"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BoostAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __boost,
                __products_filter,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BoostAction")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "boost" => Ok(__FieldTag::__boost),
                                "productsFilter" => Ok(__FieldTag::__products_filter),
                                "products_filter" => Ok(__FieldTag::__products_filter),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BoostAction;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BoostAction")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__boost => {
                                if !fields.insert(__FieldTag::__boost) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for boost",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.boost = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__products_filter => {
                                if !fields.insert(__FieldTag::__products_filter) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for products_filter",
                                    ));
                                }
                                result.products_filter = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BoostAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.boost) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("boost", &__With(&self.boost))?;
            }
            if !self.products_filter.is_empty() {
                state.serialize_entry("productsFilter", &self.products_filter)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for BoostAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("BoostAction");
            debug_struct.field("boost", &self.boost);
            debug_struct.field("products_filter", &self.products_filter);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// * Rule Condition:
    ///
    ///   - No
    ///     [Condition.query_terms][google.cloud.retail.v2.Condition.query_terms]
    ///     provided is a global match.
    ///   - 1 or more
    ///     [Condition.query_terms][google.cloud.retail.v2.Condition.query_terms]
    ///     provided are combined with OR operator.
    /// * Action Input: The request query and filter that are applied to the
    ///   retrieved products, in addition to any filters already provided with the
    ///   SearchRequest. The AND operator is used to combine the query's existing
    ///   filters with the filter rule(s). NOTE: May result in 0 results when
    ///   filters conflict.
    ///
    /// * Action Result: Filters the returned objects to be ONLY those that passed
    ///   the filter.
    ///
    ///
    /// [google.cloud.retail.v2.Condition.query_terms]: crate::model::Condition::query_terms
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FilterAction {
        /// A filter to apply on the matching condition results. Supported features:
        ///
        /// * [filter][google.cloud.retail.v2.Rule.FilterAction.filter] must be set.
        /// * Filter syntax is identical to
        ///   [SearchRequest.filter][google.cloud.retail.v2.SearchRequest.filter]. For
        ///   more
        ///   information, see [Filter](/retail/docs/filter-and-order#filter).
        /// * To filter products with product ID "product_1" or "product_2", and
        ///   color
        ///   "Red" or "Blue":\<br\>
        ///   *(id: ANY("product_1", "product_2"))<br>*
        ///   *AND<br>*
        ///   *(colorFamilies: ANY("Red", "Blue"))<br>*
        ///
        /// [google.cloud.retail.v2.Rule.FilterAction.filter]: crate::model::rule::FilterAction::filter
        /// [google.cloud.retail.v2.SearchRequest.filter]: crate::model::SearchRequest::filter
        pub filter: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FilterAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::rule::FilterAction::filter].
        pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.filter = v.into();
            self
        }
    }

    impl wkt::message::Message for FilterAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.Rule.FilterAction"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FilterAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __filter,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for FilterAction")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "filter" => Ok(__FieldTag::__filter),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FilterAction;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FilterAction")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__filter => {
                                if !fields.insert(__FieldTag::__filter) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for filter",
                                    ));
                                }
                                result.filter = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for FilterAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.filter.is_empty() {
                state.serialize_entry("filter", &self.filter)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for FilterAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("FilterAction");
            debug_struct.field("filter", &self.filter);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Redirects a shopper to a specific page.
    ///
    /// * Rule Condition:
    ///   Must specify
    ///   [Condition.query_terms][google.cloud.retail.v2.Condition.query_terms].
    /// * Action Input: Request Query
    /// * Action Result: Redirects shopper to provided uri.
    ///
    /// [google.cloud.retail.v2.Condition.query_terms]: crate::model::Condition::query_terms
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RedirectAction {
        /// URL must have length equal or less than 2000 characters.
        pub redirect_uri: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RedirectAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [redirect_uri][crate::model::rule::RedirectAction::redirect_uri].
        pub fn set_redirect_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.redirect_uri = v.into();
            self
        }
    }

    impl wkt::message::Message for RedirectAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.Rule.RedirectAction"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RedirectAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __redirect_uri,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RedirectAction")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "redirectUri" => Ok(__FieldTag::__redirect_uri),
                                "redirect_uri" => Ok(__FieldTag::__redirect_uri),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RedirectAction;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RedirectAction")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__redirect_uri => {
                                if !fields.insert(__FieldTag::__redirect_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for redirect_uri",
                                    ));
                                }
                                result.redirect_uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RedirectAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.redirect_uri.is_empty() {
                state.serialize_entry("redirectUri", &self.redirect_uri)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for RedirectAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("RedirectAction");
            debug_struct.field("redirect_uri", &self.redirect_uri);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Creates a set of terms that will be treated as synonyms of each other.
    /// Example: synonyms of "sneakers" and "shoes":
    ///
    /// * "sneakers" will use a synonym of "shoes".
    /// * "shoes" will use a synonym of "sneakers".
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TwowaySynonymsAction {
        /// Defines a set of synonyms.
        /// Can specify up to 100 synonyms.
        /// Must specify at least 2 synonyms.
        pub synonyms: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TwowaySynonymsAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [synonyms][crate::model::rule::TwowaySynonymsAction::synonyms].
        pub fn set_synonyms<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.synonyms = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for TwowaySynonymsAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.Rule.TwowaySynonymsAction"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TwowaySynonymsAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __synonyms,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TwowaySynonymsAction")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "synonyms" => Ok(__FieldTag::__synonyms),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TwowaySynonymsAction;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TwowaySynonymsAction")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__synonyms => {
                                if !fields.insert(__FieldTag::__synonyms) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for synonyms",
                                    ));
                                }
                                result.synonyms = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TwowaySynonymsAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.synonyms.is_empty() {
                state.serialize_entry("synonyms", &self.synonyms)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for TwowaySynonymsAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("TwowaySynonymsAction");
            debug_struct.field("synonyms", &self.synonyms);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Maps a set of terms to a set of synonyms.
    /// Set of synonyms will be treated as synonyms of each query term only.
    /// `query_terms` will not be treated as synonyms of each other.
    /// Example: "sneakers" will use a synonym of "shoes".
    /// "shoes" will not use a synonym of "sneakers".
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct OnewaySynonymsAction {
        /// Terms from the search query.
        /// Will treat synonyms as their synonyms.
        /// Not themselves synonyms of the synonyms.
        /// Can specify up to 100 terms.
        pub query_terms: std::vec::Vec<std::string::String>,

        /// Defines a set of synonyms.
        /// Cannot contain duplicates.
        /// Can specify up to 100 synonyms.
        pub synonyms: std::vec::Vec<std::string::String>,

        /// Will be [deprecated = true] post migration;
        pub oneway_terms: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl OnewaySynonymsAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [query_terms][crate::model::rule::OnewaySynonymsAction::query_terms].
        pub fn set_query_terms<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.query_terms = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [synonyms][crate::model::rule::OnewaySynonymsAction::synonyms].
        pub fn set_synonyms<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.synonyms = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [oneway_terms][crate::model::rule::OnewaySynonymsAction::oneway_terms].
        pub fn set_oneway_terms<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.oneway_terms = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for OnewaySynonymsAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.Rule.OnewaySynonymsAction"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for OnewaySynonymsAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __query_terms,
                __synonyms,
                __oneway_terms,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for OnewaySynonymsAction")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "queryTerms" => Ok(__FieldTag::__query_terms),
                                "query_terms" => Ok(__FieldTag::__query_terms),
                                "synonyms" => Ok(__FieldTag::__synonyms),
                                "onewayTerms" => Ok(__FieldTag::__oneway_terms),
                                "oneway_terms" => Ok(__FieldTag::__oneway_terms),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = OnewaySynonymsAction;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct OnewaySynonymsAction")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__query_terms => {
                                if !fields.insert(__FieldTag::__query_terms) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for query_terms",
                                    ));
                                }
                                result.query_terms = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__synonyms => {
                                if !fields.insert(__FieldTag::__synonyms) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for synonyms",
                                    ));
                                }
                                result.synonyms = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__oneway_terms => {
                                if !fields.insert(__FieldTag::__oneway_terms) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for oneway_terms",
                                    ));
                                }
                                result.oneway_terms = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for OnewaySynonymsAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.query_terms.is_empty() {
                state.serialize_entry("queryTerms", &self.query_terms)?;
            }
            if !self.synonyms.is_empty() {
                state.serialize_entry("synonyms", &self.synonyms)?;
            }
            if !self.oneway_terms.is_empty() {
                state.serialize_entry("onewayTerms", &self.oneway_terms)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for OnewaySynonymsAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("OnewaySynonymsAction");
            debug_struct.field("query_terms", &self.query_terms);
            debug_struct.field("synonyms", &self.synonyms);
            debug_struct.field("oneway_terms", &self.oneway_terms);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Prevents `query_term` from being associated with specified terms during
    /// search.
    /// Example: Don't associate "gShoe" and "cheap".
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DoNotAssociateAction {
        /// Terms from the search query.
        /// Will not consider do_not_associate_terms for search if in search query.
        /// Can specify up to 100 terms.
        pub query_terms: std::vec::Vec<std::string::String>,

        /// Cannot contain duplicates or the query term.
        /// Can specify up to 100 terms.
        pub do_not_associate_terms: std::vec::Vec<std::string::String>,

        /// Will be [deprecated = true] post migration;
        pub terms: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DoNotAssociateAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [query_terms][crate::model::rule::DoNotAssociateAction::query_terms].
        pub fn set_query_terms<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.query_terms = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [do_not_associate_terms][crate::model::rule::DoNotAssociateAction::do_not_associate_terms].
        pub fn set_do_not_associate_terms<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.do_not_associate_terms = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [terms][crate::model::rule::DoNotAssociateAction::terms].
        pub fn set_terms<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.terms = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for DoNotAssociateAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.Rule.DoNotAssociateAction"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DoNotAssociateAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __query_terms,
                __do_not_associate_terms,
                __terms,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DoNotAssociateAction")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "queryTerms" => Ok(__FieldTag::__query_terms),
                                "query_terms" => Ok(__FieldTag::__query_terms),
                                "doNotAssociateTerms" => Ok(__FieldTag::__do_not_associate_terms),
                                "do_not_associate_terms" => {
                                    Ok(__FieldTag::__do_not_associate_terms)
                                }
                                "terms" => Ok(__FieldTag::__terms),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DoNotAssociateAction;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DoNotAssociateAction")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__query_terms => {
                                if !fields.insert(__FieldTag::__query_terms) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for query_terms",
                                    ));
                                }
                                result.query_terms = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__do_not_associate_terms => {
                                if !fields.insert(__FieldTag::__do_not_associate_terms) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for do_not_associate_terms",
                                    ));
                                }
                                result.do_not_associate_terms = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__terms => {
                                if !fields.insert(__FieldTag::__terms) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for terms",
                                    ));
                                }
                                result.terms = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DoNotAssociateAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.query_terms.is_empty() {
                state.serialize_entry("queryTerms", &self.query_terms)?;
            }
            if !self.do_not_associate_terms.is_empty() {
                state.serialize_entry("doNotAssociateTerms", &self.do_not_associate_terms)?;
            }
            if !self.terms.is_empty() {
                state.serialize_entry("terms", &self.terms)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for DoNotAssociateAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("DoNotAssociateAction");
            debug_struct.field("query_terms", &self.query_terms);
            debug_struct.field("do_not_associate_terms", &self.do_not_associate_terms);
            debug_struct.field("terms", &self.terms);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Replaces a term in the query. Multiple replacement candidates can be
    /// specified. All `query_terms` will be replaced with the replacement term.
    /// Example: Replace "gShoe" with "google shoe".
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ReplacementAction {
        /// Terms from the search query.
        /// Will be replaced by replacement term.
        /// Can specify up to 100 terms.
        pub query_terms: std::vec::Vec<std::string::String>,

        /// Term that will be used for replacement.
        pub replacement_term: std::string::String,

        /// Will be [deprecated = true] post migration;
        pub term: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ReplacementAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [query_terms][crate::model::rule::ReplacementAction::query_terms].
        pub fn set_query_terms<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.query_terms = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [replacement_term][crate::model::rule::ReplacementAction::replacement_term].
        pub fn set_replacement_term<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.replacement_term = v.into();
            self
        }

        /// Sets the value of [term][crate::model::rule::ReplacementAction::term].
        pub fn set_term<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.term = v.into();
            self
        }
    }

    impl wkt::message::Message for ReplacementAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.Rule.ReplacementAction"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ReplacementAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __query_terms,
                __replacement_term,
                __term,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ReplacementAction")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "queryTerms" => Ok(__FieldTag::__query_terms),
                                "query_terms" => Ok(__FieldTag::__query_terms),
                                "replacementTerm" => Ok(__FieldTag::__replacement_term),
                                "replacement_term" => Ok(__FieldTag::__replacement_term),
                                "term" => Ok(__FieldTag::__term),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ReplacementAction;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ReplacementAction")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__query_terms => {
                                if !fields.insert(__FieldTag::__query_terms) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for query_terms",
                                    ));
                                }
                                result.query_terms = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__replacement_term => {
                                if !fields.insert(__FieldTag::__replacement_term) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for replacement_term",
                                    ));
                                }
                                result.replacement_term = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__term => {
                                if !fields.insert(__FieldTag::__term) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for term",
                                    ));
                                }
                                result.term = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ReplacementAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.query_terms.is_empty() {
                state.serialize_entry("queryTerms", &self.query_terms)?;
            }
            if !self.replacement_term.is_empty() {
                state.serialize_entry("replacementTerm", &self.replacement_term)?;
            }
            if !self.term.is_empty() {
                state.serialize_entry("term", &self.term)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ReplacementAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ReplacementAction");
            debug_struct.field("query_terms", &self.query_terms);
            debug_struct.field("replacement_term", &self.replacement_term);
            debug_struct.field("term", &self.term);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Prevents a term in the query from being used in search.
    /// Example: Don't search for "shoddy".
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IgnoreAction {
        /// Terms to ignore in the search query.
        pub ignore_terms: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IgnoreAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ignore_terms][crate::model::rule::IgnoreAction::ignore_terms].
        pub fn set_ignore_terms<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.ignore_terms = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for IgnoreAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.Rule.IgnoreAction"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IgnoreAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __ignore_terms,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IgnoreAction")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "ignoreTerms" => Ok(__FieldTag::__ignore_terms),
                                "ignore_terms" => Ok(__FieldTag::__ignore_terms),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IgnoreAction;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IgnoreAction")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__ignore_terms => {
                                if !fields.insert(__FieldTag::__ignore_terms) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ignore_terms",
                                    ));
                                }
                                result.ignore_terms = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IgnoreAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.ignore_terms.is_empty() {
                state.serialize_entry("ignoreTerms", &self.ignore_terms)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for IgnoreAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("IgnoreAction");
            debug_struct.field("ignore_terms", &self.ignore_terms);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Force returns an attribute/facet in the request around a certain position
    /// or above.
    ///
    /// * Rule Condition:
    ///   Must specify non-empty
    ///   [Condition.query_terms][google.cloud.retail.v2.Condition.query_terms]
    ///   (for search only) or
    ///   [Condition.page_categories][google.cloud.retail.v2.Condition.page_categories]
    ///   (for browse only), but can't specify both.
    ///
    /// * Action Inputs: attribute name, position
    ///
    /// * Action Result: Will force return a facet key around a certain position
    ///   or above if the condition is satisfied.
    ///
    ///
    /// Example: Suppose the query is "shoes", the
    /// [Condition.query_terms][google.cloud.retail.v2.Condition.query_terms] is
    /// "shoes", the
    /// [ForceReturnFacetAction.FacetPositionAdjustment.attribute_name][google.cloud.retail.v2.Rule.ForceReturnFacetAction.FacetPositionAdjustment.attribute_name]
    /// is "size" and the
    /// [ForceReturnFacetAction.FacetPositionAdjustment.position][google.cloud.retail.v2.Rule.ForceReturnFacetAction.FacetPositionAdjustment.position]
    /// is 8.
    ///
    /// Two cases: a) The facet key "size" is not already in the top 8 slots, then
    /// the facet "size" will appear at a position close to 8. b) The facet key
    /// "size" in among the top 8 positions in the request, then it will stay at
    /// its current rank.
    ///
    /// [google.cloud.retail.v2.Condition.page_categories]: crate::model::Condition::page_categories
    /// [google.cloud.retail.v2.Condition.query_terms]: crate::model::Condition::query_terms
    /// [google.cloud.retail.v2.Rule.ForceReturnFacetAction.FacetPositionAdjustment.attribute_name]: crate::model::rule::force_return_facet_action::FacetPositionAdjustment::attribute_name
    /// [google.cloud.retail.v2.Rule.ForceReturnFacetAction.FacetPositionAdjustment.position]: crate::model::rule::force_return_facet_action::FacetPositionAdjustment::position
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ForceReturnFacetAction {
        /// Each instance corresponds to a force return attribute for the given
        /// condition. There can't be more 15 instances here.
        pub facet_position_adjustments:
            std::vec::Vec<crate::model::rule::force_return_facet_action::FacetPositionAdjustment>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ForceReturnFacetAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [facet_position_adjustments][crate::model::rule::ForceReturnFacetAction::facet_position_adjustments].
        pub fn set_facet_position_adjustments<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::rule::force_return_facet_action::FacetPositionAdjustment,
                >,
        {
            use std::iter::Iterator;
            self.facet_position_adjustments = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ForceReturnFacetAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.Rule.ForceReturnFacetAction"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ForceReturnFacetAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __facet_position_adjustments,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ForceReturnFacetAction")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "facetPositionAdjustments" => {
                                    Ok(__FieldTag::__facet_position_adjustments)
                                }
                                "facet_position_adjustments" => {
                                    Ok(__FieldTag::__facet_position_adjustments)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ForceReturnFacetAction;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ForceReturnFacetAction")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__facet_position_adjustments => {
                                if !fields.insert(__FieldTag::__facet_position_adjustments) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for facet_position_adjustments",
                                    ));
                                }
                                result.facet_position_adjustments = map.next_value::<std::option::Option<std::vec::Vec<crate::model::rule::force_return_facet_action::FacetPositionAdjustment>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ForceReturnFacetAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.facet_position_adjustments.is_empty() {
                state.serialize_entry(
                    "facetPositionAdjustments",
                    &self.facet_position_adjustments,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ForceReturnFacetAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ForceReturnFacetAction");
            debug_struct.field(
                "facet_position_adjustments",
                &self.facet_position_adjustments,
            );
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [ForceReturnFacetAction].
    pub mod force_return_facet_action {
        #[allow(unused_imports)]
        use super::*;

        /// Each facet position adjustment consists of a single attribute name (i.e.
        /// facet key) along with a specified position.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct FacetPositionAdjustment {
            /// The attribute name to force return as a facet. Each attribute name
            /// should be a valid attribute name, be non-empty and contain at most 80
            /// characters long.
            pub attribute_name: std::string::String,

            /// This is the position in the request as explained above. It should be
            /// strictly positive be at most 100.
            pub position: i32,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl FacetPositionAdjustment {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [attribute_name][crate::model::rule::force_return_facet_action::FacetPositionAdjustment::attribute_name].
            pub fn set_attribute_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.attribute_name = v.into();
                self
            }

            /// Sets the value of [position][crate::model::rule::force_return_facet_action::FacetPositionAdjustment::position].
            pub fn set_position<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.position = v.into();
                self
            }
        }

        impl wkt::message::Message for FacetPositionAdjustment {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.retail.v2.Rule.ForceReturnFacetAction.FacetPositionAdjustment"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for FacetPositionAdjustment {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __attribute_name,
                    __position,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for FacetPositionAdjustment")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "attributeName" => Ok(__FieldTag::__attribute_name),
                                    "attribute_name" => Ok(__FieldTag::__attribute_name),
                                    "position" => Ok(__FieldTag::__position),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = FacetPositionAdjustment;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct FacetPositionAdjustment")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__attribute_name => {
                                    if !fields.insert(__FieldTag::__attribute_name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for attribute_name",
                                            ),
                                        );
                                    }
                                    result.attribute_name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__position => {
                                    if !fields.insert(__FieldTag::__position) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for position",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.position =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for FacetPositionAdjustment {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.attribute_name.is_empty() {
                    state.serialize_entry("attributeName", &self.attribute_name)?;
                }
                if !wkt::internal::is_default(&self.position) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("position", &__With(&self.position))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for FacetPositionAdjustment {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("FacetPositionAdjustment");
                debug_struct.field("attribute_name", &self.attribute_name);
                debug_struct.field("position", &self.position);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    /// Removes an attribute/facet in the request if is present.
    ///
    /// * Rule Condition:
    ///   Must specify non-empty
    ///   [Condition.query_terms][google.cloud.retail.v2.Condition.query_terms]
    ///   (for search only) or
    ///   [Condition.page_categories][google.cloud.retail.v2.Condition.page_categories]
    ///   (for browse only), but can't specify both.
    ///
    /// * Action Input: attribute name
    ///
    /// * Action Result: Will remove the attribute (as a facet) from the request
    ///   if it is present.
    ///
    ///
    /// Example: Suppose the query is "shoes", the
    /// [Condition.query_terms][google.cloud.retail.v2.Condition.query_terms] is
    /// "shoes" and the attribute name "size", then facet key "size" will be
    /// removed from the request (if it is present).
    ///
    /// [google.cloud.retail.v2.Condition.page_categories]: crate::model::Condition::page_categories
    /// [google.cloud.retail.v2.Condition.query_terms]: crate::model::Condition::query_terms
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RemoveFacetAction {
        /// The attribute names (i.e. facet keys) to remove from the dynamic facets
        /// (if present in the request). There can't be more 3 attribute names.
        /// Each attribute name should be a valid attribute name, be non-empty and
        /// contain at most 80 characters.
        pub attribute_names: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RemoveFacetAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [attribute_names][crate::model::rule::RemoveFacetAction::attribute_names].
        pub fn set_attribute_names<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.attribute_names = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for RemoveFacetAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.Rule.RemoveFacetAction"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RemoveFacetAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __attribute_names,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RemoveFacetAction")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "attributeNames" => Ok(__FieldTag::__attribute_names),
                                "attribute_names" => Ok(__FieldTag::__attribute_names),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RemoveFacetAction;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RemoveFacetAction")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__attribute_names => {
                                if !fields.insert(__FieldTag::__attribute_names) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for attribute_names",
                                    ));
                                }
                                result.attribute_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RemoveFacetAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.attribute_names.is_empty() {
                state.serialize_entry("attributeNames", &self.attribute_names)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for RemoveFacetAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("RemoveFacetAction");
            debug_struct.field("attribute_names", &self.attribute_names);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Pins one or more specified products to a specific position in the
    /// results.
    ///
    /// * Rule Condition:
    ///   Must specify non-empty
    ///   [Condition.query_terms][google.cloud.retail.v2.Condition.query_terms]
    ///   (for search only) or
    ///   [Condition.page_categories][google.cloud.retail.v2.Condition.page_categories]
    ///   (for browse only), but can't specify both.
    ///
    /// * Action Input: mapping of `[pin_position, product_id]` pairs (pin position
    ///   uses 1-based indexing).
    ///
    /// * Action Result: Will pin products with matching ids to the position
    ///   specified in the final result order.
    ///
    ///
    /// Example: Suppose the query is `shoes`, the
    /// [Condition.query_terms][google.cloud.retail.v2.Condition.query_terms] is
    /// `shoes` and the pin_map has `{1, "pid1"}`, then product with `pid1` will be
    /// pinned to the top position in the final results.
    ///
    /// If multiple PinActions are matched to a single request the actions will
    /// be processed from most to least recently updated.
    ///
    /// Pins to positions larger than the max allowed page size of 120 are not
    /// allowed.
    ///
    /// [google.cloud.retail.v2.Condition.page_categories]: crate::model::Condition::page_categories
    /// [google.cloud.retail.v2.Condition.query_terms]: crate::model::Condition::query_terms
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PinAction {
        /// Required. A map of positions to product_ids.
        ///
        /// Partial matches per action are allowed, if a certain position in the map
        /// is already filled that `[position, product_id]` pair will be ignored
        /// but the rest may still be applied. This case will only occur if multiple
        /// pin actions are matched to a single request, as the map guarantees that
        /// pin positions are unique within the same action.
        ///
        /// Duplicate product_ids are not permitted within a single pin map.
        ///
        /// The max size of this map is 120, equivalent to the max [request page
        /// size](https://cloud.google.com/retail/docs/reference/rest/v2/projects.locations.catalogs.placements/search#request-body).
        pub pin_map: std::collections::HashMap<i64, std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PinAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [pin_map][crate::model::rule::PinAction::pin_map].
        pub fn set_pin_map<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<i64>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.pin_map = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for PinAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.Rule.PinAction"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PinAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __pin_map,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PinAction")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "pinMap" => Ok(__FieldTag::__pin_map),
                                "pin_map" => Ok(__FieldTag::__pin_map),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PinAction;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PinAction")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__pin_map => {
                                if !fields.insert(__FieldTag::__pin_map) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for pin_map",
                                    ));
                                }
                                struct __With(
                                    std::option::Option<
                                        std::collections::HashMap<i64, std::string::String>,
                                    >,
                                );
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<
                                                std::collections::HashMap<
                                                    wkt::internal::I64,
                                                    serde_with::Same,
                                                >,
                                            >,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.pin_map = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PinAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.pin_map.is_empty() {
                struct __With<'a>(&'a std::collections::HashMap<i64, std::string::String>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<
                            std::collections::HashMap<wkt::internal::I64, serde_with::Same>,
                        >::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("pinMap", &__With(&self.pin_map))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PinAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PinAction");
            debug_struct.field("pin_map", &self.pin_map);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// An action must be provided.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Action {
        /// A boost action.
        BoostAction(std::boxed::Box<crate::model::rule::BoostAction>),
        /// Redirects a shopper to a specific page.
        RedirectAction(std::boxed::Box<crate::model::rule::RedirectAction>),
        /// Treats specific term as a synonym with a group of terms.
        /// Group of terms will not be treated as synonyms with the specific term.
        OnewaySynonymsAction(std::boxed::Box<crate::model::rule::OnewaySynonymsAction>),
        /// Prevents term from being associated with other terms.
        DoNotAssociateAction(std::boxed::Box<crate::model::rule::DoNotAssociateAction>),
        /// Replaces specific terms in the query.
        ReplacementAction(std::boxed::Box<crate::model::rule::ReplacementAction>),
        /// Ignores specific terms from query during search.
        IgnoreAction(std::boxed::Box<crate::model::rule::IgnoreAction>),
        /// Filters results.
        FilterAction(std::boxed::Box<crate::model::rule::FilterAction>),
        /// Treats a set of terms as synonyms of one another.
        TwowaySynonymsAction(std::boxed::Box<crate::model::rule::TwowaySynonymsAction>),
        /// Force returns an attribute as a facet in the request.
        ForceReturnFacetAction(std::boxed::Box<crate::model::rule::ForceReturnFacetAction>),
        /// Remove an attribute as a facet in the request (if present).
        RemoveFacetAction(std::boxed::Box<crate::model::rule::RemoveFacetAction>),
        /// Pins one or more specified products to a specific position in the
        /// results.
        PinAction(std::boxed::Box<crate::model::rule::PinAction>),
    }
}

/// An intended audience of the [Product][google.cloud.retail.v2.Product] for
/// whom it's sold.
///
/// [google.cloud.retail.v2.Product]: crate::model::Product
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Audience {
    /// The genders of the audience. Strongly encouraged to use the standard
    /// values: "male", "female", "unisex".
    ///
    /// At most 5 values are allowed. Each value must be a UTF-8 encoded string
    /// with a length limit of 128 characters. Otherwise, an INVALID_ARGUMENT error
    /// is returned.
    ///
    /// Google Merchant Center property
    /// [gender](https://support.google.com/merchants/answer/6324479). Schema.org
    /// property
    /// [Product.audience.suggestedGender](https://schema.org/suggestedGender).
    pub genders: std::vec::Vec<std::string::String>,

    /// The age groups of the audience. Strongly encouraged to use the standard
    /// values: "newborn" (up to 3 months old), "infant" (312 months old),
    /// "toddler" (15 years old), "kids" (513 years old), "adult" (typically
    /// teens or older).
    ///
    /// At most 5 values are allowed. Each value must be a UTF-8 encoded string
    /// with a length limit of 128 characters. Otherwise, an INVALID_ARGUMENT error
    /// is returned.
    ///
    /// Google Merchant Center property
    /// [age_group](https://support.google.com/merchants/answer/6324463).
    /// Schema.org property
    /// [Product.audience.suggestedMinAge](https://schema.org/suggestedMinAge) and
    /// [Product.audience.suggestedMaxAge](https://schema.org/suggestedMaxAge).
    pub age_groups: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Audience {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [genders][crate::model::Audience::genders].
    pub fn set_genders<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.genders = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [age_groups][crate::model::Audience::age_groups].
    pub fn set_age_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.age_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Audience {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.Audience"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Audience {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __genders,
            __age_groups,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Audience")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "genders" => Ok(__FieldTag::__genders),
                            "ageGroups" => Ok(__FieldTag::__age_groups),
                            "age_groups" => Ok(__FieldTag::__age_groups),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Audience;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Audience")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__genders => {
                            if !fields.insert(__FieldTag::__genders) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for genders",
                                ));
                            }
                            result.genders = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__age_groups => {
                            if !fields.insert(__FieldTag::__age_groups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for age_groups",
                                ));
                            }
                            result.age_groups = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Audience {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.genders.is_empty() {
            state.serialize_entry("genders", &self.genders)?;
        }
        if !self.age_groups.is_empty() {
            state.serialize_entry("ageGroups", &self.age_groups)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Audience {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Audience");
        debug_struct.field("genders", &self.genders);
        debug_struct.field("age_groups", &self.age_groups);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The color information of a [Product][google.cloud.retail.v2.Product].
///
/// [google.cloud.retail.v2.Product]: crate::model::Product
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ColorInfo {
    /// The standard color families. Strongly recommended to use the following
    /// standard color groups: "Red", "Pink", "Orange", "Yellow", "Purple",
    /// "Green", "Cyan", "Blue", "Brown", "White", "Gray", "Black" and "Mixed".
    /// Normally it is expected to have only 1 color family. May consider using
    /// single "Mixed" instead of multiple values.
    ///
    /// A maximum of 5 values are allowed. Each value must be a UTF-8 encoded
    /// string with a length limit of 128 characters. Otherwise, an
    /// INVALID_ARGUMENT error is returned.
    ///
    /// Google Merchant Center property
    /// [color](https://support.google.com/merchants/answer/6324487). Schema.org
    /// property [Product.color](https://schema.org/color).
    ///
    /// The colorFamilies field as a system attribute is not a required field but
    /// strongly recommended to be specified. Google Search models treat this field
    /// as more important than a custom product attribute when specified.
    pub color_families: std::vec::Vec<std::string::String>,

    /// The color display names, which may be different from standard color family
    /// names, such as the color aliases used in the website frontend. Normally
    /// it is expected to have only 1 color. May consider using single "Mixed"
    /// instead of multiple values.
    ///
    /// A maximum of 75 colors are allowed. Each value must be a UTF-8 encoded
    /// string with a length limit of 128 characters. Otherwise, an
    /// INVALID_ARGUMENT error is returned.
    ///
    /// Google Merchant Center property
    /// [color](https://support.google.com/merchants/answer/6324487). Schema.org
    /// property [Product.color](https://schema.org/color).
    pub colors: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ColorInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [color_families][crate::model::ColorInfo::color_families].
    pub fn set_color_families<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.color_families = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [colors][crate::model::ColorInfo::colors].
    pub fn set_colors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.colors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ColorInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ColorInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ColorInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __color_families,
            __colors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ColorInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "colorFamilies" => Ok(__FieldTag::__color_families),
                            "color_families" => Ok(__FieldTag::__color_families),
                            "colors" => Ok(__FieldTag::__colors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ColorInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ColorInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__color_families => {
                            if !fields.insert(__FieldTag::__color_families) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for color_families",
                                ));
                            }
                            result.color_families = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__colors => {
                            if !fields.insert(__FieldTag::__colors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for colors",
                                ));
                            }
                            result.colors = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ColorInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.color_families.is_empty() {
            state.serialize_entry("colorFamilies", &self.color_families)?;
        }
        if !self.colors.is_empty() {
            state.serialize_entry("colors", &self.colors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ColorInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ColorInfo");
        debug_struct.field("color_families", &self.color_families);
        debug_struct.field("colors", &self.colors);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A custom attribute that is not explicitly modeled in
/// [Product][google.cloud.retail.v2.Product].
///
/// [google.cloud.retail.v2.Product]: crate::model::Product
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomAttribute {
    /// The textual values of this custom attribute. For example, `["yellow",
    /// "green"]` when the key is "color".
    ///
    /// Empty string is not allowed. Otherwise, an INVALID_ARGUMENT error is
    /// returned.
    ///
    /// Exactly one of [text][google.cloud.retail.v2.CustomAttribute.text] or
    /// [numbers][google.cloud.retail.v2.CustomAttribute.numbers] should be set.
    /// Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// [google.cloud.retail.v2.CustomAttribute.numbers]: crate::model::CustomAttribute::numbers
    /// [google.cloud.retail.v2.CustomAttribute.text]: crate::model::CustomAttribute::text
    pub text: std::vec::Vec<std::string::String>,

    /// The numerical values of this custom attribute. For example, `[2.3, 15.4]`
    /// when the key is "lengths_cm".
    ///
    /// Exactly one of [text][google.cloud.retail.v2.CustomAttribute.text] or
    /// [numbers][google.cloud.retail.v2.CustomAttribute.numbers] should be set.
    /// Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// [google.cloud.retail.v2.CustomAttribute.numbers]: crate::model::CustomAttribute::numbers
    /// [google.cloud.retail.v2.CustomAttribute.text]: crate::model::CustomAttribute::text
    pub numbers: std::vec::Vec<f64>,

    /// This field is normally ignored unless
    /// [AttributesConfig.attribute_config_level][google.cloud.retail.v2.AttributesConfig.attribute_config_level]
    /// of the [Catalog][google.cloud.retail.v2.Catalog] is set to the deprecated
    /// 'PRODUCT_LEVEL_ATTRIBUTE_CONFIG' mode. For information about product-level
    /// attribute configuration, see [Configuration
    /// modes](https://cloud.google.com/retail/docs/attribute-config#config-modes).
    /// If true, custom attribute values are searchable by text queries in
    /// [SearchService.Search][google.cloud.retail.v2.SearchService.Search].
    ///
    /// This field is ignored in a [UserEvent][google.cloud.retail.v2.UserEvent].
    ///
    /// Only set if type [text][google.cloud.retail.v2.CustomAttribute.text] is
    /// set. Otherwise, a INVALID_ARGUMENT error is returned.
    ///
    /// [google.cloud.retail.v2.AttributesConfig.attribute_config_level]: crate::model::AttributesConfig::attribute_config_level
    /// [google.cloud.retail.v2.Catalog]: crate::model::Catalog
    /// [google.cloud.retail.v2.CustomAttribute.text]: crate::model::CustomAttribute::text
    /// [google.cloud.retail.v2.SearchService.Search]: crate::client::SearchService::search
    /// [google.cloud.retail.v2.UserEvent]: crate::model::UserEvent
    #[deprecated]
    pub searchable: std::option::Option<bool>,

    /// This field is normally ignored unless
    /// [AttributesConfig.attribute_config_level][google.cloud.retail.v2.AttributesConfig.attribute_config_level]
    /// of the [Catalog][google.cloud.retail.v2.Catalog] is set to the deprecated
    /// 'PRODUCT_LEVEL_ATTRIBUTE_CONFIG' mode. For information about product-level
    /// attribute configuration, see [Configuration
    /// modes](https://cloud.google.com/retail/docs/attribute-config#config-modes).
    /// If true, custom attribute values are indexed, so that they can be filtered,
    /// faceted or boosted in
    /// [SearchService.Search][google.cloud.retail.v2.SearchService.Search].
    ///
    /// This field is ignored in a [UserEvent][google.cloud.retail.v2.UserEvent].
    ///
    /// See [SearchRequest.filter][google.cloud.retail.v2.SearchRequest.filter],
    /// [SearchRequest.facet_specs][google.cloud.retail.v2.SearchRequest.facet_specs]
    /// and
    /// [SearchRequest.boost_spec][google.cloud.retail.v2.SearchRequest.boost_spec]
    /// for more details.
    ///
    /// [google.cloud.retail.v2.AttributesConfig.attribute_config_level]: crate::model::AttributesConfig::attribute_config_level
    /// [google.cloud.retail.v2.Catalog]: crate::model::Catalog
    /// [google.cloud.retail.v2.SearchRequest.boost_spec]: crate::model::SearchRequest::boost_spec
    /// [google.cloud.retail.v2.SearchRequest.facet_specs]: crate::model::SearchRequest::facet_specs
    /// [google.cloud.retail.v2.SearchRequest.filter]: crate::model::SearchRequest::filter
    /// [google.cloud.retail.v2.SearchService.Search]: crate::client::SearchService::search
    /// [google.cloud.retail.v2.UserEvent]: crate::model::UserEvent
    #[deprecated]
    pub indexable: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomAttribute {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [text][crate::model::CustomAttribute::text].
    pub fn set_text<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.text = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [numbers][crate::model::CustomAttribute::numbers].
    pub fn set_numbers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<f64>,
    {
        use std::iter::Iterator;
        self.numbers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [searchable][crate::model::CustomAttribute::searchable].
    #[deprecated]
    pub fn set_searchable<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.searchable = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [searchable][crate::model::CustomAttribute::searchable].
    #[deprecated]
    pub fn set_or_clear_searchable<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.searchable = v.map(|x| x.into());
        self
    }

    /// Sets the value of [indexable][crate::model::CustomAttribute::indexable].
    #[deprecated]
    pub fn set_indexable<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.indexable = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [indexable][crate::model::CustomAttribute::indexable].
    #[deprecated]
    pub fn set_or_clear_indexable<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.indexable = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CustomAttribute {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.CustomAttribute"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CustomAttribute {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __numbers,
            __searchable,
            __indexable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CustomAttribute")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "numbers" => Ok(__FieldTag::__numbers),
                            "searchable" => Ok(__FieldTag::__searchable),
                            "indexable" => Ok(__FieldTag::__indexable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CustomAttribute;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CustomAttribute")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            result.text = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__numbers => {
                            if !fields.insert(__FieldTag::__numbers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for numbers",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<f64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::F64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.numbers = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__searchable => {
                            if !fields.insert(__FieldTag::__searchable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for searchable",
                                ));
                            }
                            result.searchable = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__indexable => {
                            if !fields.insert(__FieldTag::__indexable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for indexable",
                                ));
                            }
                            result.indexable = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CustomAttribute {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self.numbers.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("numbers", &__With(&self.numbers))?;
        }
        if self.searchable.is_some() {
            state.serialize_entry("searchable", &self.searchable)?;
        }
        if self.indexable.is_some() {
            state.serialize_entry("indexable", &self.indexable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CustomAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CustomAttribute");
        debug_struct.field("text", &self.text);
        debug_struct.field("numbers", &self.numbers);
        debug_struct.field("searchable", &self.searchable);
        debug_struct.field("indexable", &self.indexable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Fulfillment information, such as the store IDs for in-store pickup or region
/// IDs for different shipping methods.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FulfillmentInfo {
    /// The fulfillment type, including commonly used types (such as pickup in
    /// store and same day delivery), and custom types. Customers have to map
    /// custom types to their display names before rendering UI.
    ///
    /// Supported values:
    ///
    /// * "pickup-in-store"
    /// * "ship-to-store"
    /// * "same-day-delivery"
    /// * "next-day-delivery"
    /// * "custom-type-1"
    /// * "custom-type-2"
    /// * "custom-type-3"
    /// * "custom-type-4"
    /// * "custom-type-5"
    ///
    /// If this field is set to an invalid value other than these, an
    /// INVALID_ARGUMENT error is returned.
    pub r#type: std::string::String,

    /// The IDs for this [type][google.cloud.retail.v2.FulfillmentInfo.type], such
    /// as the store IDs for
    /// [FulfillmentInfo.type.pickup-in-store][google.cloud.retail.v2.FulfillmentInfo.type]
    /// or the region IDs for
    /// [FulfillmentInfo.type.same-day-delivery][google.cloud.retail.v2.FulfillmentInfo.type].
    ///
    /// A maximum of 3000 values are allowed. Each value must be a string with a
    /// length limit of 30 characters, matching the pattern `[a-zA-Z0-9_-]+`, such
    /// as "store1" or "REGION-2". Otherwise, an INVALID_ARGUMENT error is
    /// returned.
    ///
    /// [google.cloud.retail.v2.FulfillmentInfo.type]: crate::model::FulfillmentInfo::type
    pub place_ids: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FulfillmentInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::FulfillmentInfo::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [place_ids][crate::model::FulfillmentInfo::place_ids].
    pub fn set_place_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.place_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FulfillmentInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.FulfillmentInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FulfillmentInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __place_ids,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FulfillmentInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "placeIds" => Ok(__FieldTag::__place_ids),
                            "place_ids" => Ok(__FieldTag::__place_ids),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FulfillmentInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FulfillmentInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__place_ids => {
                            if !fields.insert(__FieldTag::__place_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for place_ids",
                                ));
                            }
                            result.place_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FulfillmentInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.place_ids.is_empty() {
            state.serialize_entry("placeIds", &self.place_ids)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FulfillmentInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FulfillmentInfo");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("place_ids", &self.place_ids);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// [Product][google.cloud.retail.v2.Product] image. Recommendations AI and
/// Retail Search use product images to improve prediction and search results.
/// Product images can be returned in results, and are shown in prediction or
/// search previews in the console. Please try to provide correct product images
/// and avoid using images with size too small.
///
/// [google.cloud.retail.v2.Product]: crate::model::Product
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Image {
    /// Required. URI of the image.
    ///
    /// This field must be a valid UTF-8 encoded URI with a length limit of 5,000
    /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// Google Merchant Center property
    /// [image_link](https://support.google.com/merchants/answer/6324350).
    /// Schema.org property [Product.image](https://schema.org/image).
    pub uri: std::string::String,

    /// Height of the image in number of pixels.
    ///
    /// This field must be nonnegative. Otherwise, an INVALID_ARGUMENT error is
    /// returned.
    pub height: i32,

    /// Width of the image in number of pixels.
    ///
    /// This field must be nonnegative. Otherwise, an INVALID_ARGUMENT error is
    /// returned.
    pub width: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Image {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::Image::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [height][crate::model::Image::height].
    pub fn set_height<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.height = v.into();
        self
    }

    /// Sets the value of [width][crate::model::Image::width].
    pub fn set_width<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.width = v.into();
        self
    }
}

impl wkt::message::Message for Image {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.Image"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Image {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            __height,
            __width,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Image")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            "height" => Ok(__FieldTag::__height),
                            "width" => Ok(__FieldTag::__width),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Image;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Image")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__height => {
                            if !fields.insert(__FieldTag::__height) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for height",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.height = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__width => {
                            if !fields.insert(__FieldTag::__width) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for width",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.width = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Image {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !wkt::internal::is_default(&self.height) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("height", &__With(&self.height))?;
        }
        if !wkt::internal::is_default(&self.width) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("width", &__With(&self.width))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Image {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Image");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("height", &self.height);
        debug_struct.field("width", &self.width);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A floating point interval.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Interval {
    /// The lower bound of the interval. If neither of the min fields are set, then
    /// the lower bound is negative infinity.
    ///
    /// This field must not be larger than max.
    /// Otherwise, an INVALID_ARGUMENT error is returned.
    pub min: std::option::Option<crate::model::interval::Min>,

    /// The upper bound of the interval. If neither of the max fields are set, then
    /// the upper bound is positive infinity.
    ///
    /// This field must be not smaller than min.
    /// Otherwise, an INVALID_ARGUMENT error is returned.
    pub max: std::option::Option<crate::model::interval::Max>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Interval {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min][crate::model::Interval::min].
    ///
    /// Note that all the setters affecting `min` are mutually
    /// exclusive.
    pub fn set_min<T: std::convert::Into<std::option::Option<crate::model::interval::Min>>>(
        mut self,
        v: T,
    ) -> Self {
        self.min = v.into();
        self
    }

    /// The value of [min][crate::model::Interval::min]
    /// if it holds a `Minimum`, `None` if the field is not set or
    /// holds a different branch.
    pub fn minimum(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.min.as_ref().and_then(|v| match v {
            crate::model::interval::Min::Minimum(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [min][crate::model::Interval::min]
    /// to hold a `Minimum`.
    ///
    /// Note that all the setters affecting `min` are
    /// mutually exclusive.
    pub fn set_minimum<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.min = std::option::Option::Some(crate::model::interval::Min::Minimum(v.into()));
        self
    }

    /// The value of [min][crate::model::Interval::min]
    /// if it holds a `ExclusiveMinimum`, `None` if the field is not set or
    /// holds a different branch.
    pub fn exclusive_minimum(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.min.as_ref().and_then(|v| match v {
            crate::model::interval::Min::ExclusiveMinimum(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [min][crate::model::Interval::min]
    /// to hold a `ExclusiveMinimum`.
    ///
    /// Note that all the setters affecting `min` are
    /// mutually exclusive.
    pub fn set_exclusive_minimum<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.min =
            std::option::Option::Some(crate::model::interval::Min::ExclusiveMinimum(v.into()));
        self
    }

    /// Sets the value of [max][crate::model::Interval::max].
    ///
    /// Note that all the setters affecting `max` are mutually
    /// exclusive.
    pub fn set_max<T: std::convert::Into<std::option::Option<crate::model::interval::Max>>>(
        mut self,
        v: T,
    ) -> Self {
        self.max = v.into();
        self
    }

    /// The value of [max][crate::model::Interval::max]
    /// if it holds a `Maximum`, `None` if the field is not set or
    /// holds a different branch.
    pub fn maximum(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.max.as_ref().and_then(|v| match v {
            crate::model::interval::Max::Maximum(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [max][crate::model::Interval::max]
    /// to hold a `Maximum`.
    ///
    /// Note that all the setters affecting `max` are
    /// mutually exclusive.
    pub fn set_maximum<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.max = std::option::Option::Some(crate::model::interval::Max::Maximum(v.into()));
        self
    }

    /// The value of [max][crate::model::Interval::max]
    /// if it holds a `ExclusiveMaximum`, `None` if the field is not set or
    /// holds a different branch.
    pub fn exclusive_maximum(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.max.as_ref().and_then(|v| match v {
            crate::model::interval::Max::ExclusiveMaximum(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [max][crate::model::Interval::max]
    /// to hold a `ExclusiveMaximum`.
    ///
    /// Note that all the setters affecting `max` are
    /// mutually exclusive.
    pub fn set_exclusive_maximum<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.max =
            std::option::Option::Some(crate::model::interval::Max::ExclusiveMaximum(v.into()));
        self
    }
}

impl wkt::message::Message for Interval {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.Interval"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Interval {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __minimum,
            __exclusive_minimum,
            __maximum,
            __exclusive_maximum,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Interval")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "minimum" => Ok(__FieldTag::__minimum),
                            "exclusiveMinimum" => Ok(__FieldTag::__exclusive_minimum),
                            "exclusive_minimum" => Ok(__FieldTag::__exclusive_minimum),
                            "maximum" => Ok(__FieldTag::__maximum),
                            "exclusiveMaximum" => Ok(__FieldTag::__exclusive_maximum),
                            "exclusive_maximum" => Ok(__FieldTag::__exclusive_maximum),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Interval;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Interval")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__minimum => {
                            if !fields.insert(__FieldTag::__minimum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for minimum",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.min.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `min`, a oneof with full ID .google.cloud.retail.v2.Interval.minimum, latest field was minimum",
                                ));
                            }
                            result.min =
                                std::option::Option::Some(crate::model::interval::Min::Minimum(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__exclusive_minimum => {
                            if !fields.insert(__FieldTag::__exclusive_minimum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclusive_minimum",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.min.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `min`, a oneof with full ID .google.cloud.retail.v2.Interval.exclusive_minimum, latest field was exclusiveMinimum",
                                ));
                            }
                            result.min = std::option::Option::Some(
                                crate::model::interval::Min::ExclusiveMinimum(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__maximum => {
                            if !fields.insert(__FieldTag::__maximum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maximum",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.max.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `max`, a oneof with full ID .google.cloud.retail.v2.Interval.maximum, latest field was maximum",
                                ));
                            }
                            result.max =
                                std::option::Option::Some(crate::model::interval::Max::Maximum(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__exclusive_maximum => {
                            if !fields.insert(__FieldTag::__exclusive_maximum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclusive_maximum",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.max.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `max`, a oneof with full ID .google.cloud.retail.v2.Interval.exclusive_maximum, latest field was exclusiveMaximum",
                                ));
                            }
                            result.max = std::option::Option::Some(
                                crate::model::interval::Max::ExclusiveMaximum(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Interval {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.minimum() {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minimum", &__With(value))?;
        }
        if let Some(value) = self.exclusive_minimum() {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("exclusiveMinimum", &__With(value))?;
        }
        if let Some(value) = self.maximum() {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maximum", &__With(value))?;
        }
        if let Some(value) = self.exclusive_maximum() {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("exclusiveMaximum", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Interval {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Interval");
        debug_struct.field("min", &self.min);
        debug_struct.field("max", &self.max);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Interval].
pub mod interval {
    #[allow(unused_imports)]
    use super::*;

    /// The lower bound of the interval. If neither of the min fields are set, then
    /// the lower bound is negative infinity.
    ///
    /// This field must not be larger than max.
    /// Otherwise, an INVALID_ARGUMENT error is returned.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Min {
        /// Inclusive lower bound.
        Minimum(f64),
        /// Exclusive lower bound.
        ExclusiveMinimum(f64),
    }

    /// The upper bound of the interval. If neither of the max fields are set, then
    /// the upper bound is positive infinity.
    ///
    /// This field must be not smaller than min.
    /// Otherwise, an INVALID_ARGUMENT error is returned.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Max {
        /// Inclusive upper bound.
        Maximum(f64),
        /// Exclusive upper bound.
        ExclusiveMaximum(f64),
    }
}

/// The price information of a [Product][google.cloud.retail.v2.Product].
///
/// [google.cloud.retail.v2.Product]: crate::model::Product
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PriceInfo {
    /// The 3-letter currency code defined in [ISO
    /// 4217](https://www.iso.org/iso-4217-currency-codes.html).
    ///
    /// If this field is an unrecognizable currency code, an INVALID_ARGUMENT
    /// error is returned.
    ///
    /// The [Product.Type.VARIANT][google.cloud.retail.v2.Product.Type.VARIANT]
    /// [Product][google.cloud.retail.v2.Product]s with the same
    /// [Product.primary_product_id][google.cloud.retail.v2.Product.primary_product_id]
    /// must share the same
    /// [currency_code][google.cloud.retail.v2.PriceInfo.currency_code]. Otherwise,
    /// a FAILED_PRECONDITION error is returned.
    ///
    /// [google.cloud.retail.v2.PriceInfo.currency_code]: crate::model::PriceInfo::currency_code
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.Product.Type.VARIANT]: crate::model::product::Type::Variant
    /// [google.cloud.retail.v2.Product.primary_product_id]: crate::model::Product::primary_product_id
    pub currency_code: std::string::String,

    /// Price of the product.
    ///
    /// Google Merchant Center property
    /// [price](https://support.google.com/merchants/answer/6324371). Schema.org
    /// property [Offer.price](https://schema.org/price).
    pub price: f32,

    /// Price of the product without any discount. If zero, by default set to be
    /// the [price][google.cloud.retail.v2.PriceInfo.price]. If set,
    /// [original_price][google.cloud.retail.v2.PriceInfo.original_price] should be
    /// greater than or equal to [price][google.cloud.retail.v2.PriceInfo.price],
    /// otherwise an INVALID_ARGUMENT error is thrown.
    ///
    /// [google.cloud.retail.v2.PriceInfo.original_price]: crate::model::PriceInfo::original_price
    /// [google.cloud.retail.v2.PriceInfo.price]: crate::model::PriceInfo::price
    pub original_price: f32,

    /// The costs associated with the sale of a particular product. Used for gross
    /// profit reporting.
    ///
    /// * Profit = [price][google.cloud.retail.v2.PriceInfo.price] -
    ///   [cost][google.cloud.retail.v2.PriceInfo.cost]
    ///
    /// Google Merchant Center property
    /// [cost_of_goods_sold](https://support.google.com/merchants/answer/9017895).
    ///
    /// [google.cloud.retail.v2.PriceInfo.cost]: crate::model::PriceInfo::cost
    /// [google.cloud.retail.v2.PriceInfo.price]: crate::model::PriceInfo::price
    pub cost: f32,

    /// The timestamp when the [price][google.cloud.retail.v2.PriceInfo.price]
    /// starts to be effective. This can be set as a future timestamp, and the
    /// [price][google.cloud.retail.v2.PriceInfo.price] is only used for search
    /// after
    /// [price_effective_time][google.cloud.retail.v2.PriceInfo.price_effective_time].
    /// If so, the
    /// [original_price][google.cloud.retail.v2.PriceInfo.original_price] must be
    /// set and [original_price][google.cloud.retail.v2.PriceInfo.original_price]
    /// is used before
    /// [price_effective_time][google.cloud.retail.v2.PriceInfo.price_effective_time].
    ///
    /// Do not set if [price][google.cloud.retail.v2.PriceInfo.price] is always
    /// effective because it will cause additional latency during search.
    ///
    /// [google.cloud.retail.v2.PriceInfo.original_price]: crate::model::PriceInfo::original_price
    /// [google.cloud.retail.v2.PriceInfo.price]: crate::model::PriceInfo::price
    /// [google.cloud.retail.v2.PriceInfo.price_effective_time]: crate::model::PriceInfo::price_effective_time
    pub price_effective_time: std::option::Option<wkt::Timestamp>,

    /// The timestamp when the [price][google.cloud.retail.v2.PriceInfo.price]
    /// stops to be effective. The [price][google.cloud.retail.v2.PriceInfo.price]
    /// is used for search before
    /// [price_expire_time][google.cloud.retail.v2.PriceInfo.price_expire_time]. If
    /// this field is set, the
    /// [original_price][google.cloud.retail.v2.PriceInfo.original_price] must be
    /// set and [original_price][google.cloud.retail.v2.PriceInfo.original_price]
    /// is used after
    /// [price_expire_time][google.cloud.retail.v2.PriceInfo.price_expire_time].
    ///
    /// Do not set if [price][google.cloud.retail.v2.PriceInfo.price] is always
    /// effective because it will cause additional latency during search.
    ///
    /// [google.cloud.retail.v2.PriceInfo.original_price]: crate::model::PriceInfo::original_price
    /// [google.cloud.retail.v2.PriceInfo.price]: crate::model::PriceInfo::price
    /// [google.cloud.retail.v2.PriceInfo.price_expire_time]: crate::model::PriceInfo::price_expire_time
    pub price_expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The price range of all the child
    /// [Product.Type.VARIANT][google.cloud.retail.v2.Product.Type.VARIANT]
    /// [Product][google.cloud.retail.v2.Product]s grouped together on the
    /// [Product.Type.PRIMARY][google.cloud.retail.v2.Product.Type.PRIMARY]
    /// [Product][google.cloud.retail.v2.Product]. Only populated for
    /// [Product.Type.PRIMARY][google.cloud.retail.v2.Product.Type.PRIMARY]
    /// [Product][google.cloud.retail.v2.Product]s.
    ///
    /// Note: This field is OUTPUT_ONLY for
    /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct].
    /// Do not set this field in API requests.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.Product.Type.PRIMARY]: crate::model::product::Type::Primary
    /// [google.cloud.retail.v2.Product.Type.VARIANT]: crate::model::product::Type::Variant
    /// [google.cloud.retail.v2.ProductService.GetProduct]: crate::client::ProductService::get_product
    pub price_range: std::option::Option<crate::model::price_info::PriceRange>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PriceInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [currency_code][crate::model::PriceInfo::currency_code].
    pub fn set_currency_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.currency_code = v.into();
        self
    }

    /// Sets the value of [price][crate::model::PriceInfo::price].
    pub fn set_price<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.price = v.into();
        self
    }

    /// Sets the value of [original_price][crate::model::PriceInfo::original_price].
    pub fn set_original_price<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.original_price = v.into();
        self
    }

    /// Sets the value of [cost][crate::model::PriceInfo::cost].
    pub fn set_cost<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.cost = v.into();
        self
    }

    /// Sets the value of [price_effective_time][crate::model::PriceInfo::price_effective_time].
    pub fn set_price_effective_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.price_effective_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [price_effective_time][crate::model::PriceInfo::price_effective_time].
    pub fn set_or_clear_price_effective_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.price_effective_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [price_expire_time][crate::model::PriceInfo::price_expire_time].
    pub fn set_price_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.price_expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [price_expire_time][crate::model::PriceInfo::price_expire_time].
    pub fn set_or_clear_price_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.price_expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [price_range][crate::model::PriceInfo::price_range].
    pub fn set_price_range<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::price_info::PriceRange>,
    {
        self.price_range = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [price_range][crate::model::PriceInfo::price_range].
    pub fn set_or_clear_price_range<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::price_info::PriceRange>,
    {
        self.price_range = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PriceInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.PriceInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PriceInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __currency_code,
            __price,
            __original_price,
            __cost,
            __price_effective_time,
            __price_expire_time,
            __price_range,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PriceInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "currencyCode" => Ok(__FieldTag::__currency_code),
                            "currency_code" => Ok(__FieldTag::__currency_code),
                            "price" => Ok(__FieldTag::__price),
                            "originalPrice" => Ok(__FieldTag::__original_price),
                            "original_price" => Ok(__FieldTag::__original_price),
                            "cost" => Ok(__FieldTag::__cost),
                            "priceEffectiveTime" => Ok(__FieldTag::__price_effective_time),
                            "price_effective_time" => Ok(__FieldTag::__price_effective_time),
                            "priceExpireTime" => Ok(__FieldTag::__price_expire_time),
                            "price_expire_time" => Ok(__FieldTag::__price_expire_time),
                            "priceRange" => Ok(__FieldTag::__price_range),
                            "price_range" => Ok(__FieldTag::__price_range),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PriceInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PriceInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__currency_code => {
                            if !fields.insert(__FieldTag::__currency_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for currency_code",
                                ));
                            }
                            result.currency_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__price => {
                            if !fields.insert(__FieldTag::__price) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for price",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.price = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__original_price => {
                            if !fields.insert(__FieldTag::__original_price) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_price",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.original_price =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cost => {
                            if !fields.insert(__FieldTag::__cost) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cost",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cost = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__price_effective_time => {
                            if !fields.insert(__FieldTag::__price_effective_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for price_effective_time",
                                ));
                            }
                            result.price_effective_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__price_expire_time => {
                            if !fields.insert(__FieldTag::__price_expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for price_expire_time",
                                ));
                            }
                            result.price_expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__price_range => {
                            if !fields.insert(__FieldTag::__price_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for price_range",
                                ));
                            }
                            result.price_range = map.next_value::<std::option::Option<crate::model::price_info::PriceRange>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PriceInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.currency_code.is_empty() {
            state.serialize_entry("currencyCode", &self.currency_code)?;
        }
        if !wkt::internal::is_default(&self.price) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("price", &__With(&self.price))?;
        }
        if !wkt::internal::is_default(&self.original_price) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("originalPrice", &__With(&self.original_price))?;
        }
        if !wkt::internal::is_default(&self.cost) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cost", &__With(&self.cost))?;
        }
        if self.price_effective_time.is_some() {
            state.serialize_entry("priceEffectiveTime", &self.price_effective_time)?;
        }
        if self.price_expire_time.is_some() {
            state.serialize_entry("priceExpireTime", &self.price_expire_time)?;
        }
        if self.price_range.is_some() {
            state.serialize_entry("priceRange", &self.price_range)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PriceInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PriceInfo");
        debug_struct.field("currency_code", &self.currency_code);
        debug_struct.field("price", &self.price);
        debug_struct.field("original_price", &self.original_price);
        debug_struct.field("cost", &self.cost);
        debug_struct.field("price_effective_time", &self.price_effective_time);
        debug_struct.field("price_expire_time", &self.price_expire_time);
        debug_struct.field("price_range", &self.price_range);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PriceInfo].
pub mod price_info {
    #[allow(unused_imports)]
    use super::*;

    /// The price range of all
    /// [variant][google.cloud.retail.v2.Product.Type.VARIANT]
    /// [Product][google.cloud.retail.v2.Product] having the same
    /// [Product.primary_product_id][google.cloud.retail.v2.Product.primary_product_id].
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.Product.Type.VARIANT]: crate::model::product::Type::Variant
    /// [google.cloud.retail.v2.Product.primary_product_id]: crate::model::Product::primary_product_id
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PriceRange {
        /// The inclusive
        /// [Product.pricing_info.price][google.cloud.retail.v2.PriceInfo.price]
        /// interval of all [variant][google.cloud.retail.v2.Product.Type.VARIANT]
        /// [Product][google.cloud.retail.v2.Product] having the same
        /// [Product.primary_product_id][google.cloud.retail.v2.Product.primary_product_id].
        ///
        /// [google.cloud.retail.v2.PriceInfo.price]: crate::model::PriceInfo::price
        /// [google.cloud.retail.v2.Product]: crate::model::Product
        /// [google.cloud.retail.v2.Product.Type.VARIANT]: crate::model::product::Type::Variant
        /// [google.cloud.retail.v2.Product.primary_product_id]: crate::model::Product::primary_product_id
        pub price: std::option::Option<crate::model::Interval>,

        /// The inclusive
        /// [Product.pricing_info.original_price][google.cloud.retail.v2.PriceInfo.original_price]
        /// internal of all [variant][google.cloud.retail.v2.Product.Type.VARIANT]
        /// [Product][google.cloud.retail.v2.Product] having the same
        /// [Product.primary_product_id][google.cloud.retail.v2.Product.primary_product_id].
        ///
        /// [google.cloud.retail.v2.PriceInfo.original_price]: crate::model::PriceInfo::original_price
        /// [google.cloud.retail.v2.Product]: crate::model::Product
        /// [google.cloud.retail.v2.Product.Type.VARIANT]: crate::model::product::Type::Variant
        /// [google.cloud.retail.v2.Product.primary_product_id]: crate::model::Product::primary_product_id
        pub original_price: std::option::Option<crate::model::Interval>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PriceRange {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [price][crate::model::price_info::PriceRange::price].
        pub fn set_price<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Interval>,
        {
            self.price = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [price][crate::model::price_info::PriceRange::price].
        pub fn set_or_clear_price<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Interval>,
        {
            self.price = v.map(|x| x.into());
            self
        }

        /// Sets the value of [original_price][crate::model::price_info::PriceRange::original_price].
        pub fn set_original_price<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Interval>,
        {
            self.original_price = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [original_price][crate::model::price_info::PriceRange::original_price].
        pub fn set_or_clear_original_price<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Interval>,
        {
            self.original_price = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for PriceRange {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.PriceInfo.PriceRange"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PriceRange {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __price,
                __original_price,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PriceRange")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "price" => Ok(__FieldTag::__price),
                                "originalPrice" => Ok(__FieldTag::__original_price),
                                "original_price" => Ok(__FieldTag::__original_price),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PriceRange;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PriceRange")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__price => {
                                if !fields.insert(__FieldTag::__price) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for price",
                                    ));
                                }
                                result.price = map
                                    .next_value::<std::option::Option<crate::model::Interval>>()?;
                            }
                            __FieldTag::__original_price => {
                                if !fields.insert(__FieldTag::__original_price) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for original_price",
                                    ));
                                }
                                result.original_price = map
                                    .next_value::<std::option::Option<crate::model::Interval>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PriceRange {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.price.is_some() {
                state.serialize_entry("price", &self.price)?;
            }
            if self.original_price.is_some() {
                state.serialize_entry("originalPrice", &self.original_price)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PriceRange {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PriceRange");
            debug_struct.field("price", &self.price);
            debug_struct.field("original_price", &self.original_price);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// The rating of a [Product][google.cloud.retail.v2.Product].
///
/// [google.cloud.retail.v2.Product]: crate::model::Product
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Rating {
    /// The total number of ratings. This value is independent of the value of
    /// [rating_histogram][google.cloud.retail.v2.Rating.rating_histogram].
    ///
    /// This value must be nonnegative. Otherwise, an INVALID_ARGUMENT error is
    /// returned.
    ///
    /// [google.cloud.retail.v2.Rating.rating_histogram]: crate::model::Rating::rating_histogram
    pub rating_count: i32,

    /// The average rating of the [Product][google.cloud.retail.v2.Product].
    ///
    /// The rating is scaled at 1-5. Otherwise, an INVALID_ARGUMENT error is
    /// returned.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub average_rating: f32,

    /// List of rating counts per rating value (index = rating - 1). The list is
    /// empty if there is no rating. If the list is non-empty, its size is
    /// always 5. Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// For example, [41, 14, 13, 47, 303]. It means that the
    /// [Product][google.cloud.retail.v2.Product] got 41 ratings with 1 star, 14
    /// ratings with 2 star, and so on.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub rating_histogram: std::vec::Vec<i32>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Rating {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rating_count][crate::model::Rating::rating_count].
    pub fn set_rating_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.rating_count = v.into();
        self
    }

    /// Sets the value of [average_rating][crate::model::Rating::average_rating].
    pub fn set_average_rating<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.average_rating = v.into();
        self
    }

    /// Sets the value of [rating_histogram][crate::model::Rating::rating_histogram].
    pub fn set_rating_histogram<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i32>,
    {
        use std::iter::Iterator;
        self.rating_histogram = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Rating {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.Rating"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Rating {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rating_count,
            __average_rating,
            __rating_histogram,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Rating")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ratingCount" => Ok(__FieldTag::__rating_count),
                            "rating_count" => Ok(__FieldTag::__rating_count),
                            "averageRating" => Ok(__FieldTag::__average_rating),
                            "average_rating" => Ok(__FieldTag::__average_rating),
                            "ratingHistogram" => Ok(__FieldTag::__rating_histogram),
                            "rating_histogram" => Ok(__FieldTag::__rating_histogram),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Rating;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Rating")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rating_count => {
                            if !fields.insert(__FieldTag::__rating_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rating_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.rating_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__average_rating => {
                            if !fields.insert(__FieldTag::__average_rating) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for average_rating",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.average_rating =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__rating_histogram => {
                            if !fields.insert(__FieldTag::__rating_histogram) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rating_histogram",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i32>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.rating_histogram =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Rating {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.rating_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ratingCount", &__With(&self.rating_count))?;
        }
        if !wkt::internal::is_default(&self.average_rating) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("averageRating", &__With(&self.average_rating))?;
        }
        if !self.rating_histogram.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("ratingHistogram", &__With(&self.rating_histogram))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Rating {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Rating");
        debug_struct.field("rating_count", &self.rating_count);
        debug_struct.field("average_rating", &self.average_rating);
        debug_struct.field("rating_histogram", &self.rating_histogram);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Information of an end user.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UserInfo {
    /// Highly recommended for logged-in users. Unique identifier for logged-in
    /// user, such as a user name. Don't set for anonymous users.
    ///
    /// Always use a hashed value for this ID.
    ///
    /// Don't set the field to the same fixed ID for different users. This mixes
    /// the event history of those users together, which results in degraded
    /// model quality.
    ///
    /// The field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
    pub user_id: std::string::String,

    /// The end user's IP address. This field is used to extract location
    /// information for personalization.
    ///
    /// This field must be either an IPv4 address (e.g. "104.133.9.80") or an IPv6
    /// address (e.g. "2001:0db8:85a3:0000:0000:8a2e:0370:7334"). Otherwise, an
    /// INVALID_ARGUMENT error is returned.
    ///
    /// This should not be set when:
    ///
    /// * setting
    ///   [SearchRequest.user_info][google.cloud.retail.v2.SearchRequest.user_info].
    /// * using the JavaScript tag in
    ///   [UserEventService.CollectUserEvent][google.cloud.retail.v2.UserEventService.CollectUserEvent]
    ///   or if
    ///   [direct_user_request][google.cloud.retail.v2.UserInfo.direct_user_request]
    ///   is set.
    ///
    /// [google.cloud.retail.v2.SearchRequest.user_info]: crate::model::SearchRequest::user_info
    /// [google.cloud.retail.v2.UserEventService.CollectUserEvent]: crate::client::UserEventService::collect_user_event
    /// [google.cloud.retail.v2.UserInfo.direct_user_request]: crate::model::UserInfo::direct_user_request
    pub ip_address: std::string::String,

    /// User agent as included in the HTTP header.
    /// The field must be a UTF-8 encoded string with a length limit of 1,000
    /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// This should not be set when using the client side event reporting with
    /// GTM or JavaScript tag in
    /// [UserEventService.CollectUserEvent][google.cloud.retail.v2.UserEventService.CollectUserEvent]
    /// or if
    /// [direct_user_request][google.cloud.retail.v2.UserInfo.direct_user_request]
    /// is set.
    ///
    /// [google.cloud.retail.v2.UserEventService.CollectUserEvent]: crate::client::UserEventService::collect_user_event
    /// [google.cloud.retail.v2.UserInfo.direct_user_request]: crate::model::UserInfo::direct_user_request
    pub user_agent: std::string::String,

    /// True if the request is made directly from the end user, in which case the
    /// [ip_address][google.cloud.retail.v2.UserInfo.ip_address] and
    /// [user_agent][google.cloud.retail.v2.UserInfo.user_agent] can be populated
    /// from the HTTP request. This flag should be set only if the API request is
    /// made directly from the end user such as a mobile app (and not if a gateway
    /// or a server is processing and pushing the user events).
    ///
    /// This should not be set when using the JavaScript tag in
    /// [UserEventService.CollectUserEvent][google.cloud.retail.v2.UserEventService.CollectUserEvent].
    ///
    /// [google.cloud.retail.v2.UserEventService.CollectUserEvent]: crate::client::UserEventService::collect_user_event
    /// [google.cloud.retail.v2.UserInfo.ip_address]: crate::model::UserInfo::ip_address
    /// [google.cloud.retail.v2.UserInfo.user_agent]: crate::model::UserInfo::user_agent
    pub direct_user_request: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_id][crate::model::UserInfo::user_id].
    pub fn set_user_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_id = v.into();
        self
    }

    /// Sets the value of [ip_address][crate::model::UserInfo::ip_address].
    pub fn set_ip_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_address = v.into();
        self
    }

    /// Sets the value of [user_agent][crate::model::UserInfo::user_agent].
    pub fn set_user_agent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_agent = v.into();
        self
    }

    /// Sets the value of [direct_user_request][crate::model::UserInfo::direct_user_request].
    pub fn set_direct_user_request<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.direct_user_request = v.into();
        self
    }
}

impl wkt::message::Message for UserInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.UserInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UserInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __user_id,
            __ip_address,
            __user_agent,
            __direct_user_request,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UserInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "userId" => Ok(__FieldTag::__user_id),
                            "user_id" => Ok(__FieldTag::__user_id),
                            "ipAddress" => Ok(__FieldTag::__ip_address),
                            "ip_address" => Ok(__FieldTag::__ip_address),
                            "userAgent" => Ok(__FieldTag::__user_agent),
                            "user_agent" => Ok(__FieldTag::__user_agent),
                            "directUserRequest" => Ok(__FieldTag::__direct_user_request),
                            "direct_user_request" => Ok(__FieldTag::__direct_user_request),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UserInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UserInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__user_id => {
                            if !fields.insert(__FieldTag::__user_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_id",
                                ));
                            }
                            result.user_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ip_address => {
                            if !fields.insert(__FieldTag::__ip_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_address",
                                ));
                            }
                            result.ip_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_agent => {
                            if !fields.insert(__FieldTag::__user_agent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_agent",
                                ));
                            }
                            result.user_agent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__direct_user_request => {
                            if !fields.insert(__FieldTag::__direct_user_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for direct_user_request",
                                ));
                            }
                            result.direct_user_request = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UserInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.user_id.is_empty() {
            state.serialize_entry("userId", &self.user_id)?;
        }
        if !self.ip_address.is_empty() {
            state.serialize_entry("ipAddress", &self.ip_address)?;
        }
        if !self.user_agent.is_empty() {
            state.serialize_entry("userAgent", &self.user_agent)?;
        }
        if !wkt::internal::is_default(&self.direct_user_request) {
            state.serialize_entry("directUserRequest", &self.direct_user_request)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UserInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UserInfo");
        debug_struct.field("user_id", &self.user_id);
        debug_struct.field("ip_address", &self.ip_address);
        debug_struct.field("user_agent", &self.user_agent);
        debug_struct.field("direct_user_request", &self.direct_user_request);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The inventory information at a place (e.g. a store) identified
/// by a place ID.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LocalInventory {
    /// Optional. The place ID for the current set of inventory information.
    pub place_id: std::string::String,

    /// Optional. Product price and cost information.
    ///
    /// Google Merchant Center property
    /// [price](https://support.google.com/merchants/answer/6324371).
    pub price_info: std::option::Option<crate::model::PriceInfo>,

    /// Optional. Additional local inventory attributes, for example, store name,
    /// promotion tags, etc.
    ///
    /// This field needs to pass all below criteria, otherwise an INVALID_ARGUMENT
    /// error is returned:
    ///
    /// * At most 30 attributes are allowed.
    /// * The key must be a UTF-8 encoded string with a length limit of 32
    ///   characters.
    /// * The key must match the pattern: `[a-zA-Z0-9][a-zA-Z0-9_]*`. For example,
    ///   key0LikeThis or KEY_1_LIKE_THIS.
    /// * The attribute values must be of the same type (text or number).
    /// * Only 1 value is allowed for each attribute.
    /// * For text values, the length limit is 256 UTF-8 characters.
    /// * The attribute does not support search. The `searchable` field should be
    ///   unset or set to false.
    /// * The max summed total bytes of custom attribute keys and values per
    ///   product is 5MiB.
    pub attributes: std::collections::HashMap<std::string::String, crate::model::CustomAttribute>,

    /// Optional. Supported fulfillment types. Valid fulfillment type values
    /// include commonly used types (such as pickup in store and same day
    /// delivery), and custom types. Customers have to map custom types to their
    /// display names before rendering UI.
    ///
    /// Supported values:
    ///
    /// * "pickup-in-store"
    /// * "ship-to-store"
    /// * "same-day-delivery"
    /// * "next-day-delivery"
    /// * "custom-type-1"
    /// * "custom-type-2"
    /// * "custom-type-3"
    /// * "custom-type-4"
    /// * "custom-type-5"
    ///
    /// If this field is set to an invalid value other than these, an
    /// INVALID_ARGUMENT error is returned.
    ///
    /// All the elements must be distinct. Otherwise, an INVALID_ARGUMENT error is
    /// returned.
    pub fulfillment_types: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocalInventory {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [place_id][crate::model::LocalInventory::place_id].
    pub fn set_place_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.place_id = v.into();
        self
    }

    /// Sets the value of [price_info][crate::model::LocalInventory::price_info].
    pub fn set_price_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PriceInfo>,
    {
        self.price_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [price_info][crate::model::LocalInventory::price_info].
    pub fn set_or_clear_price_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PriceInfo>,
    {
        self.price_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [attributes][crate::model::LocalInventory::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::CustomAttribute>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [fulfillment_types][crate::model::LocalInventory::fulfillment_types].
    pub fn set_fulfillment_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.fulfillment_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LocalInventory {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.LocalInventory"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LocalInventory {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __place_id,
            __price_info,
            __attributes,
            __fulfillment_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LocalInventory")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "placeId" => Ok(__FieldTag::__place_id),
                            "place_id" => Ok(__FieldTag::__place_id),
                            "priceInfo" => Ok(__FieldTag::__price_info),
                            "price_info" => Ok(__FieldTag::__price_info),
                            "attributes" => Ok(__FieldTag::__attributes),
                            "fulfillmentTypes" => Ok(__FieldTag::__fulfillment_types),
                            "fulfillment_types" => Ok(__FieldTag::__fulfillment_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LocalInventory;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LocalInventory")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__place_id => {
                            if !fields.insert(__FieldTag::__place_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for place_id",
                                ));
                            }
                            result.place_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__price_info => {
                            if !fields.insert(__FieldTag::__price_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for price_info",
                                ));
                            }
                            result.price_info =
                                map.next_value::<std::option::Option<crate::model::PriceInfo>>()?;
                        }
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes",
                                ));
                            }
                            result.attributes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::CustomAttribute,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fulfillment_types => {
                            if !fields.insert(__FieldTag::__fulfillment_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fulfillment_types",
                                ));
                            }
                            result.fulfillment_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LocalInventory {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.place_id.is_empty() {
            state.serialize_entry("placeId", &self.place_id)?;
        }
        if self.price_info.is_some() {
            state.serialize_entry("priceInfo", &self.price_info)?;
        }
        if !self.attributes.is_empty() {
            state.serialize_entry("attributes", &self.attributes)?;
        }
        if !self.fulfillment_types.is_empty() {
            state.serialize_entry("fulfillmentTypes", &self.fulfillment_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LocalInventory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LocalInventory");
        debug_struct.field("place_id", &self.place_id);
        debug_struct.field("price_info", &self.price_info);
        debug_struct.field("attributes", &self.attributes);
        debug_struct.field("fulfillment_types", &self.fulfillment_types);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata for pinning to be returned in the response.
/// This is used for distinguishing between applied vs dropped pins.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PinControlMetadata {
    /// Map of all matched pins, keyed by pin position.
    pub all_matched_pins:
        std::collections::HashMap<i64, crate::model::pin_control_metadata::ProductPins>,

    /// Map of pins that were dropped due to overlap with other matching pins,
    /// keyed by pin position.
    pub dropped_pins:
        std::collections::HashMap<i64, crate::model::pin_control_metadata::ProductPins>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PinControlMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [all_matched_pins][crate::model::PinControlMetadata::all_matched_pins].
    pub fn set_all_matched_pins<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<i64>,
        V: std::convert::Into<crate::model::pin_control_metadata::ProductPins>,
    {
        use std::iter::Iterator;
        self.all_matched_pins = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [dropped_pins][crate::model::PinControlMetadata::dropped_pins].
    pub fn set_dropped_pins<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<i64>,
        V: std::convert::Into<crate::model::pin_control_metadata::ProductPins>,
    {
        use std::iter::Iterator;
        self.dropped_pins = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for PinControlMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.PinControlMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PinControlMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __all_matched_pins,
            __dropped_pins,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PinControlMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allMatchedPins" => Ok(__FieldTag::__all_matched_pins),
                            "all_matched_pins" => Ok(__FieldTag::__all_matched_pins),
                            "droppedPins" => Ok(__FieldTag::__dropped_pins),
                            "dropped_pins" => Ok(__FieldTag::__dropped_pins),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PinControlMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PinControlMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__all_matched_pins => {
                            if !fields.insert(__FieldTag::__all_matched_pins) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for all_matched_pins",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<
                                        i64,
                                        crate::model::pin_control_metadata::ProductPins,
                                    >,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::I64,
                                                serde_with::Same,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.all_matched_pins =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__dropped_pins => {
                            if !fields.insert(__FieldTag::__dropped_pins) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dropped_pins",
                                ));
                            }
                            struct __With(
                                std::option::Option<
                                    std::collections::HashMap<
                                        i64,
                                        crate::model::pin_control_metadata::ProductPins,
                                    >,
                                >,
                            );
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::collections::HashMap<
                                                wkt::internal::I64,
                                                serde_with::Same,
                                            >,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.dropped_pins = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PinControlMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.all_matched_pins.is_empty() {
            struct __With<'a>(
                &'a std::collections::HashMap<i64, crate::model::pin_control_metadata::ProductPins>,
            );
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::collections::HashMap<wkt::internal::I64, serde_with::Same> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("allMatchedPins", &__With(&self.all_matched_pins))?;
        }
        if !self.dropped_pins.is_empty() {
            struct __With<'a>(
                &'a std::collections::HashMap<i64, crate::model::pin_control_metadata::ProductPins>,
            );
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::< std::collections::HashMap<wkt::internal::I64, serde_with::Same> >::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("droppedPins", &__With(&self.dropped_pins))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PinControlMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PinControlMetadata");
        debug_struct.field("all_matched_pins", &self.all_matched_pins);
        debug_struct.field("dropped_pins", &self.dropped_pins);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PinControlMetadata].
pub mod pin_control_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// List of product ids which have associated pins.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ProductPins {
        /// List of product ids which have associated pins.
        pub product_id: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ProductPins {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [product_id][crate::model::pin_control_metadata::ProductPins::product_id].
        pub fn set_product_id<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.product_id = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ProductPins {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.PinControlMetadata.ProductPins"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ProductPins {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __product_id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ProductPins")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "productId" => Ok(__FieldTag::__product_id),
                                "product_id" => Ok(__FieldTag::__product_id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ProductPins;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ProductPins")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__product_id => {
                                if !fields.insert(__FieldTag::__product_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for product_id",
                                    ));
                                }
                                result.product_id = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ProductPins {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.product_id.is_empty() {
                state.serialize_entry("productId", &self.product_id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ProductPins {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ProductPins");
            debug_struct.field("product_id", &self.product_id);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// A list of string values.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StringList {
    /// String values.
    pub values: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StringList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::StringList::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StringList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.StringList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StringList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StringList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "values" => Ok(__FieldTag::__values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StringList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StringList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__values => {
                            if !fields.insert(__FieldTag::__values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for values",
                                ));
                            }
                            result.values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StringList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.values.is_empty() {
            state.serialize_entry("values", &self.values)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StringList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StringList");
        debug_struct.field("values", &self.values);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A message with a list of double values.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DoubleList {
    /// The list of double values.
    pub values: std::vec::Vec<f64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DoubleList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [values][crate::model::DoubleList::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<f64>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DoubleList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.DoubleList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DoubleList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DoubleList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "values" => Ok(__FieldTag::__values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DoubleList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DoubleList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__values => {
                            if !fields.insert(__FieldTag::__values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for values",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<f64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::F64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.values = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DoubleList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.values.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("values", &__With(&self.values))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DoubleList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DoubleList");
        debug_struct.field("values", &self.values);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Autocomplete parameters.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CompleteQueryRequest {
    /// Required. Catalog for which the completion is performed.
    ///
    /// Full resource name of catalog, such as
    /// `projects/*/locations/global/catalogs/default_catalog`.
    pub catalog: std::string::String,

    /// Required. The query used to generate suggestions.
    ///
    /// The maximum number of allowed characters is 255.
    pub query: std::string::String,

    /// Recommended field. A unique identifier for tracking visitors. For example,
    /// this could be implemented with an HTTP cookie, which should be able to
    /// uniquely identify a visitor on a single device. This unique identifier
    /// should not change if the visitor logs in or out of the website.
    ///
    /// The field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
    pub visitor_id: std::string::String,

    /// Note that this field applies for `user-data` dataset only. For requests
    /// with `cloud-retail` dataset, setting this field has no effect.
    ///
    /// The language filters applied to the output suggestions. If set, it should
    /// contain the language of the query. If not set, suggestions are returned
    /// without considering language restrictions. This is the BCP-47 language
    /// code, such as "en-US" or "sr-Latn". For more information, see [Tags for
    /// Identifying Languages](https://tools.ietf.org/html/bcp47). The maximum
    /// number of language codes is 3.
    pub language_codes: std::vec::Vec<std::string::String>,

    /// The device type context for completion suggestions. We recommend that you
    /// leave this field empty.
    ///
    /// It can apply different suggestions on different device types, e.g.
    /// `DESKTOP`, `MOBILE`. If it is empty, the suggestions are across all device
    /// types.
    ///
    /// Supported formats:
    ///
    /// * `UNKNOWN_DEVICE_TYPE`
    ///
    /// * `DESKTOP`
    ///
    /// * `MOBILE`
    ///
    /// * A customized string starts with `OTHER_`, e.g. `OTHER_IPHONE`.
    ///
    pub device_type: std::string::String,

    /// Determines which dataset to use for fetching completion. "user-data" will
    /// use the dataset imported through
    /// [CompletionService.ImportCompletionData][google.cloud.retail.v2.CompletionService.ImportCompletionData].
    /// `cloud-retail` will use the dataset generated by Cloud Retail based on user
    /// events. If left empty, completions will be fetched from the `user-data`
    /// dataset.
    ///
    /// Current supported values:
    ///
    /// * user-data
    ///
    /// * cloud-retail:
    ///   This option requires enabling auto-learning function first. See
    ///   [guidelines](https://cloud.google.com/retail/docs/completion-overview#generated-completion-dataset).
    ///
    ///
    /// [google.cloud.retail.v2.CompletionService.ImportCompletionData]: crate::client::CompletionService::import_completion_data
    pub dataset: std::string::String,

    /// Completion max suggestions. If left unset or set to 0, then will fallback
    /// to the configured value
    /// [CompletionConfig.max_suggestions][google.cloud.retail.v2.CompletionConfig.max_suggestions].
    ///
    /// The maximum allowed max suggestions is 20. If it is set higher, it will be
    /// capped by 20.
    ///
    /// [google.cloud.retail.v2.CompletionConfig.max_suggestions]: crate::model::CompletionConfig::max_suggestions
    pub max_suggestions: i32,

    /// If true, attribute suggestions are enabled and provided in the response.
    ///
    /// This field is only available for the `cloud-retail` dataset.
    pub enable_attribute_suggestions: bool,

    /// The entity for customers who run multiple entities, domains, sites, or
    /// regions, for example, `Google US`, `Google Ads`, `Waymo`,
    /// `google.com`, `youtube.com`, etc.
    /// If this is set, it must be an exact match with
    /// [UserEvent.entity][google.cloud.retail.v2.UserEvent.entity] to get
    /// per-entity autocomplete results. This field will be applied to
    /// `completion_results` only. It has no effect on the `attribute_results`.
    /// Also, this entity should be limited to 256 characters, if too long, it will
    /// be truncated to 256 characters in both generation and serving time, and may
    /// lead to mis-match. To ensure it works, please set the entity with string
    /// within 256 characters.
    ///
    /// [google.cloud.retail.v2.UserEvent.entity]: crate::model::UserEvent::entity
    pub entity: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CompleteQueryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [catalog][crate::model::CompleteQueryRequest::catalog].
    pub fn set_catalog<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.catalog = v.into();
        self
    }

    /// Sets the value of [query][crate::model::CompleteQueryRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [visitor_id][crate::model::CompleteQueryRequest::visitor_id].
    pub fn set_visitor_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.visitor_id = v.into();
        self
    }

    /// Sets the value of [language_codes][crate::model::CompleteQueryRequest::language_codes].
    pub fn set_language_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.language_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [device_type][crate::model::CompleteQueryRequest::device_type].
    pub fn set_device_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.device_type = v.into();
        self
    }

    /// Sets the value of [dataset][crate::model::CompleteQueryRequest::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [max_suggestions][crate::model::CompleteQueryRequest::max_suggestions].
    pub fn set_max_suggestions<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_suggestions = v.into();
        self
    }

    /// Sets the value of [enable_attribute_suggestions][crate::model::CompleteQueryRequest::enable_attribute_suggestions].
    pub fn set_enable_attribute_suggestions<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_attribute_suggestions = v.into();
        self
    }

    /// Sets the value of [entity][crate::model::CompleteQueryRequest::entity].
    pub fn set_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity = v.into();
        self
    }
}

impl wkt::message::Message for CompleteQueryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.CompleteQueryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CompleteQueryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __catalog,
            __query,
            __visitor_id,
            __language_codes,
            __device_type,
            __dataset,
            __max_suggestions,
            __enable_attribute_suggestions,
            __entity,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompleteQueryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "catalog" => Ok(__FieldTag::__catalog),
                            "query" => Ok(__FieldTag::__query),
                            "visitorId" => Ok(__FieldTag::__visitor_id),
                            "visitor_id" => Ok(__FieldTag::__visitor_id),
                            "languageCodes" => Ok(__FieldTag::__language_codes),
                            "language_codes" => Ok(__FieldTag::__language_codes),
                            "deviceType" => Ok(__FieldTag::__device_type),
                            "device_type" => Ok(__FieldTag::__device_type),
                            "dataset" => Ok(__FieldTag::__dataset),
                            "maxSuggestions" => Ok(__FieldTag::__max_suggestions),
                            "max_suggestions" => Ok(__FieldTag::__max_suggestions),
                            "enableAttributeSuggestions" => {
                                Ok(__FieldTag::__enable_attribute_suggestions)
                            }
                            "enable_attribute_suggestions" => {
                                Ok(__FieldTag::__enable_attribute_suggestions)
                            }
                            "entity" => Ok(__FieldTag::__entity),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CompleteQueryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompleteQueryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__catalog => {
                            if !fields.insert(__FieldTag::__catalog) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for catalog",
                                ));
                            }
                            result.catalog = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__visitor_id => {
                            if !fields.insert(__FieldTag::__visitor_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for visitor_id",
                                ));
                            }
                            result.visitor_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_codes => {
                            if !fields.insert(__FieldTag::__language_codes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_codes",
                                ));
                            }
                            result.language_codes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__device_type => {
                            if !fields.insert(__FieldTag::__device_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for device_type",
                                ));
                            }
                            result.device_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset",
                                ));
                            }
                            result.dataset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_suggestions => {
                            if !fields.insert(__FieldTag::__max_suggestions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_suggestions",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_suggestions =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__enable_attribute_suggestions => {
                            if !fields.insert(__FieldTag::__enable_attribute_suggestions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_attribute_suggestions",
                                ));
                            }
                            result.enable_attribute_suggestions = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity => {
                            if !fields.insert(__FieldTag::__entity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity",
                                ));
                            }
                            result.entity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CompleteQueryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.catalog.is_empty() {
            state.serialize_entry("catalog", &self.catalog)?;
        }
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !self.visitor_id.is_empty() {
            state.serialize_entry("visitorId", &self.visitor_id)?;
        }
        if !self.language_codes.is_empty() {
            state.serialize_entry("languageCodes", &self.language_codes)?;
        }
        if !self.device_type.is_empty() {
            state.serialize_entry("deviceType", &self.device_type)?;
        }
        if !self.dataset.is_empty() {
            state.serialize_entry("dataset", &self.dataset)?;
        }
        if !wkt::internal::is_default(&self.max_suggestions) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxSuggestions", &__With(&self.max_suggestions))?;
        }
        if !wkt::internal::is_default(&self.enable_attribute_suggestions) {
            state.serialize_entry(
                "enableAttributeSuggestions",
                &self.enable_attribute_suggestions,
            )?;
        }
        if !self.entity.is_empty() {
            state.serialize_entry("entity", &self.entity)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CompleteQueryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CompleteQueryRequest");
        debug_struct.field("catalog", &self.catalog);
        debug_struct.field("query", &self.query);
        debug_struct.field("visitor_id", &self.visitor_id);
        debug_struct.field("language_codes", &self.language_codes);
        debug_struct.field("device_type", &self.device_type);
        debug_struct.field("dataset", &self.dataset);
        debug_struct.field("max_suggestions", &self.max_suggestions);
        debug_struct.field(
            "enable_attribute_suggestions",
            &self.enable_attribute_suggestions,
        );
        debug_struct.field("entity", &self.entity);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response of the autocomplete query.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CompleteQueryResponse {
    /// Results of the matching suggestions. The result list is ordered and the
    /// first result is top suggestion.
    pub completion_results: std::vec::Vec<crate::model::complete_query_response::CompletionResult>,

    /// A unique complete token. This should be included in the
    /// [UserEvent.completion_detail][google.cloud.retail.v2.UserEvent.completion_detail]
    /// for search events resulting from this completion, which enables accurate
    /// attribution of complete model performance.
    ///
    /// [google.cloud.retail.v2.UserEvent.completion_detail]: crate::model::UserEvent::completion_detail
    pub attribution_token: std::string::String,

    /// Deprecated. Matched recent searches of this user. The maximum number of
    /// recent searches is 10. This field is a restricted feature. If you want to
    /// enable it, contact Retail Search support.
    ///
    /// This feature is only available when
    /// [CompleteQueryRequest.visitor_id][google.cloud.retail.v2.CompleteQueryRequest.visitor_id]
    /// field is set and [UserEvent][google.cloud.retail.v2.UserEvent] is imported.
    /// The recent searches satisfy the follow rules:
    ///
    /// * They are ordered from latest to oldest.
    ///
    /// * They are matched with
    ///   [CompleteQueryRequest.query][google.cloud.retail.v2.CompleteQueryRequest.query]
    ///   case insensitively.
    ///
    /// * They are transformed to lower case.
    ///
    /// * They are UTF-8 safe.
    ///
    ///
    /// Recent searches are deduplicated. More recent searches will be reserved
    /// when duplication happens.
    ///
    /// [google.cloud.retail.v2.CompleteQueryRequest.query]: crate::model::CompleteQueryRequest::query
    /// [google.cloud.retail.v2.CompleteQueryRequest.visitor_id]: crate::model::CompleteQueryRequest::visitor_id
    /// [google.cloud.retail.v2.UserEvent]: crate::model::UserEvent
    #[deprecated]
    pub recent_search_results:
        std::vec::Vec<crate::model::complete_query_response::RecentSearchResult>,

    /// A map of matched attribute suggestions. This field is only available for
    /// `cloud-retail` dataset.
    ///
    /// Current supported keys:
    ///
    /// * `brands`
    ///
    /// * `categories`
    ///
    pub attribute_results: std::collections::HashMap<
        std::string::String,
        crate::model::complete_query_response::AttributeResult,
    >,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CompleteQueryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [completion_results][crate::model::CompleteQueryResponse::completion_results].
    pub fn set_completion_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::complete_query_response::CompletionResult>,
    {
        use std::iter::Iterator;
        self.completion_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [attribution_token][crate::model::CompleteQueryResponse::attribution_token].
    pub fn set_attribution_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.attribution_token = v.into();
        self
    }

    /// Sets the value of [recent_search_results][crate::model::CompleteQueryResponse::recent_search_results].
    #[deprecated]
    pub fn set_recent_search_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::complete_query_response::RecentSearchResult>,
    {
        use std::iter::Iterator;
        self.recent_search_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [attribute_results][crate::model::CompleteQueryResponse::attribute_results].
    pub fn set_attribute_results<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::complete_query_response::AttributeResult>,
    {
        use std::iter::Iterator;
        self.attribute_results = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for CompleteQueryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.CompleteQueryResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CompleteQueryResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __completion_results,
            __attribution_token,
            __recent_search_results,
            __attribute_results,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompleteQueryResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "completionResults" => Ok(__FieldTag::__completion_results),
                            "completion_results" => Ok(__FieldTag::__completion_results),
                            "attributionToken" => Ok(__FieldTag::__attribution_token),
                            "attribution_token" => Ok(__FieldTag::__attribution_token),
                            "recentSearchResults" => Ok(__FieldTag::__recent_search_results),
                            "recent_search_results" => Ok(__FieldTag::__recent_search_results),
                            "attributeResults" => Ok(__FieldTag::__attribute_results),
                            "attribute_results" => Ok(__FieldTag::__attribute_results),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CompleteQueryResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompleteQueryResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__completion_results => {
                            if !fields.insert(__FieldTag::__completion_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completion_results",
                                ));
                            }
                            result.completion_results = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::complete_query_response::CompletionResult,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attribution_token => {
                            if !fields.insert(__FieldTag::__attribution_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attribution_token",
                                ));
                            }
                            result.attribution_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__recent_search_results => {
                            if !fields.insert(__FieldTag::__recent_search_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recent_search_results",
                                ));
                            }
                            result.recent_search_results = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::complete_query_response::RecentSearchResult,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attribute_results => {
                            if !fields.insert(__FieldTag::__attribute_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attribute_results",
                                ));
                            }
                            result.attribute_results = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::complete_query_response::AttributeResult,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CompleteQueryResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.completion_results.is_empty() {
            state.serialize_entry("completionResults", &self.completion_results)?;
        }
        if !self.attribution_token.is_empty() {
            state.serialize_entry("attributionToken", &self.attribution_token)?;
        }
        if !self.recent_search_results.is_empty() {
            state.serialize_entry("recentSearchResults", &self.recent_search_results)?;
        }
        if !self.attribute_results.is_empty() {
            state.serialize_entry("attributeResults", &self.attribute_results)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CompleteQueryResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CompleteQueryResponse");
        debug_struct.field("completion_results", &self.completion_results);
        debug_struct.field("attribution_token", &self.attribution_token);
        debug_struct.field("recent_search_results", &self.recent_search_results);
        debug_struct.field("attribute_results", &self.attribute_results);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CompleteQueryResponse].
pub mod complete_query_response {
    #[allow(unused_imports)]
    use super::*;

    /// Resource that represents completion results.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CompletionResult {
        /// The suggestion for the query.
        pub suggestion: std::string::String,

        /// Custom attributes for the suggestion term.
        ///
        /// * For `user-data`, the attributes are additional custom attributes
        ///   ingested through BigQuery.
        ///
        /// * For `cloud-retail`, the attributes are product attributes generated
        ///   by Cloud Retail. It requires
        ///   [UserEvent.product_details][google.cloud.retail.v2.UserEvent.product_details]
        ///   is imported properly.
        ///
        ///
        /// [google.cloud.retail.v2.UserEvent.product_details]: crate::model::UserEvent::product_details
        pub attributes:
            std::collections::HashMap<std::string::String, crate::model::CustomAttribute>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CompletionResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [suggestion][crate::model::complete_query_response::CompletionResult::suggestion].
        pub fn set_suggestion<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.suggestion = v.into();
            self
        }

        /// Sets the value of [attributes][crate::model::complete_query_response::CompletionResult::attributes].
        pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::CustomAttribute>,
        {
            use std::iter::Iterator;
            self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for CompletionResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.CompleteQueryResponse.CompletionResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CompletionResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __suggestion,
                __attributes,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CompletionResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "suggestion" => Ok(__FieldTag::__suggestion),
                                "attributes" => Ok(__FieldTag::__attributes),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CompletionResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CompletionResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__suggestion => {
                                if !fields.insert(__FieldTag::__suggestion) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for suggestion",
                                    ));
                                }
                                result.suggestion = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__attributes => {
                                if !fields.insert(__FieldTag::__attributes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for attributes",
                                    ));
                                }
                                result.attributes = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            crate::model::CustomAttribute,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CompletionResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.suggestion.is_empty() {
                state.serialize_entry("suggestion", &self.suggestion)?;
            }
            if !self.attributes.is_empty() {
                state.serialize_entry("attributes", &self.attributes)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for CompletionResult {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("CompletionResult");
            debug_struct.field("suggestion", &self.suggestion);
            debug_struct.field("attributes", &self.attributes);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Deprecated: Recent search of this user.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    #[deprecated]
    pub struct RecentSearchResult {
        /// The recent search query.
        pub recent_search: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RecentSearchResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [recent_search][crate::model::complete_query_response::RecentSearchResult::recent_search].
        pub fn set_recent_search<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.recent_search = v.into();
            self
        }
    }

    impl wkt::message::Message for RecentSearchResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.CompleteQueryResponse.RecentSearchResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RecentSearchResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __recent_search,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RecentSearchResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "recentSearch" => Ok(__FieldTag::__recent_search),
                                "recent_search" => Ok(__FieldTag::__recent_search),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RecentSearchResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RecentSearchResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__recent_search => {
                                if !fields.insert(__FieldTag::__recent_search) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for recent_search",
                                    ));
                                }
                                result.recent_search = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RecentSearchResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.recent_search.is_empty() {
                state.serialize_entry("recentSearch", &self.recent_search)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for RecentSearchResult {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("RecentSearchResult");
            debug_struct.field("recent_search", &self.recent_search);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Resource that represents attribute results.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AttributeResult {
        /// The list of suggestions for the attribute.
        pub suggestions: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AttributeResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [suggestions][crate::model::complete_query_response::AttributeResult::suggestions].
        pub fn set_suggestions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.suggestions = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for AttributeResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.CompleteQueryResponse.AttributeResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AttributeResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __suggestions,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AttributeResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "suggestions" => Ok(__FieldTag::__suggestions),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AttributeResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AttributeResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__suggestions => {
                                if !fields.insert(__FieldTag::__suggestions) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for suggestions",
                                    ));
                                }
                                result.suggestions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AttributeResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.suggestions.is_empty() {
                state.serialize_entry("suggestions", &self.suggestions)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AttributeResult {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AttributeResult");
            debug_struct.field("suggestions", &self.suggestions);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Configures dynamic metadata that can be linked to a
/// [ServingConfig][google.cloud.retail.v2.ServingConfig] and affect search or
/// recommendation results at serving time.
///
/// [google.cloud.retail.v2.ServingConfig]: crate::model::ServingConfig
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Control {
    /// Immutable. Fully qualified name
    /// `projects/*/locations/global/catalogs/*/controls/*`
    pub name: std::string::String,

    /// Required. The human readable control display name. Used in Retail UI.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an INVALID_ARGUMENT error is thrown.
    pub display_name: std::string::String,

    /// Output only. List of [serving config][google.cloud.retail.v2.ServingConfig]
    /// ids that are associated with this control in the same
    /// [Catalog][google.cloud.retail.v2.Catalog].
    ///
    /// Note the association is managed via the
    /// [ServingConfig][google.cloud.retail.v2.ServingConfig], this is an output
    /// only denormalized view.
    ///
    /// [google.cloud.retail.v2.Catalog]: crate::model::Catalog
    /// [google.cloud.retail.v2.ServingConfig]: crate::model::ServingConfig
    pub associated_serving_config_ids: std::vec::Vec<std::string::String>,

    /// Required. Immutable. The solution types that the control is used for.
    /// Currently we support setting only one type of solution at creation time.
    ///
    /// Only `SOLUTION_TYPE_SEARCH` value is supported at the moment.
    /// If no solution type is provided at creation time, will default to
    /// [SOLUTION_TYPE_SEARCH][google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH].
    ///
    /// [google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH]: crate::model::SolutionType::Search
    pub solution_types: std::vec::Vec<crate::model::SolutionType>,

    /// Specifies the use case for the control.
    /// Affects what condition fields can be set.
    /// Only settable by search controls.
    /// Will default to
    /// [SEARCH_SOLUTION_USE_CASE_SEARCH][google.cloud.retail.v2.SearchSolutionUseCase.SEARCH_SOLUTION_USE_CASE_SEARCH]
    /// if not specified. Currently only allow one search_solution_use_case per
    /// control.
    ///
    /// [google.cloud.retail.v2.SearchSolutionUseCase.SEARCH_SOLUTION_USE_CASE_SEARCH]: crate::model::SearchSolutionUseCase::Search
    pub search_solution_use_case: std::vec::Vec<crate::model::SearchSolutionUseCase>,

    /// The behavior/type of the control
    ///
    /// A behavior/type must be specified on creation. Type cannot be changed once
    /// specified (e.g. A Rule control will always be a Rule control.). An
    /// INVALID_ARGUMENT will be returned if either condition is violated.
    pub control: std::option::Option<crate::model::control::Control>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Control {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Control::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Control::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [associated_serving_config_ids][crate::model::Control::associated_serving_config_ids].
    pub fn set_associated_serving_config_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.associated_serving_config_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [solution_types][crate::model::Control::solution_types].
    pub fn set_solution_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SolutionType>,
    {
        use std::iter::Iterator;
        self.solution_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [search_solution_use_case][crate::model::Control::search_solution_use_case].
    pub fn set_search_solution_use_case<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SearchSolutionUseCase>,
    {
        use std::iter::Iterator;
        self.search_solution_use_case = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [control][crate::model::Control::control].
    ///
    /// Note that all the setters affecting `control` are mutually
    /// exclusive.
    pub fn set_control<
        T: std::convert::Into<std::option::Option<crate::model::control::Control>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.control = v.into();
        self
    }

    /// The value of [control][crate::model::Control::control]
    /// if it holds a `Rule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn rule(&self) -> std::option::Option<&std::boxed::Box<crate::model::Rule>> {
        #[allow(unreachable_patterns)]
        self.control.as_ref().and_then(|v| match v {
            crate::model::control::Control::Rule(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [control][crate::model::Control::control]
    /// to hold a `Rule`.
    ///
    /// Note that all the setters affecting `control` are
    /// mutually exclusive.
    pub fn set_rule<T: std::convert::Into<std::boxed::Box<crate::model::Rule>>>(
        mut self,
        v: T,
    ) -> Self {
        self.control = std::option::Option::Some(crate::model::control::Control::Rule(v.into()));
        self
    }
}

impl wkt::message::Message for Control {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.Control"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Control {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rule,
            __name,
            __display_name,
            __associated_serving_config_ids,
            __solution_types,
            __search_solution_use_case,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Control")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rule" => Ok(__FieldTag::__rule),
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "associatedServingConfigIds" => {
                                Ok(__FieldTag::__associated_serving_config_ids)
                            }
                            "associated_serving_config_ids" => {
                                Ok(__FieldTag::__associated_serving_config_ids)
                            }
                            "solutionTypes" => Ok(__FieldTag::__solution_types),
                            "solution_types" => Ok(__FieldTag::__solution_types),
                            "searchSolutionUseCase" => Ok(__FieldTag::__search_solution_use_case),
                            "search_solution_use_case" => {
                                Ok(__FieldTag::__search_solution_use_case)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Control;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Control")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rule => {
                            if !fields.insert(__FieldTag::__rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rule",
                                ));
                            }
                            if result.control.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `control`, a oneof with full ID .google.cloud.retail.v2.Control.rule, latest field was rule",
                                ));
                            }
                            result.control =
                                std::option::Option::Some(
                                    crate::model::control::Control::Rule(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Rule>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__associated_serving_config_ids => {
                            if !fields.insert(__FieldTag::__associated_serving_config_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for associated_serving_config_ids",
                                ));
                            }
                            result.associated_serving_config_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__solution_types => {
                            if !fields.insert(__FieldTag::__solution_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for solution_types",
                                ));
                            }
                            result.solution_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SolutionType>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__search_solution_use_case => {
                            if !fields.insert(__FieldTag::__search_solution_use_case) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for search_solution_use_case",
                                ));
                            }
                            result.search_solution_use_case = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SearchSolutionUseCase>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Control {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.rule() {
            state.serialize_entry("rule", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.associated_serving_config_ids.is_empty() {
            state.serialize_entry(
                "associatedServingConfigIds",
                &self.associated_serving_config_ids,
            )?;
        }
        if !self.solution_types.is_empty() {
            state.serialize_entry("solutionTypes", &self.solution_types)?;
        }
        if !self.search_solution_use_case.is_empty() {
            state.serialize_entry("searchSolutionUseCase", &self.search_solution_use_case)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Control {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Control");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field(
            "associated_serving_config_ids",
            &self.associated_serving_config_ids,
        );
        debug_struct.field("solution_types", &self.solution_types);
        debug_struct.field("search_solution_use_case", &self.search_solution_use_case);
        debug_struct.field("control", &self.control);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Control].
pub mod control {
    #[allow(unused_imports)]
    use super::*;

    /// The behavior/type of the control
    ///
    /// A behavior/type must be specified on creation. Type cannot be changed once
    /// specified (e.g. A Rule control will always be a Rule control.). An
    /// INVALID_ARGUMENT will be returned if either condition is violated.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Control {
        /// A rule control - a condition-action pair.
        /// Enacts a set action when the condition is triggered.
        /// For example: Boost "gShoe" when query full matches "Running Shoes".
        Rule(std::boxed::Box<crate::model::Rule>),
    }
}

/// Request for CreateControl method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateControlRequest {
    /// Required. Full resource name of parent catalog. Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}`
    pub parent: std::string::String,

    /// Required. The Control to create.
    pub control: std::option::Option<crate::model::Control>,

    /// Required. The ID to use for the Control, which will become the final
    /// component of the Control's resource name.
    ///
    /// This value should be 4-63 characters, and valid characters
    /// are /[a-z][0-9]-_/.
    pub control_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateControlRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateControlRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [control][crate::model::CreateControlRequest::control].
    pub fn set_control<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Control>,
    {
        self.control = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [control][crate::model::CreateControlRequest::control].
    pub fn set_or_clear_control<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Control>,
    {
        self.control = v.map(|x| x.into());
        self
    }

    /// Sets the value of [control_id][crate::model::CreateControlRequest::control_id].
    pub fn set_control_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.control_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateControlRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.CreateControlRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateControlRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __control,
            __control_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateControlRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "control" => Ok(__FieldTag::__control),
                            "controlId" => Ok(__FieldTag::__control_id),
                            "control_id" => Ok(__FieldTag::__control_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateControlRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateControlRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__control => {
                            if !fields.insert(__FieldTag::__control) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for control",
                                ));
                            }
                            result.control =
                                map.next_value::<std::option::Option<crate::model::Control>>()?;
                        }
                        __FieldTag::__control_id => {
                            if !fields.insert(__FieldTag::__control_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for control_id",
                                ));
                            }
                            result.control_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateControlRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.control.is_some() {
            state.serialize_entry("control", &self.control)?;
        }
        if !self.control_id.is_empty() {
            state.serialize_entry("controlId", &self.control_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateControlRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateControlRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("control", &self.control);
        debug_struct.field("control_id", &self.control_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for UpdateControl method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateControlRequest {
    /// Required. The Control to update.
    pub control: std::option::Option<crate::model::Control>,

    /// Indicates which fields in the provided
    /// [Control][google.cloud.retail.v2.Control] to update. The following are NOT
    /// supported:
    ///
    /// * [Control.name][google.cloud.retail.v2.Control.name]
    ///
    /// If not set or empty, all supported fields are updated.
    ///
    /// [google.cloud.retail.v2.Control]: crate::model::Control
    /// [google.cloud.retail.v2.Control.name]: crate::model::Control::name
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateControlRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [control][crate::model::UpdateControlRequest::control].
    pub fn set_control<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Control>,
    {
        self.control = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [control][crate::model::UpdateControlRequest::control].
    pub fn set_or_clear_control<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Control>,
    {
        self.control = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateControlRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateControlRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateControlRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.UpdateControlRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateControlRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __control,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateControlRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "control" => Ok(__FieldTag::__control),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateControlRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateControlRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__control => {
                            if !fields.insert(__FieldTag::__control) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for control",
                                ));
                            }
                            result.control =
                                map.next_value::<std::option::Option<crate::model::Control>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateControlRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.control.is_some() {
            state.serialize_entry("control", &self.control)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateControlRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateControlRequest");
        debug_struct.field("control", &self.control);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for DeleteControl method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteControlRequest {
    /// Required. The resource name of the Control to delete. Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}/controls/{control_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteControlRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteControlRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteControlRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.DeleteControlRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteControlRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteControlRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteControlRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteControlRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteControlRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteControlRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteControlRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for GetControl method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetControlRequest {
    /// Required. The resource name of the Control to get. Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}/controls/{control_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetControlRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetControlRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetControlRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.GetControlRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetControlRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetControlRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetControlRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetControlRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetControlRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetControlRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetControlRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for ListControls method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListControlsRequest {
    /// Required. The catalog resource name. Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}`
    pub parent: std::string::String,

    /// Optional. Maximum number of results to return. If unspecified, defaults
    /// to 50. Max allowed value is 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListControls` call.
    /// Provide this to retrieve the subsequent page.
    pub page_token: std::string::String,

    /// Optional. A filter to apply on the list results. Supported features:
    ///
    /// * List all the products under the parent branch if
    ///   [filter][google.cloud.retail.v2.ListControlsRequest.filter] is unset.
    /// * List controls that are used in a single ServingConfig:
    ///   'serving_config = "boosted_home_page_cvr"'
    ///
    /// [google.cloud.retail.v2.ListControlsRequest.filter]: crate::model::ListControlsRequest::filter
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListControlsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListControlsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListControlsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListControlsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListControlsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListControlsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ListControlsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListControlsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListControlsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListControlsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListControlsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListControlsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListControlsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListControlsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for ListControls method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListControlsResponse {
    /// All the Controls for a given catalog.
    pub controls: std::vec::Vec<crate::model::Control>,

    /// Pagination token, if not returned indicates the last page.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListControlsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [controls][crate::model::ListControlsResponse::controls].
    pub fn set_controls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Control>,
    {
        use std::iter::Iterator;
        self.controls = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListControlsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListControlsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ListControlsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListControlsResponse {
    type PageItem = crate::model::Control;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.controls
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListControlsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __controls,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListControlsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "controls" => Ok(__FieldTag::__controls),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListControlsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListControlsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__controls => {
                            if !fields.insert(__FieldTag::__controls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for controls",
                                ));
                            }
                            result.controls = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Control>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListControlsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.controls.is_empty() {
            state.serialize_entry("controls", &self.controls)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListControlsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListControlsResponse");
        debug_struct.field("controls", &self.controls);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The output configuration setting.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OutputConfig {
    /// The configuration of destination for holding output data.
    pub destination: std::option::Option<crate::model::output_config::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OutputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination][crate::model::OutputConfig::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::output_config::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::OutputConfig::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::output_config::GcsDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::output_config::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::OutputConfig::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::output_config::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::output_config::Destination::GcsDestination(v.into()),
        );
        self
    }

    /// The value of [destination][crate::model::OutputConfig::destination]
    /// if it holds a `BigqueryDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::output_config::BigQueryDestination>>
    {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::output_config::Destination::BigqueryDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::OutputConfig::destination]
    /// to hold a `BigqueryDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_bigquery_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::output_config::BigQueryDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::output_config::Destination::BigqueryDestination(v.into()),
        );
        self
    }
}

impl wkt::message::Message for OutputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.OutputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OutputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_destination,
            __bigquery_destination,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OutputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsDestination" => Ok(__FieldTag::__gcs_destination),
                            "gcs_destination" => Ok(__FieldTag::__gcs_destination),
                            "bigqueryDestination" => Ok(__FieldTag::__bigquery_destination),
                            "bigquery_destination" => Ok(__FieldTag::__bigquery_destination),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OutputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OutputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_destination => {
                            if !fields.insert(__FieldTag::__gcs_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_destination",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.retail.v2.OutputConfig.gcs_destination, latest field was gcsDestination",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::output_config::Destination::GcsDestination(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::output_config::GcsDestination,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__bigquery_destination => {
                            if !fields.insert(__FieldTag::__bigquery_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bigquery_destination",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.retail.v2.OutputConfig.bigquery_destination, latest field was bigqueryDestination",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::output_config::Destination::BigqueryDestination(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::output_config::BigQueryDestination,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OutputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_destination() {
            state.serialize_entry("gcsDestination", value)?;
        }
        if let Some(value) = self.bigquery_destination() {
            state.serialize_entry("bigqueryDestination", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OutputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OutputConfig");
        debug_struct.field("destination", &self.destination);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [OutputConfig].
pub mod output_config {
    #[allow(unused_imports)]
    use super::*;

    /// The Google Cloud Storage output destination configuration.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GcsDestination {
        /// Required. The output uri prefix for saving output data to json files.
        /// Some mapping examples are as follows:
        /// output_uri_prefix         sample output(assuming the object is foo.json)
        /// ========================  =============================================
        /// gs://bucket/              gs://bucket/foo.json
        /// gs://bucket/folder/       gs://bucket/folder/foo.json
        /// gs://bucket/folder/item_  gs://bucket/folder/item_foo.json
        pub output_uri_prefix: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GcsDestination {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [output_uri_prefix][crate::model::output_config::GcsDestination::output_uri_prefix].
        pub fn set_output_uri_prefix<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.output_uri_prefix = v.into();
            self
        }
    }

    impl wkt::message::Message for GcsDestination {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.OutputConfig.GcsDestination"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GcsDestination {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __output_uri_prefix,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GcsDestination")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "outputUriPrefix" => Ok(__FieldTag::__output_uri_prefix),
                                "output_uri_prefix" => Ok(__FieldTag::__output_uri_prefix),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GcsDestination;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GcsDestination")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__output_uri_prefix => {
                                if !fields.insert(__FieldTag::__output_uri_prefix) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for output_uri_prefix",
                                    ));
                                }
                                result.output_uri_prefix = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GcsDestination {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.output_uri_prefix.is_empty() {
                state.serialize_entry("outputUriPrefix", &self.output_uri_prefix)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GcsDestination {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GcsDestination");
            debug_struct.field("output_uri_prefix", &self.output_uri_prefix);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The BigQuery output destination configuration.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BigQueryDestination {
        /// Required. The ID of a BigQuery Dataset.
        pub dataset_id: std::string::String,

        /// Required. The prefix of exported BigQuery tables.
        pub table_id_prefix: std::string::String,

        /// Required. Describes the table type. The following values are supported:
        ///
        /// * `table`: A BigQuery native table.
        /// * `view`: A virtual table defined by a SQL query.
        pub table_type: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BigQueryDestination {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataset_id][crate::model::output_config::BigQueryDestination::dataset_id].
        pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dataset_id = v.into();
            self
        }

        /// Sets the value of [table_id_prefix][crate::model::output_config::BigQueryDestination::table_id_prefix].
        pub fn set_table_id_prefix<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.table_id_prefix = v.into();
            self
        }

        /// Sets the value of [table_type][crate::model::output_config::BigQueryDestination::table_type].
        pub fn set_table_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.table_type = v.into();
            self
        }
    }

    impl wkt::message::Message for BigQueryDestination {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.OutputConfig.BigQueryDestination"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BigQueryDestination {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __dataset_id,
                __table_id_prefix,
                __table_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BigQueryDestination")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "datasetId" => Ok(__FieldTag::__dataset_id),
                                "dataset_id" => Ok(__FieldTag::__dataset_id),
                                "tableIdPrefix" => Ok(__FieldTag::__table_id_prefix),
                                "table_id_prefix" => Ok(__FieldTag::__table_id_prefix),
                                "tableType" => Ok(__FieldTag::__table_type),
                                "table_type" => Ok(__FieldTag::__table_type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BigQueryDestination;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BigQueryDestination")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__dataset_id => {
                                if !fields.insert(__FieldTag::__dataset_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dataset_id",
                                    ));
                                }
                                result.dataset_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__table_id_prefix => {
                                if !fields.insert(__FieldTag::__table_id_prefix) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for table_id_prefix",
                                    ));
                                }
                                result.table_id_prefix = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__table_type => {
                                if !fields.insert(__FieldTag::__table_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for table_type",
                                    ));
                                }
                                result.table_type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BigQueryDestination {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.dataset_id.is_empty() {
                state.serialize_entry("datasetId", &self.dataset_id)?;
            }
            if !self.table_id_prefix.is_empty() {
                state.serialize_entry("tableIdPrefix", &self.table_id_prefix)?;
            }
            if !self.table_type.is_empty() {
                state.serialize_entry("tableType", &self.table_type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for BigQueryDestination {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("BigQueryDestination");
            debug_struct.field("dataset_id", &self.dataset_id);
            debug_struct.field("table_id_prefix", &self.table_id_prefix);
            debug_struct.field("table_type", &self.table_type);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The configuration of destination for holding output data.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// The Google Cloud Storage location where the output is to be written to.
        GcsDestination(std::boxed::Box<crate::model::output_config::GcsDestination>),
        /// The BigQuery location where the output is to be written to.
        BigqueryDestination(std::boxed::Box<crate::model::output_config::BigQueryDestination>),
    }
}

/// Configuration of destination for Export related errors.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportErrorsConfig {
    /// Required. Errors destination.
    pub destination: std::option::Option<crate::model::export_errors_config::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportErrorsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination][crate::model::ExportErrorsConfig::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::export_errors_config::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ExportErrorsConfig::destination]
    /// if it holds a `GcsPrefix`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_prefix(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_errors_config::Destination::GcsPrefix(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportErrorsConfig::destination]
    /// to hold a `GcsPrefix`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_errors_config::Destination::GcsPrefix(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExportErrorsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ExportErrorsConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportErrorsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_prefix,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportErrorsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsPrefix" => Ok(__FieldTag::__gcs_prefix),
                            "gcs_prefix" => Ok(__FieldTag::__gcs_prefix),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportErrorsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportErrorsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_prefix => {
                            if !fields.insert(__FieldTag::__gcs_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_prefix",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.retail.v2.ExportErrorsConfig.gcs_prefix, latest field was gcsPrefix",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::export_errors_config::Destination::GcsPrefix(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportErrorsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_prefix() {
            state.serialize_entry("gcsPrefix", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExportErrorsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportErrorsConfig");
        debug_struct.field("destination", &self.destination);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ExportErrorsConfig].
pub mod export_errors_config {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Errors destination.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Google Cloud Storage path for import errors. This must be an empty,
        /// existing Cloud Storage bucket. Export errors will be written to a file in
        /// this bucket, one per line, as a JSON-encoded
        /// `google.rpc.Status` message.
        GcsPrefix(std::string::String),
    }
}

/// Request message for the `ExportAnalyticsMetrics` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportAnalyticsMetricsRequest {
    /// Required. Full resource name of the parent catalog.
    /// Expected format: `projects/*/locations/*/catalogs/*`
    pub catalog: std::string::String,

    /// Required. The output location of the data.
    pub output_config: std::option::Option<crate::model::OutputConfig>,

    /// A filtering expression to specify restrictions on returned metrics.
    /// The expression is a sequence of terms. Each term applies a restriction to
    /// the returned metrics. Use this expression to restrict results to a
    /// specific time range.
    ///
    /// Currently we expect only one types of fields:
    ///
    /// * `timestamp`: This can be specified twice, once with a
    ///   less than operator and once with a greater than operator. The
    ///   `timestamp` restriction should result in one, contiguous, valid,
    ///   `timestamp` range.
    ///
    /// Some examples of valid filters expressions:
    ///
    /// * Example 1: `timestamp > "2012-04-23T18:25:43.511Z"
    ///   timestamp < "2012-04-23T18:30:43.511Z"`
    /// * Example 2: `timestamp > "2012-04-23T18:25:43.511Z"`
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportAnalyticsMetricsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [catalog][crate::model::ExportAnalyticsMetricsRequest::catalog].
    pub fn set_catalog<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.catalog = v.into();
        self
    }

    /// Sets the value of [output_config][crate::model::ExportAnalyticsMetricsRequest::output_config].
    pub fn set_output_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputConfig>,
    {
        self.output_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_config][crate::model::ExportAnalyticsMetricsRequest::output_config].
    pub fn set_or_clear_output_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputConfig>,
    {
        self.output_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [filter][crate::model::ExportAnalyticsMetricsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ExportAnalyticsMetricsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ExportAnalyticsMetricsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportAnalyticsMetricsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __catalog,
            __output_config,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportAnalyticsMetricsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "catalog" => Ok(__FieldTag::__catalog),
                            "outputConfig" => Ok(__FieldTag::__output_config),
                            "output_config" => Ok(__FieldTag::__output_config),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportAnalyticsMetricsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportAnalyticsMetricsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__catalog => {
                            if !fields.insert(__FieldTag::__catalog) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for catalog",
                                ));
                            }
                            result.catalog = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__output_config => {
                            if !fields.insert(__FieldTag::__output_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_config",
                                ));
                            }
                            result.output_config = map
                                .next_value::<std::option::Option<crate::model::OutputConfig>>()?;
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportAnalyticsMetricsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.catalog.is_empty() {
            state.serialize_entry("catalog", &self.catalog)?;
        }
        if self.output_config.is_some() {
            state.serialize_entry("outputConfig", &self.output_config)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExportAnalyticsMetricsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportAnalyticsMetricsRequest");
        debug_struct.field("catalog", &self.catalog);
        debug_struct.field("output_config", &self.output_config);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata related to the progress of the Export operation. This is
/// returned by the google.longrunning.Operation.metadata field.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportMetadata {
    /// Operation create time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::ExportMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ExportMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ExportMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ExportMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ExportMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ExportMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExportMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response of the ExportAnalyticsMetricsRequest. If the long running
/// operation was successful, then this message is returned by the
/// google.longrunning.Operations.response field if the operation was successful.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportAnalyticsMetricsResponse {
    /// A sample of errors encountered while processing the request.
    pub error_samples: std::vec::Vec<rpc::model::Status>,

    /// This field is never set.
    pub errors_config: std::option::Option<crate::model::ExportErrorsConfig>,

    /// Output result indicating where the data were exported to.
    pub output_result: std::option::Option<crate::model::OutputResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportAnalyticsMetricsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_samples][crate::model::ExportAnalyticsMetricsResponse::error_samples].
    pub fn set_error_samples<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.error_samples = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [errors_config][crate::model::ExportAnalyticsMetricsResponse::errors_config].
    pub fn set_errors_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ExportErrorsConfig>,
    {
        self.errors_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [errors_config][crate::model::ExportAnalyticsMetricsResponse::errors_config].
    pub fn set_or_clear_errors_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ExportErrorsConfig>,
    {
        self.errors_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_result][crate::model::ExportAnalyticsMetricsResponse::output_result].
    pub fn set_output_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputResult>,
    {
        self.output_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_result][crate::model::ExportAnalyticsMetricsResponse::output_result].
    pub fn set_or_clear_output_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputResult>,
    {
        self.output_result = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ExportAnalyticsMetricsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ExportAnalyticsMetricsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportAnalyticsMetricsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __error_samples,
            __errors_config,
            __output_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportAnalyticsMetricsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "errorSamples" => Ok(__FieldTag::__error_samples),
                            "error_samples" => Ok(__FieldTag::__error_samples),
                            "errorsConfig" => Ok(__FieldTag::__errors_config),
                            "errors_config" => Ok(__FieldTag::__errors_config),
                            "outputResult" => Ok(__FieldTag::__output_result),
                            "output_result" => Ok(__FieldTag::__output_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportAnalyticsMetricsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportAnalyticsMetricsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__error_samples => {
                            if !fields.insert(__FieldTag::__error_samples) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_samples",
                                ));
                            }
                            result.error_samples = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__errors_config => {
                            if !fields.insert(__FieldTag::__errors_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors_config",
                                ));
                            }
                            result.errors_config = map.next_value::<std::option::Option<crate::model::ExportErrorsConfig>>()?
                                ;
                        }
                        __FieldTag::__output_result => {
                            if !fields.insert(__FieldTag::__output_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_result",
                                ));
                            }
                            result.output_result = map
                                .next_value::<std::option::Option<crate::model::OutputResult>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportAnalyticsMetricsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.error_samples.is_empty() {
            state.serialize_entry("errorSamples", &self.error_samples)?;
        }
        if self.errors_config.is_some() {
            state.serialize_entry("errorsConfig", &self.errors_config)?;
        }
        if self.output_result.is_some() {
            state.serialize_entry("outputResult", &self.output_result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExportAnalyticsMetricsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportAnalyticsMetricsResponse");
        debug_struct.field("error_samples", &self.error_samples);
        debug_struct.field("errors_config", &self.errors_config);
        debug_struct.field("output_result", &self.output_result);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Output result that stores the information about where the exported data is
/// stored.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OutputResult {
    /// The BigQuery location where the result is stored.
    pub bigquery_result: std::vec::Vec<crate::model::BigQueryOutputResult>,

    /// The Google Cloud Storage location where the result is stored.
    pub gcs_result: std::vec::Vec<crate::model::GcsOutputResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OutputResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bigquery_result][crate::model::OutputResult::bigquery_result].
    pub fn set_bigquery_result<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BigQueryOutputResult>,
    {
        use std::iter::Iterator;
        self.bigquery_result = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [gcs_result][crate::model::OutputResult::gcs_result].
    pub fn set_gcs_result<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GcsOutputResult>,
    {
        use std::iter::Iterator;
        self.gcs_result = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OutputResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.OutputResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OutputResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bigquery_result,
            __gcs_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OutputResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bigqueryResult" => Ok(__FieldTag::__bigquery_result),
                            "bigquery_result" => Ok(__FieldTag::__bigquery_result),
                            "gcsResult" => Ok(__FieldTag::__gcs_result),
                            "gcs_result" => Ok(__FieldTag::__gcs_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OutputResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OutputResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bigquery_result => {
                            if !fields.insert(__FieldTag::__bigquery_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bigquery_result",
                                ));
                            }
                            result.bigquery_result = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::BigQueryOutputResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcs_result => {
                            if !fields.insert(__FieldTag::__gcs_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_result",
                                ));
                            }
                            result.gcs_result =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::GcsOutputResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OutputResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.bigquery_result.is_empty() {
            state.serialize_entry("bigqueryResult", &self.bigquery_result)?;
        }
        if !self.gcs_result.is_empty() {
            state.serialize_entry("gcsResult", &self.gcs_result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OutputResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OutputResult");
        debug_struct.field("bigquery_result", &self.bigquery_result);
        debug_struct.field("gcs_result", &self.gcs_result);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A BigQuery output result.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQueryOutputResult {
    /// The ID of a BigQuery Dataset.
    pub dataset_id: std::string::String,

    /// The ID of a BigQuery Table.
    pub table_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQueryOutputResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset_id][crate::model::BigQueryOutputResult::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::BigQueryOutputResult::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryOutputResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.BigQueryOutputResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQueryOutputResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataset_id,
            __table_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryOutputResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQueryOutputResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryOutputResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQueryOutputResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BigQueryOutputResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BigQueryOutputResult");
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("table_id", &self.table_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A Gcs output result.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsOutputResult {
    /// The uri of Gcs output
    pub output_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsOutputResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [output_uri][crate::model::GcsOutputResult::output_uri].
    pub fn set_output_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.output_uri = v.into();
        self
    }
}

impl wkt::message::Message for GcsOutputResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.GcsOutputResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsOutputResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __output_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsOutputResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "outputUri" => Ok(__FieldTag::__output_uri),
                            "output_uri" => Ok(__FieldTag::__output_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsOutputResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsOutputResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__output_uri => {
                            if !fields.insert(__FieldTag::__output_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_uri",
                                ));
                            }
                            result.output_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsOutputResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.output_uri.is_empty() {
            state.serialize_entry("outputUri", &self.output_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GcsOutputResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsOutputResult");
        debug_struct.field("output_uri", &self.output_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for overall generative question feature state.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerativeQuestionsFeatureConfig {
    /// Required. Resource name of the affected catalog.
    /// Format: projects/{project}/locations/{location}/catalogs/{catalog}
    pub catalog: std::string::String,

    /// Optional. Determines whether questions will be used at serving time.
    /// Note: This feature cannot be enabled until initial data requirements are
    /// satisfied.
    pub feature_enabled: bool,

    /// Optional. Minimum number of products in the response to trigger follow-up
    /// questions. Value must be 0 or positive.
    pub minimum_products: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerativeQuestionsFeatureConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [catalog][crate::model::GenerativeQuestionsFeatureConfig::catalog].
    pub fn set_catalog<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.catalog = v.into();
        self
    }

    /// Sets the value of [feature_enabled][crate::model::GenerativeQuestionsFeatureConfig::feature_enabled].
    pub fn set_feature_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.feature_enabled = v.into();
        self
    }

    /// Sets the value of [minimum_products][crate::model::GenerativeQuestionsFeatureConfig::minimum_products].
    pub fn set_minimum_products<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.minimum_products = v.into();
        self
    }
}

impl wkt::message::Message for GenerativeQuestionsFeatureConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.GenerativeQuestionsFeatureConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerativeQuestionsFeatureConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __catalog,
            __feature_enabled,
            __minimum_products,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerativeQuestionsFeatureConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "catalog" => Ok(__FieldTag::__catalog),
                            "featureEnabled" => Ok(__FieldTag::__feature_enabled),
                            "feature_enabled" => Ok(__FieldTag::__feature_enabled),
                            "minimumProducts" => Ok(__FieldTag::__minimum_products),
                            "minimum_products" => Ok(__FieldTag::__minimum_products),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerativeQuestionsFeatureConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerativeQuestionsFeatureConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__catalog => {
                            if !fields.insert(__FieldTag::__catalog) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for catalog",
                                ));
                            }
                            result.catalog = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__feature_enabled => {
                            if !fields.insert(__FieldTag::__feature_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for feature_enabled",
                                ));
                            }
                            result.feature_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__minimum_products => {
                            if !fields.insert(__FieldTag::__minimum_products) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for minimum_products",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.minimum_products =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerativeQuestionsFeatureConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.catalog.is_empty() {
            state.serialize_entry("catalog", &self.catalog)?;
        }
        if !wkt::internal::is_default(&self.feature_enabled) {
            state.serialize_entry("featureEnabled", &self.feature_enabled)?;
        }
        if !wkt::internal::is_default(&self.minimum_products) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minimumProducts", &__With(&self.minimum_products))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GenerativeQuestionsFeatureConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerativeQuestionsFeatureConfig");
        debug_struct.field("catalog", &self.catalog);
        debug_struct.field("feature_enabled", &self.feature_enabled);
        debug_struct.field("minimum_products", &self.minimum_products);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for a single generated question.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerativeQuestionConfig {
    /// Required. Resource name of the catalog.
    /// Format: projects/{project}/locations/{location}/catalogs/{catalog}
    pub catalog: std::string::String,

    /// Required. The facet to which the question is associated.
    pub facet: std::string::String,

    /// Output only. The LLM generated question.
    pub generated_question: std::string::String,

    /// Optional. The question that will be used at serving time.
    /// Question can have a max length of 300 bytes.
    /// When not populated, generated_question should be used.
    pub final_question: std::string::String,

    /// Output only. Values that can be used to answer the question.
    pub example_values: std::vec::Vec<std::string::String>,

    /// Output only. The ratio of how often a question was asked.
    pub frequency: f32,

    /// Optional. Whether the question is asked at serving time.
    pub allowed_in_conversation: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerativeQuestionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [catalog][crate::model::GenerativeQuestionConfig::catalog].
    pub fn set_catalog<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.catalog = v.into();
        self
    }

    /// Sets the value of [facet][crate::model::GenerativeQuestionConfig::facet].
    pub fn set_facet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.facet = v.into();
        self
    }

    /// Sets the value of [generated_question][crate::model::GenerativeQuestionConfig::generated_question].
    pub fn set_generated_question<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.generated_question = v.into();
        self
    }

    /// Sets the value of [final_question][crate::model::GenerativeQuestionConfig::final_question].
    pub fn set_final_question<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.final_question = v.into();
        self
    }

    /// Sets the value of [example_values][crate::model::GenerativeQuestionConfig::example_values].
    pub fn set_example_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.example_values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [frequency][crate::model::GenerativeQuestionConfig::frequency].
    pub fn set_frequency<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.frequency = v.into();
        self
    }

    /// Sets the value of [allowed_in_conversation][crate::model::GenerativeQuestionConfig::allowed_in_conversation].
    pub fn set_allowed_in_conversation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allowed_in_conversation = v.into();
        self
    }
}

impl wkt::message::Message for GenerativeQuestionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.GenerativeQuestionConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerativeQuestionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __catalog,
            __facet,
            __generated_question,
            __final_question,
            __example_values,
            __frequency,
            __allowed_in_conversation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerativeQuestionConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "catalog" => Ok(__FieldTag::__catalog),
                            "facet" => Ok(__FieldTag::__facet),
                            "generatedQuestion" => Ok(__FieldTag::__generated_question),
                            "generated_question" => Ok(__FieldTag::__generated_question),
                            "finalQuestion" => Ok(__FieldTag::__final_question),
                            "final_question" => Ok(__FieldTag::__final_question),
                            "exampleValues" => Ok(__FieldTag::__example_values),
                            "example_values" => Ok(__FieldTag::__example_values),
                            "frequency" => Ok(__FieldTag::__frequency),
                            "allowedInConversation" => Ok(__FieldTag::__allowed_in_conversation),
                            "allowed_in_conversation" => Ok(__FieldTag::__allowed_in_conversation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerativeQuestionConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerativeQuestionConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__catalog => {
                            if !fields.insert(__FieldTag::__catalog) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for catalog",
                                ));
                            }
                            result.catalog = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__facet => {
                            if !fields.insert(__FieldTag::__facet) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for facet",
                                ));
                            }
                            result.facet = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generated_question => {
                            if !fields.insert(__FieldTag::__generated_question) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generated_question",
                                ));
                            }
                            result.generated_question = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__final_question => {
                            if !fields.insert(__FieldTag::__final_question) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for final_question",
                                ));
                            }
                            result.final_question = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__example_values => {
                            if !fields.insert(__FieldTag::__example_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for example_values",
                                ));
                            }
                            result.example_values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__frequency => {
                            if !fields.insert(__FieldTag::__frequency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for frequency",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.frequency = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__allowed_in_conversation => {
                            if !fields.insert(__FieldTag::__allowed_in_conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_in_conversation",
                                ));
                            }
                            result.allowed_in_conversation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerativeQuestionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.catalog.is_empty() {
            state.serialize_entry("catalog", &self.catalog)?;
        }
        if !self.facet.is_empty() {
            state.serialize_entry("facet", &self.facet)?;
        }
        if !self.generated_question.is_empty() {
            state.serialize_entry("generatedQuestion", &self.generated_question)?;
        }
        if !self.final_question.is_empty() {
            state.serialize_entry("finalQuestion", &self.final_question)?;
        }
        if !self.example_values.is_empty() {
            state.serialize_entry("exampleValues", &self.example_values)?;
        }
        if !wkt::internal::is_default(&self.frequency) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("frequency", &__With(&self.frequency))?;
        }
        if !wkt::internal::is_default(&self.allowed_in_conversation) {
            state.serialize_entry("allowedInConversation", &self.allowed_in_conversation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GenerativeQuestionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerativeQuestionConfig");
        debug_struct.field("catalog", &self.catalog);
        debug_struct.field("facet", &self.facet);
        debug_struct.field("generated_question", &self.generated_question);
        debug_struct.field("final_question", &self.final_question);
        debug_struct.field("example_values", &self.example_values);
        debug_struct.field("frequency", &self.frequency);
        debug_struct.field("allowed_in_conversation", &self.allowed_in_conversation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for UpdateGenerativeQuestionsFeatureConfig method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateGenerativeQuestionsFeatureConfigRequest {
    /// Required. The configuration managing the feature state.
    pub generative_questions_feature_config:
        std::option::Option<crate::model::GenerativeQuestionsFeatureConfig>,

    /// Optional. Indicates which fields in the provided
    /// [GenerativeQuestionsFeatureConfig][google.cloud.retail.v2.GenerativeQuestionsFeatureConfig]
    /// to update. If not set or empty, all supported fields are updated.
    ///
    /// [google.cloud.retail.v2.GenerativeQuestionsFeatureConfig]: crate::model::GenerativeQuestionsFeatureConfig
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateGenerativeQuestionsFeatureConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generative_questions_feature_config][crate::model::UpdateGenerativeQuestionsFeatureConfigRequest::generative_questions_feature_config].
    pub fn set_generative_questions_feature_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GenerativeQuestionsFeatureConfig>,
    {
        self.generative_questions_feature_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [generative_questions_feature_config][crate::model::UpdateGenerativeQuestionsFeatureConfigRequest::generative_questions_feature_config].
    pub fn set_or_clear_generative_questions_feature_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::GenerativeQuestionsFeatureConfig>,
    {
        self.generative_questions_feature_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateGenerativeQuestionsFeatureConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateGenerativeQuestionsFeatureConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateGenerativeQuestionsFeatureConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.UpdateGenerativeQuestionsFeatureConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateGenerativeQuestionsFeatureConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __generative_questions_feature_config,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for UpdateGenerativeQuestionsFeatureConfigRequest",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "generativeQuestionsFeatureConfig" => {
                                Ok(__FieldTag::__generative_questions_feature_config)
                            }
                            "generative_questions_feature_config" => {
                                Ok(__FieldTag::__generative_questions_feature_config)
                            }
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateGenerativeQuestionsFeatureConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateGenerativeQuestionsFeatureConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__generative_questions_feature_config => {
                            if !fields.insert(__FieldTag::__generative_questions_feature_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generative_questions_feature_config",
                                ));
                            }
                            result.generative_questions_feature_config = map
                                .next_value::<std::option::Option<
                                    crate::model::GenerativeQuestionsFeatureConfig,
                                >>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateGenerativeQuestionsFeatureConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.generative_questions_feature_config.is_some() {
            state.serialize_entry(
                "generativeQuestionsFeatureConfig",
                &self.generative_questions_feature_config,
            )?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateGenerativeQuestionsFeatureConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateGenerativeQuestionsFeatureConfigRequest");
        debug_struct.field(
            "generative_questions_feature_config",
            &self.generative_questions_feature_config,
        );
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for GetGenerativeQuestionsFeatureConfig method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetGenerativeQuestionsFeatureConfigRequest {
    /// Required. Resource name of the parent catalog.
    /// Format: projects/{project}/locations/{location}/catalogs/{catalog}
    pub catalog: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetGenerativeQuestionsFeatureConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [catalog][crate::model::GetGenerativeQuestionsFeatureConfigRequest::catalog].
    pub fn set_catalog<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.catalog = v.into();
        self
    }
}

impl wkt::message::Message for GetGenerativeQuestionsFeatureConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.GetGenerativeQuestionsFeatureConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetGenerativeQuestionsFeatureConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __catalog,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for GetGenerativeQuestionsFeatureConfigRequest",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "catalog" => Ok(__FieldTag::__catalog),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetGenerativeQuestionsFeatureConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetGenerativeQuestionsFeatureConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__catalog => {
                            if !fields.insert(__FieldTag::__catalog) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for catalog",
                                ));
                            }
                            result.catalog = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetGenerativeQuestionsFeatureConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.catalog.is_empty() {
            state.serialize_entry("catalog", &self.catalog)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetGenerativeQuestionsFeatureConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetGenerativeQuestionsFeatureConfigRequest");
        debug_struct.field("catalog", &self.catalog);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for ListQuestions method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGenerativeQuestionConfigsRequest {
    /// Required. Resource name of the parent catalog.
    /// Format: projects/{project}/locations/{location}/catalogs/{catalog}
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGenerativeQuestionConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListGenerativeQuestionConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListGenerativeQuestionConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ListGenerativeQuestionConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGenerativeQuestionConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGenerativeQuestionConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGenerativeQuestionConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGenerativeQuestionConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGenerativeQuestionConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListGenerativeQuestionConfigsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListGenerativeQuestionConfigsRequest");
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for ListQuestions method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGenerativeQuestionConfigsResponse {
    /// All the questions for a given catalog.
    pub generative_question_configs: std::vec::Vec<crate::model::GenerativeQuestionConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGenerativeQuestionConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generative_question_configs][crate::model::ListGenerativeQuestionConfigsResponse::generative_question_configs].
    pub fn set_generative_question_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GenerativeQuestionConfig>,
    {
        use std::iter::Iterator;
        self.generative_question_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListGenerativeQuestionConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ListGenerativeQuestionConfigsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGenerativeQuestionConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __generative_question_configs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListGenerativeQuestionConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "generativeQuestionConfigs" => {
                                Ok(__FieldTag::__generative_question_configs)
                            }
                            "generative_question_configs" => {
                                Ok(__FieldTag::__generative_question_configs)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGenerativeQuestionConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGenerativeQuestionConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__generative_question_configs => {
                            if !fields.insert(__FieldTag::__generative_question_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generative_question_configs",
                                ));
                            }
                            result.generative_question_configs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::GenerativeQuestionConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGenerativeQuestionConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.generative_question_configs.is_empty() {
            state.serialize_entry(
                "generativeQuestionConfigs",
                &self.generative_question_configs,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListGenerativeQuestionConfigsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListGenerativeQuestionConfigsResponse");
        debug_struct.field(
            "generative_question_configs",
            &self.generative_question_configs,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for UpdateGenerativeQuestionConfig method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateGenerativeQuestionConfigRequest {
    /// Required. The question to update.
    pub generative_question_config: std::option::Option<crate::model::GenerativeQuestionConfig>,

    /// Optional. Indicates which fields in the provided
    /// [GenerativeQuestionConfig][google.cloud.retail.v2.GenerativeQuestionConfig]
    /// to update. The following are NOT supported:
    ///
    /// * [GenerativeQuestionConfig.frequency][google.cloud.retail.v2.GenerativeQuestionConfig.frequency]
    ///
    /// If not set or empty, all supported fields are updated.
    ///
    /// [google.cloud.retail.v2.GenerativeQuestionConfig]: crate::model::GenerativeQuestionConfig
    /// [google.cloud.retail.v2.GenerativeQuestionConfig.frequency]: crate::model::GenerativeQuestionConfig::frequency
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateGenerativeQuestionConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generative_question_config][crate::model::UpdateGenerativeQuestionConfigRequest::generative_question_config].
    pub fn set_generative_question_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GenerativeQuestionConfig>,
    {
        self.generative_question_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [generative_question_config][crate::model::UpdateGenerativeQuestionConfigRequest::generative_question_config].
    pub fn set_or_clear_generative_question_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GenerativeQuestionConfig>,
    {
        self.generative_question_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateGenerativeQuestionConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateGenerativeQuestionConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateGenerativeQuestionConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.UpdateGenerativeQuestionConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateGenerativeQuestionConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __generative_question_config,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for UpdateGenerativeQuestionConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "generativeQuestionConfig" => {
                                Ok(__FieldTag::__generative_question_config)
                            }
                            "generative_question_config" => {
                                Ok(__FieldTag::__generative_question_config)
                            }
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateGenerativeQuestionConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateGenerativeQuestionConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__generative_question_config => {
                            if !fields.insert(__FieldTag::__generative_question_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generative_question_config",
                                ));
                            }
                            result.generative_question_config = map.next_value::<std::option::Option<crate::model::GenerativeQuestionConfig>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateGenerativeQuestionConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.generative_question_config.is_some() {
            state.serialize_entry("generativeQuestionConfig", &self.generative_question_config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateGenerativeQuestionConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateGenerativeQuestionConfigRequest");
        debug_struct.field(
            "generative_question_config",
            &self.generative_question_config,
        );
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for BatchUpdateGenerativeQuestionConfig method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchUpdateGenerativeQuestionConfigsRequest {
    /// Optional. Resource name of the parent catalog.
    /// Format: projects/{project}/locations/{location}/catalogs/{catalog}
    pub parent: std::string::String,

    /// Required. The updates question configs.
    pub requests: std::vec::Vec<crate::model::UpdateGenerativeQuestionConfigRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchUpdateGenerativeQuestionConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchUpdateGenerativeQuestionConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [requests][crate::model::BatchUpdateGenerativeQuestionConfigsRequest::requests].
    pub fn set_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UpdateGenerativeQuestionConfigRequest>,
    {
        use std::iter::Iterator;
        self.requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchUpdateGenerativeQuestionConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.BatchUpdateGenerativeQuestionConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchUpdateGenerativeQuestionConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __requests,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for BatchUpdateGenerativeQuestionConfigsRequest",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "requests" => Ok(__FieldTag::__requests),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchUpdateGenerativeQuestionConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchUpdateGenerativeQuestionConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requests => {
                            if !fields.insert(__FieldTag::__requests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requests",
                                ));
                            }
                            result.requests = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::UpdateGenerativeQuestionConfigRequest,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchUpdateGenerativeQuestionConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.requests.is_empty() {
            state.serialize_entry("requests", &self.requests)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchUpdateGenerativeQuestionConfigsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchUpdateGenerativeQuestionConfigsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("requests", &self.requests);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Aggregated response for UpdateGenerativeQuestionConfig method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchUpdateGenerativeQuestionConfigsResponse {
    /// Optional. The updates question configs.
    pub generative_question_configs: std::vec::Vec<crate::model::GenerativeQuestionConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchUpdateGenerativeQuestionConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generative_question_configs][crate::model::BatchUpdateGenerativeQuestionConfigsResponse::generative_question_configs].
    pub fn set_generative_question_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GenerativeQuestionConfig>,
    {
        use std::iter::Iterator;
        self.generative_question_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchUpdateGenerativeQuestionConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.BatchUpdateGenerativeQuestionConfigsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchUpdateGenerativeQuestionConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __generative_question_configs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for BatchUpdateGenerativeQuestionConfigsResponse",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "generativeQuestionConfigs" => {
                                Ok(__FieldTag::__generative_question_configs)
                            }
                            "generative_question_configs" => {
                                Ok(__FieldTag::__generative_question_configs)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchUpdateGenerativeQuestionConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchUpdateGenerativeQuestionConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__generative_question_configs => {
                            if !fields.insert(__FieldTag::__generative_question_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generative_question_configs",
                                ));
                            }
                            result.generative_question_configs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::GenerativeQuestionConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchUpdateGenerativeQuestionConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.generative_question_configs.is_empty() {
            state.serialize_entry(
                "generativeQuestionConfigs",
                &self.generative_question_configs,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BatchUpdateGenerativeQuestionConfigsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BatchUpdateGenerativeQuestionConfigsResponse");
        debug_struct.field(
            "generative_question_configs",
            &self.generative_question_configs,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Google Cloud Storage location for input content.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsSource {
    /// Required. Google Cloud Storage URIs to input files. URI can be up to
    /// 2000 characters long. URIs can match the full object path (for example,
    /// `gs://bucket/directory/object.json`) or a pattern matching one or more
    /// files, such as `gs://bucket/directory/*.json`. A request can
    /// contain at most 100 files, and each file can be up to 2 GB. See
    /// [Importing product
    /// information](https://cloud.google.com/retail/recommendations-ai/docs/upload-catalog)
    /// for the expected file format and setup instructions.
    pub input_uris: std::vec::Vec<std::string::String>,

    /// The schema to use when parsing the data from the source.
    ///
    /// Supported values for product imports:
    ///
    /// * `product` (default): One JSON [Product][google.cloud.retail.v2.Product]
    ///   per line. Each product must
    ///   have a valid [Product.id][google.cloud.retail.v2.Product.id].
    /// * `product_merchant_center`: See [Importing catalog data from Merchant
    ///   Center](https://cloud.google.com/retail/recommendations-ai/docs/upload-catalog#mc).
    ///
    /// Supported values for user events imports:
    ///
    /// * `user_event` (default): One JSON
    ///   [UserEvent][google.cloud.retail.v2.UserEvent] per line.
    /// * `user_event_ga360`: Using
    ///   <https://support.google.com/analytics/answer/3437719>.
    ///
    /// Supported values for control imports:
    ///
    /// * `control` (default): One JSON [Control][google.cloud.retail.v2.Control]
    ///   per line.
    ///
    /// Supported values for catalog attribute imports:
    ///
    /// * `catalog_attribute` (default): One CSV
    ///   [CatalogAttribute][google.cloud.retail.v2.CatalogAttribute] per line.
    ///
    /// [google.cloud.retail.v2.CatalogAttribute]: crate::model::CatalogAttribute
    /// [google.cloud.retail.v2.Control]: crate::model::Control
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.Product.id]: crate::model::Product::id
    /// [google.cloud.retail.v2.UserEvent]: crate::model::UserEvent
    pub data_schema: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input_uris][crate::model::GcsSource::input_uris].
    pub fn set_input_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.input_uris = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [data_schema][crate::model::GcsSource::data_schema].
    pub fn set_data_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_schema = v.into();
        self
    }
}

impl wkt::message::Message for GcsSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.GcsSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __input_uris,
            __data_schema,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inputUris" => Ok(__FieldTag::__input_uris),
                            "input_uris" => Ok(__FieldTag::__input_uris),
                            "dataSchema" => Ok(__FieldTag::__data_schema),
                            "data_schema" => Ok(__FieldTag::__data_schema),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__input_uris => {
                            if !fields.insert(__FieldTag::__input_uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_uris",
                                ));
                            }
                            result.input_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__data_schema => {
                            if !fields.insert(__FieldTag::__data_schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_schema",
                                ));
                            }
                            result.data_schema = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.input_uris.is_empty() {
            state.serialize_entry("inputUris", &self.input_uris)?;
        }
        if !self.data_schema.is_empty() {
            state.serialize_entry("dataSchema", &self.data_schema)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GcsSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsSource");
        debug_struct.field("input_uris", &self.input_uris);
        debug_struct.field("data_schema", &self.data_schema);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// BigQuery source import data from.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BigQuerySource {
    /// The project ID (can be project # or ID) that the BigQuery source is in with
    /// a length limit of 128 characters. If not specified, inherits the project
    /// ID from the parent request.
    pub project_id: std::string::String,

    /// Required. The BigQuery data set to copy the data from with a length limit
    /// of 1,024 characters.
    pub dataset_id: std::string::String,

    /// Required. The BigQuery table to copy the data from with a length limit of
    /// 1,024 characters.
    pub table_id: std::string::String,

    /// Intermediate Cloud Storage directory used for the import with a length
    /// limit of 2,000 characters. Can be specified if one wants to have the
    /// BigQuery export to a specific Cloud Storage directory.
    pub gcs_staging_dir: std::string::String,

    /// The schema to use when parsing the data from the source.
    ///
    /// Supported values for product imports:
    ///
    /// * `product` (default): One JSON [Product][google.cloud.retail.v2.Product]
    ///   per line. Each product must
    ///   have a valid [Product.id][google.cloud.retail.v2.Product.id].
    /// * `product_merchant_center`: See [Importing catalog data from Merchant
    ///   Center](https://cloud.google.com/retail/recommendations-ai/docs/upload-catalog#mc).
    ///
    /// Supported values for user events imports:
    ///
    /// * `user_event` (default): One JSON
    ///   [UserEvent][google.cloud.retail.v2.UserEvent] per line.
    /// * `user_event_ga360`:
    ///   The schema is available here:
    ///   <https://support.google.com/analytics/answer/3437719>.
    /// * `user_event_ga4`:
    ///   The schema is available here:
    ///   <https://support.google.com/analytics/answer/7029846>.
    ///
    /// Supported values for autocomplete imports:
    ///
    /// * `suggestions` (default): One JSON completion suggestion per line.
    /// * `denylist`:  One JSON deny suggestion per line.
    /// * `allowlist`:  One JSON allow suggestion per line.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.Product.id]: crate::model::Product::id
    /// [google.cloud.retail.v2.UserEvent]: crate::model::UserEvent
    pub data_schema: std::string::String,

    /// BigQuery table partition info. Leave this empty if the BigQuery table
    /// is not partitioned.
    pub partition: std::option::Option<crate::model::big_query_source::Partition>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BigQuerySource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::BigQuerySource::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::BigQuerySource::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::BigQuerySource::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [gcs_staging_dir][crate::model::BigQuerySource::gcs_staging_dir].
    pub fn set_gcs_staging_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcs_staging_dir = v.into();
        self
    }

    /// Sets the value of [data_schema][crate::model::BigQuerySource::data_schema].
    pub fn set_data_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_schema = v.into();
        self
    }

    /// Sets the value of [partition][crate::model::BigQuerySource::partition].
    ///
    /// Note that all the setters affecting `partition` are mutually
    /// exclusive.
    pub fn set_partition<
        T: std::convert::Into<std::option::Option<crate::model::big_query_source::Partition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.partition = v.into();
        self
    }

    /// The value of [partition][crate::model::BigQuerySource::partition]
    /// if it holds a `PartitionDate`, `None` if the field is not set or
    /// holds a different branch.
    pub fn partition_date(&self) -> std::option::Option<&std::boxed::Box<gtype::model::Date>> {
        #[allow(unreachable_patterns)]
        self.partition.as_ref().and_then(|v| match v {
            crate::model::big_query_source::Partition::PartitionDate(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [partition][crate::model::BigQuerySource::partition]
    /// to hold a `PartitionDate`.
    ///
    /// Note that all the setters affecting `partition` are
    /// mutually exclusive.
    pub fn set_partition_date<T: std::convert::Into<std::boxed::Box<gtype::model::Date>>>(
        mut self,
        v: T,
    ) -> Self {
        self.partition = std::option::Option::Some(
            crate::model::big_query_source::Partition::PartitionDate(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BigQuerySource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.BigQuerySource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BigQuerySource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __partition_date,
            __project_id,
            __dataset_id,
            __table_id,
            __gcs_staging_dir,
            __data_schema,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQuerySource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "partitionDate" => Ok(__FieldTag::__partition_date),
                            "partition_date" => Ok(__FieldTag::__partition_date),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "gcsStagingDir" => Ok(__FieldTag::__gcs_staging_dir),
                            "gcs_staging_dir" => Ok(__FieldTag::__gcs_staging_dir),
                            "dataSchema" => Ok(__FieldTag::__data_schema),
                            "data_schema" => Ok(__FieldTag::__data_schema),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BigQuerySource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQuerySource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__partition_date => {
                            if !fields.insert(__FieldTag::__partition_date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partition_date",
                                ));
                            }
                            if result.partition.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `partition`, a oneof with full ID .google.cloud.retail.v2.BigQuerySource.partition_date, latest field was partitionDate",
                                ));
                            }
                            result.partition =
                                std::option::Option::Some(
                                    crate::model::big_query_source::Partition::PartitionDate(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<gtype::model::Date>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcs_staging_dir => {
                            if !fields.insert(__FieldTag::__gcs_staging_dir) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_staging_dir",
                                ));
                            }
                            result.gcs_staging_dir = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_schema => {
                            if !fields.insert(__FieldTag::__data_schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_schema",
                                ));
                            }
                            result.data_schema = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BigQuerySource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.partition_date() {
            state.serialize_entry("partitionDate", value)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if !self.gcs_staging_dir.is_empty() {
            state.serialize_entry("gcsStagingDir", &self.gcs_staging_dir)?;
        }
        if !self.data_schema.is_empty() {
            state.serialize_entry("dataSchema", &self.data_schema)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BigQuerySource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BigQuerySource");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("dataset_id", &self.dataset_id);
        debug_struct.field("table_id", &self.table_id);
        debug_struct.field("gcs_staging_dir", &self.gcs_staging_dir);
        debug_struct.field("data_schema", &self.data_schema);
        debug_struct.field("partition", &self.partition);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [BigQuerySource].
pub mod big_query_source {
    #[allow(unused_imports)]
    use super::*;

    /// BigQuery table partition info. Leave this empty if the BigQuery table
    /// is not partitioned.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Partition {
        /// BigQuery time partitioned table's _PARTITIONDATE in YYYY-MM-DD format.
        PartitionDate(std::boxed::Box<gtype::model::Date>),
    }
}

/// The inline source for the input config for ImportProducts method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProductInlineSource {
    /// Required. A list of products to update/create. Each product must have a
    /// valid [Product.id][google.cloud.retail.v2.Product.id]. Recommended max of
    /// 100 items.
    ///
    /// [google.cloud.retail.v2.Product.id]: crate::model::Product::id
    pub products: std::vec::Vec<crate::model::Product>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProductInlineSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [products][crate::model::ProductInlineSource::products].
    pub fn set_products<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Product>,
    {
        use std::iter::Iterator;
        self.products = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ProductInlineSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ProductInlineSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProductInlineSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __products,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProductInlineSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "products" => Ok(__FieldTag::__products),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProductInlineSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProductInlineSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__products => {
                            if !fields.insert(__FieldTag::__products) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for products",
                                ));
                            }
                            result.products = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Product>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProductInlineSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.products.is_empty() {
            state.serialize_entry("products", &self.products)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ProductInlineSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProductInlineSource");
        debug_struct.field("products", &self.products);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The inline source for the input config for ImportUserEvents method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UserEventInlineSource {
    /// Required. A list of user events to import. Recommended max of 10k items.
    pub user_events: std::vec::Vec<crate::model::UserEvent>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserEventInlineSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_events][crate::model::UserEventInlineSource::user_events].
    pub fn set_user_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UserEvent>,
    {
        use std::iter::Iterator;
        self.user_events = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UserEventInlineSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.UserEventInlineSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UserEventInlineSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __user_events,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UserEventInlineSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "userEvents" => Ok(__FieldTag::__user_events),
                            "user_events" => Ok(__FieldTag::__user_events),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UserEventInlineSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UserEventInlineSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__user_events => {
                            if !fields.insert(__FieldTag::__user_events) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_events",
                                ));
                            }
                            result.user_events = map.next_value::<std::option::Option<std::vec::Vec<crate::model::UserEvent>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UserEventInlineSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.user_events.is_empty() {
            state.serialize_entry("userEvents", &self.user_events)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UserEventInlineSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UserEventInlineSource");
        debug_struct.field("user_events", &self.user_events);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration of destination for Import related errors.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportErrorsConfig {
    /// Required. Errors destination.
    pub destination: std::option::Option<crate::model::import_errors_config::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportErrorsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination][crate::model::ImportErrorsConfig::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::import_errors_config::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ImportErrorsConfig::destination]
    /// if it holds a `GcsPrefix`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_prefix(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::import_errors_config::Destination::GcsPrefix(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ImportErrorsConfig::destination]
    /// to hold a `GcsPrefix`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::import_errors_config::Destination::GcsPrefix(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImportErrorsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ImportErrorsConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportErrorsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_prefix,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportErrorsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsPrefix" => Ok(__FieldTag::__gcs_prefix),
                            "gcs_prefix" => Ok(__FieldTag::__gcs_prefix),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportErrorsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportErrorsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_prefix => {
                            if !fields.insert(__FieldTag::__gcs_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_prefix",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.retail.v2.ImportErrorsConfig.gcs_prefix, latest field was gcsPrefix",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::import_errors_config::Destination::GcsPrefix(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportErrorsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_prefix() {
            state.serialize_entry("gcsPrefix", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImportErrorsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportErrorsConfig");
        debug_struct.field("destination", &self.destination);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ImportErrorsConfig].
pub mod import_errors_config {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Errors destination.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Google Cloud Storage prefix for import errors. This must be an empty,
        /// existing Cloud Storage directory. Import errors are written to
        /// sharded files in this directory, one per line, as a JSON-encoded
        /// `google.rpc.Status` message.
        GcsPrefix(std::string::String),
    }
}

/// Request message for Import methods.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportProductsRequest {
    /// Required.
    /// `projects/1234/locations/global/catalogs/default_catalog/branches/default_branch`
    ///
    /// If no updateMask is specified, requires products.create permission.
    /// If updateMask is specified, requires products.update permission.
    pub parent: std::string::String,

    /// Deprecated. This field has no effect.
    #[deprecated]
    pub request_id: std::string::String,

    /// Required. The desired input location of the data.
    pub input_config: std::option::Option<crate::model::ProductInputConfig>,

    /// The desired location of errors incurred during the Import.
    pub errors_config: std::option::Option<crate::model::ImportErrorsConfig>,

    /// Indicates which fields in the provided imported `products` to update. If
    /// not set, all fields are updated. If provided, only the existing product
    /// fields are updated. Missing products will not be created.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// The mode of reconciliation between existing products and the products to be
    /// imported. Defaults to
    /// [ReconciliationMode.INCREMENTAL][google.cloud.retail.v2.ImportProductsRequest.ReconciliationMode.INCREMENTAL].
    ///
    /// [google.cloud.retail.v2.ImportProductsRequest.ReconciliationMode.INCREMENTAL]: crate::model::import_products_request::ReconciliationMode::Incremental
    pub reconciliation_mode: crate::model::import_products_request::ReconciliationMode,

    /// Full Pub/Sub topic name for receiving notification. If this field is set,
    /// when the import is finished, a notification is sent to
    /// specified Pub/Sub topic. The message data is JSON string of a
    /// [Operation][google.longrunning.Operation].
    ///
    /// Format of the Pub/Sub topic is `projects/{project}/topics/{topic}`. It has
    /// to be within the same project as
    /// [ImportProductsRequest.parent][google.cloud.retail.v2.ImportProductsRequest.parent].
    /// Make sure that both
    /// `cloud-retail-customer-data-access@system.gserviceaccount.com` and
    /// `service-<project number>@gcp-sa-retail.iam.gserviceaccount.com`
    /// have the `pubsub.topics.publish` IAM permission on the topic.
    ///
    /// Only supported when
    /// [ImportProductsRequest.reconciliation_mode][google.cloud.retail.v2.ImportProductsRequest.reconciliation_mode]
    /// is set to `FULL`.
    ///
    /// [google.cloud.retail.v2.ImportProductsRequest.parent]: crate::model::ImportProductsRequest::parent
    /// [google.cloud.retail.v2.ImportProductsRequest.reconciliation_mode]: crate::model::ImportProductsRequest::reconciliation_mode
    /// [google.longrunning.Operation]: longrunning::model::Operation
    pub notification_pubsub_topic: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportProductsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportProductsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::ImportProductsRequest::request_id].
    #[deprecated]
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [input_config][crate::model::ImportProductsRequest::input_config].
    pub fn set_input_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ProductInputConfig>,
    {
        self.input_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [input_config][crate::model::ImportProductsRequest::input_config].
    pub fn set_or_clear_input_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ProductInputConfig>,
    {
        self.input_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [errors_config][crate::model::ImportProductsRequest::errors_config].
    pub fn set_errors_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorsConfig>,
    {
        self.errors_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [errors_config][crate::model::ImportProductsRequest::errors_config].
    pub fn set_or_clear_errors_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorsConfig>,
    {
        self.errors_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::ImportProductsRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::ImportProductsRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [reconciliation_mode][crate::model::ImportProductsRequest::reconciliation_mode].
    pub fn set_reconciliation_mode<
        T: std::convert::Into<crate::model::import_products_request::ReconciliationMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reconciliation_mode = v.into();
        self
    }

    /// Sets the value of [notification_pubsub_topic][crate::model::ImportProductsRequest::notification_pubsub_topic].
    pub fn set_notification_pubsub_topic<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.notification_pubsub_topic = v.into();
        self
    }
}

impl wkt::message::Message for ImportProductsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ImportProductsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportProductsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __request_id,
            __input_config,
            __errors_config,
            __update_mask,
            __reconciliation_mode,
            __notification_pubsub_topic,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportProductsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "inputConfig" => Ok(__FieldTag::__input_config),
                            "input_config" => Ok(__FieldTag::__input_config),
                            "errorsConfig" => Ok(__FieldTag::__errors_config),
                            "errors_config" => Ok(__FieldTag::__errors_config),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "reconciliationMode" => Ok(__FieldTag::__reconciliation_mode),
                            "reconciliation_mode" => Ok(__FieldTag::__reconciliation_mode),
                            "notificationPubsubTopic" => {
                                Ok(__FieldTag::__notification_pubsub_topic)
                            }
                            "notification_pubsub_topic" => {
                                Ok(__FieldTag::__notification_pubsub_topic)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportProductsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportProductsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__input_config => {
                            if !fields.insert(__FieldTag::__input_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_config",
                                ));
                            }
                            result.input_config = map.next_value::<std::option::Option<crate::model::ProductInputConfig>>()?
                                ;
                        }
                        __FieldTag::__errors_config => {
                            if !fields.insert(__FieldTag::__errors_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors_config",
                                ));
                            }
                            result.errors_config = map.next_value::<std::option::Option<crate::model::ImportErrorsConfig>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__reconciliation_mode => {
                            if !fields.insert(__FieldTag::__reconciliation_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciliation_mode",
                                ));
                            }
                            result.reconciliation_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::import_products_request::ReconciliationMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__notification_pubsub_topic => {
                            if !fields.insert(__FieldTag::__notification_pubsub_topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notification_pubsub_topic",
                                ));
                            }
                            result.notification_pubsub_topic = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportProductsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if self.input_config.is_some() {
            state.serialize_entry("inputConfig", &self.input_config)?;
        }
        if self.errors_config.is_some() {
            state.serialize_entry("errorsConfig", &self.errors_config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.reconciliation_mode) {
            state.serialize_entry("reconciliationMode", &self.reconciliation_mode)?;
        }
        if !self.notification_pubsub_topic.is_empty() {
            state.serialize_entry("notificationPubsubTopic", &self.notification_pubsub_topic)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImportProductsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportProductsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("input_config", &self.input_config);
        debug_struct.field("errors_config", &self.errors_config);
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("reconciliation_mode", &self.reconciliation_mode);
        debug_struct.field("notification_pubsub_topic", &self.notification_pubsub_topic);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ImportProductsRequest].
pub mod import_products_request {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates how imported products are reconciled with the existing products
    /// created or imported before.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ReconciliationMode {
        /// Defaults to INCREMENTAL.
        Unspecified,
        /// Inserts new products or updates existing products.
        Incremental,
        /// Calculates diff and replaces the entire product dataset. Existing
        /// products may be deleted if they are not present in the source location.
        Full,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ReconciliationMode::value] or
        /// [ReconciliationMode::name].
        UnknownValue(reconciliation_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod reconciliation_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ReconciliationMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Incremental => std::option::Option::Some(1),
                Self::Full => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RECONCILIATION_MODE_UNSPECIFIED"),
                Self::Incremental => std::option::Option::Some("INCREMENTAL"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ReconciliationMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ReconciliationMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ReconciliationMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Incremental,
                2 => Self::Full,
                _ => Self::UnknownValue(reconciliation_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ReconciliationMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RECONCILIATION_MODE_UNSPECIFIED" => Self::Unspecified,
                "INCREMENTAL" => Self::Incremental,
                "FULL" => Self::Full,
                _ => Self::UnknownValue(reconciliation_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ReconciliationMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Incremental => serializer.serialize_i32(1),
                Self::Full => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ReconciliationMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ReconciliationMode>::new(
                ".google.cloud.retail.v2.ImportProductsRequest.ReconciliationMode",
            ))
        }
    }
}

/// Request message for the ImportUserEvents request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportUserEventsRequest {
    /// Required. `projects/1234/locations/global/catalogs/default_catalog`
    pub parent: std::string::String,

    /// Required. The desired input location of the data.
    pub input_config: std::option::Option<crate::model::UserEventInputConfig>,

    /// The desired location of errors incurred during the Import. Cannot be set
    /// for inline user event imports.
    pub errors_config: std::option::Option<crate::model::ImportErrorsConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportUserEventsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportUserEventsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [input_config][crate::model::ImportUserEventsRequest::input_config].
    pub fn set_input_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserEventInputConfig>,
    {
        self.input_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [input_config][crate::model::ImportUserEventsRequest::input_config].
    pub fn set_or_clear_input_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserEventInputConfig>,
    {
        self.input_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [errors_config][crate::model::ImportUserEventsRequest::errors_config].
    pub fn set_errors_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorsConfig>,
    {
        self.errors_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [errors_config][crate::model::ImportUserEventsRequest::errors_config].
    pub fn set_or_clear_errors_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorsConfig>,
    {
        self.errors_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ImportUserEventsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ImportUserEventsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportUserEventsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __input_config,
            __errors_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportUserEventsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "inputConfig" => Ok(__FieldTag::__input_config),
                            "input_config" => Ok(__FieldTag::__input_config),
                            "errorsConfig" => Ok(__FieldTag::__errors_config),
                            "errors_config" => Ok(__FieldTag::__errors_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportUserEventsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportUserEventsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__input_config => {
                            if !fields.insert(__FieldTag::__input_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_config",
                                ));
                            }
                            result.input_config = map.next_value::<std::option::Option<crate::model::UserEventInputConfig>>()?
                                ;
                        }
                        __FieldTag::__errors_config => {
                            if !fields.insert(__FieldTag::__errors_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors_config",
                                ));
                            }
                            result.errors_config = map.next_value::<std::option::Option<crate::model::ImportErrorsConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportUserEventsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.input_config.is_some() {
            state.serialize_entry("inputConfig", &self.input_config)?;
        }
        if self.errors_config.is_some() {
            state.serialize_entry("errorsConfig", &self.errors_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImportUserEventsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportUserEventsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("input_config", &self.input_config);
        debug_struct.field("errors_config", &self.errors_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for ImportCompletionData methods.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportCompletionDataRequest {
    /// Required. The catalog which the suggestions dataset belongs to.
    ///
    /// Format: `projects/1234/locations/global/catalogs/default_catalog`.
    pub parent: std::string::String,

    /// Required. The desired input location of the data.
    pub input_config: std::option::Option<crate::model::CompletionDataInputConfig>,

    /// Pub/Sub topic for receiving notification. If this field is set,
    /// when the import is finished, a notification is sent to
    /// specified Pub/Sub topic. The message data is JSON string of a
    /// [Operation][google.longrunning.Operation].
    /// Format of the Pub/Sub topic is `projects/{project}/topics/{topic}`.
    ///
    /// [google.longrunning.Operation]: longrunning::model::Operation
    pub notification_pubsub_topic: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportCompletionDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportCompletionDataRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [input_config][crate::model::ImportCompletionDataRequest::input_config].
    pub fn set_input_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CompletionDataInputConfig>,
    {
        self.input_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [input_config][crate::model::ImportCompletionDataRequest::input_config].
    pub fn set_or_clear_input_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CompletionDataInputConfig>,
    {
        self.input_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [notification_pubsub_topic][crate::model::ImportCompletionDataRequest::notification_pubsub_topic].
    pub fn set_notification_pubsub_topic<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.notification_pubsub_topic = v.into();
        self
    }
}

impl wkt::message::Message for ImportCompletionDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ImportCompletionDataRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportCompletionDataRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __input_config,
            __notification_pubsub_topic,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportCompletionDataRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "inputConfig" => Ok(__FieldTag::__input_config),
                            "input_config" => Ok(__FieldTag::__input_config),
                            "notificationPubsubTopic" => {
                                Ok(__FieldTag::__notification_pubsub_topic)
                            }
                            "notification_pubsub_topic" => {
                                Ok(__FieldTag::__notification_pubsub_topic)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportCompletionDataRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportCompletionDataRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__input_config => {
                            if !fields.insert(__FieldTag::__input_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_config",
                                ));
                            }
                            result.input_config = map.next_value::<std::option::Option<crate::model::CompletionDataInputConfig>>()?
                                ;
                        }
                        __FieldTag::__notification_pubsub_topic => {
                            if !fields.insert(__FieldTag::__notification_pubsub_topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notification_pubsub_topic",
                                ));
                            }
                            result.notification_pubsub_topic = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportCompletionDataRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.input_config.is_some() {
            state.serialize_entry("inputConfig", &self.input_config)?;
        }
        if !self.notification_pubsub_topic.is_empty() {
            state.serialize_entry("notificationPubsubTopic", &self.notification_pubsub_topic)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImportCompletionDataRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportCompletionDataRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("input_config", &self.input_config);
        debug_struct.field("notification_pubsub_topic", &self.notification_pubsub_topic);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The input config source for products.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProductInputConfig {
    /// Required. The source of the input.
    pub source: std::option::Option<crate::model::product_input_config::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProductInputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::ProductInputConfig::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::product_input_config::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ProductInputConfig::source]
    /// if it holds a `ProductInlineSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn product_inline_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ProductInlineSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::product_input_config::Source::ProductInlineSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ProductInputConfig::source]
    /// to hold a `ProductInlineSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_product_inline_source<
        T: std::convert::Into<std::boxed::Box<crate::model::ProductInlineSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::product_input_config::Source::ProductInlineSource(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::ProductInputConfig::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::product_input_config::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ProductInputConfig::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::product_input_config::Source::GcsSource(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::ProductInputConfig::source]
    /// if it holds a `BigQuerySource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn big_query_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQuerySource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::product_input_config::Source::BigQuerySource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ProductInputConfig::source]
    /// to hold a `BigQuerySource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_big_query_source<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQuerySource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::product_input_config::Source::BigQuerySource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ProductInputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ProductInputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProductInputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __product_inline_source,
            __gcs_source,
            __big_query_source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProductInputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "productInlineSource" => Ok(__FieldTag::__product_inline_source),
                            "product_inline_source" => Ok(__FieldTag::__product_inline_source),
                            "gcsSource" => Ok(__FieldTag::__gcs_source),
                            "gcs_source" => Ok(__FieldTag::__gcs_source),
                            "bigQuerySource" => Ok(__FieldTag::__big_query_source),
                            "big_query_source" => Ok(__FieldTag::__big_query_source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProductInputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProductInputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__product_inline_source => {
                            if !fields.insert(__FieldTag::__product_inline_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product_inline_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.retail.v2.ProductInputConfig.product_inline_source, latest field was productInlineSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::product_input_config::Source::ProductInlineSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ProductInlineSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__gcs_source => {
                            if !fields.insert(__FieldTag::__gcs_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.retail.v2.ProductInputConfig.gcs_source, latest field was gcsSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::product_input_config::Source::GcsSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__big_query_source => {
                            if !fields.insert(__FieldTag::__big_query_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for big_query_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.retail.v2.ProductInputConfig.big_query_source, latest field was bigQuerySource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::product_input_config::Source::BigQuerySource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BigQuerySource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProductInputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.product_inline_source() {
            state.serialize_entry("productInlineSource", value)?;
        }
        if let Some(value) = self.gcs_source() {
            state.serialize_entry("gcsSource", value)?;
        }
        if let Some(value) = self.big_query_source() {
            state.serialize_entry("bigQuerySource", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ProductInputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProductInputConfig");
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ProductInputConfig].
pub mod product_input_config {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The source of the input.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// The Inline source for the input content for products.
        ProductInlineSource(std::boxed::Box<crate::model::ProductInlineSource>),
        /// Google Cloud Storage location for the input content.
        GcsSource(std::boxed::Box<crate::model::GcsSource>),
        /// BigQuery input source.
        BigQuerySource(std::boxed::Box<crate::model::BigQuerySource>),
    }
}

/// The input config source for user events.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UserEventInputConfig {
    /// The source of the input.
    pub source: std::option::Option<crate::model::user_event_input_config::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserEventInputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::UserEventInputConfig::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::user_event_input_config::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::UserEventInputConfig::source]
    /// if it holds a `UserEventInlineSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn user_event_inline_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::UserEventInlineSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::user_event_input_config::Source::UserEventInlineSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::UserEventInputConfig::source]
    /// to hold a `UserEventInlineSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_user_event_inline_source<
        T: std::convert::Into<std::boxed::Box<crate::model::UserEventInlineSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::user_event_input_config::Source::UserEventInlineSource(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::UserEventInputConfig::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::user_event_input_config::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::UserEventInputConfig::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSource>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::user_event_input_config::Source::GcsSource(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::UserEventInputConfig::source]
    /// if it holds a `BigQuerySource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn big_query_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQuerySource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::user_event_input_config::Source::BigQuerySource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::UserEventInputConfig::source]
    /// to hold a `BigQuerySource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_big_query_source<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQuerySource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::user_event_input_config::Source::BigQuerySource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for UserEventInputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.UserEventInputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UserEventInputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __user_event_inline_source,
            __gcs_source,
            __big_query_source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UserEventInputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "userEventInlineSource" => Ok(__FieldTag::__user_event_inline_source),
                            "user_event_inline_source" => {
                                Ok(__FieldTag::__user_event_inline_source)
                            }
                            "gcsSource" => Ok(__FieldTag::__gcs_source),
                            "gcs_source" => Ok(__FieldTag::__gcs_source),
                            "bigQuerySource" => Ok(__FieldTag::__big_query_source),
                            "big_query_source" => Ok(__FieldTag::__big_query_source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UserEventInputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UserEventInputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__user_event_inline_source => {
                            if !fields.insert(__FieldTag::__user_event_inline_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_event_inline_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.retail.v2.UserEventInputConfig.user_event_inline_source, latest field was userEventInlineSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::user_event_input_config::Source::UserEventInlineSource(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::UserEventInlineSource>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__gcs_source => {
                            if !fields.insert(__FieldTag::__gcs_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.retail.v2.UserEventInputConfig.gcs_source, latest field was gcsSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::user_event_input_config::Source::GcsSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__big_query_source => {
                            if !fields.insert(__FieldTag::__big_query_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for big_query_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.retail.v2.UserEventInputConfig.big_query_source, latest field was bigQuerySource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::user_event_input_config::Source::BigQuerySource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BigQuerySource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UserEventInputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.user_event_inline_source() {
            state.serialize_entry("userEventInlineSource", value)?;
        }
        if let Some(value) = self.gcs_source() {
            state.serialize_entry("gcsSource", value)?;
        }
        if let Some(value) = self.big_query_source() {
            state.serialize_entry("bigQuerySource", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UserEventInputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UserEventInputConfig");
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [UserEventInputConfig].
pub mod user_event_input_config {
    #[allow(unused_imports)]
    use super::*;

    /// The source of the input.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Required. The Inline source for the input content for UserEvents.
        UserEventInlineSource(std::boxed::Box<crate::model::UserEventInlineSource>),
        /// Required. Google Cloud Storage location for the input content.
        GcsSource(std::boxed::Box<crate::model::GcsSource>),
        /// Required. BigQuery input source.
        BigQuerySource(std::boxed::Box<crate::model::BigQuerySource>),
    }
}

/// The input config source for completion data.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CompletionDataInputConfig {
    /// The source of the input.
    ///
    /// Supported
    /// [BigQuerySource.data_schema][google.cloud.retail.v2.BigQuerySource.data_schema]
    /// values for suggestions imports:
    ///
    /// * `suggestions` (default): One JSON completion suggestion per line.
    /// * `denylist`:  One JSON deny suggestion per line.
    /// * `allowlist`:  One JSON allow suggestion per line.
    ///
    /// [google.cloud.retail.v2.BigQuerySource.data_schema]: crate::model::BigQuerySource::data_schema
    pub source: std::option::Option<crate::model::completion_data_input_config::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CompletionDataInputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::CompletionDataInputConfig::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::completion_data_input_config::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::CompletionDataInputConfig::source]
    /// if it holds a `BigQuerySource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn big_query_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::BigQuerySource>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::completion_data_input_config::Source::BigQuerySource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::CompletionDataInputConfig::source]
    /// to hold a `BigQuerySource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_big_query_source<
        T: std::convert::Into<std::boxed::Box<crate::model::BigQuerySource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::completion_data_input_config::Source::BigQuerySource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CompletionDataInputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.CompletionDataInputConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CompletionDataInputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __big_query_source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompletionDataInputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bigQuerySource" => Ok(__FieldTag::__big_query_source),
                            "big_query_source" => Ok(__FieldTag::__big_query_source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CompletionDataInputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompletionDataInputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__big_query_source => {
                            if !fields.insert(__FieldTag::__big_query_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for big_query_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.retail.v2.CompletionDataInputConfig.big_query_source, latest field was bigQuerySource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::completion_data_input_config::Source::BigQuerySource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BigQuerySource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CompletionDataInputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.big_query_source() {
            state.serialize_entry("bigQuerySource", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CompletionDataInputConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CompletionDataInputConfig");
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CompletionDataInputConfig].
pub mod completion_data_input_config {
    #[allow(unused_imports)]
    use super::*;

    /// The source of the input.
    ///
    /// Supported
    /// [BigQuerySource.data_schema][google.cloud.retail.v2.BigQuerySource.data_schema]
    /// values for suggestions imports:
    ///
    /// * `suggestions` (default): One JSON completion suggestion per line.
    /// * `denylist`:  One JSON deny suggestion per line.
    /// * `allowlist`:  One JSON allow suggestion per line.
    ///
    /// [google.cloud.retail.v2.BigQuerySource.data_schema]: crate::model::BigQuerySource::data_schema
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Required. BigQuery input source.
        ///
        /// Add the IAM permission "BigQuery Data Viewer" for
        /// cloud-retail-customer-data-access@system.gserviceaccount.com before
        /// using this feature otherwise an error is thrown.
        BigQuerySource(std::boxed::Box<crate::model::BigQuerySource>),
    }
}

/// Metadata related to the progress of the Import operation. This is
/// returned by the google.longrunning.Operation.metadata field.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportMetadata {
    /// Operation create time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Count of entries that were processed successfully.
    pub success_count: i64,

    /// Count of entries that encountered errors while processing.
    pub failure_count: i64,

    /// Deprecated. This field is never set.
    #[deprecated]
    pub request_id: std::string::String,

    /// Pub/Sub topic for receiving notification. If this field is set,
    /// when the import is finished, a notification is sent to
    /// specified Pub/Sub topic. The message data is JSON string of a
    /// [Operation][google.longrunning.Operation].
    /// Format of the Pub/Sub topic is `projects/{project}/topics/{topic}`.
    ///
    /// [google.longrunning.Operation]: longrunning::model::Operation
    pub notification_pubsub_topic: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::ImportMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ImportMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ImportMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ImportMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [success_count][crate::model::ImportMetadata::success_count].
    pub fn set_success_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.success_count = v.into();
        self
    }

    /// Sets the value of [failure_count][crate::model::ImportMetadata::failure_count].
    pub fn set_failure_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failure_count = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::ImportMetadata::request_id].
    #[deprecated]
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [notification_pubsub_topic][crate::model::ImportMetadata::notification_pubsub_topic].
    pub fn set_notification_pubsub_topic<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.notification_pubsub_topic = v.into();
        self
    }
}

impl wkt::message::Message for ImportMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ImportMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __update_time,
            __success_count,
            __failure_count,
            __request_id,
            __notification_pubsub_topic,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "successCount" => Ok(__FieldTag::__success_count),
                            "success_count" => Ok(__FieldTag::__success_count),
                            "failureCount" => Ok(__FieldTag::__failure_count),
                            "failure_count" => Ok(__FieldTag::__failure_count),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "notificationPubsubTopic" => {
                                Ok(__FieldTag::__notification_pubsub_topic)
                            }
                            "notification_pubsub_topic" => {
                                Ok(__FieldTag::__notification_pubsub_topic)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__success_count => {
                            if !fields.insert(__FieldTag::__success_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for success_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.success_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__failure_count => {
                            if !fields.insert(__FieldTag::__failure_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.failure_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__notification_pubsub_topic => {
                            if !fields.insert(__FieldTag::__notification_pubsub_topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notification_pubsub_topic",
                                ));
                            }
                            result.notification_pubsub_topic = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.success_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("successCount", &__With(&self.success_count))?;
        }
        if !wkt::internal::is_default(&self.failure_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failureCount", &__With(&self.failure_count))?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self.notification_pubsub_topic.is_empty() {
            state.serialize_entry("notificationPubsubTopic", &self.notification_pubsub_topic)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImportMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("success_count", &self.success_count);
        debug_struct.field("failure_count", &self.failure_count);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("notification_pubsub_topic", &self.notification_pubsub_topic);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response of the
/// [ImportProductsRequest][google.cloud.retail.v2.ImportProductsRequest]. If the
/// long running operation is done, then this message is returned by the
/// google.longrunning.Operations.response field if the operation was successful.
///
/// [google.cloud.retail.v2.ImportProductsRequest]: crate::model::ImportProductsRequest
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportProductsResponse {
    /// A sample of errors encountered while processing the request.
    pub error_samples: std::vec::Vec<rpc::model::Status>,

    /// Echoes the destination for the complete errors in the request if set.
    pub errors_config: std::option::Option<crate::model::ImportErrorsConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportProductsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_samples][crate::model::ImportProductsResponse::error_samples].
    pub fn set_error_samples<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.error_samples = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [errors_config][crate::model::ImportProductsResponse::errors_config].
    pub fn set_errors_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorsConfig>,
    {
        self.errors_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [errors_config][crate::model::ImportProductsResponse::errors_config].
    pub fn set_or_clear_errors_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorsConfig>,
    {
        self.errors_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ImportProductsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ImportProductsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportProductsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __error_samples,
            __errors_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportProductsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "errorSamples" => Ok(__FieldTag::__error_samples),
                            "error_samples" => Ok(__FieldTag::__error_samples),
                            "errorsConfig" => Ok(__FieldTag::__errors_config),
                            "errors_config" => Ok(__FieldTag::__errors_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportProductsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportProductsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__error_samples => {
                            if !fields.insert(__FieldTag::__error_samples) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_samples",
                                ));
                            }
                            result.error_samples = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__errors_config => {
                            if !fields.insert(__FieldTag::__errors_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors_config",
                                ));
                            }
                            result.errors_config = map.next_value::<std::option::Option<crate::model::ImportErrorsConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportProductsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.error_samples.is_empty() {
            state.serialize_entry("errorSamples", &self.error_samples)?;
        }
        if self.errors_config.is_some() {
            state.serialize_entry("errorsConfig", &self.errors_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImportProductsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportProductsResponse");
        debug_struct.field("error_samples", &self.error_samples);
        debug_struct.field("errors_config", &self.errors_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response of the ImportUserEventsRequest. If the long running
/// operation was successful, then this message is returned by the
/// google.longrunning.Operations.response field if the operation was successful.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportUserEventsResponse {
    /// A sample of errors encountered while processing the request.
    pub error_samples: std::vec::Vec<rpc::model::Status>,

    /// Echoes the destination for the complete errors if this field was set in
    /// the request.
    pub errors_config: std::option::Option<crate::model::ImportErrorsConfig>,

    /// Aggregated statistics of user event import status.
    pub import_summary: std::option::Option<crate::model::UserEventImportSummary>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportUserEventsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_samples][crate::model::ImportUserEventsResponse::error_samples].
    pub fn set_error_samples<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.error_samples = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [errors_config][crate::model::ImportUserEventsResponse::errors_config].
    pub fn set_errors_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorsConfig>,
    {
        self.errors_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [errors_config][crate::model::ImportUserEventsResponse::errors_config].
    pub fn set_or_clear_errors_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImportErrorsConfig>,
    {
        self.errors_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [import_summary][crate::model::ImportUserEventsResponse::import_summary].
    pub fn set_import_summary<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserEventImportSummary>,
    {
        self.import_summary = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [import_summary][crate::model::ImportUserEventsResponse::import_summary].
    pub fn set_or_clear_import_summary<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserEventImportSummary>,
    {
        self.import_summary = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ImportUserEventsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ImportUserEventsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportUserEventsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __error_samples,
            __errors_config,
            __import_summary,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportUserEventsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "errorSamples" => Ok(__FieldTag::__error_samples),
                            "error_samples" => Ok(__FieldTag::__error_samples),
                            "errorsConfig" => Ok(__FieldTag::__errors_config),
                            "errors_config" => Ok(__FieldTag::__errors_config),
                            "importSummary" => Ok(__FieldTag::__import_summary),
                            "import_summary" => Ok(__FieldTag::__import_summary),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportUserEventsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportUserEventsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__error_samples => {
                            if !fields.insert(__FieldTag::__error_samples) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_samples",
                                ));
                            }
                            result.error_samples = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__errors_config => {
                            if !fields.insert(__FieldTag::__errors_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors_config",
                                ));
                            }
                            result.errors_config = map.next_value::<std::option::Option<crate::model::ImportErrorsConfig>>()?
                                ;
                        }
                        __FieldTag::__import_summary => {
                            if !fields.insert(__FieldTag::__import_summary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_summary",
                                ));
                            }
                            result.import_summary = map.next_value::<std::option::Option<crate::model::UserEventImportSummary>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportUserEventsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.error_samples.is_empty() {
            state.serialize_entry("errorSamples", &self.error_samples)?;
        }
        if self.errors_config.is_some() {
            state.serialize_entry("errorsConfig", &self.errors_config)?;
        }
        if self.import_summary.is_some() {
            state.serialize_entry("importSummary", &self.import_summary)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImportUserEventsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportUserEventsResponse");
        debug_struct.field("error_samples", &self.error_samples);
        debug_struct.field("errors_config", &self.errors_config);
        debug_struct.field("import_summary", &self.import_summary);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A summary of import result. The UserEventImportSummary summarizes
/// the import status for user events.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UserEventImportSummary {
    /// Count of user events imported with complete existing catalog information.
    pub joined_events_count: i64,

    /// Count of user events imported, but with catalog information not found
    /// in the imported catalog.
    pub unjoined_events_count: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserEventImportSummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [joined_events_count][crate::model::UserEventImportSummary::joined_events_count].
    pub fn set_joined_events_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.joined_events_count = v.into();
        self
    }

    /// Sets the value of [unjoined_events_count][crate::model::UserEventImportSummary::unjoined_events_count].
    pub fn set_unjoined_events_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.unjoined_events_count = v.into();
        self
    }
}

impl wkt::message::Message for UserEventImportSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.UserEventImportSummary"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UserEventImportSummary {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __joined_events_count,
            __unjoined_events_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UserEventImportSummary")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "joinedEventsCount" => Ok(__FieldTag::__joined_events_count),
                            "joined_events_count" => Ok(__FieldTag::__joined_events_count),
                            "unjoinedEventsCount" => Ok(__FieldTag::__unjoined_events_count),
                            "unjoined_events_count" => Ok(__FieldTag::__unjoined_events_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UserEventImportSummary;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UserEventImportSummary")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__joined_events_count => {
                            if !fields.insert(__FieldTag::__joined_events_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for joined_events_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.joined_events_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__unjoined_events_count => {
                            if !fields.insert(__FieldTag::__unjoined_events_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unjoined_events_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.unjoined_events_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UserEventImportSummary {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.joined_events_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("joinedEventsCount", &__With(&self.joined_events_count))?;
        }
        if !wkt::internal::is_default(&self.unjoined_events_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("unjoinedEventsCount", &__With(&self.unjoined_events_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UserEventImportSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UserEventImportSummary");
        debug_struct.field("joined_events_count", &self.joined_events_count);
        debug_struct.field("unjoined_events_count", &self.unjoined_events_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response of the
/// [ImportCompletionDataRequest][google.cloud.retail.v2.ImportCompletionDataRequest].
/// If the long running operation is done, this message is returned by the
/// google.longrunning.Operations.response field if the operation is successful.
///
/// [google.cloud.retail.v2.ImportCompletionDataRequest]: crate::model::ImportCompletionDataRequest
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportCompletionDataResponse {
    /// A sample of errors encountered while processing the request.
    pub error_samples: std::vec::Vec<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImportCompletionDataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error_samples][crate::model::ImportCompletionDataResponse::error_samples].
    pub fn set_error_samples<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.error_samples = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportCompletionDataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ImportCompletionDataResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportCompletionDataResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __error_samples,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportCompletionDataResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "errorSamples" => Ok(__FieldTag::__error_samples),
                            "error_samples" => Ok(__FieldTag::__error_samples),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportCompletionDataResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportCompletionDataResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__error_samples => {
                            if !fields.insert(__FieldTag::__error_samples) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_samples",
                                ));
                            }
                            result.error_samples = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImportCompletionDataResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.error_samples.is_empty() {
            state.serialize_entry("errorSamples", &self.error_samples)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImportCompletionDataResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImportCompletionDataResponse");
        debug_struct.field("error_samples", &self.error_samples);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata that describes the training and serving parameters of a
/// [Model][google.cloud.retail.v2.Model]. A
/// [Model][google.cloud.retail.v2.Model] can be associated with a
/// [ServingConfig][google.cloud.retail.v2.ServingConfig] and then queried
/// through the Predict API.
///
/// [google.cloud.retail.v2.Model]: crate::model::Model
/// [google.cloud.retail.v2.ServingConfig]: crate::model::ServingConfig
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Model {
    /// Required. The fully qualified resource name of the model.
    ///
    /// Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}/models/{model_id}`
    /// catalog_id has char limit of 50.
    /// recommendation_model_id has char limit of 40.
    pub name: std::string::String,

    /// Required. The display name of the model.
    ///
    /// Should be human readable, used to display Recommendation Models in the
    /// Retail Cloud Console Dashboard. UTF-8 encoded string with limit of 1024
    /// characters.
    pub display_name: std::string::String,

    /// Optional. The training state that the model is in (e.g.
    /// `TRAINING` or `PAUSED`).
    ///
    /// Since part of the cost of running the service
    /// is frequency of training - this can be used to determine when to train
    /// model in order to control cost. If not specified: the default value for
    /// `CreateModel` method is `TRAINING`. The default value for
    /// `UpdateModel` method is to keep the state the same as before.
    pub training_state: crate::model::model::TrainingState,

    /// Output only. The serving state of the model: `ACTIVE`, `NOT_ACTIVE`.
    pub serving_state: crate::model::model::ServingState,

    /// Output only. Timestamp the Recommendation Model was created at.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp the Recommendation Model was last updated. E.g.
    /// if a Recommendation Model was paused - this would be the time the pause was
    /// initiated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. The type of model e.g. `home-page`.
    ///
    /// Currently supported values: `recommended-for-you`, `others-you-may-like`,
    /// `frequently-bought-together`, `page-optimization`, `similar-items`,
    /// `buy-it-again`, `on-sale-items`, and `recently-viewed`(readonly value).
    ///
    /// This field together with
    /// [optimization_objective][google.cloud.retail.v2.Model.optimization_objective]
    /// describe model metadata to use to control model training and serving.
    /// See <https://cloud.google.com/retail/docs/models>
    /// for more details on what the model metadata control and which combination
    /// of parameters are valid. For invalid combinations of parameters (e.g. type
    /// = `frequently-bought-together` and optimization_objective = `ctr`), you
    /// receive an error 400 if you try to create/update a recommendation with
    /// this set of knobs.
    ///
    /// [google.cloud.retail.v2.Model.optimization_objective]: crate::model::Model::optimization_objective
    pub r#type: std::string::String,

    /// Optional. The optimization objective e.g. `cvr`.
    ///
    /// Currently supported
    /// values: `ctr`, `cvr`, `revenue-per-order`.
    ///
    /// If not specified, we choose default based on model type.
    /// Default depends on type of recommendation:
    ///
    /// `recommended-for-you` => `ctr`
    ///
    /// `others-you-may-like` => `ctr`
    ///
    /// `frequently-bought-together` => `revenue_per_order`
    ///
    /// This field together with
    /// [optimization_objective][google.cloud.retail.v2.Model.type]
    /// describe model metadata to use to control model training and serving.
    /// See <https://cloud.google.com/retail/docs/models>
    /// for more details on what the model metadata control and which combination
    /// of parameters are valid. For invalid combinations of parameters (e.g. type
    /// = `frequently-bought-together` and optimization_objective = `ctr`), you
    /// receive an error 400 if you try to create/update a recommendation with
    /// this set of knobs.
    ///
    /// [google.cloud.retail.v2.Model.type]: crate::model::Model::type
    pub optimization_objective: std::string::String,

    /// Optional. The state of periodic tuning.
    ///
    /// The period we use is 3 months - to do a
    /// one-off tune earlier use the `TuneModel` method. Default value
    /// is `PERIODIC_TUNING_ENABLED`.
    pub periodic_tuning_state: crate::model::model::PeriodicTuningState,

    /// Output only. The timestamp when the latest successful tune finished.
    pub last_tune_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The tune operation associated with the model.
    ///
    /// Can be used to determine if there is an ongoing tune for this
    /// recommendation. Empty field implies no tune is goig on.
    pub tuning_operation: std::string::String,

    /// Output only. The state of data requirements for this model: `DATA_OK` and
    /// `DATA_ERROR`.
    ///
    /// Recommendation model cannot be trained if the data is in
    /// `DATA_ERROR` state. Recommendation model can have `DATA_ERROR` state even
    /// if serving state is `ACTIVE`: models were trained successfully before, but
    /// cannot be refreshed because model no longer has sufficient
    /// data for training.
    pub data_state: crate::model::model::DataState,

    /// Optional. If `RECOMMENDATIONS_FILTERING_ENABLED`, recommendation filtering
    /// by attributes is enabled for the model.
    pub filtering_option: crate::model::RecommendationsFilteringOption,

    /// Output only. The list of valid serving configs associated with the
    /// PageOptimizationConfig.
    pub serving_config_lists: std::vec::Vec<crate::model::model::ServingConfigList>,

    /// Optional. Additional model features config.
    pub model_features_config: std::option::Option<crate::model::model::ModelFeaturesConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Model {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Model::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Model::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [training_state][crate::model::Model::training_state].
    pub fn set_training_state<T: std::convert::Into<crate::model::model::TrainingState>>(
        mut self,
        v: T,
    ) -> Self {
        self.training_state = v.into();
        self
    }

    /// Sets the value of [serving_state][crate::model::Model::serving_state].
    pub fn set_serving_state<T: std::convert::Into<crate::model::model::ServingState>>(
        mut self,
        v: T,
    ) -> Self {
        self.serving_state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Model::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Model::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Model::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Model::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::Model::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [optimization_objective][crate::model::Model::optimization_objective].
    pub fn set_optimization_objective<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.optimization_objective = v.into();
        self
    }

    /// Sets the value of [periodic_tuning_state][crate::model::Model::periodic_tuning_state].
    pub fn set_periodic_tuning_state<
        T: std::convert::Into<crate::model::model::PeriodicTuningState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.periodic_tuning_state = v.into();
        self
    }

    /// Sets the value of [last_tune_time][crate::model::Model::last_tune_time].
    pub fn set_last_tune_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_tune_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_tune_time][crate::model::Model::last_tune_time].
    pub fn set_or_clear_last_tune_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_tune_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tuning_operation][crate::model::Model::tuning_operation].
    pub fn set_tuning_operation<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tuning_operation = v.into();
        self
    }

    /// Sets the value of [data_state][crate::model::Model::data_state].
    pub fn set_data_state<T: std::convert::Into<crate::model::model::DataState>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_state = v.into();
        self
    }

    /// Sets the value of [filtering_option][crate::model::Model::filtering_option].
    pub fn set_filtering_option<
        T: std::convert::Into<crate::model::RecommendationsFilteringOption>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.filtering_option = v.into();
        self
    }

    /// Sets the value of [serving_config_lists][crate::model::Model::serving_config_lists].
    pub fn set_serving_config_lists<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::model::ServingConfigList>,
    {
        use std::iter::Iterator;
        self.serving_config_lists = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [model_features_config][crate::model::Model::model_features_config].
    pub fn set_model_features_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::model::ModelFeaturesConfig>,
    {
        self.model_features_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [model_features_config][crate::model::Model::model_features_config].
    pub fn set_or_clear_model_features_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::model::ModelFeaturesConfig>,
    {
        self.model_features_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Model {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.Model"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Model {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __training_state,
            __serving_state,
            __create_time,
            __update_time,
            __type,
            __optimization_objective,
            __periodic_tuning_state,
            __last_tune_time,
            __tuning_operation,
            __data_state,
            __filtering_option,
            __serving_config_lists,
            __model_features_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Model")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "trainingState" => Ok(__FieldTag::__training_state),
                            "training_state" => Ok(__FieldTag::__training_state),
                            "servingState" => Ok(__FieldTag::__serving_state),
                            "serving_state" => Ok(__FieldTag::__serving_state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "type" => Ok(__FieldTag::__type),
                            "optimizationObjective" => Ok(__FieldTag::__optimization_objective),
                            "optimization_objective" => Ok(__FieldTag::__optimization_objective),
                            "periodicTuningState" => Ok(__FieldTag::__periodic_tuning_state),
                            "periodic_tuning_state" => Ok(__FieldTag::__periodic_tuning_state),
                            "lastTuneTime" => Ok(__FieldTag::__last_tune_time),
                            "last_tune_time" => Ok(__FieldTag::__last_tune_time),
                            "tuningOperation" => Ok(__FieldTag::__tuning_operation),
                            "tuning_operation" => Ok(__FieldTag::__tuning_operation),
                            "dataState" => Ok(__FieldTag::__data_state),
                            "data_state" => Ok(__FieldTag::__data_state),
                            "filteringOption" => Ok(__FieldTag::__filtering_option),
                            "filtering_option" => Ok(__FieldTag::__filtering_option),
                            "servingConfigLists" => Ok(__FieldTag::__serving_config_lists),
                            "serving_config_lists" => Ok(__FieldTag::__serving_config_lists),
                            "modelFeaturesConfig" => Ok(__FieldTag::__model_features_config),
                            "model_features_config" => Ok(__FieldTag::__model_features_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Model;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Model")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__training_state => {
                            if !fields.insert(__FieldTag::__training_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for training_state",
                                ));
                            }
                            result.training_state = map.next_value::<std::option::Option<crate::model::model::TrainingState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__serving_state => {
                            if !fields.insert(__FieldTag::__serving_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serving_state",
                                ));
                            }
                            result.serving_state = map.next_value::<std::option::Option<crate::model::model::ServingState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__optimization_objective => {
                            if !fields.insert(__FieldTag::__optimization_objective) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optimization_objective",
                                ));
                            }
                            result.optimization_objective = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__periodic_tuning_state => {
                            if !fields.insert(__FieldTag::__periodic_tuning_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for periodic_tuning_state",
                                ));
                            }
                            result.periodic_tuning_state = map.next_value::<std::option::Option<crate::model::model::PeriodicTuningState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__last_tune_time => {
                            if !fields.insert(__FieldTag::__last_tune_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_tune_time",
                                ));
                            }
                            result.last_tune_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__tuning_operation => {
                            if !fields.insert(__FieldTag::__tuning_operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tuning_operation",
                                ));
                            }
                            result.tuning_operation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_state => {
                            if !fields.insert(__FieldTag::__data_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_state",
                                ));
                            }
                            result.data_state = map
                                .next_value::<std::option::Option<crate::model::model::DataState>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filtering_option => {
                            if !fields.insert(__FieldTag::__filtering_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filtering_option",
                                ));
                            }
                            result.filtering_option =
                                map.next_value::<std::option::Option<
                                    crate::model::RecommendationsFilteringOption,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__serving_config_lists => {
                            if !fields.insert(__FieldTag::__serving_config_lists) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serving_config_lists",
                                ));
                            }
                            result.serving_config_lists = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::model::ServingConfigList>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model_features_config => {
                            if !fields.insert(__FieldTag::__model_features_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_features_config",
                                ));
                            }
                            result.model_features_config = map.next_value::<std::option::Option<crate::model::model::ModelFeaturesConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Model {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.training_state) {
            state.serialize_entry("trainingState", &self.training_state)?;
        }
        if !wkt::internal::is_default(&self.serving_state) {
            state.serialize_entry("servingState", &self.serving_state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.optimization_objective.is_empty() {
            state.serialize_entry("optimizationObjective", &self.optimization_objective)?;
        }
        if !wkt::internal::is_default(&self.periodic_tuning_state) {
            state.serialize_entry("periodicTuningState", &self.periodic_tuning_state)?;
        }
        if self.last_tune_time.is_some() {
            state.serialize_entry("lastTuneTime", &self.last_tune_time)?;
        }
        if !self.tuning_operation.is_empty() {
            state.serialize_entry("tuningOperation", &self.tuning_operation)?;
        }
        if !wkt::internal::is_default(&self.data_state) {
            state.serialize_entry("dataState", &self.data_state)?;
        }
        if !wkt::internal::is_default(&self.filtering_option) {
            state.serialize_entry("filteringOption", &self.filtering_option)?;
        }
        if !self.serving_config_lists.is_empty() {
            state.serialize_entry("servingConfigLists", &self.serving_config_lists)?;
        }
        if self.model_features_config.is_some() {
            state.serialize_entry("modelFeaturesConfig", &self.model_features_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Model {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Model");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("training_state", &self.training_state);
        debug_struct.field("serving_state", &self.serving_state);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("optimization_objective", &self.optimization_objective);
        debug_struct.field("periodic_tuning_state", &self.periodic_tuning_state);
        debug_struct.field("last_tune_time", &self.last_tune_time);
        debug_struct.field("tuning_operation", &self.tuning_operation);
        debug_struct.field("data_state", &self.data_state);
        debug_struct.field("filtering_option", &self.filtering_option);
        debug_struct.field("serving_config_lists", &self.serving_config_lists);
        debug_struct.field("model_features_config", &self.model_features_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Model].
pub mod model {
    #[allow(unused_imports)]
    use super::*;

    /// Represents an ordered combination of valid serving configs, which
    /// can be used for `PAGE_OPTIMIZATION` recommendations.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ServingConfigList {
        /// Optional. A set of valid serving configs that may be used for
        /// `PAGE_OPTIMIZATION`.
        pub serving_config_ids: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ServingConfigList {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [serving_config_ids][crate::model::model::ServingConfigList::serving_config_ids].
        pub fn set_serving_config_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.serving_config_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ServingConfigList {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.Model.ServingConfigList"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ServingConfigList {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __serving_config_ids,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ServingConfigList")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "servingConfigIds" => Ok(__FieldTag::__serving_config_ids),
                                "serving_config_ids" => Ok(__FieldTag::__serving_config_ids),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ServingConfigList;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ServingConfigList")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__serving_config_ids => {
                                if !fields.insert(__FieldTag::__serving_config_ids) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for serving_config_ids",
                                    ));
                                }
                                result.serving_config_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ServingConfigList {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.serving_config_ids.is_empty() {
                state.serialize_entry("servingConfigIds", &self.serving_config_ids)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ServingConfigList {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ServingConfigList");
            debug_struct.field("serving_config_ids", &self.serving_config_ids);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Additional configs for the frequently-bought-together model type.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FrequentlyBoughtTogetherFeaturesConfig {
        /// Optional. Specifies the context of the model when it is used in predict
        /// requests. Can only be set for the `frequently-bought-together` type. If
        /// it isn't specified, it defaults to
        /// [MULTIPLE_CONTEXT_PRODUCTS][google.cloud.retail.v2.Model.ContextProductsType.MULTIPLE_CONTEXT_PRODUCTS].
        ///
        /// [google.cloud.retail.v2.Model.ContextProductsType.MULTIPLE_CONTEXT_PRODUCTS]: crate::model::model::ContextProductsType::MultipleContextProducts
        pub context_products_type: crate::model::model::ContextProductsType,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FrequentlyBoughtTogetherFeaturesConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [context_products_type][crate::model::model::FrequentlyBoughtTogetherFeaturesConfig::context_products_type].
        pub fn set_context_products_type<
            T: std::convert::Into<crate::model::model::ContextProductsType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.context_products_type = v.into();
            self
        }
    }

    impl wkt::message::Message for FrequentlyBoughtTogetherFeaturesConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.Model.FrequentlyBoughtTogetherFeaturesConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FrequentlyBoughtTogetherFeaturesConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __context_products_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str(
                                "a field name for FrequentlyBoughtTogetherFeaturesConfig",
                            )
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "contextProductsType" => Ok(__FieldTag::__context_products_type),
                                "context_products_type" => Ok(__FieldTag::__context_products_type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FrequentlyBoughtTogetherFeaturesConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FrequentlyBoughtTogetherFeaturesConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__context_products_type => {
                                if !fields.insert(__FieldTag::__context_products_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for context_products_type",
                                    ));
                                }
                                result.context_products_type =
                                    map.next_value::<std::option::Option<
                                        crate::model::model::ContextProductsType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for FrequentlyBoughtTogetherFeaturesConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.context_products_type) {
                state.serialize_entry("contextProductsType", &self.context_products_type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for FrequentlyBoughtTogetherFeaturesConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("FrequentlyBoughtTogetherFeaturesConfig");
            debug_struct.field("context_products_type", &self.context_products_type);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Additional model features config.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ModelFeaturesConfig {
        pub type_dedicated_config:
            std::option::Option<crate::model::model::model_features_config::TypeDedicatedConfig>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ModelFeaturesConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [type_dedicated_config][crate::model::model::ModelFeaturesConfig::type_dedicated_config].
        ///
        /// Note that all the setters affecting `type_dedicated_config` are mutually
        /// exclusive.
        pub fn set_type_dedicated_config<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::model::model_features_config::TypeDedicatedConfig,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.type_dedicated_config = v.into();
            self
        }

        /// The value of [type_dedicated_config][crate::model::model::ModelFeaturesConfig::type_dedicated_config]
        /// if it holds a `FrequentlyBoughtTogetherConfig`, `None` if the field is not set or
        /// holds a different branch.
        pub fn frequently_bought_together_config(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::model::FrequentlyBoughtTogetherFeaturesConfig>,
        > {
            #[allow(unreachable_patterns)]
            self.type_dedicated_config.as_ref().and_then(|v| match v {
                crate::model::model::model_features_config::TypeDedicatedConfig::FrequentlyBoughtTogetherConfig(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [type_dedicated_config][crate::model::model::ModelFeaturesConfig::type_dedicated_config]
        /// to hold a `FrequentlyBoughtTogetherConfig`.
        ///
        /// Note that all the setters affecting `type_dedicated_config` are
        /// mutually exclusive.
        pub fn set_frequently_bought_together_config<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::model::FrequentlyBoughtTogetherFeaturesConfig>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.type_dedicated_config = std::option::Option::Some(
                crate::model::model::model_features_config::TypeDedicatedConfig::FrequentlyBoughtTogetherConfig(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for ModelFeaturesConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.Model.ModelFeaturesConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ModelFeaturesConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __frequently_bought_together_config,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ModelFeaturesConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "frequentlyBoughtTogetherConfig" => {
                                    Ok(__FieldTag::__frequently_bought_together_config)
                                }
                                "frequently_bought_together_config" => {
                                    Ok(__FieldTag::__frequently_bought_together_config)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ModelFeaturesConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ModelFeaturesConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__frequently_bought_together_config => {
                                if !fields.insert(__FieldTag::__frequently_bought_together_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for frequently_bought_together_config",
                                    ));
                                }
                                if result.type_dedicated_config.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `type_dedicated_config`, a oneof with full ID .google.cloud.retail.v2.Model.ModelFeaturesConfig.frequently_bought_together_config, latest field was frequentlyBoughtTogetherConfig",
                                    ));
                                }
                                result.type_dedicated_config = std::option::Option::Some(
                                    crate::model::model::model_features_config::TypeDedicatedConfig::FrequentlyBoughtTogetherConfig(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::model::FrequentlyBoughtTogetherFeaturesConfig>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ModelFeaturesConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.frequently_bought_together_config() {
                state.serialize_entry("frequentlyBoughtTogetherConfig", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ModelFeaturesConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ModelFeaturesConfig");
            debug_struct.field("type_dedicated_config", &self.type_dedicated_config);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [ModelFeaturesConfig].
    pub mod model_features_config {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum TypeDedicatedConfig {
            /// Additional configs for frequently-bought-together models.
            FrequentlyBoughtTogetherConfig(
                std::boxed::Box<crate::model::model::FrequentlyBoughtTogetherFeaturesConfig>,
            ),
        }
    }

    /// The serving state of the model.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ServingState {
        /// Unspecified serving state.
        Unspecified,
        /// The model is not serving.
        Inactive,
        /// The model is serving and can be queried.
        Active,
        /// The model is trained on tuned hyperparameters and can be
        /// queried.
        Tuned,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ServingState::value] or
        /// [ServingState::name].
        UnknownValue(serving_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod serving_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ServingState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Inactive => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Tuned => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SERVING_STATE_UNSPECIFIED"),
                Self::Inactive => std::option::Option::Some("INACTIVE"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Tuned => std::option::Option::Some("TUNED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ServingState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ServingState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ServingState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Inactive,
                2 => Self::Active,
                3 => Self::Tuned,
                _ => Self::UnknownValue(serving_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ServingState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SERVING_STATE_UNSPECIFIED" => Self::Unspecified,
                "INACTIVE" => Self::Inactive,
                "ACTIVE" => Self::Active,
                "TUNED" => Self::Tuned,
                _ => Self::UnknownValue(serving_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ServingState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Inactive => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Tuned => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ServingState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ServingState>::new(
                ".google.cloud.retail.v2.Model.ServingState",
            ))
        }
    }

    /// The training state of the model.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TrainingState {
        /// Unspecified training state.
        Unspecified,
        /// The model training is paused.
        Paused,
        /// The model is training.
        Training,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TrainingState::value] or
        /// [TrainingState::name].
        UnknownValue(training_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod training_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TrainingState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Paused => std::option::Option::Some(1),
                Self::Training => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TRAINING_STATE_UNSPECIFIED"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::Training => std::option::Option::Some("TRAINING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TrainingState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TrainingState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TrainingState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Paused,
                2 => Self::Training,
                _ => Self::UnknownValue(training_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TrainingState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TRAINING_STATE_UNSPECIFIED" => Self::Unspecified,
                "PAUSED" => Self::Paused,
                "TRAINING" => Self::Training,
                _ => Self::UnknownValue(training_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TrainingState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Paused => serializer.serialize_i32(1),
                Self::Training => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TrainingState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TrainingState>::new(
                ".google.cloud.retail.v2.Model.TrainingState",
            ))
        }
    }

    /// Describes whether periodic tuning is enabled for this model
    /// or not. Periodic tuning is scheduled at most every three months. You can
    /// start a tuning process manually by using the `TuneModel`
    /// method, which starts a tuning process immediately and resets the quarterly
    /// schedule. Enabling or disabling periodic tuning does not affect any
    /// current tuning processes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PeriodicTuningState {
        /// Unspecified default value, should never be explicitly set.
        Unspecified,
        /// The model has periodic tuning disabled. Tuning
        /// can be reenabled by calling the `EnableModelPeriodicTuning`
        /// method or by calling the `TuneModel` method.
        PeriodicTuningDisabled,
        /// The model cannot be tuned with periodic tuning OR the
        /// `TuneModel` method. Hide the options in customer UI and
        /// reject any requests through the backend self serve API.
        AllTuningDisabled,
        /// The model has periodic tuning enabled. Tuning
        /// can be disabled by calling the `DisableModelPeriodicTuning`
        /// method.
        PeriodicTuningEnabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PeriodicTuningState::value] or
        /// [PeriodicTuningState::name].
        UnknownValue(periodic_tuning_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod periodic_tuning_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PeriodicTuningState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PeriodicTuningDisabled => std::option::Option::Some(1),
                Self::AllTuningDisabled => std::option::Option::Some(3),
                Self::PeriodicTuningEnabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PERIODIC_TUNING_STATE_UNSPECIFIED"),
                Self::PeriodicTuningDisabled => {
                    std::option::Option::Some("PERIODIC_TUNING_DISABLED")
                }
                Self::AllTuningDisabled => std::option::Option::Some("ALL_TUNING_DISABLED"),
                Self::PeriodicTuningEnabled => std::option::Option::Some("PERIODIC_TUNING_ENABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PeriodicTuningState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PeriodicTuningState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PeriodicTuningState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PeriodicTuningDisabled,
                2 => Self::PeriodicTuningEnabled,
                3 => Self::AllTuningDisabled,
                _ => Self::UnknownValue(periodic_tuning_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PeriodicTuningState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PERIODIC_TUNING_STATE_UNSPECIFIED" => Self::Unspecified,
                "PERIODIC_TUNING_DISABLED" => Self::PeriodicTuningDisabled,
                "ALL_TUNING_DISABLED" => Self::AllTuningDisabled,
                "PERIODIC_TUNING_ENABLED" => Self::PeriodicTuningEnabled,
                _ => Self::UnknownValue(periodic_tuning_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PeriodicTuningState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PeriodicTuningDisabled => serializer.serialize_i32(1),
                Self::AllTuningDisabled => serializer.serialize_i32(3),
                Self::PeriodicTuningEnabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PeriodicTuningState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PeriodicTuningState>::new(
                ".google.cloud.retail.v2.Model.PeriodicTuningState",
            ))
        }
    }

    /// Describes whether this model have sufficient training data
    /// to be continuously trained.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataState {
        /// Unspecified default value, should never be explicitly set.
        Unspecified,
        /// The model has sufficient training data.
        DataOk,
        /// The model does not have sufficient training data. Error
        /// messages can be queried via Stackdriver.
        DataError,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataState::value] or
        /// [DataState::name].
        UnknownValue(data_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod data_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DataState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::DataOk => std::option::Option::Some(1),
                Self::DataError => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATA_STATE_UNSPECIFIED"),
                Self::DataOk => std::option::Option::Some("DATA_OK"),
                Self::DataError => std::option::Option::Some("DATA_ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DataState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DataState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DataState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::DataOk,
                2 => Self::DataError,
                _ => Self::UnknownValue(data_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DataState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATA_STATE_UNSPECIFIED" => Self::Unspecified,
                "DATA_OK" => Self::DataOk,
                "DATA_ERROR" => Self::DataError,
                _ => Self::UnknownValue(data_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DataState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::DataOk => serializer.serialize_i32(1),
                Self::DataError => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DataState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataState>::new(
                ".google.cloud.retail.v2.Model.DataState",
            ))
        }
    }

    /// Use single or multiple context products for recommendations.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ContextProductsType {
        /// Unspecified default value, should never be explicitly set.
        /// Defaults to
        /// [MULTIPLE_CONTEXT_PRODUCTS][google.cloud.retail.v2.Model.ContextProductsType.MULTIPLE_CONTEXT_PRODUCTS].
        ///
        /// [google.cloud.retail.v2.Model.ContextProductsType.MULTIPLE_CONTEXT_PRODUCTS]: crate::model::model::ContextProductsType::MultipleContextProducts
        Unspecified,
        /// Use only a single product as context for the recommendation. Typically
        /// used on pages like add-to-cart or product details.
        SingleContextProduct,
        /// Use one or multiple products as context for the recommendation. Typically
        /// used on shopping cart pages.
        MultipleContextProducts,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ContextProductsType::value] or
        /// [ContextProductsType::name].
        UnknownValue(context_products_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod context_products_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ContextProductsType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SingleContextProduct => std::option::Option::Some(1),
                Self::MultipleContextProducts => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONTEXT_PRODUCTS_TYPE_UNSPECIFIED"),
                Self::SingleContextProduct => std::option::Option::Some("SINGLE_CONTEXT_PRODUCT"),
                Self::MultipleContextProducts => {
                    std::option::Option::Some("MULTIPLE_CONTEXT_PRODUCTS")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ContextProductsType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ContextProductsType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ContextProductsType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SingleContextProduct,
                2 => Self::MultipleContextProducts,
                _ => Self::UnknownValue(context_products_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ContextProductsType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONTEXT_PRODUCTS_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SINGLE_CONTEXT_PRODUCT" => Self::SingleContextProduct,
                "MULTIPLE_CONTEXT_PRODUCTS" => Self::MultipleContextProducts,
                _ => Self::UnknownValue(context_products_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ContextProductsType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SingleContextProduct => serializer.serialize_i32(1),
                Self::MultipleContextProducts => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ContextProductsType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ContextProductsType>::new(
                ".google.cloud.retail.v2.Model.ContextProductsType",
            ))
        }
    }
}

/// Request for creating a model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateModelRequest {
    /// Required. The parent resource under which to create the model. Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}`
    pub parent: std::string::String,

    /// Required. The payload of the [Model][google.cloud.retail.v2.Model]  to
    /// create.
    ///
    /// [google.cloud.retail.v2.Model]: crate::model::Model
    pub model: std::option::Option<crate::model::Model>,

    /// Optional. Whether to run a dry run to validate the request (without
    /// actually creating the model).
    pub dry_run: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateModelRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [model][crate::model::CreateModelRequest::model].
    pub fn set_model<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Model>,
    {
        self.model = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [model][crate::model::CreateModelRequest::model].
    pub fn set_or_clear_model<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Model>,
    {
        self.model = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dry_run][crate::model::CreateModelRequest::dry_run].
    pub fn set_dry_run<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.dry_run = v.into();
        self
    }
}

impl wkt::message::Message for CreateModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.CreateModelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __model,
            __dry_run,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "model" => Ok(__FieldTag::__model),
                            "dryRun" => Ok(__FieldTag::__dry_run),
                            "dry_run" => Ok(__FieldTag::__dry_run),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model =
                                map.next_value::<std::option::Option<crate::model::Model>>()?;
                        }
                        __FieldTag::__dry_run => {
                            if !fields.insert(__FieldTag::__dry_run) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dry_run",
                                ));
                            }
                            result.dry_run = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.model.is_some() {
            state.serialize_entry("model", &self.model)?;
        }
        if !wkt::internal::is_default(&self.dry_run) {
            state.serialize_entry("dryRun", &self.dry_run)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateModelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateModelRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("model", &self.model);
        debug_struct.field("dry_run", &self.dry_run);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for updating an existing model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateModelRequest {
    /// Required. The body of the updated [Model][google.cloud.retail.v2.Model].
    ///
    /// [google.cloud.retail.v2.Model]: crate::model::Model
    pub model: std::option::Option<crate::model::Model>,

    /// Optional. Indicates which fields in the provided 'model' to
    /// update. If not set, by default updates all fields.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model][crate::model::UpdateModelRequest::model].
    pub fn set_model<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Model>,
    {
        self.model = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [model][crate::model::UpdateModelRequest::model].
    pub fn set_or_clear_model<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Model>,
    {
        self.model = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateModelRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateModelRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.UpdateModelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __model,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "model" => Ok(__FieldTag::__model),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model =
                                map.next_value::<std::option::Option<crate::model::Model>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.model.is_some() {
            state.serialize_entry("model", &self.model)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateModelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateModelRequest");
        debug_struct.field("model", &self.model);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for getting a model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetModelRequest {
    /// Required. The resource name of the [Model][google.cloud.retail.v2.Model] to
    /// get. Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog}/models/{model_id}`
    ///
    /// [google.cloud.retail.v2.Model]: crate::model::Model
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.GetModelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetModelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetModelRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for pausing training of a model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PauseModelRequest {
    /// Required. The name of the model to pause.
    /// Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}/models/{model_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PauseModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PauseModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for PauseModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.PauseModelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PauseModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PauseModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PauseModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PauseModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PauseModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PauseModelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PauseModelRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for resuming training of a model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResumeModelRequest {
    /// Required. The name of the model to resume.
    /// Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}/models/{model_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResumeModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResumeModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResumeModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ResumeModelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResumeModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResumeModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResumeModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResumeModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResumeModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ResumeModelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResumeModelRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for listing models associated with a resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListModelsRequest {
    /// Required. The parent for which to list models.
    /// Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}`
    pub parent: std::string::String,

    /// Optional. Maximum number of results to return. If unspecified, defaults
    /// to 50. Max allowed value is 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListModels`
    /// call. Provide this to retrieve the subsequent page.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListModelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListModelsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListModelsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListModelsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListModelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ListModelsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListModelsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListModelsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListModelsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListModelsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListModelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListModelsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListModelsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for deleting a model.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteModelRequest {
    /// Required. The resource name of the [Model][google.cloud.retail.v2.Model] to
    /// delete. Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}/models/{model_id}`
    ///
    /// [google.cloud.retail.v2.Model]: crate::model::Model
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.DeleteModelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteModelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteModelRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response to a ListModelRequest.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListModelsResponse {
    /// List of Models.
    pub models: std::vec::Vec<crate::model::Model>,

    /// Pagination token, if not returned indicates the last page.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListModelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [models][crate::model::ListModelsResponse::models].
    pub fn set_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Model>,
    {
        use std::iter::Iterator;
        self.models = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListModelsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListModelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ListModelsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListModelsResponse {
    type PageItem = crate::model::Model;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.models
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListModelsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __models,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListModelsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "models" => Ok(__FieldTag::__models),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListModelsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListModelsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__models => {
                            if !fields.insert(__FieldTag::__models) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for models",
                                ));
                            }
                            result.models = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Model>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListModelsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.models.is_empty() {
            state.serialize_entry("models", &self.models)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListModelsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListModelsResponse");
        debug_struct.field("models", &self.models);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request to manually start a tuning process now (instead of waiting for
/// the periodically scheduled tuning to happen).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TuneModelRequest {
    /// Required. The resource name of the model to tune.
    /// Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}/models/{model_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TuneModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TuneModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for TuneModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.TuneModelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TuneModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TuneModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TuneModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TuneModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TuneModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TuneModelRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TuneModelRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata associated with a create operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateModelMetadata {
    /// The resource name of the model that this create applies to.
    /// Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}/models/{model_id}`
    pub model: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateModelMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model][crate::model::CreateModelMetadata::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }
}

impl wkt::message::Message for CreateModelMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.CreateModelMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateModelMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __model,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateModelMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "model" => Ok(__FieldTag::__model),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateModelMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateModelMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateModelMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateModelMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateModelMetadata");
        debug_struct.field("model", &self.model);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata associated with a tune operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TuneModelMetadata {
    /// The resource name of the model that this tune applies to.
    /// Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}/models/{model_id}`
    pub model: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TuneModelMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model][crate::model::TuneModelMetadata::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }
}

impl wkt::message::Message for TuneModelMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.TuneModelMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TuneModelMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __model,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TuneModelMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "model" => Ok(__FieldTag::__model),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TuneModelMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TuneModelMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TuneModelMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TuneModelMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TuneModelMetadata");
        debug_struct.field("model", &self.model);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response associated with a tune operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TuneModelResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TuneModelResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for TuneModelResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.TuneModelResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TuneModelResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TuneModelResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TuneModelResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TuneModelResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TuneModelResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TuneModelResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TuneModelResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for Predict method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PredictRequest {
    /// Required. Full resource name of the format:
    /// `{placement=projects/*/locations/global/catalogs/default_catalog/servingConfigs/*}`
    /// or
    /// `{placement=projects/*/locations/global/catalogs/default_catalog/placements/*}`.
    /// We recommend using the `servingConfigs` resource. `placements` is a legacy
    /// resource.
    /// The ID of the Recommendations AI serving config or placement.
    /// Before you can request predictions from your model, you must create at
    /// least one serving config or placement for it. For more information, see
    /// [Manage serving configs]
    /// (<https://cloud.google.com/retail/docs/manage-configs>).
    ///
    /// The full list of available serving configs can be seen at
    /// <https://console.cloud.google.com/ai/retail/catalogs/default_catalog/configs>
    pub placement: std::string::String,

    /// Required. Context about the user, what they are looking at and what action
    /// they took to trigger the predict request. Note that this user event detail
    /// won't be ingested to userEvent logs. Thus, a separate userEvent write
    /// request is required for event logging.
    ///
    /// Don't set
    /// [UserEvent.visitor_id][google.cloud.retail.v2.UserEvent.visitor_id] or
    /// [UserInfo.user_id][google.cloud.retail.v2.UserInfo.user_id] to the same
    /// fixed ID for different users. If you are trying to receive non-personalized
    /// recommendations (not recommended; this can negatively impact model
    /// performance), instead set
    /// [UserEvent.visitor_id][google.cloud.retail.v2.UserEvent.visitor_id] to a
    /// random unique ID and leave
    /// [UserInfo.user_id][google.cloud.retail.v2.UserInfo.user_id] unset.
    ///
    /// [google.cloud.retail.v2.UserEvent.visitor_id]: crate::model::UserEvent::visitor_id
    /// [google.cloud.retail.v2.UserInfo.user_id]: crate::model::UserInfo::user_id
    pub user_event: std::option::Option<crate::model::UserEvent>,

    /// Maximum number of results to return. Set this property to the number of
    /// prediction results needed. If zero, the service will choose a reasonable
    /// default. The maximum allowed value is 100. Values above 100 will be coerced
    /// to 100.
    pub page_size: i32,

    /// This field is not used; leave it unset.
    #[deprecated]
    pub page_token: std::string::String,

    /// Filter for restricting prediction results with a length limit of 5,000
    /// characters. Accepts values for tags and the `filterOutOfStockItems` flag.
    ///
    /// * Tag expressions. Restricts predictions to products that match all of the
    ///   specified tags. Boolean operators `OR` and `NOT` are supported if the
    ///   expression is enclosed in parentheses, and must be separated from the
    ///   tag values by a space. `-"tagA"` is also supported and is equivalent to
    ///   `NOT "tagA"`. Tag values must be double quoted UTF-8 encoded strings
    ///   with a size limit of 1,000 characters.
    ///
    ///   Note: "Recently viewed" models don't support tag filtering at the
    ///   moment.
    ///
    /// * filterOutOfStockItems. Restricts predictions to products that do not
    ///   have a
    ///   stockState value of OUT_OF_STOCK.
    ///
    ///
    /// Examples:
    ///
    /// * tag=("Red" OR "Blue") tag="New-Arrival" tag=(NOT "promotional")
    /// * filterOutOfStockItems  tag=(-"promotional")
    /// * filterOutOfStockItems
    ///
    /// If your filter blocks all prediction results, the API will return *no*
    /// results. If instead you want empty result sets to return generic
    /// (unfiltered) popular products, set `strictFiltering` to False in
    /// `PredictRequest.params`. Note that the API will never return items with
    /// storageStatus of "EXPIRED" or "DELETED" regardless of filter choices.
    ///
    /// If `filterSyntaxV2` is set to true under the `params` field, then
    /// attribute-based expressions are expected instead of the above described
    /// tag-based syntax. Examples:
    ///
    /// * (colors: ANY("Red", "Blue")) AND NOT (categories: ANY("Phones"))
    /// * (availability: ANY("IN_STOCK")) AND
    ///   (colors: ANY("Red") OR categories: ANY("Phones"))
    ///
    /// For more information, see
    /// [Filter recommendations](https://cloud.google.com/retail/docs/filter-recs).
    pub filter: std::string::String,

    /// Use validate only mode for this prediction query. If set to true, a
    /// dummy model will be used that returns arbitrary products.
    /// Note that the validate only mode should only be used for testing the API,
    /// or if the model is not ready.
    pub validate_only: bool,

    /// Additional domain specific parameters for the predictions.
    ///
    /// Allowed values:
    ///
    /// * `returnProduct`: Boolean. If set to true, the associated product
    ///   object will be returned in the `results.metadata` field in the
    ///   prediction response.
    /// * `returnScore`: Boolean. If set to true, the prediction 'score'
    ///   corresponding to each returned product will be set in the
    ///   `results.metadata` field in the prediction response. The given
    ///   'score' indicates the probability of a product being clicked/purchased
    ///   given the user's context and history.
    /// * `strictFiltering`: Boolean. True by default. If set to false, the service
    ///   will return generic (unfiltered) popular products instead of empty if
    ///   your filter blocks all prediction results.
    /// * `priceRerankLevel`: String. Default empty. If set to be non-empty, then
    ///   it needs to be one of {'no-price-reranking', 'low-price-reranking',
    ///   'medium-price-reranking', 'high-price-reranking'}. This gives
    ///   request-level control and adjusts prediction results based on product
    ///   price.
    /// * `diversityLevel`: String. Default empty. If set to be non-empty, then
    ///   it needs to be one of {'no-diversity', 'low-diversity',
    ///   'medium-diversity', 'high-diversity', 'auto-diversity'}. This gives
    ///   request-level control and adjusts prediction results based on product
    ///   category.
    /// * `filterSyntaxV2`: Boolean. False by default. If set to true, the `filter`
    ///   field is interpreteted according to the new, attribute-based syntax.
    pub params: std::collections::HashMap<std::string::String, wkt::Value>,

    /// The labels applied to a resource must meet the following requirements:
    ///
    /// * Each resource can have multiple labels, up to a maximum of 64.
    /// * Each label must be a key-value pair.
    /// * Keys have a minimum length of 1 character and a maximum length of 63
    ///   characters and cannot be empty. Values can be empty and have a maximum
    ///   length of 63 characters.
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes. All characters must use UTF-8 encoding, and
    ///   international characters are allowed.
    /// * The key portion of a label must be unique. However, you can use the same
    ///   key with multiple resources.
    /// * Keys must start with a lowercase letter or international character.
    ///
    /// See [Google Cloud
    /// Document](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements)
    /// for more details.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PredictRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [placement][crate::model::PredictRequest::placement].
    pub fn set_placement<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.placement = v.into();
        self
    }

    /// Sets the value of [user_event][crate::model::PredictRequest::user_event].
    pub fn set_user_event<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserEvent>,
    {
        self.user_event = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user_event][crate::model::PredictRequest::user_event].
    pub fn set_or_clear_user_event<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserEvent>,
    {
        self.user_event = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_size][crate::model::PredictRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::PredictRequest::page_token].
    #[deprecated]
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::PredictRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::PredictRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [params][crate::model::PredictRequest::params].
    pub fn set_params<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.params = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::PredictRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for PredictRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.PredictRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PredictRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __placement,
            __user_event,
            __page_size,
            __page_token,
            __filter,
            __validate_only,
            __params,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PredictRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "placement" => Ok(__FieldTag::__placement),
                            "userEvent" => Ok(__FieldTag::__user_event),
                            "user_event" => Ok(__FieldTag::__user_event),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "params" => Ok(__FieldTag::__params),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PredictRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PredictRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__placement => {
                            if !fields.insert(__FieldTag::__placement) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for placement",
                                ));
                            }
                            result.placement = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_event => {
                            if !fields.insert(__FieldTag::__user_event) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_event",
                                ));
                            }
                            result.user_event =
                                map.next_value::<std::option::Option<crate::model::UserEvent>>()?;
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__params => {
                            if !fields.insert(__FieldTag::__params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for params",
                                ));
                            }
                            result.params = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<std::string::String, wkt::Value>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PredictRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.placement.is_empty() {
            state.serialize_entry("placement", &self.placement)?;
        }
        if self.user_event.is_some() {
            state.serialize_entry("userEvent", &self.user_event)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.params.is_empty() {
            state.serialize_entry("params", &self.params)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PredictRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PredictRequest");
        debug_struct.field("placement", &self.placement);
        debug_struct.field("user_event", &self.user_event);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("params", &self.params);
        debug_struct.field("labels", &self.labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for predict method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PredictResponse {
    /// A list of recommended products. The order represents the ranking (from the
    /// most relevant product to the least).
    pub results: std::vec::Vec<crate::model::predict_response::PredictionResult>,

    /// A unique attribution token. This should be included in the
    /// [UserEvent][google.cloud.retail.v2.UserEvent] logs resulting from this
    /// recommendation, which enables accurate attribution of recommendation model
    /// performance.
    ///
    /// [google.cloud.retail.v2.UserEvent]: crate::model::UserEvent
    pub attribution_token: std::string::String,

    /// IDs of products in the request that were missing from the inventory.
    pub missing_ids: std::vec::Vec<std::string::String>,

    /// True if the validateOnly property was set in the request.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PredictResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [results][crate::model::PredictResponse::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::predict_response::PredictionResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [attribution_token][crate::model::PredictResponse::attribution_token].
    pub fn set_attribution_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.attribution_token = v.into();
        self
    }

    /// Sets the value of [missing_ids][crate::model::PredictResponse::missing_ids].
    pub fn set_missing_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.missing_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [validate_only][crate::model::PredictResponse::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for PredictResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.PredictResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PredictResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __results,
            __attribution_token,
            __missing_ids,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PredictResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "results" => Ok(__FieldTag::__results),
                            "attributionToken" => Ok(__FieldTag::__attribution_token),
                            "attribution_token" => Ok(__FieldTag::__attribution_token),
                            "missingIds" => Ok(__FieldTag::__missing_ids),
                            "missing_ids" => Ok(__FieldTag::__missing_ids),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PredictResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PredictResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__results => {
                            if !fields.insert(__FieldTag::__results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for results",
                                ));
                            }
                            result.results = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::predict_response::PredictionResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attribution_token => {
                            if !fields.insert(__FieldTag::__attribution_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attribution_token",
                                ));
                            }
                            result.attribution_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__missing_ids => {
                            if !fields.insert(__FieldTag::__missing_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for missing_ids",
                                ));
                            }
                            result.missing_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PredictResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.results.is_empty() {
            state.serialize_entry("results", &self.results)?;
        }
        if !self.attribution_token.is_empty() {
            state.serialize_entry("attributionToken", &self.attribution_token)?;
        }
        if !self.missing_ids.is_empty() {
            state.serialize_entry("missingIds", &self.missing_ids)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PredictResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PredictResponse");
        debug_struct.field("results", &self.results);
        debug_struct.field("attribution_token", &self.attribution_token);
        debug_struct.field("missing_ids", &self.missing_ids);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PredictResponse].
pub mod predict_response {
    #[allow(unused_imports)]
    use super::*;

    /// PredictionResult represents the recommendation prediction results.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PredictionResult {
        /// ID of the recommended product
        pub id: std::string::String,

        /// Additional product metadata / annotations.
        ///
        /// Possible values:
        ///
        /// * `product`: JSON representation of the product. Is set if
        ///   `returnProduct` is set to true in `PredictRequest.params`.
        /// * `score`: Prediction score in double value. Is set if
        ///   `returnScore` is set to true in `PredictRequest.params`.
        pub metadata: std::collections::HashMap<std::string::String, wkt::Value>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PredictionResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::predict_response::PredictionResult::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [metadata][crate::model::predict_response::PredictionResult::metadata].
        pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<wkt::Value>,
        {
            use std::iter::Iterator;
            self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for PredictionResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.PredictResponse.PredictionResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PredictionResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                __metadata,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PredictionResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                "metadata" => Ok(__FieldTag::__metadata),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PredictionResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PredictionResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__metadata => {
                                if !fields.insert(__FieldTag::__metadata) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for metadata",
                                    ));
                                }
                                result.metadata = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<std::string::String, wkt::Value>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PredictionResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !self.metadata.is_empty() {
                state.serialize_entry("metadata", &self.metadata)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PredictionResult {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PredictionResult");
            debug_struct.field("id", &self.id);
            debug_struct.field("metadata", &self.metadata);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Product captures all metadata information of items to be recommended or
/// searched.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Product {
    /// Immutable. Full resource name of the product, such as
    /// `projects/*/locations/global/catalogs/default_catalog/branches/default_branch/products/product_id`.
    pub name: std::string::String,

    /// Immutable. [Product][google.cloud.retail.v2.Product] identifier, which is
    /// the final component of [name][google.cloud.retail.v2.Product.name]. For
    /// example, this field is "id_1", if
    /// [name][google.cloud.retail.v2.Product.name] is
    /// `projects/*/locations/global/catalogs/default_catalog/branches/default_branch/products/id_1`.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// Corresponding properties: Google Merchant Center property
    /// [id](https://support.google.com/merchants/answer/6324405). Schema.org
    /// property [Product.sku](https://schema.org/sku).
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.Product.name]: crate::model::Product::name
    pub id: std::string::String,

    /// Immutable. The type of the product. Default to
    /// [Catalog.product_level_config.ingestion_product_type][google.cloud.retail.v2.ProductLevelConfig.ingestion_product_type]
    /// if unset.
    ///
    /// [google.cloud.retail.v2.ProductLevelConfig.ingestion_product_type]: crate::model::ProductLevelConfig::ingestion_product_type
    pub r#type: crate::model::product::Type,

    /// Variant group identifier. Must be an
    /// [id][google.cloud.retail.v2.Product.id], with the same parent branch with
    /// this product. Otherwise, an error is thrown.
    ///
    /// For [Type.PRIMARY][google.cloud.retail.v2.Product.Type.PRIMARY]
    /// [Product][google.cloud.retail.v2.Product]s, this field can only be empty or
    /// set to the same value as [id][google.cloud.retail.v2.Product.id].
    ///
    /// For VARIANT [Product][google.cloud.retail.v2.Product]s, this field cannot
    /// be empty. A maximum of 2,000 products are allowed to share the same
    /// [Type.PRIMARY][google.cloud.retail.v2.Product.Type.PRIMARY]
    /// [Product][google.cloud.retail.v2.Product]. Otherwise, an INVALID_ARGUMENT
    /// error is returned.
    ///
    /// Corresponding properties: Google Merchant Center property
    /// [item_group_id](https://support.google.com/merchants/answer/6324507).
    /// Schema.org property
    /// [Product.inProductGroupWithID](https://schema.org/inProductGroupWithID).
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.Product.Type.PRIMARY]: crate::model::product::Type::Primary
    /// [google.cloud.retail.v2.Product.id]: crate::model::Product::id
    pub primary_product_id: std::string::String,

    /// The [id][google.cloud.retail.v2.Product.id] of the collection members when
    /// [type][google.cloud.retail.v2.Product.type] is
    /// [Type.COLLECTION][google.cloud.retail.v2.Product.Type.COLLECTION].
    ///
    /// Non-existent product ids are allowed.
    /// The [type][google.cloud.retail.v2.Product.type] of the members must be
    /// either [Type.PRIMARY][google.cloud.retail.v2.Product.Type.PRIMARY] or
    /// [Type.VARIANT][google.cloud.retail.v2.Product.Type.VARIANT] otherwise an
    /// INVALID_ARGUMENT error is thrown. Should not set it for other types. A
    /// maximum of 1000 values are allowed. Otherwise, an INVALID_ARGUMENT error is
    /// return.
    ///
    /// [google.cloud.retail.v2.Product.Type.COLLECTION]: crate::model::product::Type::Collection
    /// [google.cloud.retail.v2.Product.Type.PRIMARY]: crate::model::product::Type::Primary
    /// [google.cloud.retail.v2.Product.Type.VARIANT]: crate::model::product::Type::Variant
    /// [google.cloud.retail.v2.Product.id]: crate::model::Product::id
    /// [google.cloud.retail.v2.Product.type]: crate::model::Product::type
    pub collection_member_ids: std::vec::Vec<std::string::String>,

    /// The Global Trade Item Number (GTIN) of the product.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// This field must be a Unigram. Otherwise, an INVALID_ARGUMENT error is
    /// returned.
    ///
    /// Corresponding properties: Google Merchant Center property
    /// [gtin](https://support.google.com/merchants/answer/6324461).
    /// Schema.org property
    /// [Product.isbn](https://schema.org/isbn),
    /// [Product.gtin8](https://schema.org/gtin8),
    /// [Product.gtin12](https://schema.org/gtin12),
    /// [Product.gtin13](https://schema.org/gtin13), or
    /// [Product.gtin14](https://schema.org/gtin14).
    ///
    /// If the value is not a valid GTIN, an INVALID_ARGUMENT error is returned.
    pub gtin: std::string::String,

    /// Product categories. This field is repeated for supporting one product
    /// belonging to several parallel categories. Strongly recommended using the
    /// full path for better search / recommendation quality.
    ///
    /// To represent full path of category, use '>' sign to separate different
    /// hierarchies. If '>' is part of the category name, replace it with
    /// other character(s).
    ///
    /// For example, if a shoes product belongs to both
    /// ["Shoes & Accessories" -> "Shoes"] and
    /// ["Sports & Fitness" -> "Athletic Clothing" -> "Shoes"], it could be
    /// represented as:
    ///
    /// ```norust
    ///  "categories": [
    ///    "Shoes & Accessories > Shoes",
    ///    "Sports & Fitness > Athletic Clothing > Shoes"
    ///  ]
    /// ```
    ///
    /// Must be set for [Type.PRIMARY][google.cloud.retail.v2.Product.Type.PRIMARY]
    /// [Product][google.cloud.retail.v2.Product] otherwise an INVALID_ARGUMENT
    /// error is returned.
    ///
    /// At most 250 values are allowed per
    /// [Product][google.cloud.retail.v2.Product] unless overridden through the
    /// Google Cloud console. Empty values are not allowed. Each value must be a
    /// UTF-8 encoded string with a length limit of 5,000 characters. Otherwise, an
    /// INVALID_ARGUMENT error is returned.
    ///
    /// Corresponding properties: Google Merchant Center property
    /// [google_product_category][mc_google_product_category]. Schema.org property
    /// [Product.category] (<https://schema.org/category>).
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.Product.Type.PRIMARY]: crate::model::product::Type::Primary
    pub categories: std::vec::Vec<std::string::String>,

    /// Required. Product title.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 1,000
    /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// Corresponding properties: Google Merchant Center property
    /// [title](https://support.google.com/merchants/answer/6324415). Schema.org
    /// property [Product.name](https://schema.org/name).
    pub title: std::string::String,

    /// The brands of the product.
    ///
    /// A maximum of 30 brands are allowed unless overridden through the Google
    /// Cloud console. Each
    /// brand must be a UTF-8 encoded string with a length limit of 1,000
    /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// Corresponding properties: Google Merchant Center property
    /// [brand](https://support.google.com/merchants/answer/6324351). Schema.org
    /// property [Product.brand](https://schema.org/brand).
    pub brands: std::vec::Vec<std::string::String>,

    /// Product description.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 5,000
    /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// Corresponding properties: Google Merchant Center property
    /// [description](https://support.google.com/merchants/answer/6324468).
    /// Schema.org property [Product.description](https://schema.org/description).
    pub description: std::string::String,

    /// Language of the title/description and other string attributes. Use language
    /// tags defined by [BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt).
    ///
    /// For product prediction, this field is ignored and the model automatically
    /// detects the text language. The [Product][google.cloud.retail.v2.Product]
    /// can include text in different languages, but duplicating
    /// [Product][google.cloud.retail.v2.Product]s to provide text in multiple
    /// languages can result in degraded model performance.
    ///
    /// For product search this field is in use. It defaults to "en-US" if unset.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub language_code: std::string::String,

    /// Highly encouraged. Extra product attributes to be included. For example,
    /// for products, this could include the store name, vendor, style, color, etc.
    /// These are very strong signals for recommendation model, thus we highly
    /// recommend providing the attributes here.
    ///
    /// Features that can take on one of a limited number of possible values. Two
    /// types of features can be set are:
    ///
    /// Textual features. some examples would be the brand/maker of a product, or
    /// country of a customer. Numerical features. Some examples would be the
    /// height/weight of a product, or age of a customer.
    ///
    /// For example: `{ "vendor": {"text": ["vendor123", "vendor456"]},
    /// "lengths_cm": {"numbers":[2.3, 15.4]}, "heights_cm": {"numbers":[8.1, 6.4]}
    /// }`.
    ///
    /// This field needs to pass all below criteria, otherwise an INVALID_ARGUMENT
    /// error is returned:
    ///
    /// * Max entries count: 200.
    /// * The key must be a UTF-8 encoded string with a length limit of 128
    ///   characters.
    /// * For indexable attribute, the key must match the pattern:
    ///   `[a-zA-Z0-9][a-zA-Z0-9_]*`. For example, `key0LikeThis` or
    ///   `KEY_1_LIKE_THIS`.
    /// * For text attributes, at most 400 values are allowed. Empty values are not
    ///   allowed. Each value must be a non-empty UTF-8 encoded string with a
    ///   length limit of 256 characters.
    /// * For number attributes, at most 400 values are allowed.
    pub attributes: std::collections::HashMap<std::string::String, crate::model::CustomAttribute>,

    /// Custom tags associated with the product.
    ///
    /// At most 250 values are allowed per
    /// [Product][google.cloud.retail.v2.Product]. This value must be a UTF-8
    /// encoded string with a length limit of 1,000 characters. Otherwise, an
    /// INVALID_ARGUMENT error is returned.
    ///
    /// This tag can be used for filtering recommendation results by passing the
    /// tag as part of the
    /// [PredictRequest.filter][google.cloud.retail.v2.PredictRequest.filter].
    ///
    /// Corresponding properties: Google Merchant Center property
    /// [custom_label_04](https://support.google.com/merchants/answer/6324473).
    ///
    /// [google.cloud.retail.v2.PredictRequest.filter]: crate::model::PredictRequest::filter
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub tags: std::vec::Vec<std::string::String>,

    /// Product price and cost information.
    ///
    /// Corresponding properties: Google Merchant Center property
    /// [price](https://support.google.com/merchants/answer/6324371).
    pub price_info: std::option::Option<crate::model::PriceInfo>,

    /// The rating of this product.
    pub rating: std::option::Option<crate::model::Rating>,

    /// The timestamp when this [Product][google.cloud.retail.v2.Product] becomes
    /// available for
    /// [SearchService.Search][google.cloud.retail.v2.SearchService.Search]. Note
    /// that this is only applicable to
    /// [Type.PRIMARY][google.cloud.retail.v2.Product.Type.PRIMARY] and
    /// [Type.COLLECTION][google.cloud.retail.v2.Product.Type.COLLECTION], and
    /// ignored for [Type.VARIANT][google.cloud.retail.v2.Product.Type.VARIANT].
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.Product.Type.COLLECTION]: crate::model::product::Type::Collection
    /// [google.cloud.retail.v2.Product.Type.PRIMARY]: crate::model::product::Type::Primary
    /// [google.cloud.retail.v2.Product.Type.VARIANT]: crate::model::product::Type::Variant
    /// [google.cloud.retail.v2.SearchService.Search]: crate::client::SearchService::search
    pub available_time: std::option::Option<wkt::Timestamp>,

    /// The online availability of the [Product][google.cloud.retail.v2.Product].
    /// Default to
    /// [Availability.IN_STOCK][google.cloud.retail.v2.Product.Availability.IN_STOCK].
    ///
    /// For primary products with variants set the availability of the primary as
    /// [Availability.OUT_OF_STOCK][google.cloud.retail.v2.Product.Availability.OUT_OF_STOCK]
    /// and set the true availability at the variant level. This way the primary
    /// product will be considered "in stock" as long as it has at least one
    /// variant in stock.
    ///
    /// For primary products with no variants set the true availability at the
    /// primary level.
    ///
    /// Corresponding properties: Google Merchant Center property
    /// [availability](https://support.google.com/merchants/answer/6324448).
    /// Schema.org property [Offer.availability](https://schema.org/availability).
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.Product.Availability.IN_STOCK]: crate::model::product::Availability::InStock
    /// [google.cloud.retail.v2.Product.Availability.OUT_OF_STOCK]: crate::model::product::Availability::OutOfStock
    pub availability: crate::model::product::Availability,

    /// The available quantity of the item.
    pub available_quantity: std::option::Option<wkt::Int32Value>,

    /// Fulfillment information, such as the store IDs for in-store pickup or
    /// region IDs for different shipping methods.
    ///
    /// All the elements must have distinct
    /// [FulfillmentInfo.type][google.cloud.retail.v2.FulfillmentInfo.type].
    /// Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// [google.cloud.retail.v2.FulfillmentInfo.type]: crate::model::FulfillmentInfo::type
    pub fulfillment_info: std::vec::Vec<crate::model::FulfillmentInfo>,

    /// Canonical URL directly linking to the product detail page.
    ///
    /// It is strongly recommended to provide a valid uri for the product,
    /// otherwise the service performance could be significantly degraded.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 5,000
    /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// Corresponding properties: Google Merchant Center property
    /// [link](https://support.google.com/merchants/answer/6324416). Schema.org
    /// property [Offer.url](https://schema.org/url).
    pub uri: std::string::String,

    /// Product images for the product. We highly recommend putting the main
    /// image first.
    ///
    /// A maximum of 300 images are allowed.
    ///
    /// Corresponding properties: Google Merchant Center property
    /// [image_link](https://support.google.com/merchants/answer/6324350).
    /// Schema.org property [Product.image](https://schema.org/image).
    pub images: std::vec::Vec<crate::model::Image>,

    /// The target group associated with a given audience (e.g. male, veterans,
    /// car owners, musicians, etc.) of the product.
    pub audience: std::option::Option<crate::model::Audience>,

    /// The color of the product.
    ///
    /// Corresponding properties: Google Merchant Center property
    /// [color](https://support.google.com/merchants/answer/6324487). Schema.org
    /// property [Product.color](https://schema.org/color).
    pub color_info: std::option::Option<crate::model::ColorInfo>,

    /// The size of the product. To represent different size systems or size types,
    /// consider using this format: [[[size_system:]size_type:]size_value].
    ///
    /// For example, in "US:MENS:M", "US" represents size system; "MENS" represents
    /// size type; "M" represents size value. In "GIRLS:27", size system is empty;
    /// "GIRLS" represents size type; "27" represents size value. In "32 inches",
    /// both size system and size type are empty, while size value is "32 inches".
    ///
    /// A maximum of 20 values are allowed per
    /// [Product][google.cloud.retail.v2.Product]. Each value must be a UTF-8
    /// encoded string with a length limit of 128 characters. Otherwise, an
    /// INVALID_ARGUMENT error is returned.
    ///
    /// Corresponding properties: Google Merchant Center property
    /// [size](https://support.google.com/merchants/answer/6324492),
    /// [size_type](https://support.google.com/merchants/answer/6324497), and
    /// [size_system](https://support.google.com/merchants/answer/6324502).
    /// Schema.org property [Product.size](https://schema.org/size).
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub sizes: std::vec::Vec<std::string::String>,

    /// The material of the product. For example, "leather", "wooden".
    ///
    /// A maximum of 20 values are allowed. Each value must be a UTF-8 encoded
    /// string with a length limit of 200 characters. Otherwise, an
    /// INVALID_ARGUMENT error is returned.
    ///
    /// Corresponding properties: Google Merchant Center property
    /// [material](https://support.google.com/merchants/answer/6324410). Schema.org
    /// property [Product.material](https://schema.org/material).
    pub materials: std::vec::Vec<std::string::String>,

    /// The pattern or graphic print of the product. For example, "striped", "polka
    /// dot", "paisley".
    ///
    /// A maximum of 20 values are allowed per
    /// [Product][google.cloud.retail.v2.Product]. Each value must be a UTF-8
    /// encoded string with a length limit of 128 characters. Otherwise, an
    /// INVALID_ARGUMENT error is returned.
    ///
    /// Corresponding properties: Google Merchant Center property
    /// [pattern](https://support.google.com/merchants/answer/6324483). Schema.org
    /// property [Product.pattern](https://schema.org/pattern).
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub patterns: std::vec::Vec<std::string::String>,

    /// The condition of the product. Strongly encouraged to use the standard
    /// values: "new", "refurbished", "used".
    ///
    /// A maximum of 1 value is allowed per
    /// [Product][google.cloud.retail.v2.Product]. Each value must be a UTF-8
    /// encoded string with a length limit of 128 characters. Otherwise, an
    /// INVALID_ARGUMENT error is returned.
    ///
    /// Corresponding properties: Google Merchant Center property
    /// [condition](https://support.google.com/merchants/answer/6324469).
    /// Schema.org property
    /// [Offer.itemCondition](https://schema.org/itemCondition).
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub conditions: std::vec::Vec<std::string::String>,

    /// The promotions applied to the product. A maximum of 10 values are allowed
    /// per [Product][google.cloud.retail.v2.Product]. Only
    /// [Promotion.promotion_id][google.cloud.retail.v2.Promotion.promotion_id]
    /// will be used, other fields will be ignored if set.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.Promotion.promotion_id]: crate::model::Promotion::promotion_id
    pub promotions: std::vec::Vec<crate::model::Promotion>,

    /// The timestamp when the product is published by the retailer for the first
    /// time, which indicates the freshness of the products. Note that this field
    /// is different from
    /// [available_time][google.cloud.retail.v2.Product.available_time], given it
    /// purely describes product freshness regardless of when it is available on
    /// search and recommendation.
    ///
    /// [google.cloud.retail.v2.Product.available_time]: crate::model::Product::available_time
    pub publish_time: std::option::Option<wkt::Timestamp>,

    /// Indicates which fields in the [Product][google.cloud.retail.v2.Product]s
    /// are returned in [SearchResponse][google.cloud.retail.v2.SearchResponse].
    ///
    /// Supported fields for all [type][google.cloud.retail.v2.Product.type]s:
    ///
    /// * [audience][google.cloud.retail.v2.Product.audience]
    /// * [availability][google.cloud.retail.v2.Product.availability]
    /// * [brands][google.cloud.retail.v2.Product.brands]
    /// * [color_info][google.cloud.retail.v2.Product.color_info]
    /// * [conditions][google.cloud.retail.v2.Product.conditions]
    /// * [gtin][google.cloud.retail.v2.Product.gtin]
    /// * [materials][google.cloud.retail.v2.Product.materials]
    /// * [name][google.cloud.retail.v2.Product.name]
    /// * [patterns][google.cloud.retail.v2.Product.patterns]
    /// * [price_info][google.cloud.retail.v2.Product.price_info]
    /// * [rating][google.cloud.retail.v2.Product.rating]
    /// * [sizes][google.cloud.retail.v2.Product.sizes]
    /// * [title][google.cloud.retail.v2.Product.title]
    /// * [uri][google.cloud.retail.v2.Product.uri]
    ///
    /// Supported fields only for
    /// [Type.PRIMARY][google.cloud.retail.v2.Product.Type.PRIMARY] and
    /// [Type.COLLECTION][google.cloud.retail.v2.Product.Type.COLLECTION]:
    ///
    /// * [categories][google.cloud.retail.v2.Product.categories]
    /// * [description][google.cloud.retail.v2.Product.description]
    /// * [images][google.cloud.retail.v2.Product.images]
    ///
    /// Supported fields only for
    /// [Type.VARIANT][google.cloud.retail.v2.Product.Type.VARIANT]:
    ///
    /// * Only the first image in [images][google.cloud.retail.v2.Product.images]
    ///
    /// To mark [attributes][google.cloud.retail.v2.Product.attributes] as
    /// retrievable, include paths of the form "attributes.key" where "key" is the
    /// key of a custom attribute, as specified in
    /// [attributes][google.cloud.retail.v2.Product.attributes].
    ///
    /// For [Type.PRIMARY][google.cloud.retail.v2.Product.Type.PRIMARY] and
    /// [Type.COLLECTION][google.cloud.retail.v2.Product.Type.COLLECTION], the
    /// following fields are always returned in
    /// [SearchResponse][google.cloud.retail.v2.SearchResponse] by default:
    ///
    /// * [name][google.cloud.retail.v2.Product.name]
    ///
    /// For [Type.VARIANT][google.cloud.retail.v2.Product.Type.VARIANT], the
    /// following fields are always returned in by default:
    ///
    /// * [name][google.cloud.retail.v2.Product.name]
    /// * [color_info][google.cloud.retail.v2.Product.color_info]
    ///
    /// Note: Returning more fields in
    /// [SearchResponse][google.cloud.retail.v2.SearchResponse] can increase
    /// response payload size and serving latency.
    ///
    /// This field is deprecated. Use the retrievable site-wide control instead.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.Product.Type.COLLECTION]: crate::model::product::Type::Collection
    /// [google.cloud.retail.v2.Product.Type.PRIMARY]: crate::model::product::Type::Primary
    /// [google.cloud.retail.v2.Product.Type.VARIANT]: crate::model::product::Type::Variant
    /// [google.cloud.retail.v2.Product.attributes]: crate::model::Product::attributes
    /// [google.cloud.retail.v2.Product.audience]: crate::model::Product::audience
    /// [google.cloud.retail.v2.Product.availability]: crate::model::Product::availability
    /// [google.cloud.retail.v2.Product.brands]: crate::model::Product::brands
    /// [google.cloud.retail.v2.Product.categories]: crate::model::Product::categories
    /// [google.cloud.retail.v2.Product.color_info]: crate::model::Product::color_info
    /// [google.cloud.retail.v2.Product.conditions]: crate::model::Product::conditions
    /// [google.cloud.retail.v2.Product.description]: crate::model::Product::description
    /// [google.cloud.retail.v2.Product.gtin]: crate::model::Product::gtin
    /// [google.cloud.retail.v2.Product.images]: crate::model::Product::images
    /// [google.cloud.retail.v2.Product.materials]: crate::model::Product::materials
    /// [google.cloud.retail.v2.Product.name]: crate::model::Product::name
    /// [google.cloud.retail.v2.Product.patterns]: crate::model::Product::patterns
    /// [google.cloud.retail.v2.Product.price_info]: crate::model::Product::price_info
    /// [google.cloud.retail.v2.Product.rating]: crate::model::Product::rating
    /// [google.cloud.retail.v2.Product.sizes]: crate::model::Product::sizes
    /// [google.cloud.retail.v2.Product.title]: crate::model::Product::title
    /// [google.cloud.retail.v2.Product.type]: crate::model::Product::type
    /// [google.cloud.retail.v2.Product.uri]: crate::model::Product::uri
    /// [google.cloud.retail.v2.SearchResponse]: crate::model::SearchResponse
    #[deprecated]
    pub retrievable_fields: std::option::Option<wkt::FieldMask>,

    /// Output only. Product variants grouped together on primary product which
    /// share similar product attributes. It's automatically grouped by
    /// [primary_product_id][google.cloud.retail.v2.Product.primary_product_id] for
    /// all the product variants. Only populated for
    /// [Type.PRIMARY][google.cloud.retail.v2.Product.Type.PRIMARY]
    /// [Product][google.cloud.retail.v2.Product]s.
    ///
    /// Note: This field is OUTPUT_ONLY for
    /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct].
    /// Do not set this field in API requests.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.Product.Type.PRIMARY]: crate::model::product::Type::Primary
    /// [google.cloud.retail.v2.Product.primary_product_id]: crate::model::Product::primary_product_id
    /// [google.cloud.retail.v2.ProductService.GetProduct]: crate::client::ProductService::get_product
    pub variants: std::vec::Vec<crate::model::Product>,

    /// Output only. A list of local inventories specific to different places.
    ///
    /// This field can be managed by
    /// [ProductService.AddLocalInventories][google.cloud.retail.v2.ProductService.AddLocalInventories]
    /// and
    /// [ProductService.RemoveLocalInventories][google.cloud.retail.v2.ProductService.RemoveLocalInventories]
    /// APIs if fine-grained, high-volume updates are necessary.
    ///
    /// [google.cloud.retail.v2.ProductService.AddLocalInventories]: crate::client::ProductService::add_local_inventories
    /// [google.cloud.retail.v2.ProductService.RemoveLocalInventories]: crate::client::ProductService::remove_local_inventories
    pub local_inventories: std::vec::Vec<crate::model::LocalInventory>,

    pub expiration: std::option::Option<crate::model::product::Expiration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Product {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Product::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Product::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Product::type].
    pub fn set_type<T: std::convert::Into<crate::model::product::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [primary_product_id][crate::model::Product::primary_product_id].
    pub fn set_primary_product_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.primary_product_id = v.into();
        self
    }

    /// Sets the value of [collection_member_ids][crate::model::Product::collection_member_ids].
    pub fn set_collection_member_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.collection_member_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [gtin][crate::model::Product::gtin].
    pub fn set_gtin<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gtin = v.into();
        self
    }

    /// Sets the value of [categories][crate::model::Product::categories].
    pub fn set_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.categories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [title][crate::model::Product::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [brands][crate::model::Product::brands].
    pub fn set_brands<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.brands = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [description][crate::model::Product::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::Product::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [attributes][crate::model::Product::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::CustomAttribute>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [tags][crate::model::Product::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [price_info][crate::model::Product::price_info].
    pub fn set_price_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PriceInfo>,
    {
        self.price_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [price_info][crate::model::Product::price_info].
    pub fn set_or_clear_price_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PriceInfo>,
    {
        self.price_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rating][crate::model::Product::rating].
    pub fn set_rating<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Rating>,
    {
        self.rating = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rating][crate::model::Product::rating].
    pub fn set_or_clear_rating<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Rating>,
    {
        self.rating = v.map(|x| x.into());
        self
    }

    /// Sets the value of [available_time][crate::model::Product::available_time].
    pub fn set_available_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.available_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [available_time][crate::model::Product::available_time].
    pub fn set_or_clear_available_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.available_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [availability][crate::model::Product::availability].
    pub fn set_availability<T: std::convert::Into<crate::model::product::Availability>>(
        mut self,
        v: T,
    ) -> Self {
        self.availability = v.into();
        self
    }

    /// Sets the value of [available_quantity][crate::model::Product::available_quantity].
    pub fn set_available_quantity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.available_quantity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [available_quantity][crate::model::Product::available_quantity].
    pub fn set_or_clear_available_quantity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.available_quantity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fulfillment_info][crate::model::Product::fulfillment_info].
    pub fn set_fulfillment_info<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FulfillmentInfo>,
    {
        use std::iter::Iterator;
        self.fulfillment_info = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [uri][crate::model::Product::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [images][crate::model::Product::images].
    pub fn set_images<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Image>,
    {
        use std::iter::Iterator;
        self.images = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [audience][crate::model::Product::audience].
    pub fn set_audience<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Audience>,
    {
        self.audience = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [audience][crate::model::Product::audience].
    pub fn set_or_clear_audience<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Audience>,
    {
        self.audience = v.map(|x| x.into());
        self
    }

    /// Sets the value of [color_info][crate::model::Product::color_info].
    pub fn set_color_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ColorInfo>,
    {
        self.color_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [color_info][crate::model::Product::color_info].
    pub fn set_or_clear_color_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ColorInfo>,
    {
        self.color_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sizes][crate::model::Product::sizes].
    pub fn set_sizes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.sizes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [materials][crate::model::Product::materials].
    pub fn set_materials<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.materials = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [patterns][crate::model::Product::patterns].
    pub fn set_patterns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.patterns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [conditions][crate::model::Product::conditions].
    pub fn set_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [promotions][crate::model::Product::promotions].
    pub fn set_promotions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Promotion>,
    {
        use std::iter::Iterator;
        self.promotions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [publish_time][crate::model::Product::publish_time].
    pub fn set_publish_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.publish_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [publish_time][crate::model::Product::publish_time].
    pub fn set_or_clear_publish_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.publish_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [retrievable_fields][crate::model::Product::retrievable_fields].
    #[deprecated]
    pub fn set_retrievable_fields<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.retrievable_fields = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [retrievable_fields][crate::model::Product::retrievable_fields].
    #[deprecated]
    pub fn set_or_clear_retrievable_fields<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.retrievable_fields = v.map(|x| x.into());
        self
    }

    /// Sets the value of [variants][crate::model::Product::variants].
    pub fn set_variants<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Product>,
    {
        use std::iter::Iterator;
        self.variants = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [local_inventories][crate::model::Product::local_inventories].
    pub fn set_local_inventories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LocalInventory>,
    {
        use std::iter::Iterator;
        self.local_inventories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [expiration][crate::model::Product::expiration].
    ///
    /// Note that all the setters affecting `expiration` are mutually
    /// exclusive.
    pub fn set_expiration<
        T: std::convert::Into<std::option::Option<crate::model::product::Expiration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expiration = v.into();
        self
    }

    /// The value of [expiration][crate::model::Product::expiration]
    /// if it holds a `ExpireTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn expire_time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::product::Expiration::ExpireTime(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [expiration][crate::model::Product::expiration]
    /// to hold a `ExpireTime`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_expire_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiration =
            std::option::Option::Some(crate::model::product::Expiration::ExpireTime(v.into()));
        self
    }

    /// The value of [expiration][crate::model::Product::expiration]
    /// if it holds a `Ttl`, `None` if the field is not set or
    /// holds a different branch.
    pub fn ttl(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::product::Expiration::Ttl(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [expiration][crate::model::Product::expiration]
    /// to hold a `Ttl`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_ttl<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(mut self, v: T) -> Self {
        self.expiration =
            std::option::Option::Some(crate::model::product::Expiration::Ttl(v.into()));
        self
    }
}

impl wkt::message::Message for Product {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.Product"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Product {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __expire_time,
            __ttl,
            __name,
            __id,
            __type,
            __primary_product_id,
            __collection_member_ids,
            __gtin,
            __categories,
            __title,
            __brands,
            __description,
            __language_code,
            __attributes,
            __tags,
            __price_info,
            __rating,
            __available_time,
            __availability,
            __available_quantity,
            __fulfillment_info,
            __uri,
            __images,
            __audience,
            __color_info,
            __sizes,
            __materials,
            __patterns,
            __conditions,
            __promotions,
            __publish_time,
            __retrievable_fields,
            __variants,
            __local_inventories,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Product")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "ttl" => Ok(__FieldTag::__ttl),
                            "name" => Ok(__FieldTag::__name),
                            "id" => Ok(__FieldTag::__id),
                            "type" => Ok(__FieldTag::__type),
                            "primaryProductId" => Ok(__FieldTag::__primary_product_id),
                            "primary_product_id" => Ok(__FieldTag::__primary_product_id),
                            "collectionMemberIds" => Ok(__FieldTag::__collection_member_ids),
                            "collection_member_ids" => Ok(__FieldTag::__collection_member_ids),
                            "gtin" => Ok(__FieldTag::__gtin),
                            "categories" => Ok(__FieldTag::__categories),
                            "title" => Ok(__FieldTag::__title),
                            "brands" => Ok(__FieldTag::__brands),
                            "description" => Ok(__FieldTag::__description),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "attributes" => Ok(__FieldTag::__attributes),
                            "tags" => Ok(__FieldTag::__tags),
                            "priceInfo" => Ok(__FieldTag::__price_info),
                            "price_info" => Ok(__FieldTag::__price_info),
                            "rating" => Ok(__FieldTag::__rating),
                            "availableTime" => Ok(__FieldTag::__available_time),
                            "available_time" => Ok(__FieldTag::__available_time),
                            "availability" => Ok(__FieldTag::__availability),
                            "availableQuantity" => Ok(__FieldTag::__available_quantity),
                            "available_quantity" => Ok(__FieldTag::__available_quantity),
                            "fulfillmentInfo" => Ok(__FieldTag::__fulfillment_info),
                            "fulfillment_info" => Ok(__FieldTag::__fulfillment_info),
                            "uri" => Ok(__FieldTag::__uri),
                            "images" => Ok(__FieldTag::__images),
                            "audience" => Ok(__FieldTag::__audience),
                            "colorInfo" => Ok(__FieldTag::__color_info),
                            "color_info" => Ok(__FieldTag::__color_info),
                            "sizes" => Ok(__FieldTag::__sizes),
                            "materials" => Ok(__FieldTag::__materials),
                            "patterns" => Ok(__FieldTag::__patterns),
                            "conditions" => Ok(__FieldTag::__conditions),
                            "promotions" => Ok(__FieldTag::__promotions),
                            "publishTime" => Ok(__FieldTag::__publish_time),
                            "publish_time" => Ok(__FieldTag::__publish_time),
                            "retrievableFields" => Ok(__FieldTag::__retrievable_fields),
                            "retrievable_fields" => Ok(__FieldTag::__retrievable_fields),
                            "variants" => Ok(__FieldTag::__variants),
                            "localInventories" => Ok(__FieldTag::__local_inventories),
                            "local_inventories" => Ok(__FieldTag::__local_inventories),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Product;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Product")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            if result.expiration.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `expiration`, a oneof with full ID .google.cloud.retail.v2.Product.expire_time, latest field was expireTime",
                                ));
                            }
                            result.expiration = std::option::Option::Some(
                                crate::model::product::Expiration::ExpireTime(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__ttl => {
                            if !fields.insert(__FieldTag::__ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ttl",
                                ));
                            }
                            if result.expiration.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `expiration`, a oneof with full ID .google.cloud.retail.v2.Product.ttl, latest field was ttl",
                                ));
                            }
                            result.expiration = std::option::Option::Some(
                                crate::model::product::Expiration::Ttl(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Duration>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::product::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__primary_product_id => {
                            if !fields.insert(__FieldTag::__primary_product_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_product_id",
                                ));
                            }
                            result.primary_product_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__collection_member_ids => {
                            if !fields.insert(__FieldTag::__collection_member_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for collection_member_ids",
                                ));
                            }
                            result.collection_member_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__gtin => {
                            if !fields.insert(__FieldTag::__gtin) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gtin",
                                ));
                            }
                            result.gtin = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__categories => {
                            if !fields.insert(__FieldTag::__categories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for categories",
                                ));
                            }
                            result.categories = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for title",
                                ));
                            }
                            result.title = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__brands => {
                            if !fields.insert(__FieldTag::__brands) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for brands",
                                ));
                            }
                            result.brands = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes",
                                ));
                            }
                            result.attributes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::CustomAttribute,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__price_info => {
                            if !fields.insert(__FieldTag::__price_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for price_info",
                                ));
                            }
                            result.price_info =
                                map.next_value::<std::option::Option<crate::model::PriceInfo>>()?;
                        }
                        __FieldTag::__rating => {
                            if !fields.insert(__FieldTag::__rating) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rating",
                                ));
                            }
                            result.rating =
                                map.next_value::<std::option::Option<crate::model::Rating>>()?;
                        }
                        __FieldTag::__available_time => {
                            if !fields.insert(__FieldTag::__available_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_time",
                                ));
                            }
                            result.available_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__availability => {
                            if !fields.insert(__FieldTag::__availability) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for availability",
                                ));
                            }
                            result.availability = map.next_value::<std::option::Option<crate::model::product::Availability>>()?.unwrap_or_default();
                        }
                        __FieldTag::__available_quantity => {
                            if !fields.insert(__FieldTag::__available_quantity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_quantity",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.available_quantity = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__fulfillment_info => {
                            if !fields.insert(__FieldTag::__fulfillment_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fulfillment_info",
                                ));
                            }
                            result.fulfillment_info =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::FulfillmentInfo>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__images => {
                            if !fields.insert(__FieldTag::__images) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for images",
                                ));
                            }
                            result.images = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Image>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__audience => {
                            if !fields.insert(__FieldTag::__audience) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audience",
                                ));
                            }
                            result.audience =
                                map.next_value::<std::option::Option<crate::model::Audience>>()?;
                        }
                        __FieldTag::__color_info => {
                            if !fields.insert(__FieldTag::__color_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for color_info",
                                ));
                            }
                            result.color_info =
                                map.next_value::<std::option::Option<crate::model::ColorInfo>>()?;
                        }
                        __FieldTag::__sizes => {
                            if !fields.insert(__FieldTag::__sizes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sizes",
                                ));
                            }
                            result.sizes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__materials => {
                            if !fields.insert(__FieldTag::__materials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for materials",
                                ));
                            }
                            result.materials = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__patterns => {
                            if !fields.insert(__FieldTag::__patterns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patterns",
                                ));
                            }
                            result.patterns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__conditions => {
                            if !fields.insert(__FieldTag::__conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conditions",
                                ));
                            }
                            result.conditions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__promotions => {
                            if !fields.insert(__FieldTag::__promotions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for promotions",
                                ));
                            }
                            result.promotions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Promotion>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__publish_time => {
                            if !fields.insert(__FieldTag::__publish_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for publish_time",
                                ));
                            }
                            result.publish_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__retrievable_fields => {
                            if !fields.insert(__FieldTag::__retrievable_fields) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retrievable_fields",
                                ));
                            }
                            result.retrievable_fields =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__variants => {
                            if !fields.insert(__FieldTag::__variants) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for variants",
                                ));
                            }
                            result.variants = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Product>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__local_inventories => {
                            if !fields.insert(__FieldTag::__local_inventories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_inventories",
                                ));
                            }
                            result.local_inventories =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::LocalInventory>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Product {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.expire_time() {
            state.serialize_entry("expireTime", value)?;
        }
        if let Some(value) = self.ttl() {
            state.serialize_entry("ttl", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.primary_product_id.is_empty() {
            state.serialize_entry("primaryProductId", &self.primary_product_id)?;
        }
        if !self.collection_member_ids.is_empty() {
            state.serialize_entry("collectionMemberIds", &self.collection_member_ids)?;
        }
        if !self.gtin.is_empty() {
            state.serialize_entry("gtin", &self.gtin)?;
        }
        if !self.categories.is_empty() {
            state.serialize_entry("categories", &self.categories)?;
        }
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.brands.is_empty() {
            state.serialize_entry("brands", &self.brands)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self.attributes.is_empty() {
            state.serialize_entry("attributes", &self.attributes)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if self.price_info.is_some() {
            state.serialize_entry("priceInfo", &self.price_info)?;
        }
        if self.rating.is_some() {
            state.serialize_entry("rating", &self.rating)?;
        }
        if self.available_time.is_some() {
            state.serialize_entry("availableTime", &self.available_time)?;
        }
        if !wkt::internal::is_default(&self.availability) {
            state.serialize_entry("availability", &self.availability)?;
        }
        if self.available_quantity.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("availableQuantity", &__With(&self.available_quantity))?;
        }
        if !self.fulfillment_info.is_empty() {
            state.serialize_entry("fulfillmentInfo", &self.fulfillment_info)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.images.is_empty() {
            state.serialize_entry("images", &self.images)?;
        }
        if self.audience.is_some() {
            state.serialize_entry("audience", &self.audience)?;
        }
        if self.color_info.is_some() {
            state.serialize_entry("colorInfo", &self.color_info)?;
        }
        if !self.sizes.is_empty() {
            state.serialize_entry("sizes", &self.sizes)?;
        }
        if !self.materials.is_empty() {
            state.serialize_entry("materials", &self.materials)?;
        }
        if !self.patterns.is_empty() {
            state.serialize_entry("patterns", &self.patterns)?;
        }
        if !self.conditions.is_empty() {
            state.serialize_entry("conditions", &self.conditions)?;
        }
        if !self.promotions.is_empty() {
            state.serialize_entry("promotions", &self.promotions)?;
        }
        if self.publish_time.is_some() {
            state.serialize_entry("publishTime", &self.publish_time)?;
        }
        if self.retrievable_fields.is_some() {
            state.serialize_entry("retrievableFields", &self.retrievable_fields)?;
        }
        if !self.variants.is_empty() {
            state.serialize_entry("variants", &self.variants)?;
        }
        if !self.local_inventories.is_empty() {
            state.serialize_entry("localInventories", &self.local_inventories)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Product {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Product");
        debug_struct.field("name", &self.name);
        debug_struct.field("id", &self.id);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("primary_product_id", &self.primary_product_id);
        debug_struct.field("collection_member_ids", &self.collection_member_ids);
        debug_struct.field("gtin", &self.gtin);
        debug_struct.field("categories", &self.categories);
        debug_struct.field("title", &self.title);
        debug_struct.field("brands", &self.brands);
        debug_struct.field("description", &self.description);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("attributes", &self.attributes);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("price_info", &self.price_info);
        debug_struct.field("rating", &self.rating);
        debug_struct.field("available_time", &self.available_time);
        debug_struct.field("availability", &self.availability);
        debug_struct.field("available_quantity", &self.available_quantity);
        debug_struct.field("fulfillment_info", &self.fulfillment_info);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("images", &self.images);
        debug_struct.field("audience", &self.audience);
        debug_struct.field("color_info", &self.color_info);
        debug_struct.field("sizes", &self.sizes);
        debug_struct.field("materials", &self.materials);
        debug_struct.field("patterns", &self.patterns);
        debug_struct.field("conditions", &self.conditions);
        debug_struct.field("promotions", &self.promotions);
        debug_struct.field("publish_time", &self.publish_time);
        debug_struct.field("retrievable_fields", &self.retrievable_fields);
        debug_struct.field("variants", &self.variants);
        debug_struct.field("local_inventories", &self.local_inventories);
        debug_struct.field("expiration", &self.expiration);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Product].
pub mod product {
    #[allow(unused_imports)]
    use super::*;

    /// The type of this product.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Default value. Default to
        /// [Catalog.product_level_config.ingestion_product_type][google.cloud.retail.v2.ProductLevelConfig.ingestion_product_type]
        /// if unset.
        ///
        /// [google.cloud.retail.v2.ProductLevelConfig.ingestion_product_type]: crate::model::ProductLevelConfig::ingestion_product_type
        Unspecified,
        /// The primary type.
        ///
        /// As the primary unit for predicting, indexing and search serving, a
        /// [Type.PRIMARY][google.cloud.retail.v2.Product.Type.PRIMARY]
        /// [Product][google.cloud.retail.v2.Product] is grouped with multiple
        /// [Type.VARIANT][google.cloud.retail.v2.Product.Type.VARIANT]
        /// [Product][google.cloud.retail.v2.Product]s.
        ///
        /// [google.cloud.retail.v2.Product]: crate::model::Product
        /// [google.cloud.retail.v2.Product.Type.PRIMARY]: crate::model::product::Type::Primary
        /// [google.cloud.retail.v2.Product.Type.VARIANT]: crate::model::product::Type::Variant
        Primary,
        /// The variant type.
        ///
        /// [Type.VARIANT][google.cloud.retail.v2.Product.Type.VARIANT]
        /// [Product][google.cloud.retail.v2.Product]s usually share some common
        /// attributes on the same
        /// [Type.PRIMARY][google.cloud.retail.v2.Product.Type.PRIMARY]
        /// [Product][google.cloud.retail.v2.Product]s, but they have variant
        /// attributes like different colors, sizes and prices, etc.
        ///
        /// [google.cloud.retail.v2.Product]: crate::model::Product
        /// [google.cloud.retail.v2.Product.Type.PRIMARY]: crate::model::product::Type::Primary
        /// [google.cloud.retail.v2.Product.Type.VARIANT]: crate::model::product::Type::Variant
        Variant,
        /// The collection type. Collection products are bundled
        /// [Type.PRIMARY][google.cloud.retail.v2.Product.Type.PRIMARY]
        /// [Product][google.cloud.retail.v2.Product]s or
        /// [Type.VARIANT][google.cloud.retail.v2.Product.Type.VARIANT]
        /// [Product][google.cloud.retail.v2.Product]s that are sold together, such
        /// as a jewelry set with necklaces, earrings and rings, etc.
        ///
        /// [google.cloud.retail.v2.Product]: crate::model::Product
        /// [google.cloud.retail.v2.Product.Type.PRIMARY]: crate::model::product::Type::Primary
        /// [google.cloud.retail.v2.Product.Type.VARIANT]: crate::model::product::Type::Variant
        Collection,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Primary => std::option::Option::Some(1),
                Self::Variant => std::option::Option::Some(2),
                Self::Collection => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Primary => std::option::Option::Some("PRIMARY"),
                Self::Variant => std::option::Option::Some("VARIANT"),
                Self::Collection => std::option::Option::Some("COLLECTION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Primary,
                2 => Self::Variant,
                3 => Self::Collection,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "PRIMARY" => Self::Primary,
                "VARIANT" => Self::Variant,
                "COLLECTION" => Self::Collection,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Primary => serializer.serialize_i32(1),
                Self::Variant => serializer.serialize_i32(2),
                Self::Collection => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.retail.v2.Product.Type",
            ))
        }
    }

    /// Product availability. If this field is unspecified, the product is
    /// assumed to be in stock.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Availability {
        /// Default product availability. Default to
        /// [Availability.IN_STOCK][google.cloud.retail.v2.Product.Availability.IN_STOCK]
        /// if unset.
        ///
        /// [google.cloud.retail.v2.Product.Availability.IN_STOCK]: crate::model::product::Availability::InStock
        Unspecified,
        /// Product in stock.
        InStock,
        /// Product out of stock.
        OutOfStock,
        /// Product that is in pre-order state.
        Preorder,
        /// Product that is back-ordered (i.e. temporarily out of stock).
        Backorder,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Availability::value] or
        /// [Availability::name].
        UnknownValue(availability::UnknownValue),
    }

    #[doc(hidden)]
    pub mod availability {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Availability {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InStock => std::option::Option::Some(1),
                Self::OutOfStock => std::option::Option::Some(2),
                Self::Preorder => std::option::Option::Some(3),
                Self::Backorder => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("AVAILABILITY_UNSPECIFIED"),
                Self::InStock => std::option::Option::Some("IN_STOCK"),
                Self::OutOfStock => std::option::Option::Some("OUT_OF_STOCK"),
                Self::Preorder => std::option::Option::Some("PREORDER"),
                Self::Backorder => std::option::Option::Some("BACKORDER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Availability {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Availability {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Availability {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InStock,
                2 => Self::OutOfStock,
                3 => Self::Preorder,
                4 => Self::Backorder,
                _ => Self::UnknownValue(availability::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Availability {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AVAILABILITY_UNSPECIFIED" => Self::Unspecified,
                "IN_STOCK" => Self::InStock,
                "OUT_OF_STOCK" => Self::OutOfStock,
                "PREORDER" => Self::Preorder,
                "BACKORDER" => Self::Backorder,
                _ => Self::UnknownValue(availability::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Availability {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InStock => serializer.serialize_i32(1),
                Self::OutOfStock => serializer.serialize_i32(2),
                Self::Preorder => serializer.serialize_i32(3),
                Self::Backorder => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Availability {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Availability>::new(
                ".google.cloud.retail.v2.Product.Availability",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Expiration {
        /// Note that this field is applied in the following ways:
        ///
        /// * If the [Product][google.cloud.retail.v2.Product] is already expired
        ///   when it is uploaded, this product
        ///   is not indexed for search.
        ///
        /// * If the [Product][google.cloud.retail.v2.Product] is not expired when it
        ///   is uploaded, only the
        ///   [Type.PRIMARY][google.cloud.retail.v2.Product.Type.PRIMARY]'s and
        ///   [Type.COLLECTION][google.cloud.retail.v2.Product.Type.COLLECTION]'s
        ///   expireTime is respected, and
        ///   [Type.VARIANT][google.cloud.retail.v2.Product.Type.VARIANT]'s
        ///   expireTime is not used.
        ///
        ///
        /// In general, we suggest the users to delete the stale
        /// products explicitly, instead of using this field to determine staleness.
        ///
        /// [expire_time][google.cloud.retail.v2.Product.expire_time] must be later
        /// than [available_time][google.cloud.retail.v2.Product.available_time] and
        /// [publish_time][google.cloud.retail.v2.Product.publish_time], otherwise an
        /// INVALID_ARGUMENT error is thrown.
        ///
        /// Corresponding properties: Google Merchant Center property
        /// [expiration_date](https://support.google.com/merchants/answer/6324499).
        ///
        /// [google.cloud.retail.v2.Product]: crate::model::Product
        /// [google.cloud.retail.v2.Product.Type.COLLECTION]: crate::model::product::Type::Collection
        /// [google.cloud.retail.v2.Product.Type.PRIMARY]: crate::model::product::Type::Primary
        /// [google.cloud.retail.v2.Product.Type.VARIANT]: crate::model::product::Type::Variant
        /// [google.cloud.retail.v2.Product.available_time]: crate::model::Product::available_time
        /// [google.cloud.retail.v2.Product.expire_time]: crate::model::Product::expiration
        /// [google.cloud.retail.v2.Product.publish_time]: crate::model::Product::publish_time
        ExpireTime(std::boxed::Box<wkt::Timestamp>),
        /// Input only. The TTL (time to live) of the product. Note that this is only
        /// applicable to [Type.PRIMARY][google.cloud.retail.v2.Product.Type.PRIMARY]
        /// and [Type.COLLECTION][google.cloud.retail.v2.Product.Type.COLLECTION],
        /// and ignored for
        /// [Type.VARIANT][google.cloud.retail.v2.Product.Type.VARIANT]. In general,
        /// we suggest the users to delete the stale products explicitly, instead of
        /// using this field to determine staleness.
        ///
        /// If it is set, it must be a non-negative value, and
        /// [expire_time][google.cloud.retail.v2.Product.expire_time] is set as
        /// current timestamp plus [ttl][google.cloud.retail.v2.Product.ttl]. The
        /// derived [expire_time][google.cloud.retail.v2.Product.expire_time] is
        /// returned in the output and [ttl][google.cloud.retail.v2.Product.ttl] is
        /// left blank when retrieving the [Product][google.cloud.retail.v2.Product].
        ///
        /// If it is set, the product is not available for
        /// [SearchService.Search][google.cloud.retail.v2.SearchService.Search] after
        /// current timestamp plus [ttl][google.cloud.retail.v2.Product.ttl].
        /// However, the product can still be retrieved by
        /// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct]
        /// and
        /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts].
        ///
        /// [google.cloud.retail.v2.Product]: crate::model::Product
        /// [google.cloud.retail.v2.Product.Type.COLLECTION]: crate::model::product::Type::Collection
        /// [google.cloud.retail.v2.Product.Type.PRIMARY]: crate::model::product::Type::Primary
        /// [google.cloud.retail.v2.Product.Type.VARIANT]: crate::model::product::Type::Variant
        /// [google.cloud.retail.v2.Product.expire_time]: crate::model::Product::expiration
        /// [google.cloud.retail.v2.Product.ttl]: crate::model::Product::expiration
        /// [google.cloud.retail.v2.ProductService.GetProduct]: crate::client::ProductService::get_product
        /// [google.cloud.retail.v2.ProductService.ListProducts]: crate::client::ProductService::list_products
        /// [google.cloud.retail.v2.SearchService.Search]: crate::client::SearchService::search
        Ttl(std::boxed::Box<wkt::Duration>),
    }
}

/// Request message for
/// [ProductService.CreateProduct][google.cloud.retail.v2.ProductService.CreateProduct]
/// method.
///
/// [google.cloud.retail.v2.ProductService.CreateProduct]: crate::client::ProductService::create_product
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateProductRequest {
    /// Required. The parent catalog resource name, such as
    /// `projects/*/locations/global/catalogs/default_catalog/branches/default_branch`.
    pub parent: std::string::String,

    /// Required. The [Product][google.cloud.retail.v2.Product] to create.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub product: std::option::Option<crate::model::Product>,

    /// Required. The ID to use for the [Product][google.cloud.retail.v2.Product],
    /// which will become the final component of the
    /// [Product.name][google.cloud.retail.v2.Product.name].
    ///
    /// If the caller does not have permission to create the
    /// [Product][google.cloud.retail.v2.Product], regardless of whether or not it
    /// exists, a PERMISSION_DENIED error is returned.
    ///
    /// This field must be unique among all
    /// [Product][google.cloud.retail.v2.Product]s with the same
    /// [parent][google.cloud.retail.v2.CreateProductRequest.parent]. Otherwise, an
    /// ALREADY_EXISTS error is returned.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// [google.cloud.retail.v2.CreateProductRequest.parent]: crate::model::CreateProductRequest::parent
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.Product.name]: crate::model::Product::name
    pub product_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateProductRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateProductRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [product][crate::model::CreateProductRequest::product].
    pub fn set_product<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Product>,
    {
        self.product = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [product][crate::model::CreateProductRequest::product].
    pub fn set_or_clear_product<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Product>,
    {
        self.product = v.map(|x| x.into());
        self
    }

    /// Sets the value of [product_id][crate::model::CreateProductRequest::product_id].
    pub fn set_product_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.product_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateProductRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.CreateProductRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateProductRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __product,
            __product_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateProductRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "product" => Ok(__FieldTag::__product),
                            "productId" => Ok(__FieldTag::__product_id),
                            "product_id" => Ok(__FieldTag::__product_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateProductRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateProductRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__product => {
                            if !fields.insert(__FieldTag::__product) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product",
                                ));
                            }
                            result.product =
                                map.next_value::<std::option::Option<crate::model::Product>>()?;
                        }
                        __FieldTag::__product_id => {
                            if !fields.insert(__FieldTag::__product_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product_id",
                                ));
                            }
                            result.product_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateProductRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.product.is_some() {
            state.serialize_entry("product", &self.product)?;
        }
        if !self.product_id.is_empty() {
            state.serialize_entry("productId", &self.product_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateProductRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateProductRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("product", &self.product);
        debug_struct.field("product_id", &self.product_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [ProductService.GetProduct][google.cloud.retail.v2.ProductService.GetProduct]
/// method.
///
/// [google.cloud.retail.v2.ProductService.GetProduct]: crate::client::ProductService::get_product
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetProductRequest {
    /// Required. Full resource name of [Product][google.cloud.retail.v2.Product],
    /// such as
    /// `projects/*/locations/global/catalogs/default_catalog/branches/default_branch/products/some_product_id`.
    ///
    /// If the caller does not have permission to access the
    /// [Product][google.cloud.retail.v2.Product], regardless of whether or not it
    /// exists, a PERMISSION_DENIED error is returned.
    ///
    /// If the requested [Product][google.cloud.retail.v2.Product] does not exist,
    /// a NOT_FOUND error is returned.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetProductRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetProductRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetProductRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.GetProductRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetProductRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetProductRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetProductRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetProductRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetProductRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetProductRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetProductRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [ProductService.UpdateProduct][google.cloud.retail.v2.ProductService.UpdateProduct]
/// method.
///
/// [google.cloud.retail.v2.ProductService.UpdateProduct]: crate::client::ProductService::update_product
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateProductRequest {
    /// Required. The product to update/create.
    ///
    /// If the caller does not have permission to update the
    /// [Product][google.cloud.retail.v2.Product], regardless of whether or not it
    /// exists, a PERMISSION_DENIED error is returned.
    ///
    /// If the [Product][google.cloud.retail.v2.Product] to update does not exist
    /// and
    /// [allow_missing][google.cloud.retail.v2.UpdateProductRequest.allow_missing]
    /// is not set, a NOT_FOUND error is returned.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.UpdateProductRequest.allow_missing]: crate::model::UpdateProductRequest::allow_missing
    pub product: std::option::Option<crate::model::Product>,

    /// Indicates which fields in the provided
    /// [Product][google.cloud.retail.v2.Product] to update. The immutable and
    /// output only fields are NOT supported. If not set, all supported fields (the
    /// fields that are neither immutable nor output only) are updated.
    ///
    /// If an unsupported or unknown field is provided, an INVALID_ARGUMENT error
    /// is returned.
    ///
    /// The attribute key can be updated by setting the mask path as
    /// "attributes.${key_name}". If a key name is present in the mask but not in
    /// the patching product from the request, this key will be deleted after the
    /// update.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If set to true, and the [Product][google.cloud.retail.v2.Product] is not
    /// found, a new [Product][google.cloud.retail.v2.Product] will be created. In
    /// this situation, `update_mask` is ignored.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub allow_missing: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateProductRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [product][crate::model::UpdateProductRequest::product].
    pub fn set_product<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Product>,
    {
        self.product = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [product][crate::model::UpdateProductRequest::product].
    pub fn set_or_clear_product<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Product>,
    {
        self.product = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateProductRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateProductRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateProductRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateProductRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.UpdateProductRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateProductRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __product,
            __update_mask,
            __allow_missing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateProductRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "product" => Ok(__FieldTag::__product),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateProductRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateProductRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__product => {
                            if !fields.insert(__FieldTag::__product) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product",
                                ));
                            }
                            result.product =
                                map.next_value::<std::option::Option<crate::model::Product>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateProductRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.product.is_some() {
            state.serialize_entry("product", &self.product)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateProductRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateProductRequest");
        debug_struct.field("product", &self.product);
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("allow_missing", &self.allow_missing);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [ProductService.DeleteProduct][google.cloud.retail.v2.ProductService.DeleteProduct]
/// method.
///
/// [google.cloud.retail.v2.ProductService.DeleteProduct]: crate::client::ProductService::delete_product
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteProductRequest {
    /// Required. Full resource name of [Product][google.cloud.retail.v2.Product],
    /// such as
    /// `projects/*/locations/global/catalogs/default_catalog/branches/default_branch/products/some_product_id`.
    ///
    /// If the caller does not have permission to delete the
    /// [Product][google.cloud.retail.v2.Product], regardless of whether or not it
    /// exists, a PERMISSION_DENIED error is returned.
    ///
    /// If the [Product][google.cloud.retail.v2.Product] to delete does not exist,
    /// a NOT_FOUND error is returned.
    ///
    /// The [Product][google.cloud.retail.v2.Product] to delete can neither be a
    /// [Product.Type.COLLECTION][google.cloud.retail.v2.Product.Type.COLLECTION]
    /// [Product][google.cloud.retail.v2.Product] member nor a
    /// [Product.Type.PRIMARY][google.cloud.retail.v2.Product.Type.PRIMARY]
    /// [Product][google.cloud.retail.v2.Product] with more than one
    /// [variants][google.cloud.retail.v2.Product.Type.VARIANT]. Otherwise, an
    /// INVALID_ARGUMENT error is returned.
    ///
    /// All inventory information for the named
    /// [Product][google.cloud.retail.v2.Product] will be deleted.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.Product.Type.COLLECTION]: crate::model::product::Type::Collection
    /// [google.cloud.retail.v2.Product.Type.PRIMARY]: crate::model::product::Type::Primary
    /// [google.cloud.retail.v2.Product.Type.VARIANT]: crate::model::product::Type::Variant
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteProductRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteProductRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteProductRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.DeleteProductRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteProductRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteProductRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteProductRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteProductRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteProductRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteProductRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteProductRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts]
/// method.
///
/// [google.cloud.retail.v2.ProductService.ListProducts]: crate::client::ProductService::list_products
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProductsRequest {
    /// Required. The parent branch resource name, such as
    /// `projects/*/locations/global/catalogs/default_catalog/branches/0`. Use
    /// `default_branch` as the branch ID, to list products under the default
    /// branch.
    ///
    /// If the caller does not have permission to list
    /// [Product][google.cloud.retail.v2.Product]s under this branch, regardless of
    /// whether or not this branch exists, a PERMISSION_DENIED error is returned.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub parent: std::string::String,

    /// Maximum number of [Product][google.cloud.retail.v2.Product]s to return. If
    /// unspecified, defaults to 100. The maximum allowed value is 1000. Values
    /// above 1000 will be coerced to 1000.
    ///
    /// If this field is negative, an INVALID_ARGUMENT error is returned.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub page_size: i32,

    /// A page token
    /// [ListProductsResponse.next_page_token][google.cloud.retail.v2.ListProductsResponse.next_page_token],
    /// received from a previous
    /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts]
    /// must match the call that provided the page token. Otherwise, an
    /// INVALID_ARGUMENT error is returned.
    ///
    /// [google.cloud.retail.v2.ListProductsResponse.next_page_token]: crate::model::ListProductsResponse::next_page_token
    /// [google.cloud.retail.v2.ProductService.ListProducts]: crate::client::ProductService::list_products
    pub page_token: std::string::String,

    /// A filter to apply on the list results. Supported features:
    ///
    /// * List all the products under the parent branch if
    ///   [filter][google.cloud.retail.v2.ListProductsRequest.filter] is unset.
    /// * List [Product.Type.VARIANT][google.cloud.retail.v2.Product.Type.VARIANT]
    ///   [Product][google.cloud.retail.v2.Product]s sharing the same
    ///   [Product.Type.PRIMARY][google.cloud.retail.v2.Product.Type.PRIMARY]
    ///   [Product][google.cloud.retail.v2.Product]. For example:
    ///   `primary_product_id = "some_product_id"`
    /// * List [Product][google.cloud.retail.v2.Product]s bundled in a
    ///   [Product.Type.COLLECTION][google.cloud.retail.v2.Product.Type.COLLECTION]
    ///   [Product][google.cloud.retail.v2.Product].
    ///   For example:
    ///   `collection_product_id = "some_product_id"`
    /// * List [Product][google.cloud.retail.v2.Product]s with a partibular type.
    ///   For example:
    ///   `type = "PRIMARY"`
    ///   `type = "VARIANT"`
    ///   `type = "COLLECTION"`
    ///
    /// If the field is unrecognizable, an INVALID_ARGUMENT error is returned.
    ///
    /// If the specified
    /// [Product.Type.PRIMARY][google.cloud.retail.v2.Product.Type.PRIMARY]
    /// [Product][google.cloud.retail.v2.Product] or
    /// [Product.Type.COLLECTION][google.cloud.retail.v2.Product.Type.COLLECTION]
    /// [Product][google.cloud.retail.v2.Product] does not exist, a NOT_FOUND error
    /// is returned.
    ///
    /// [google.cloud.retail.v2.ListProductsRequest.filter]: crate::model::ListProductsRequest::filter
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.Product.Type.COLLECTION]: crate::model::product::Type::Collection
    /// [google.cloud.retail.v2.Product.Type.PRIMARY]: crate::model::product::Type::Primary
    /// [google.cloud.retail.v2.Product.Type.VARIANT]: crate::model::product::Type::Variant
    pub filter: std::string::String,

    /// The fields of [Product][google.cloud.retail.v2.Product] to return in the
    /// responses. If not set or empty, the following fields are returned:
    ///
    /// * [Product.name][google.cloud.retail.v2.Product.name]
    /// * [Product.id][google.cloud.retail.v2.Product.id]
    /// * [Product.title][google.cloud.retail.v2.Product.title]
    /// * [Product.uri][google.cloud.retail.v2.Product.uri]
    /// * [Product.images][google.cloud.retail.v2.Product.images]
    /// * [Product.price_info][google.cloud.retail.v2.Product.price_info]
    /// * [Product.brands][google.cloud.retail.v2.Product.brands]
    ///
    /// If "*" is provided, all fields are returned.
    /// [Product.name][google.cloud.retail.v2.Product.name] is always returned no
    /// matter what mask is set.
    ///
    /// If an unsupported or unknown field is provided, an INVALID_ARGUMENT error
    /// is returned.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.Product.brands]: crate::model::Product::brands
    /// [google.cloud.retail.v2.Product.id]: crate::model::Product::id
    /// [google.cloud.retail.v2.Product.images]: crate::model::Product::images
    /// [google.cloud.retail.v2.Product.name]: crate::model::Product::name
    /// [google.cloud.retail.v2.Product.price_info]: crate::model::Product::price_info
    /// [google.cloud.retail.v2.Product.title]: crate::model::Product::title
    /// [google.cloud.retail.v2.Product.uri]: crate::model::Product::uri
    pub read_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProductsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListProductsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListProductsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListProductsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListProductsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [read_mask][crate::model::ListProductsRequest::read_mask].
    pub fn set_read_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_mask][crate::model::ListProductsRequest::read_mask].
    pub fn set_or_clear_read_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.read_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ListProductsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ListProductsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProductsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __read_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProductsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "readMask" => Ok(__FieldTag::__read_mask),
                            "read_mask" => Ok(__FieldTag::__read_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProductsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProductsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__read_mask => {
                            if !fields.insert(__FieldTag::__read_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for read_mask",
                                ));
                            }
                            result.read_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProductsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if self.read_mask.is_some() {
            state.serialize_entry("readMask", &self.read_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListProductsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProductsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("read_mask", &self.read_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for
/// [ProductService.ListProducts][google.cloud.retail.v2.ProductService.ListProducts]
/// method.
///
/// [google.cloud.retail.v2.ProductService.ListProducts]: crate::client::ProductService::list_products
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListProductsResponse {
    /// The [Product][google.cloud.retail.v2.Product]s.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub products: std::vec::Vec<crate::model::Product>,

    /// A token that can be sent as
    /// [ListProductsRequest.page_token][google.cloud.retail.v2.ListProductsRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.retail.v2.ListProductsRequest.page_token]: crate::model::ListProductsRequest::page_token
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListProductsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [products][crate::model::ListProductsResponse::products].
    pub fn set_products<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Product>,
    {
        use std::iter::Iterator;
        self.products = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListProductsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListProductsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ListProductsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListProductsResponse {
    type PageItem = crate::model::Product;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.products
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListProductsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __products,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListProductsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "products" => Ok(__FieldTag::__products),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListProductsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListProductsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__products => {
                            if !fields.insert(__FieldTag::__products) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for products",
                                ));
                            }
                            result.products = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Product>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListProductsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.products.is_empty() {
            state.serialize_entry("products", &self.products)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListProductsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListProductsResponse");
        debug_struct.field("products", &self.products);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [ProductService.SetInventory][google.cloud.retail.v2.ProductService.SetInventory]
/// method.
///
/// [google.cloud.retail.v2.ProductService.SetInventory]: crate::client::ProductService::set_inventory
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetInventoryRequest {
    /// Required. The inventory information to update. The allowable fields to
    /// update are:
    ///
    /// * [Product.price_info][google.cloud.retail.v2.Product.price_info]
    /// * [Product.availability][google.cloud.retail.v2.Product.availability]
    /// * [Product.available_quantity][google.cloud.retail.v2.Product.available_quantity]
    /// * [Product.fulfillment_info][google.cloud.retail.v2.Product.fulfillment_info]
    ///   The updated inventory fields must be specified in
    ///   [SetInventoryRequest.set_mask][google.cloud.retail.v2.SetInventoryRequest.set_mask].
    ///
    /// If
    /// [SetInventoryRequest.inventory.name][google.cloud.retail.v2.Product.name]
    /// is empty or invalid, an INVALID_ARGUMENT error is returned.
    ///
    /// If the caller does not have permission to update the
    /// [Product][google.cloud.retail.v2.Product] named in
    /// [Product.name][google.cloud.retail.v2.Product.name], regardless of whether
    /// or not it exists, a PERMISSION_DENIED error is returned.
    ///
    /// If the [Product][google.cloud.retail.v2.Product] to update does not have
    /// existing inventory information, the provided inventory information will be
    /// inserted.
    ///
    /// If the [Product][google.cloud.retail.v2.Product] to update has existing
    /// inventory information, the provided inventory information will be merged
    /// while respecting the last update time for each inventory field, using the
    /// provided or default value for
    /// [SetInventoryRequest.set_time][google.cloud.retail.v2.SetInventoryRequest.set_time].
    ///
    /// The caller can replace place IDs for a subset of fulfillment types in the
    /// following ways:
    ///
    /// * Adds "fulfillment_info" in
    ///   [SetInventoryRequest.set_mask][google.cloud.retail.v2.SetInventoryRequest.set_mask]
    /// * Specifies only the desired fulfillment types and corresponding place IDs
    ///   to update in
    ///   [SetInventoryRequest.inventory.fulfillment_info][google.cloud.retail.v2.Product.fulfillment_info]
    ///
    /// The caller can clear all place IDs from a subset of fulfillment types in
    /// the following ways:
    ///
    /// * Adds "fulfillment_info" in
    ///   [SetInventoryRequest.set_mask][google.cloud.retail.v2.SetInventoryRequest.set_mask]
    /// * Specifies only the desired fulfillment types to clear in
    ///   [SetInventoryRequest.inventory.fulfillment_info][google.cloud.retail.v2.Product.fulfillment_info]
    /// * Checks that only the desired fulfillment info types have empty
    ///   [SetInventoryRequest.inventory.fulfillment_info.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids]
    ///
    /// The last update time is recorded for the following inventory fields:
    ///
    /// * [Product.price_info][google.cloud.retail.v2.Product.price_info]
    /// * [Product.availability][google.cloud.retail.v2.Product.availability]
    /// * [Product.available_quantity][google.cloud.retail.v2.Product.available_quantity]
    /// * [Product.fulfillment_info][google.cloud.retail.v2.Product.fulfillment_info]
    ///
    /// If a full overwrite of inventory information while ignoring timestamps is
    /// needed,
    /// [ProductService.UpdateProduct][google.cloud.retail.v2.ProductService.UpdateProduct]
    /// should be invoked instead.
    ///
    /// [google.cloud.retail.v2.FulfillmentInfo.place_ids]: crate::model::FulfillmentInfo::place_ids
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.Product.availability]: crate::model::Product::availability
    /// [google.cloud.retail.v2.Product.available_quantity]: crate::model::Product::available_quantity
    /// [google.cloud.retail.v2.Product.fulfillment_info]: crate::model::Product::fulfillment_info
    /// [google.cloud.retail.v2.Product.name]: crate::model::Product::name
    /// [google.cloud.retail.v2.Product.price_info]: crate::model::Product::price_info
    /// [google.cloud.retail.v2.ProductService.UpdateProduct]: crate::client::ProductService::update_product
    /// [google.cloud.retail.v2.SetInventoryRequest.set_mask]: crate::model::SetInventoryRequest::set_mask
    /// [google.cloud.retail.v2.SetInventoryRequest.set_time]: crate::model::SetInventoryRequest::set_time
    pub inventory: std::option::Option<crate::model::Product>,

    /// Indicates which inventory fields in the provided
    /// [Product][google.cloud.retail.v2.Product] to update.
    ///
    /// At least one field must be provided.
    ///
    /// If an unsupported or unknown field is provided, an INVALID_ARGUMENT error
    /// is returned and the entire update will be ignored.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub set_mask: std::option::Option<wkt::FieldMask>,

    /// The time when the request is issued, used to prevent
    /// out-of-order updates on inventory fields with the last update time
    /// recorded. If not provided, the internal system time will be used.
    pub set_time: std::option::Option<wkt::Timestamp>,

    /// If set to true, and the [Product][google.cloud.retail.v2.Product] with name
    /// [Product.name][google.cloud.retail.v2.Product.name] is not found, the
    /// inventory update will still be processed and retained for at most 1 day
    /// until the [Product][google.cloud.retail.v2.Product] is created. If set to
    /// false, a NOT_FOUND error is returned if the
    /// [Product][google.cloud.retail.v2.Product] is not found.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.Product.name]: crate::model::Product::name
    pub allow_missing: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetInventoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [inventory][crate::model::SetInventoryRequest::inventory].
    pub fn set_inventory<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Product>,
    {
        self.inventory = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inventory][crate::model::SetInventoryRequest::inventory].
    pub fn set_or_clear_inventory<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Product>,
    {
        self.inventory = v.map(|x| x.into());
        self
    }

    /// Sets the value of [set_mask][crate::model::SetInventoryRequest::set_mask].
    pub fn set_set_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.set_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [set_mask][crate::model::SetInventoryRequest::set_mask].
    pub fn set_or_clear_set_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.set_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [set_time][crate::model::SetInventoryRequest::set_time].
    pub fn set_set_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.set_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [set_time][crate::model::SetInventoryRequest::set_time].
    pub fn set_or_clear_set_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.set_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_missing][crate::model::SetInventoryRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for SetInventoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.SetInventoryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetInventoryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __inventory,
            __set_mask,
            __set_time,
            __allow_missing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetInventoryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inventory" => Ok(__FieldTag::__inventory),
                            "setMask" => Ok(__FieldTag::__set_mask),
                            "set_mask" => Ok(__FieldTag::__set_mask),
                            "setTime" => Ok(__FieldTag::__set_time),
                            "set_time" => Ok(__FieldTag::__set_time),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetInventoryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetInventoryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__inventory => {
                            if !fields.insert(__FieldTag::__inventory) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inventory",
                                ));
                            }
                            result.inventory =
                                map.next_value::<std::option::Option<crate::model::Product>>()?;
                        }
                        __FieldTag::__set_mask => {
                            if !fields.insert(__FieldTag::__set_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for set_mask",
                                ));
                            }
                            result.set_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__set_time => {
                            if !fields.insert(__FieldTag::__set_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for set_time",
                                ));
                            }
                            result.set_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SetInventoryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.inventory.is_some() {
            state.serialize_entry("inventory", &self.inventory)?;
        }
        if self.set_mask.is_some() {
            state.serialize_entry("setMask", &self.set_mask)?;
        }
        if self.set_time.is_some() {
            state.serialize_entry("setTime", &self.set_time)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SetInventoryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetInventoryRequest");
        debug_struct.field("inventory", &self.inventory);
        debug_struct.field("set_mask", &self.set_mask);
        debug_struct.field("set_time", &self.set_time);
        debug_struct.field("allow_missing", &self.allow_missing);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata related to the progress of the SetInventory operation.
/// Currently empty because there is no meaningful metadata populated from the
/// [ProductService.SetInventory][google.cloud.retail.v2.ProductService.SetInventory]
/// method.
///
/// [google.cloud.retail.v2.ProductService.SetInventory]: crate::client::ProductService::set_inventory
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetInventoryMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetInventoryMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SetInventoryMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.SetInventoryMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetInventoryMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetInventoryMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetInventoryMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetInventoryMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SetInventoryMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SetInventoryMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetInventoryMetadata");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response of the SetInventoryRequest.  Currently empty because
/// there is no meaningful response populated from the
/// [ProductService.SetInventory][google.cloud.retail.v2.ProductService.SetInventory]
/// method.
///
/// [google.cloud.retail.v2.ProductService.SetInventory]: crate::client::ProductService::set_inventory
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetInventoryResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetInventoryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SetInventoryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.SetInventoryResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetInventoryResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetInventoryResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetInventoryResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetInventoryResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SetInventoryResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SetInventoryResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetInventoryResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [ProductService.AddFulfillmentPlaces][google.cloud.retail.v2.ProductService.AddFulfillmentPlaces]
/// method.
///
/// [google.cloud.retail.v2.ProductService.AddFulfillmentPlaces]: crate::client::ProductService::add_fulfillment_places
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AddFulfillmentPlacesRequest {
    /// Required. Full resource name of [Product][google.cloud.retail.v2.Product],
    /// such as
    /// `projects/*/locations/global/catalogs/default_catalog/branches/default_branch/products/some_product_id`.
    ///
    /// If the caller does not have permission to access the
    /// [Product][google.cloud.retail.v2.Product], regardless of whether or not it
    /// exists, a PERMISSION_DENIED error is returned.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub product: std::string::String,

    /// Required. The fulfillment type, including commonly used types (such as
    /// pickup in store and same day delivery), and custom types.
    ///
    /// Supported values:
    ///
    /// * "pickup-in-store"
    /// * "ship-to-store"
    /// * "same-day-delivery"
    /// * "next-day-delivery"
    /// * "custom-type-1"
    /// * "custom-type-2"
    /// * "custom-type-3"
    /// * "custom-type-4"
    /// * "custom-type-5"
    ///
    /// If this field is set to an invalid value other than these, an
    /// INVALID_ARGUMENT error is returned.
    ///
    /// This field directly corresponds to
    /// [Product.fulfillment_info.type][google.cloud.retail.v2.FulfillmentInfo.type].
    ///
    /// [google.cloud.retail.v2.FulfillmentInfo.type]: crate::model::FulfillmentInfo::type
    pub r#type: std::string::String,

    /// Required. The IDs for this
    /// [type][google.cloud.retail.v2.AddFulfillmentPlacesRequest.type], such as
    /// the store IDs for "pickup-in-store" or the region IDs for
    /// "same-day-delivery" to be added for this
    /// [type][google.cloud.retail.v2.AddFulfillmentPlacesRequest.type]. Duplicate
    /// IDs will be automatically ignored.
    ///
    /// At least 1 value is required, and a maximum of 2000 values are allowed.
    /// Each value must be a string with a length limit of 10 characters, matching
    /// the pattern `[a-zA-Z0-9_-]+`, such as "store1" or "REGION-2". Otherwise, an
    /// INVALID_ARGUMENT error is returned.
    ///
    /// If the total number of place IDs exceeds 2000 for this
    /// [type][google.cloud.retail.v2.AddFulfillmentPlacesRequest.type] after
    /// adding, then the update will be rejected.
    ///
    /// [google.cloud.retail.v2.AddFulfillmentPlacesRequest.type]: crate::model::AddFulfillmentPlacesRequest::type
    pub place_ids: std::vec::Vec<std::string::String>,

    /// The time when the fulfillment updates are issued, used to prevent
    /// out-of-order updates on fulfillment information. If not provided, the
    /// internal system time will be used.
    pub add_time: std::option::Option<wkt::Timestamp>,

    /// If set to true, and the [Product][google.cloud.retail.v2.Product] is not
    /// found, the fulfillment information will still be processed and retained for
    /// at most 1 day and processed once the
    /// [Product][google.cloud.retail.v2.Product] is created. If set to false, a
    /// NOT_FOUND error is returned if the
    /// [Product][google.cloud.retail.v2.Product] is not found.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub allow_missing: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddFulfillmentPlacesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [product][crate::model::AddFulfillmentPlacesRequest::product].
    pub fn set_product<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.product = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::AddFulfillmentPlacesRequest::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [place_ids][crate::model::AddFulfillmentPlacesRequest::place_ids].
    pub fn set_place_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.place_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [add_time][crate::model::AddFulfillmentPlacesRequest::add_time].
    pub fn set_add_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.add_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [add_time][crate::model::AddFulfillmentPlacesRequest::add_time].
    pub fn set_or_clear_add_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.add_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_missing][crate::model::AddFulfillmentPlacesRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for AddFulfillmentPlacesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.AddFulfillmentPlacesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AddFulfillmentPlacesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __product,
            __type,
            __place_ids,
            __add_time,
            __allow_missing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AddFulfillmentPlacesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "product" => Ok(__FieldTag::__product),
                            "type" => Ok(__FieldTag::__type),
                            "placeIds" => Ok(__FieldTag::__place_ids),
                            "place_ids" => Ok(__FieldTag::__place_ids),
                            "addTime" => Ok(__FieldTag::__add_time),
                            "add_time" => Ok(__FieldTag::__add_time),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AddFulfillmentPlacesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AddFulfillmentPlacesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__product => {
                            if !fields.insert(__FieldTag::__product) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product",
                                ));
                            }
                            result.product = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__place_ids => {
                            if !fields.insert(__FieldTag::__place_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for place_ids",
                                ));
                            }
                            result.place_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__add_time => {
                            if !fields.insert(__FieldTag::__add_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for add_time",
                                ));
                            }
                            result.add_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AddFulfillmentPlacesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.product.is_empty() {
            state.serialize_entry("product", &self.product)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.place_ids.is_empty() {
            state.serialize_entry("placeIds", &self.place_ids)?;
        }
        if self.add_time.is_some() {
            state.serialize_entry("addTime", &self.add_time)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AddFulfillmentPlacesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AddFulfillmentPlacesRequest");
        debug_struct.field("product", &self.product);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("place_ids", &self.place_ids);
        debug_struct.field("add_time", &self.add_time);
        debug_struct.field("allow_missing", &self.allow_missing);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata related to the progress of the AddFulfillmentPlaces operation.
/// Currently empty because there is no meaningful metadata populated from the
/// [ProductService.AddFulfillmentPlaces][google.cloud.retail.v2.ProductService.AddFulfillmentPlaces]
/// method.
///
/// [google.cloud.retail.v2.ProductService.AddFulfillmentPlaces]: crate::client::ProductService::add_fulfillment_places
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AddFulfillmentPlacesMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddFulfillmentPlacesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AddFulfillmentPlacesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.AddFulfillmentPlacesMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AddFulfillmentPlacesMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AddFulfillmentPlacesMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AddFulfillmentPlacesMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AddFulfillmentPlacesMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AddFulfillmentPlacesMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AddFulfillmentPlacesMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AddFulfillmentPlacesMetadata");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response of the AddFulfillmentPlacesRequest.  Currently empty because
/// there is no meaningful response populated from the
/// [ProductService.AddFulfillmentPlaces][google.cloud.retail.v2.ProductService.AddFulfillmentPlaces]
/// method.
///
/// [google.cloud.retail.v2.ProductService.AddFulfillmentPlaces]: crate::client::ProductService::add_fulfillment_places
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AddFulfillmentPlacesResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddFulfillmentPlacesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AddFulfillmentPlacesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.AddFulfillmentPlacesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AddFulfillmentPlacesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AddFulfillmentPlacesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AddFulfillmentPlacesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AddFulfillmentPlacesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AddFulfillmentPlacesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AddFulfillmentPlacesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AddFulfillmentPlacesResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [ProductService.AddLocalInventories][google.cloud.retail.v2.ProductService.AddLocalInventories]
/// method.
///
/// [google.cloud.retail.v2.ProductService.AddLocalInventories]: crate::client::ProductService::add_local_inventories
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AddLocalInventoriesRequest {
    /// Required. Full resource name of [Product][google.cloud.retail.v2.Product],
    /// such as
    /// `projects/*/locations/global/catalogs/default_catalog/branches/default_branch/products/some_product_id`.
    ///
    /// If the caller does not have permission to access the
    /// [Product][google.cloud.retail.v2.Product], regardless of whether or not it
    /// exists, a PERMISSION_DENIED error is returned.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub product: std::string::String,

    /// Required. A list of inventory information at difference places. Each place
    /// is identified by its place ID. At most 3000 inventories are allowed per
    /// request.
    pub local_inventories: std::vec::Vec<crate::model::LocalInventory>,

    /// Indicates which inventory fields in the provided list of
    /// [LocalInventory][google.cloud.retail.v2.LocalInventory] to update. The
    /// field is updated to the provided value.
    ///
    /// If a field is set while the place does not have a previous local inventory,
    /// the local inventory at that store is created.
    ///
    /// If a field is set while the value of that field is not provided, the
    /// original field value, if it exists, is deleted.
    ///
    /// If the mask is not set or set with empty paths, all inventory fields will
    /// be updated.
    ///
    /// If an unsupported or unknown field is provided, an INVALID_ARGUMENT error
    /// is returned and the entire update will be ignored.
    ///
    /// [google.cloud.retail.v2.LocalInventory]: crate::model::LocalInventory
    pub add_mask: std::option::Option<wkt::FieldMask>,

    /// The time when the inventory updates are issued. Used to prevent
    /// out-of-order updates on local inventory fields. If not provided, the
    /// internal system time will be used.
    pub add_time: std::option::Option<wkt::Timestamp>,

    /// If set to true, and the [Product][google.cloud.retail.v2.Product] is not
    /// found, the local inventory will still be processed and retained for at most
    /// 1 day and processed once the [Product][google.cloud.retail.v2.Product] is
    /// created. If set to false, a NOT_FOUND error is returned if the
    /// [Product][google.cloud.retail.v2.Product] is not found.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub allow_missing: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddLocalInventoriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [product][crate::model::AddLocalInventoriesRequest::product].
    pub fn set_product<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.product = v.into();
        self
    }

    /// Sets the value of [local_inventories][crate::model::AddLocalInventoriesRequest::local_inventories].
    pub fn set_local_inventories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LocalInventory>,
    {
        use std::iter::Iterator;
        self.local_inventories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [add_mask][crate::model::AddLocalInventoriesRequest::add_mask].
    pub fn set_add_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.add_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [add_mask][crate::model::AddLocalInventoriesRequest::add_mask].
    pub fn set_or_clear_add_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.add_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [add_time][crate::model::AddLocalInventoriesRequest::add_time].
    pub fn set_add_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.add_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [add_time][crate::model::AddLocalInventoriesRequest::add_time].
    pub fn set_or_clear_add_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.add_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_missing][crate::model::AddLocalInventoriesRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for AddLocalInventoriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.AddLocalInventoriesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AddLocalInventoriesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __product,
            __local_inventories,
            __add_mask,
            __add_time,
            __allow_missing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AddLocalInventoriesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "product" => Ok(__FieldTag::__product),
                            "localInventories" => Ok(__FieldTag::__local_inventories),
                            "local_inventories" => Ok(__FieldTag::__local_inventories),
                            "addMask" => Ok(__FieldTag::__add_mask),
                            "add_mask" => Ok(__FieldTag::__add_mask),
                            "addTime" => Ok(__FieldTag::__add_time),
                            "add_time" => Ok(__FieldTag::__add_time),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AddLocalInventoriesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AddLocalInventoriesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__product => {
                            if !fields.insert(__FieldTag::__product) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product",
                                ));
                            }
                            result.product = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__local_inventories => {
                            if !fields.insert(__FieldTag::__local_inventories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_inventories",
                                ));
                            }
                            result.local_inventories =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::LocalInventory>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__add_mask => {
                            if !fields.insert(__FieldTag::__add_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for add_mask",
                                ));
                            }
                            result.add_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__add_time => {
                            if !fields.insert(__FieldTag::__add_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for add_time",
                                ));
                            }
                            result.add_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AddLocalInventoriesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.product.is_empty() {
            state.serialize_entry("product", &self.product)?;
        }
        if !self.local_inventories.is_empty() {
            state.serialize_entry("localInventories", &self.local_inventories)?;
        }
        if self.add_mask.is_some() {
            state.serialize_entry("addMask", &self.add_mask)?;
        }
        if self.add_time.is_some() {
            state.serialize_entry("addTime", &self.add_time)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AddLocalInventoriesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AddLocalInventoriesRequest");
        debug_struct.field("product", &self.product);
        debug_struct.field("local_inventories", &self.local_inventories);
        debug_struct.field("add_mask", &self.add_mask);
        debug_struct.field("add_time", &self.add_time);
        debug_struct.field("allow_missing", &self.allow_missing);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata related to the progress of the AddLocalInventories operation.
/// Currently empty because there is no meaningful metadata populated from the
/// [ProductService.AddLocalInventories][google.cloud.retail.v2.ProductService.AddLocalInventories]
/// method.
///
/// [google.cloud.retail.v2.ProductService.AddLocalInventories]: crate::client::ProductService::add_local_inventories
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AddLocalInventoriesMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddLocalInventoriesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AddLocalInventoriesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.AddLocalInventoriesMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AddLocalInventoriesMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AddLocalInventoriesMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AddLocalInventoriesMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AddLocalInventoriesMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AddLocalInventoriesMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AddLocalInventoriesMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AddLocalInventoriesMetadata");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response of the
/// [ProductService.AddLocalInventories][google.cloud.retail.v2.ProductService.AddLocalInventories]
/// API.  Currently empty because there is no meaningful response populated from
/// the
/// [ProductService.AddLocalInventories][google.cloud.retail.v2.ProductService.AddLocalInventories]
/// method.
///
/// [google.cloud.retail.v2.ProductService.AddLocalInventories]: crate::client::ProductService::add_local_inventories
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AddLocalInventoriesResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddLocalInventoriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AddLocalInventoriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.AddLocalInventoriesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AddLocalInventoriesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AddLocalInventoriesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AddLocalInventoriesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AddLocalInventoriesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AddLocalInventoriesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AddLocalInventoriesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AddLocalInventoriesResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [ProductService.RemoveLocalInventories][google.cloud.retail.v2.ProductService.RemoveLocalInventories]
/// method.
///
/// [google.cloud.retail.v2.ProductService.RemoveLocalInventories]: crate::client::ProductService::remove_local_inventories
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoveLocalInventoriesRequest {
    /// Required. Full resource name of [Product][google.cloud.retail.v2.Product],
    /// such as
    /// `projects/*/locations/global/catalogs/default_catalog/branches/default_branch/products/some_product_id`.
    ///
    /// If the caller does not have permission to access the
    /// [Product][google.cloud.retail.v2.Product], regardless of whether or not it
    /// exists, a PERMISSION_DENIED error is returned.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub product: std::string::String,

    /// Required. A list of place IDs to have their inventory deleted.
    /// At most 3000 place IDs are allowed per request.
    pub place_ids: std::vec::Vec<std::string::String>,

    /// The time when the inventory deletions are issued. Used to prevent
    /// out-of-order updates and deletions on local inventory fields. If not
    /// provided, the internal system time will be used.
    pub remove_time: std::option::Option<wkt::Timestamp>,

    /// If set to true, and the [Product][google.cloud.retail.v2.Product] is not
    /// found, the local inventory removal request will still be processed and
    /// retained for at most 1 day and processed once the
    /// [Product][google.cloud.retail.v2.Product] is created. If set to false, a
    /// NOT_FOUND error is returned if the
    /// [Product][google.cloud.retail.v2.Product] is not found.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub allow_missing: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveLocalInventoriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [product][crate::model::RemoveLocalInventoriesRequest::product].
    pub fn set_product<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.product = v.into();
        self
    }

    /// Sets the value of [place_ids][crate::model::RemoveLocalInventoriesRequest::place_ids].
    pub fn set_place_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.place_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [remove_time][crate::model::RemoveLocalInventoriesRequest::remove_time].
    pub fn set_remove_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.remove_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [remove_time][crate::model::RemoveLocalInventoriesRequest::remove_time].
    pub fn set_or_clear_remove_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.remove_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_missing][crate::model::RemoveLocalInventoriesRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for RemoveLocalInventoriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.RemoveLocalInventoriesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RemoveLocalInventoriesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __product,
            __place_ids,
            __remove_time,
            __allow_missing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RemoveLocalInventoriesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "product" => Ok(__FieldTag::__product),
                            "placeIds" => Ok(__FieldTag::__place_ids),
                            "place_ids" => Ok(__FieldTag::__place_ids),
                            "removeTime" => Ok(__FieldTag::__remove_time),
                            "remove_time" => Ok(__FieldTag::__remove_time),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RemoveLocalInventoriesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RemoveLocalInventoriesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__product => {
                            if !fields.insert(__FieldTag::__product) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product",
                                ));
                            }
                            result.product = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__place_ids => {
                            if !fields.insert(__FieldTag::__place_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for place_ids",
                                ));
                            }
                            result.place_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__remove_time => {
                            if !fields.insert(__FieldTag::__remove_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remove_time",
                                ));
                            }
                            result.remove_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RemoveLocalInventoriesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.product.is_empty() {
            state.serialize_entry("product", &self.product)?;
        }
        if !self.place_ids.is_empty() {
            state.serialize_entry("placeIds", &self.place_ids)?;
        }
        if self.remove_time.is_some() {
            state.serialize_entry("removeTime", &self.remove_time)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RemoveLocalInventoriesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RemoveLocalInventoriesRequest");
        debug_struct.field("product", &self.product);
        debug_struct.field("place_ids", &self.place_ids);
        debug_struct.field("remove_time", &self.remove_time);
        debug_struct.field("allow_missing", &self.allow_missing);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata related to the progress of the RemoveLocalInventories operation.
/// Currently empty because there is no meaningful metadata populated from the
/// [ProductService.RemoveLocalInventories][google.cloud.retail.v2.ProductService.RemoveLocalInventories]
/// method.
///
/// [google.cloud.retail.v2.ProductService.RemoveLocalInventories]: crate::client::ProductService::remove_local_inventories
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoveLocalInventoriesMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveLocalInventoriesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RemoveLocalInventoriesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.RemoveLocalInventoriesMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RemoveLocalInventoriesMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RemoveLocalInventoriesMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RemoveLocalInventoriesMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RemoveLocalInventoriesMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RemoveLocalInventoriesMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RemoveLocalInventoriesMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RemoveLocalInventoriesMetadata");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response of the
/// [ProductService.RemoveLocalInventories][google.cloud.retail.v2.ProductService.RemoveLocalInventories]
/// API.  Currently empty because there is no meaningful response populated from
/// the
/// [ProductService.RemoveLocalInventories][google.cloud.retail.v2.ProductService.RemoveLocalInventories]
/// method.
///
/// [google.cloud.retail.v2.ProductService.RemoveLocalInventories]: crate::client::ProductService::remove_local_inventories
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoveLocalInventoriesResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveLocalInventoriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RemoveLocalInventoriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.RemoveLocalInventoriesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RemoveLocalInventoriesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RemoveLocalInventoriesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RemoveLocalInventoriesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RemoveLocalInventoriesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RemoveLocalInventoriesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RemoveLocalInventoriesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RemoveLocalInventoriesResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [ProductService.RemoveFulfillmentPlaces][google.cloud.retail.v2.ProductService.RemoveFulfillmentPlaces]
/// method.
///
/// [google.cloud.retail.v2.ProductService.RemoveFulfillmentPlaces]: crate::client::ProductService::remove_fulfillment_places
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoveFulfillmentPlacesRequest {
    /// Required. Full resource name of [Product][google.cloud.retail.v2.Product],
    /// such as
    /// `projects/*/locations/global/catalogs/default_catalog/branches/default_branch/products/some_product_id`.
    ///
    /// If the caller does not have permission to access the
    /// [Product][google.cloud.retail.v2.Product], regardless of whether or not it
    /// exists, a PERMISSION_DENIED error is returned.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub product: std::string::String,

    /// Required. The fulfillment type, including commonly used types (such as
    /// pickup in store and same day delivery), and custom types.
    ///
    /// Supported values:
    ///
    /// * "pickup-in-store"
    /// * "ship-to-store"
    /// * "same-day-delivery"
    /// * "next-day-delivery"
    /// * "custom-type-1"
    /// * "custom-type-2"
    /// * "custom-type-3"
    /// * "custom-type-4"
    /// * "custom-type-5"
    ///
    /// If this field is set to an invalid value other than these, an
    /// INVALID_ARGUMENT error is returned.
    ///
    /// This field directly corresponds to
    /// [Product.fulfillment_info.type][google.cloud.retail.v2.FulfillmentInfo.type].
    ///
    /// [google.cloud.retail.v2.FulfillmentInfo.type]: crate::model::FulfillmentInfo::type
    pub r#type: std::string::String,

    /// Required. The IDs for this
    /// [type][google.cloud.retail.v2.RemoveFulfillmentPlacesRequest.type], such as
    /// the store IDs for "pickup-in-store" or the region IDs for
    /// "same-day-delivery", to be removed for this
    /// [type][google.cloud.retail.v2.RemoveFulfillmentPlacesRequest.type].
    ///
    /// At least 1 value is required, and a maximum of 2000 values are allowed.
    /// Each value must be a string with a length limit of 10 characters, matching
    /// the pattern `[a-zA-Z0-9_-]+`, such as "store1" or "REGION-2". Otherwise, an
    /// INVALID_ARGUMENT error is returned.
    ///
    /// [google.cloud.retail.v2.RemoveFulfillmentPlacesRequest.type]: crate::model::RemoveFulfillmentPlacesRequest::type
    pub place_ids: std::vec::Vec<std::string::String>,

    /// The time when the fulfillment updates are issued, used to prevent
    /// out-of-order updates on fulfillment information. If not provided, the
    /// internal system time will be used.
    pub remove_time: std::option::Option<wkt::Timestamp>,

    /// If set to true, and the [Product][google.cloud.retail.v2.Product] is not
    /// found, the fulfillment information will still be processed and retained for
    /// at most 1 day and processed once the
    /// [Product][google.cloud.retail.v2.Product] is created. If set to false, a
    /// NOT_FOUND error is returned if the
    /// [Product][google.cloud.retail.v2.Product] is not found.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub allow_missing: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveFulfillmentPlacesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [product][crate::model::RemoveFulfillmentPlacesRequest::product].
    pub fn set_product<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.product = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::RemoveFulfillmentPlacesRequest::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [place_ids][crate::model::RemoveFulfillmentPlacesRequest::place_ids].
    pub fn set_place_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.place_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [remove_time][crate::model::RemoveFulfillmentPlacesRequest::remove_time].
    pub fn set_remove_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.remove_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [remove_time][crate::model::RemoveFulfillmentPlacesRequest::remove_time].
    pub fn set_or_clear_remove_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.remove_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_missing][crate::model::RemoveFulfillmentPlacesRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for RemoveFulfillmentPlacesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.RemoveFulfillmentPlacesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RemoveFulfillmentPlacesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __product,
            __type,
            __place_ids,
            __remove_time,
            __allow_missing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RemoveFulfillmentPlacesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "product" => Ok(__FieldTag::__product),
                            "type" => Ok(__FieldTag::__type),
                            "placeIds" => Ok(__FieldTag::__place_ids),
                            "place_ids" => Ok(__FieldTag::__place_ids),
                            "removeTime" => Ok(__FieldTag::__remove_time),
                            "remove_time" => Ok(__FieldTag::__remove_time),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RemoveFulfillmentPlacesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RemoveFulfillmentPlacesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__product => {
                            if !fields.insert(__FieldTag::__product) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product",
                                ));
                            }
                            result.product = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__place_ids => {
                            if !fields.insert(__FieldTag::__place_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for place_ids",
                                ));
                            }
                            result.place_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__remove_time => {
                            if !fields.insert(__FieldTag::__remove_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remove_time",
                                ));
                            }
                            result.remove_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RemoveFulfillmentPlacesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.product.is_empty() {
            state.serialize_entry("product", &self.product)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.place_ids.is_empty() {
            state.serialize_entry("placeIds", &self.place_ids)?;
        }
        if self.remove_time.is_some() {
            state.serialize_entry("removeTime", &self.remove_time)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RemoveFulfillmentPlacesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RemoveFulfillmentPlacesRequest");
        debug_struct.field("product", &self.product);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("place_ids", &self.place_ids);
        debug_struct.field("remove_time", &self.remove_time);
        debug_struct.field("allow_missing", &self.allow_missing);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata related to the progress of the RemoveFulfillmentPlaces operation.
/// Currently empty because there is no meaningful metadata populated from the
/// [ProductService.RemoveFulfillmentPlaces][google.cloud.retail.v2.ProductService.RemoveFulfillmentPlaces]
/// method.
///
/// [google.cloud.retail.v2.ProductService.RemoveFulfillmentPlaces]: crate::client::ProductService::remove_fulfillment_places
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoveFulfillmentPlacesMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveFulfillmentPlacesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RemoveFulfillmentPlacesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.RemoveFulfillmentPlacesMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RemoveFulfillmentPlacesMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RemoveFulfillmentPlacesMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RemoveFulfillmentPlacesMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RemoveFulfillmentPlacesMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RemoveFulfillmentPlacesMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RemoveFulfillmentPlacesMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RemoveFulfillmentPlacesMetadata");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response of the RemoveFulfillmentPlacesRequest. Currently empty because there
/// is no meaningful response populated from the
/// [ProductService.RemoveFulfillmentPlaces][google.cloud.retail.v2.ProductService.RemoveFulfillmentPlaces]
/// method.
///
/// [google.cloud.retail.v2.ProductService.RemoveFulfillmentPlaces]: crate::client::ProductService::remove_fulfillment_places
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoveFulfillmentPlacesResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveFulfillmentPlacesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RemoveFulfillmentPlacesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.RemoveFulfillmentPlacesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RemoveFulfillmentPlacesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RemoveFulfillmentPlacesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RemoveFulfillmentPlacesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RemoveFulfillmentPlacesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RemoveFulfillmentPlacesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RemoveFulfillmentPlacesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RemoveFulfillmentPlacesResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Promotion information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Promotion {
    /// ID of the promotion. For example, "free gift".
    ///
    /// The value must be a UTF-8 encoded string with a length limit of 128
    /// characters, and match the pattern: `[a-zA-Z][a-zA-Z0-9_]*`. For example,
    /// id0LikeThis or ID_1_LIKE_THIS. Otherwise, an INVALID_ARGUMENT error is
    /// returned.
    ///
    /// Corresponds to Google Merchant Center property
    /// [promotion_id](https://support.google.com/merchants/answer/7050148).
    pub promotion_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Promotion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [promotion_id][crate::model::Promotion::promotion_id].
    pub fn set_promotion_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.promotion_id = v.into();
        self
    }
}

impl wkt::message::Message for Promotion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.Promotion"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Promotion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __promotion_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Promotion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "promotionId" => Ok(__FieldTag::__promotion_id),
                            "promotion_id" => Ok(__FieldTag::__promotion_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Promotion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Promotion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__promotion_id => {
                            if !fields.insert(__FieldTag::__promotion_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for promotion_id",
                                ));
                            }
                            result.promotion_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Promotion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.promotion_id.is_empty() {
            state.serialize_entry("promotionId", &self.promotion_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Promotion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Promotion");
        debug_struct.field("promotion_id", &self.promotion_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata related to the progress of the Purge operation.
/// This will be returned by the google.longrunning.Operation.metadata field.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PurgeMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PurgeMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for PurgeMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.PurgeMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PurgeMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PurgeMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PurgeMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PurgeMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PurgeMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PurgeMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PurgeMetadata");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata related to the progress of the PurgeProducts operation.
/// This will be returned by the google.longrunning.Operation.metadata field.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PurgeProductsMetadata {
    /// Operation create time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Count of entries that were deleted successfully.
    pub success_count: i64,

    /// Count of entries that encountered errors while processing.
    pub failure_count: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PurgeProductsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::PurgeProductsMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::PurgeProductsMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::PurgeProductsMetadata::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::PurgeProductsMetadata::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [success_count][crate::model::PurgeProductsMetadata::success_count].
    pub fn set_success_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.success_count = v.into();
        self
    }

    /// Sets the value of [failure_count][crate::model::PurgeProductsMetadata::failure_count].
    pub fn set_failure_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.failure_count = v.into();
        self
    }
}

impl wkt::message::Message for PurgeProductsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.PurgeProductsMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PurgeProductsMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __update_time,
            __success_count,
            __failure_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PurgeProductsMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "successCount" => Ok(__FieldTag::__success_count),
                            "success_count" => Ok(__FieldTag::__success_count),
                            "failureCount" => Ok(__FieldTag::__failure_count),
                            "failure_count" => Ok(__FieldTag::__failure_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PurgeProductsMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PurgeProductsMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__success_count => {
                            if !fields.insert(__FieldTag::__success_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for success_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.success_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__failure_count => {
                            if !fields.insert(__FieldTag::__failure_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.failure_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PurgeProductsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.success_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("successCount", &__With(&self.success_count))?;
        }
        if !wkt::internal::is_default(&self.failure_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("failureCount", &__With(&self.failure_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PurgeProductsMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PurgeProductsMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("success_count", &self.success_count);
        debug_struct.field("failure_count", &self.failure_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for PurgeProducts method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PurgeProductsRequest {
    /// Required. The resource name of the branch under which the products are
    /// created. The format is
    /// `projects/${projectId}/locations/global/catalogs/${catalogId}/branches/${branchId}`
    pub parent: std::string::String,

    /// Required. The filter string to specify the products to be deleted with a
    /// length limit of 5,000 characters.
    ///
    /// Empty string filter is not allowed. "*" implies delete all items in a
    /// branch.
    ///
    /// The eligible fields for filtering are:
    ///
    /// * `availability`: Double quoted
    ///   [Product.availability][google.cloud.retail.v2.Product.availability] string.
    /// * `create_time` : in ISO 8601 "zulu" format.
    ///
    /// Supported syntax:
    ///
    /// * Comparators (">", "<", ">=", "<=", "=").
    ///   Examples:
    ///
    ///   * create_time <= "2015-02-13T17:05:46Z"
    ///   * availability = "IN_STOCK"
    /// * Conjunctions ("AND")
    ///   Examples:
    ///
    ///   * create_time <= "2015-02-13T17:05:46Z" AND availability = "PREORDER"
    /// * Disjunctions ("OR")
    ///   Examples:
    ///
    ///   * create_time <= "2015-02-13T17:05:46Z" OR availability = "IN_STOCK"
    /// * Can support nested queries.
    ///   Examples:
    ///
    ///   * (create_time <= "2015-02-13T17:05:46Z" AND availability = "PREORDER")
    ///     OR (create_time >= "2015-02-14T13:03:32Z" AND availability = "IN_STOCK")
    /// * Filter Limits:
    ///
    ///   * Filter should not contain more than 6 conditions.
    ///   * Max nesting depth should not exceed 2 levels.
    ///
    /// Examples queries:
    ///
    /// * Delete back order products created before a timestamp.
    ///   create_time <= "2015-02-13T17:05:46Z" OR availability = "BACKORDER"
    ///
    /// [google.cloud.retail.v2.Product.availability]: crate::model::Product::availability
    pub filter: std::string::String,

    /// Actually perform the purge.
    /// If `force` is set to false, the method will return the expected purge count
    /// without deleting any products.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PurgeProductsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::PurgeProductsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::PurgeProductsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [force][crate::model::PurgeProductsRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for PurgeProductsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.PurgeProductsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PurgeProductsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PurgeProductsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PurgeProductsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PurgeProductsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PurgeProductsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PurgeProductsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PurgeProductsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response of the PurgeProductsRequest. If the long running operation is
/// successfully done, then this message is returned by the
/// google.longrunning.Operations.response field.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PurgeProductsResponse {
    /// The total count of products purged as a result of the operation.
    pub purge_count: i64,

    /// A sample of the product names that will be deleted.
    /// Only populated if `force` is set to false. A max of 100 names will be
    /// returned and the names are chosen at random.
    pub purge_sample: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PurgeProductsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [purge_count][crate::model::PurgeProductsResponse::purge_count].
    pub fn set_purge_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.purge_count = v.into();
        self
    }

    /// Sets the value of [purge_sample][crate::model::PurgeProductsResponse::purge_sample].
    pub fn set_purge_sample<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.purge_sample = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PurgeProductsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.PurgeProductsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PurgeProductsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __purge_count,
            __purge_sample,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PurgeProductsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "purgeCount" => Ok(__FieldTag::__purge_count),
                            "purge_count" => Ok(__FieldTag::__purge_count),
                            "purgeSample" => Ok(__FieldTag::__purge_sample),
                            "purge_sample" => Ok(__FieldTag::__purge_sample),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PurgeProductsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PurgeProductsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__purge_count => {
                            if !fields.insert(__FieldTag::__purge_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for purge_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.purge_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__purge_sample => {
                            if !fields.insert(__FieldTag::__purge_sample) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for purge_sample",
                                ));
                            }
                            result.purge_sample = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PurgeProductsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.purge_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("purgeCount", &__With(&self.purge_count))?;
        }
        if !self.purge_sample.is_empty() {
            state.serialize_entry("purgeSample", &self.purge_sample)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PurgeProductsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PurgeProductsResponse");
        debug_struct.field("purge_count", &self.purge_count);
        debug_struct.field("purge_sample", &self.purge_sample);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for PurgeUserEvents method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PurgeUserEventsRequest {
    /// Required. The resource name of the catalog under which the events are
    /// created. The format is
    /// `projects/${projectId}/locations/global/catalogs/${catalogId}`
    pub parent: std::string::String,

    /// Required. The filter string to specify the events to be deleted with a
    /// length limit of 5,000 characters. Empty string filter is not allowed. The
    /// eligible fields for filtering are:
    ///
    /// * `eventType`: Double quoted
    ///   [UserEvent.event_type][google.cloud.retail.v2.UserEvent.event_type] string.
    /// * `eventTime`: in ISO 8601 "zulu" format.
    /// * `visitorId`: Double quoted string. Specifying this will delete all
    ///   events associated with a visitor.
    /// * `userId`: Double quoted string. Specifying this will delete all events
    ///   associated with a user.
    ///
    /// Examples:
    ///
    /// * Deleting all events in a time range:
    ///   `eventTime > "2012-04-23T18:25:43.511Z"
    ///   eventTime < "2012-04-23T18:30:43.511Z"`
    /// * Deleting specific eventType in time range:
    ///   `eventTime > "2012-04-23T18:25:43.511Z" eventType = "detail-page-view"`
    /// * Deleting all events for a specific visitor:
    ///   `visitorId = "visitor1024"`
    ///
    /// The filtering fields are assumed to have an implicit AND.
    ///
    /// [google.cloud.retail.v2.UserEvent.event_type]: crate::model::UserEvent::event_type
    pub filter: std::string::String,

    /// Actually perform the purge.
    /// If `force` is set to false, the method will return the expected purge count
    /// without deleting any user events.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PurgeUserEventsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::PurgeUserEventsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::PurgeUserEventsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [force][crate::model::PurgeUserEventsRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for PurgeUserEventsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.PurgeUserEventsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PurgeUserEventsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PurgeUserEventsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PurgeUserEventsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PurgeUserEventsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PurgeUserEventsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PurgeUserEventsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PurgeUserEventsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response of the PurgeUserEventsRequest. If the long running operation is
/// successfully done, then this message is returned by the
/// google.longrunning.Operations.response field.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PurgeUserEventsResponse {
    /// The total count of events purged as a result of the operation.
    pub purged_events_count: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PurgeUserEventsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [purged_events_count][crate::model::PurgeUserEventsResponse::purged_events_count].
    pub fn set_purged_events_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.purged_events_count = v.into();
        self
    }
}

impl wkt::message::Message for PurgeUserEventsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.PurgeUserEventsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PurgeUserEventsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __purged_events_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PurgeUserEventsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "purgedEventsCount" => Ok(__FieldTag::__purged_events_count),
                            "purged_events_count" => Ok(__FieldTag::__purged_events_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PurgeUserEventsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PurgeUserEventsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__purged_events_count => {
                            if !fields.insert(__FieldTag::__purged_events_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for purged_events_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.purged_events_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PurgeUserEventsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.purged_events_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("purgedEventsCount", &__With(&self.purged_events_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PurgeUserEventsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PurgeUserEventsResponse");
        debug_struct.field("purged_events_count", &self.purged_events_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Product attribute which structured by an attribute name and value. This
/// structure is used in conversational search filters and answers. For example,
/// if we have `name=color` and `value=red`, this means that the color is `red`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProductAttributeValue {
    /// The attribute name.
    pub name: std::string::String,

    /// The attribute value.
    pub value: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProductAttributeValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ProductAttributeValue::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [value][crate::model::ProductAttributeValue::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }
}

impl wkt::message::Message for ProductAttributeValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ProductAttributeValue"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProductAttributeValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProductAttributeValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "value" => Ok(__FieldTag::__value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProductAttributeValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProductAttributeValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProductAttributeValue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ProductAttributeValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProductAttributeValue");
        debug_struct.field("name", &self.name);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Product attribute name and numeric interval.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProductAttributeInterval {
    /// The attribute name (e.g. "length")
    pub name: std::string::String,

    /// The numeric interval (e.g. [10, 20))
    pub interval: std::option::Option<crate::model::Interval>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProductAttributeInterval {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ProductAttributeInterval::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [interval][crate::model::ProductAttributeInterval::interval].
    pub fn set_interval<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Interval>,
    {
        self.interval = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [interval][crate::model::ProductAttributeInterval::interval].
    pub fn set_or_clear_interval<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Interval>,
    {
        self.interval = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ProductAttributeInterval {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ProductAttributeInterval"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProductAttributeInterval {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __interval,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProductAttributeInterval")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "interval" => Ok(__FieldTag::__interval),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProductAttributeInterval;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProductAttributeInterval")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__interval => {
                            if !fields.insert(__FieldTag::__interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for interval",
                                ));
                            }
                            result.interval =
                                map.next_value::<std::option::Option<crate::model::Interval>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProductAttributeInterval {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.interval.is_some() {
            state.serialize_entry("interval", &self.interval)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ProductAttributeInterval {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProductAttributeInterval");
        debug_struct.field("name", &self.name);
        debug_struct.field("interval", &self.interval);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// This field specifies the tile information including an attribute key,
/// attribute value. More fields will be added in the future, eg: product id
/// or product counts, etc.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Tile {
    /// The representative product id for this tile.
    pub representative_product_id: std::string::String,

    /// The attribute key and value for the tile.
    pub product_attribute: std::option::Option<crate::model::tile::ProductAttribute>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Tile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [representative_product_id][crate::model::Tile::representative_product_id].
    pub fn set_representative_product_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.representative_product_id = v.into();
        self
    }

    /// Sets the value of [product_attribute][crate::model::Tile::product_attribute].
    ///
    /// Note that all the setters affecting `product_attribute` are mutually
    /// exclusive.
    pub fn set_product_attribute<
        T: std::convert::Into<std::option::Option<crate::model::tile::ProductAttribute>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.product_attribute = v.into();
        self
    }

    /// The value of [product_attribute][crate::model::Tile::product_attribute]
    /// if it holds a `ProductAttributeValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn product_attribute_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ProductAttributeValue>> {
        #[allow(unreachable_patterns)]
        self.product_attribute.as_ref().and_then(|v| match v {
            crate::model::tile::ProductAttribute::ProductAttributeValue(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [product_attribute][crate::model::Tile::product_attribute]
    /// to hold a `ProductAttributeValue`.
    ///
    /// Note that all the setters affecting `product_attribute` are
    /// mutually exclusive.
    pub fn set_product_attribute_value<
        T: std::convert::Into<std::boxed::Box<crate::model::ProductAttributeValue>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.product_attribute = std::option::Option::Some(
            crate::model::tile::ProductAttribute::ProductAttributeValue(v.into()),
        );
        self
    }

    /// The value of [product_attribute][crate::model::Tile::product_attribute]
    /// if it holds a `ProductAttributeInterval`, `None` if the field is not set or
    /// holds a different branch.
    pub fn product_attribute_interval(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ProductAttributeInterval>> {
        #[allow(unreachable_patterns)]
        self.product_attribute.as_ref().and_then(|v| match v {
            crate::model::tile::ProductAttribute::ProductAttributeInterval(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [product_attribute][crate::model::Tile::product_attribute]
    /// to hold a `ProductAttributeInterval`.
    ///
    /// Note that all the setters affecting `product_attribute` are
    /// mutually exclusive.
    pub fn set_product_attribute_interval<
        T: std::convert::Into<std::boxed::Box<crate::model::ProductAttributeInterval>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.product_attribute = std::option::Option::Some(
            crate::model::tile::ProductAttribute::ProductAttributeInterval(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Tile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.Tile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Tile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __product_attribute_value,
            __product_attribute_interval,
            __representative_product_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Tile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "productAttributeValue" => Ok(__FieldTag::__product_attribute_value),
                            "product_attribute_value" => Ok(__FieldTag::__product_attribute_value),
                            "productAttributeInterval" => {
                                Ok(__FieldTag::__product_attribute_interval)
                            }
                            "product_attribute_interval" => {
                                Ok(__FieldTag::__product_attribute_interval)
                            }
                            "representativeProductId" => {
                                Ok(__FieldTag::__representative_product_id)
                            }
                            "representative_product_id" => {
                                Ok(__FieldTag::__representative_product_id)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Tile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Tile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__product_attribute_value => {
                            if !fields.insert(__FieldTag::__product_attribute_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product_attribute_value",
                                ));
                            }
                            if result.product_attribute.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `product_attribute`, a oneof with full ID .google.cloud.retail.v2.Tile.product_attribute_value, latest field was productAttributeValue",
                                ));
                            }
                            result.product_attribute = std::option::Option::Some(
                                crate::model::tile::ProductAttribute::ProductAttributeValue(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ProductAttributeValue>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__product_attribute_interval => {
                            if !fields.insert(__FieldTag::__product_attribute_interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product_attribute_interval",
                                ));
                            }
                            if result.product_attribute.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `product_attribute`, a oneof with full ID .google.cloud.retail.v2.Tile.product_attribute_interval, latest field was productAttributeInterval",
                                ));
                            }
                            result.product_attribute = std::option::Option::Some(
                                crate::model::tile::ProductAttribute::ProductAttributeInterval(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ProductAttributeInterval>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__representative_product_id => {
                            if !fields.insert(__FieldTag::__representative_product_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for representative_product_id",
                                ));
                            }
                            result.representative_product_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Tile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.product_attribute_value() {
            state.serialize_entry("productAttributeValue", value)?;
        }
        if let Some(value) = self.product_attribute_interval() {
            state.serialize_entry("productAttributeInterval", value)?;
        }
        if !self.representative_product_id.is_empty() {
            state.serialize_entry("representativeProductId", &self.representative_product_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Tile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Tile");
        debug_struct.field("representative_product_id", &self.representative_product_id);
        debug_struct.field("product_attribute", &self.product_attribute);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Tile].
pub mod tile {
    #[allow(unused_imports)]
    use super::*;

    /// The attribute key and value for the tile.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ProductAttribute {
        /// The product attribute key-value.
        ProductAttributeValue(std::boxed::Box<crate::model::ProductAttributeValue>),
        /// The product attribute key-numeric interval.
        ProductAttributeInterval(std::boxed::Box<crate::model::ProductAttributeInterval>),
    }
}

/// Request message for
/// [SearchService.Search][google.cloud.retail.v2.SearchService.Search] method.
///
/// [google.cloud.retail.v2.SearchService.Search]: crate::client::SearchService::search
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchRequest {
    /// Required. The resource name of the Retail Search serving config, such as
    /// `projects/*/locations/global/catalogs/default_catalog/servingConfigs/default_serving_config`
    /// or the name of the legacy placement resource, such as
    /// `projects/*/locations/global/catalogs/default_catalog/placements/default_search`.
    /// This field is used to identify the serving config name and the set
    /// of models that are used to make the search.
    pub placement: std::string::String,

    /// The branch resource name, such as
    /// `projects/*/locations/global/catalogs/default_catalog/branches/0`.
    ///
    /// Use "default_branch" as the branch ID or leave this field empty, to search
    /// products under the default branch.
    pub branch: std::string::String,

    /// Raw search query.
    ///
    /// If this field is empty, the request is considered a category browsing
    /// request and returned results are based on
    /// [filter][google.cloud.retail.v2.SearchRequest.filter] and
    /// [page_categories][google.cloud.retail.v2.SearchRequest.page_categories].
    ///
    /// [google.cloud.retail.v2.SearchRequest.filter]: crate::model::SearchRequest::filter
    /// [google.cloud.retail.v2.SearchRequest.page_categories]: crate::model::SearchRequest::page_categories
    pub query: std::string::String,

    /// Required. A unique identifier for tracking visitors. For example, this
    /// could be implemented with an HTTP cookie, which should be able to uniquely
    /// identify a visitor on a single device. This unique identifier should not
    /// change if the visitor logs in or out of the website.
    ///
    /// This should be the same identifier as
    /// [UserEvent.visitor_id][google.cloud.retail.v2.UserEvent.visitor_id].
    ///
    /// The field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// [google.cloud.retail.v2.UserEvent.visitor_id]: crate::model::UserEvent::visitor_id
    pub visitor_id: std::string::String,

    /// User information.
    pub user_info: std::option::Option<crate::model::UserInfo>,

    /// Maximum number of [Product][google.cloud.retail.v2.Product]s to return. If
    /// unspecified, defaults to a reasonable value. The maximum allowed value is
    /// 120. Values above 120 will be coerced to 120.
    ///
    /// If this field is negative, an INVALID_ARGUMENT is returned.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub page_size: i32,

    /// A page token
    /// [SearchResponse.next_page_token][google.cloud.retail.v2.SearchResponse.next_page_token],
    /// received from a previous
    /// [SearchService.Search][google.cloud.retail.v2.SearchService.Search] call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// [SearchService.Search][google.cloud.retail.v2.SearchService.Search] must
    /// match the call that provided the page token. Otherwise, an INVALID_ARGUMENT
    /// error is returned.
    ///
    /// [google.cloud.retail.v2.SearchResponse.next_page_token]: crate::model::SearchResponse::next_page_token
    /// [google.cloud.retail.v2.SearchService.Search]: crate::client::SearchService::search
    pub page_token: std::string::String,

    /// A 0-indexed integer that specifies the current offset (that is, starting
    /// result location, amongst the [Product][google.cloud.retail.v2.Product]s
    /// deemed by the API as relevant) in search results. This field is only
    /// considered if [page_token][google.cloud.retail.v2.SearchRequest.page_token]
    /// is unset.
    ///
    /// If this field is negative, an INVALID_ARGUMENT is returned.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.SearchRequest.page_token]: crate::model::SearchRequest::page_token
    pub offset: i32,

    /// The filter syntax consists of an expression language for constructing a
    /// predicate from one or more fields of the products being filtered. Filter
    /// expression is case-sensitive. For more information, see
    /// [Filter](https://cloud.google.com/retail/docs/filter-and-order#filter).
    ///
    /// If this field is unrecognizable, an INVALID_ARGUMENT is returned.
    pub filter: std::string::String,

    /// The default filter that is applied when a user performs a search without
    /// checking any filters on the search page.
    ///
    /// The filter applied to every search request when quality improvement such as
    /// query expansion is needed. In the case a query does not have a sufficient
    /// amount of results this filter will be used to determine whether or not to
    /// enable the query expansion flow. The original filter will still be used for
    /// the query expanded search.
    /// This field is strongly recommended to achieve high search quality.
    ///
    /// For more information about filter syntax, see
    /// [SearchRequest.filter][google.cloud.retail.v2.SearchRequest.filter].
    ///
    /// [google.cloud.retail.v2.SearchRequest.filter]: crate::model::SearchRequest::filter
    pub canonical_filter: std::string::String,

    /// The order in which products are returned. Products can be ordered by
    /// a field in an [Product][google.cloud.retail.v2.Product] object. Leave it
    /// unset if ordered by relevance. OrderBy expression is case-sensitive. For
    /// more information, see
    /// [Order](https://cloud.google.com/retail/docs/filter-and-order#order).
    ///
    /// If this field is unrecognizable, an INVALID_ARGUMENT is returned.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    pub order_by: std::string::String,

    /// Facet specifications for faceted search. If empty, no facets are returned.
    ///
    /// A maximum of 200 values are allowed. Otherwise, an INVALID_ARGUMENT error
    /// is returned.
    pub facet_specs: std::vec::Vec<crate::model::search_request::FacetSpec>,

    /// Deprecated. Refer to <https://cloud.google.com/retail/docs/configs#dynamic>
    /// to enable dynamic facets. Do not set this field.
    ///
    /// The specification for dynamically generated facets. Notice that only
    /// textual facets can be dynamically generated.
    #[deprecated]
    pub dynamic_facet_spec: std::option::Option<crate::model::search_request::DynamicFacetSpec>,

    /// Boost specification to boost certain products. For more information, see
    /// [Boost results](https://cloud.google.com/retail/docs/boosting).
    ///
    /// Notice that if both
    /// [ServingConfig.boost_control_ids][google.cloud.retail.v2.ServingConfig.boost_control_ids]
    /// and
    /// [SearchRequest.boost_spec][google.cloud.retail.v2.SearchRequest.boost_spec]
    /// are set, the boost conditions from both places are evaluated. If a search
    /// request matches multiple boost conditions, the final boost score is equal
    /// to the sum of the boost scores from all matched boost conditions.
    ///
    /// [google.cloud.retail.v2.SearchRequest.boost_spec]: crate::model::SearchRequest::boost_spec
    /// [google.cloud.retail.v2.ServingConfig.boost_control_ids]: crate::model::ServingConfig::boost_control_ids
    pub boost_spec: std::option::Option<crate::model::search_request::BoostSpec>,

    /// The query expansion specification that specifies the conditions under which
    /// query expansion occurs. For more information, see [Query
    /// expansion](https://cloud.google.com/retail/docs/result-size#query_expansion).
    pub query_expansion_spec: std::option::Option<crate::model::search_request::QueryExpansionSpec>,

    /// The keys to fetch and rollup the matching
    /// [variant][google.cloud.retail.v2.Product.Type.VARIANT]
    /// [Product][google.cloud.retail.v2.Product]s attributes,
    /// [FulfillmentInfo][google.cloud.retail.v2.FulfillmentInfo] or
    /// [LocalInventory][google.cloud.retail.v2.LocalInventory]s attributes. The
    /// attributes from all the matching
    /// [variant][google.cloud.retail.v2.Product.Type.VARIANT]
    /// [Product][google.cloud.retail.v2.Product]s or
    /// [LocalInventory][google.cloud.retail.v2.LocalInventory]s are merged and
    /// de-duplicated. Notice that rollup attributes will lead to extra query
    /// latency. Maximum number of keys is 30.
    ///
    /// For [FulfillmentInfo][google.cloud.retail.v2.FulfillmentInfo], a
    /// fulfillment type and a fulfillment ID must be provided in the format of
    /// "fulfillmentType.fulfillmentId". E.g., in "pickupInStore.store123",
    /// "pickupInStore" is fulfillment type and "store123" is the store ID.
    ///
    /// Supported keys are:
    ///
    /// * colorFamilies
    /// * price
    /// * originalPrice
    /// * discount
    /// * variantId
    /// * inventory(place_id,price)
    /// * inventory(place_id,original_price)
    /// * inventory(place_id,attributes.key), where key is any key in the
    ///   [Product.local_inventories.attributes][google.cloud.retail.v2.LocalInventory.attributes]
    ///   map.
    /// * attributes.key, where key is any key in the
    ///   [Product.attributes][google.cloud.retail.v2.Product.attributes] map.
    /// * pickupInStore.id, where id is any
    ///   [FulfillmentInfo.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids]
    ///   for [FulfillmentInfo.type][google.cloud.retail.v2.FulfillmentInfo.type]
    ///   "pickup-in-store".
    /// * shipToStore.id, where id is any
    ///   [FulfillmentInfo.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids]
    ///   for [FulfillmentInfo.type][google.cloud.retail.v2.FulfillmentInfo.type]
    ///   "ship-to-store".
    /// * sameDayDelivery.id, where id is any
    ///   [FulfillmentInfo.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids]
    ///   for [FulfillmentInfo.type][google.cloud.retail.v2.FulfillmentInfo.type]
    ///   "same-day-delivery".
    /// * nextDayDelivery.id, where id is any
    ///   [FulfillmentInfo.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids]
    ///   for [FulfillmentInfo.type][google.cloud.retail.v2.FulfillmentInfo.type]
    ///   "next-day-delivery".
    /// * customFulfillment1.id, where id is any
    ///   [FulfillmentInfo.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids]
    ///   for [FulfillmentInfo.type][google.cloud.retail.v2.FulfillmentInfo.type]
    ///   "custom-type-1".
    /// * customFulfillment2.id, where id is any
    ///   [FulfillmentInfo.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids]
    ///   for [FulfillmentInfo.type][google.cloud.retail.v2.FulfillmentInfo.type]
    ///   "custom-type-2".
    /// * customFulfillment3.id, where id is any
    ///   [FulfillmentInfo.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids]
    ///   for [FulfillmentInfo.type][google.cloud.retail.v2.FulfillmentInfo.type]
    ///   "custom-type-3".
    /// * customFulfillment4.id, where id is any
    ///   [FulfillmentInfo.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids]
    ///   for [FulfillmentInfo.type][google.cloud.retail.v2.FulfillmentInfo.type]
    ///   "custom-type-4".
    /// * customFulfillment5.id, where id is any
    ///   [FulfillmentInfo.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids]
    ///   for [FulfillmentInfo.type][google.cloud.retail.v2.FulfillmentInfo.type]
    ///   "custom-type-5".
    ///
    /// If this field is set to an invalid value other than these, an
    /// INVALID_ARGUMENT error is returned.
    ///
    /// [google.cloud.retail.v2.FulfillmentInfo]: crate::model::FulfillmentInfo
    /// [google.cloud.retail.v2.FulfillmentInfo.place_ids]: crate::model::FulfillmentInfo::place_ids
    /// [google.cloud.retail.v2.FulfillmentInfo.type]: crate::model::FulfillmentInfo::type
    /// [google.cloud.retail.v2.LocalInventory]: crate::model::LocalInventory
    /// [google.cloud.retail.v2.LocalInventory.attributes]: crate::model::LocalInventory::attributes
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.Product.Type.VARIANT]: crate::model::product::Type::Variant
    /// [google.cloud.retail.v2.Product.attributes]: crate::model::Product::attributes
    pub variant_rollup_keys: std::vec::Vec<std::string::String>,

    /// The categories associated with a category page. Must be set for category
    /// navigation queries to achieve good search quality. The format should be
    /// the same as
    /// [UserEvent.page_categories][google.cloud.retail.v2.UserEvent.page_categories];
    ///
    /// To represent full path of category, use '>' sign to separate different
    /// hierarchies. If '>' is part of the category name, replace it with
    /// other character(s).
    ///
    /// Category pages include special pages such as sales or promotions. For
    /// instance, a special sale page may have the category hierarchy:
    /// "pageCategories" : ["Sales > 2017 Black Friday Deals"].
    ///
    /// [google.cloud.retail.v2.UserEvent.page_categories]: crate::model::UserEvent::page_categories
    pub page_categories: std::vec::Vec<std::string::String>,

    /// The search mode of the search request. If not specified, a single search
    /// request triggers both product search and faceted search.
    pub search_mode: crate::model::search_request::SearchMode,

    /// The specification for personalization.
    ///
    /// Notice that if both
    /// [ServingConfig.personalization_spec][google.cloud.retail.v2.ServingConfig.personalization_spec]
    /// and
    /// [SearchRequest.personalization_spec][google.cloud.retail.v2.SearchRequest.personalization_spec]
    /// are set.
    /// [SearchRequest.personalization_spec][google.cloud.retail.v2.SearchRequest.personalization_spec]
    /// will override
    /// [ServingConfig.personalization_spec][google.cloud.retail.v2.ServingConfig.personalization_spec].
    ///
    /// [google.cloud.retail.v2.SearchRequest.personalization_spec]: crate::model::SearchRequest::personalization_spec
    /// [google.cloud.retail.v2.ServingConfig.personalization_spec]: crate::model::ServingConfig::personalization_spec
    pub personalization_spec:
        std::option::Option<crate::model::search_request::PersonalizationSpec>,

    /// The labels applied to a resource must meet the following requirements:
    ///
    /// * Each resource can have multiple labels, up to a maximum of 64.
    /// * Each label must be a key-value pair.
    /// * Keys have a minimum length of 1 character and a maximum length of 63
    ///   characters and cannot be empty. Values can be empty and have a maximum
    ///   length of 63 characters.
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes. All characters must use UTF-8 encoding, and
    ///   international characters are allowed.
    /// * The key portion of a label must be unique. However, you can use the same
    ///   key with multiple resources.
    /// * Keys must start with a lowercase letter or international character.
    ///
    /// For more information, see [Requirements for
    /// labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements)
    /// in the Resource Manager documentation.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The spell correction specification that specifies the mode under
    /// which spell correction will take effect.
    pub spell_correction_spec:
        std::option::Option<crate::model::search_request::SpellCorrectionSpec>,

    /// The entity for customers that may run multiple different entities, domains,
    /// sites or regions, for example, `Google US`, `Google Ads`, `Waymo`,
    /// `google.com`, `youtube.com`, etc.
    /// If this is set, it should be exactly matched with
    /// [UserEvent.entity][google.cloud.retail.v2.UserEvent.entity] to get search
    /// results boosted by entity.
    ///
    /// [google.cloud.retail.v2.UserEvent.entity]: crate::model::UserEvent::entity
    pub entity: std::string::String,

    /// Optional. This field specifies all conversational related parameters
    /// addition to traditional retail search.
    pub conversational_search_spec:
        std::option::Option<crate::model::search_request::ConversationalSearchSpec>,

    /// Optional. This field specifies tile navigation related parameters.
    pub tile_navigation_spec: std::option::Option<crate::model::search_request::TileNavigationSpec>,

    /// Optional. The BCP-47 language code, such as "en-US" or "sr-Latn"
    /// [list](https://www.unicode.org/cldr/charts/46/summary/root.html). For more
    /// information, see [Standardized codes](https://google.aip.dev/143). This
    /// field helps to better interpret the query. If a value isn't specified, the
    /// query language code is automatically detected, which may not be accurate.
    pub language_code: std::string::String,

    /// Optional. The Unicode country/region code (CLDR) of a location, such as
    /// "US" and "419"
    /// [list](https://www.unicode.org/cldr/charts/46/supplemental/territory_information.html).
    /// For more information, see [Standardized codes](https://google.aip.dev/143).
    /// If set, then results will be boosted based on the region_code provided.
    pub region_code: std::string::String,

    /// Optional. An id corresponding to a place, such as a store id or region id.
    /// When specified, we use the price from the local inventory with the matching
    /// product's
    /// [LocalInventory.place_id][google.cloud.retail.v2.LocalInventory.place_id]
    /// for revenue optimization.
    ///
    /// [google.cloud.retail.v2.LocalInventory.place_id]: crate::model::LocalInventory::place_id
    pub place_id: std::string::String,

    /// Optional. The user attributes that could be used for personalization of
    /// search results.
    ///
    /// * Populate at most 100 key-value pairs per query.
    /// * Only supports string keys and repeated string values.
    /// * Duplicate keys are not allowed within a single query.
    ///
    /// Example:
    /// user_attributes: [
    /// { key: "pets"
    /// value {
    /// values: "dog"
    /// values: "cat"
    /// }
    /// },
    /// { key: "state"
    /// value {
    /// values: "CA"
    /// }
    /// }
    /// ]
    pub user_attributes: std::collections::HashMap<std::string::String, crate::model::StringList>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [placement][crate::model::SearchRequest::placement].
    pub fn set_placement<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.placement = v.into();
        self
    }

    /// Sets the value of [branch][crate::model::SearchRequest::branch].
    pub fn set_branch<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.branch = v.into();
        self
    }

    /// Sets the value of [query][crate::model::SearchRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [visitor_id][crate::model::SearchRequest::visitor_id].
    pub fn set_visitor_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.visitor_id = v.into();
        self
    }

    /// Sets the value of [user_info][crate::model::SearchRequest::user_info].
    pub fn set_user_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserInfo>,
    {
        self.user_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user_info][crate::model::SearchRequest::user_info].
    pub fn set_or_clear_user_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserInfo>,
    {
        self.user_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_size][crate::model::SearchRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [offset][crate::model::SearchRequest::offset].
    pub fn set_offset<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.offset = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::SearchRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [canonical_filter][crate::model::SearchRequest::canonical_filter].
    pub fn set_canonical_filter<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.canonical_filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::SearchRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [facet_specs][crate::model::SearchRequest::facet_specs].
    pub fn set_facet_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::search_request::FacetSpec>,
    {
        use std::iter::Iterator;
        self.facet_specs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dynamic_facet_spec][crate::model::SearchRequest::dynamic_facet_spec].
    #[deprecated]
    pub fn set_dynamic_facet_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_request::DynamicFacetSpec>,
    {
        self.dynamic_facet_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dynamic_facet_spec][crate::model::SearchRequest::dynamic_facet_spec].
    #[deprecated]
    pub fn set_or_clear_dynamic_facet_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_request::DynamicFacetSpec>,
    {
        self.dynamic_facet_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [boost_spec][crate::model::SearchRequest::boost_spec].
    pub fn set_boost_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_request::BoostSpec>,
    {
        self.boost_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [boost_spec][crate::model::SearchRequest::boost_spec].
    pub fn set_or_clear_boost_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_request::BoostSpec>,
    {
        self.boost_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [query_expansion_spec][crate::model::SearchRequest::query_expansion_spec].
    pub fn set_query_expansion_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_request::QueryExpansionSpec>,
    {
        self.query_expansion_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_expansion_spec][crate::model::SearchRequest::query_expansion_spec].
    pub fn set_or_clear_query_expansion_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_request::QueryExpansionSpec>,
    {
        self.query_expansion_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [variant_rollup_keys][crate::model::SearchRequest::variant_rollup_keys].
    pub fn set_variant_rollup_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.variant_rollup_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [page_categories][crate::model::SearchRequest::page_categories].
    pub fn set_page_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.page_categories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [search_mode][crate::model::SearchRequest::search_mode].
    pub fn set_search_mode<T: std::convert::Into<crate::model::search_request::SearchMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.search_mode = v.into();
        self
    }

    /// Sets the value of [personalization_spec][crate::model::SearchRequest::personalization_spec].
    pub fn set_personalization_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_request::PersonalizationSpec>,
    {
        self.personalization_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [personalization_spec][crate::model::SearchRequest::personalization_spec].
    pub fn set_or_clear_personalization_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_request::PersonalizationSpec>,
    {
        self.personalization_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::SearchRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [spell_correction_spec][crate::model::SearchRequest::spell_correction_spec].
    pub fn set_spell_correction_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_request::SpellCorrectionSpec>,
    {
        self.spell_correction_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [spell_correction_spec][crate::model::SearchRequest::spell_correction_spec].
    pub fn set_or_clear_spell_correction_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_request::SpellCorrectionSpec>,
    {
        self.spell_correction_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [entity][crate::model::SearchRequest::entity].
    pub fn set_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity = v.into();
        self
    }

    /// Sets the value of [conversational_search_spec][crate::model::SearchRequest::conversational_search_spec].
    pub fn set_conversational_search_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_request::ConversationalSearchSpec>,
    {
        self.conversational_search_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversational_search_spec][crate::model::SearchRequest::conversational_search_spec].
    pub fn set_or_clear_conversational_search_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_request::ConversationalSearchSpec>,
    {
        self.conversational_search_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tile_navigation_spec][crate::model::SearchRequest::tile_navigation_spec].
    pub fn set_tile_navigation_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_request::TileNavigationSpec>,
    {
        self.tile_navigation_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tile_navigation_spec][crate::model::SearchRequest::tile_navigation_spec].
    pub fn set_or_clear_tile_navigation_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_request::TileNavigationSpec>,
    {
        self.tile_navigation_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::SearchRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [region_code][crate::model::SearchRequest::region_code].
    pub fn set_region_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.region_code = v.into();
        self
    }

    /// Sets the value of [place_id][crate::model::SearchRequest::place_id].
    pub fn set_place_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.place_id = v.into();
        self
    }

    /// Sets the value of [user_attributes][crate::model::SearchRequest::user_attributes].
    pub fn set_user_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::StringList>,
    {
        use std::iter::Iterator;
        self.user_attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for SearchRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.SearchRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __placement,
            __branch,
            __query,
            __visitor_id,
            __user_info,
            __page_size,
            __page_token,
            __offset,
            __filter,
            __canonical_filter,
            __order_by,
            __facet_specs,
            __dynamic_facet_spec,
            __boost_spec,
            __query_expansion_spec,
            __variant_rollup_keys,
            __page_categories,
            __search_mode,
            __personalization_spec,
            __labels,
            __spell_correction_spec,
            __entity,
            __conversational_search_spec,
            __tile_navigation_spec,
            __language_code,
            __region_code,
            __place_id,
            __user_attributes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "placement" => Ok(__FieldTag::__placement),
                            "branch" => Ok(__FieldTag::__branch),
                            "query" => Ok(__FieldTag::__query),
                            "visitorId" => Ok(__FieldTag::__visitor_id),
                            "visitor_id" => Ok(__FieldTag::__visitor_id),
                            "userInfo" => Ok(__FieldTag::__user_info),
                            "user_info" => Ok(__FieldTag::__user_info),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "offset" => Ok(__FieldTag::__offset),
                            "filter" => Ok(__FieldTag::__filter),
                            "canonicalFilter" => Ok(__FieldTag::__canonical_filter),
                            "canonical_filter" => Ok(__FieldTag::__canonical_filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "facetSpecs" => Ok(__FieldTag::__facet_specs),
                            "facet_specs" => Ok(__FieldTag::__facet_specs),
                            "dynamicFacetSpec" => Ok(__FieldTag::__dynamic_facet_spec),
                            "dynamic_facet_spec" => Ok(__FieldTag::__dynamic_facet_spec),
                            "boostSpec" => Ok(__FieldTag::__boost_spec),
                            "boost_spec" => Ok(__FieldTag::__boost_spec),
                            "queryExpansionSpec" => Ok(__FieldTag::__query_expansion_spec),
                            "query_expansion_spec" => Ok(__FieldTag::__query_expansion_spec),
                            "variantRollupKeys" => Ok(__FieldTag::__variant_rollup_keys),
                            "variant_rollup_keys" => Ok(__FieldTag::__variant_rollup_keys),
                            "pageCategories" => Ok(__FieldTag::__page_categories),
                            "page_categories" => Ok(__FieldTag::__page_categories),
                            "searchMode" => Ok(__FieldTag::__search_mode),
                            "search_mode" => Ok(__FieldTag::__search_mode),
                            "personalizationSpec" => Ok(__FieldTag::__personalization_spec),
                            "personalization_spec" => Ok(__FieldTag::__personalization_spec),
                            "labels" => Ok(__FieldTag::__labels),
                            "spellCorrectionSpec" => Ok(__FieldTag::__spell_correction_spec),
                            "spell_correction_spec" => Ok(__FieldTag::__spell_correction_spec),
                            "entity" => Ok(__FieldTag::__entity),
                            "conversationalSearchSpec" => {
                                Ok(__FieldTag::__conversational_search_spec)
                            }
                            "conversational_search_spec" => {
                                Ok(__FieldTag::__conversational_search_spec)
                            }
                            "tileNavigationSpec" => Ok(__FieldTag::__tile_navigation_spec),
                            "tile_navigation_spec" => Ok(__FieldTag::__tile_navigation_spec),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "regionCode" => Ok(__FieldTag::__region_code),
                            "region_code" => Ok(__FieldTag::__region_code),
                            "placeId" => Ok(__FieldTag::__place_id),
                            "place_id" => Ok(__FieldTag::__place_id),
                            "userAttributes" => Ok(__FieldTag::__user_attributes),
                            "user_attributes" => Ok(__FieldTag::__user_attributes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__placement => {
                            if !fields.insert(__FieldTag::__placement) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for placement",
                                ));
                            }
                            result.placement = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__branch => {
                            if !fields.insert(__FieldTag::__branch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for branch",
                                ));
                            }
                            result.branch = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__visitor_id => {
                            if !fields.insert(__FieldTag::__visitor_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for visitor_id",
                                ));
                            }
                            result.visitor_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_info => {
                            if !fields.insert(__FieldTag::__user_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_info",
                                ));
                            }
                            result.user_info =
                                map.next_value::<std::option::Option<crate::model::UserInfo>>()?;
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__offset => {
                            if !fields.insert(__FieldTag::__offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for offset",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.offset = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__canonical_filter => {
                            if !fields.insert(__FieldTag::__canonical_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for canonical_filter",
                                ));
                            }
                            result.canonical_filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__facet_specs => {
                            if !fields.insert(__FieldTag::__facet_specs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for facet_specs",
                                ));
                            }
                            result.facet_specs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::search_request::FacetSpec>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dynamic_facet_spec => {
                            if !fields.insert(__FieldTag::__dynamic_facet_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dynamic_facet_spec",
                                ));
                            }
                            result.dynamic_facet_spec = map.next_value::<std::option::Option<
                                crate::model::search_request::DynamicFacetSpec,
                            >>()?;
                        }
                        __FieldTag::__boost_spec => {
                            if !fields.insert(__FieldTag::__boost_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boost_spec",
                                ));
                            }
                            result.boost_spec = map.next_value::<std::option::Option<crate::model::search_request::BoostSpec>>()?
                                ;
                        }
                        __FieldTag::__query_expansion_spec => {
                            if !fields.insert(__FieldTag::__query_expansion_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_expansion_spec",
                                ));
                            }
                            result.query_expansion_spec = map.next_value::<std::option::Option<
                                crate::model::search_request::QueryExpansionSpec,
                            >>()?;
                        }
                        __FieldTag::__variant_rollup_keys => {
                            if !fields.insert(__FieldTag::__variant_rollup_keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for variant_rollup_keys",
                                ));
                            }
                            result.variant_rollup_keys = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__page_categories => {
                            if !fields.insert(__FieldTag::__page_categories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_categories",
                                ));
                            }
                            result.page_categories = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__search_mode => {
                            if !fields.insert(__FieldTag::__search_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for search_mode",
                                ));
                            }
                            result.search_mode = map.next_value::<std::option::Option<crate::model::search_request::SearchMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__personalization_spec => {
                            if !fields.insert(__FieldTag::__personalization_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for personalization_spec",
                                ));
                            }
                            result.personalization_spec = map.next_value::<std::option::Option<
                                crate::model::search_request::PersonalizationSpec,
                            >>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__spell_correction_spec => {
                            if !fields.insert(__FieldTag::__spell_correction_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spell_correction_spec",
                                ));
                            }
                            result.spell_correction_spec = map.next_value::<std::option::Option<
                                crate::model::search_request::SpellCorrectionSpec,
                            >>()?;
                        }
                        __FieldTag::__entity => {
                            if !fields.insert(__FieldTag::__entity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity",
                                ));
                            }
                            result.entity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conversational_search_spec => {
                            if !fields.insert(__FieldTag::__conversational_search_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversational_search_spec",
                                ));
                            }
                            result.conversational_search_spec = map
                                .next_value::<std::option::Option<
                                    crate::model::search_request::ConversationalSearchSpec,
                                >>()?;
                        }
                        __FieldTag::__tile_navigation_spec => {
                            if !fields.insert(__FieldTag::__tile_navigation_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tile_navigation_spec",
                                ));
                            }
                            result.tile_navigation_spec = map.next_value::<std::option::Option<
                                crate::model::search_request::TileNavigationSpec,
                            >>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__region_code => {
                            if !fields.insert(__FieldTag::__region_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for region_code",
                                ));
                            }
                            result.region_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__place_id => {
                            if !fields.insert(__FieldTag::__place_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for place_id",
                                ));
                            }
                            result.place_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_attributes => {
                            if !fields.insert(__FieldTag::__user_attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_attributes",
                                ));
                            }
                            result.user_attributes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::StringList,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.placement.is_empty() {
            state.serialize_entry("placement", &self.placement)?;
        }
        if !self.branch.is_empty() {
            state.serialize_entry("branch", &self.branch)?;
        }
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !self.visitor_id.is_empty() {
            state.serialize_entry("visitorId", &self.visitor_id)?;
        }
        if self.user_info.is_some() {
            state.serialize_entry("userInfo", &self.user_info)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.offset) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("offset", &__With(&self.offset))?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.canonical_filter.is_empty() {
            state.serialize_entry("canonicalFilter", &self.canonical_filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.facet_specs.is_empty() {
            state.serialize_entry("facetSpecs", &self.facet_specs)?;
        }
        if self.dynamic_facet_spec.is_some() {
            state.serialize_entry("dynamicFacetSpec", &self.dynamic_facet_spec)?;
        }
        if self.boost_spec.is_some() {
            state.serialize_entry("boostSpec", &self.boost_spec)?;
        }
        if self.query_expansion_spec.is_some() {
            state.serialize_entry("queryExpansionSpec", &self.query_expansion_spec)?;
        }
        if !self.variant_rollup_keys.is_empty() {
            state.serialize_entry("variantRollupKeys", &self.variant_rollup_keys)?;
        }
        if !self.page_categories.is_empty() {
            state.serialize_entry("pageCategories", &self.page_categories)?;
        }
        if !wkt::internal::is_default(&self.search_mode) {
            state.serialize_entry("searchMode", &self.search_mode)?;
        }
        if self.personalization_spec.is_some() {
            state.serialize_entry("personalizationSpec", &self.personalization_spec)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.spell_correction_spec.is_some() {
            state.serialize_entry("spellCorrectionSpec", &self.spell_correction_spec)?;
        }
        if !self.entity.is_empty() {
            state.serialize_entry("entity", &self.entity)?;
        }
        if self.conversational_search_spec.is_some() {
            state.serialize_entry("conversationalSearchSpec", &self.conversational_search_spec)?;
        }
        if self.tile_navigation_spec.is_some() {
            state.serialize_entry("tileNavigationSpec", &self.tile_navigation_spec)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self.region_code.is_empty() {
            state.serialize_entry("regionCode", &self.region_code)?;
        }
        if !self.place_id.is_empty() {
            state.serialize_entry("placeId", &self.place_id)?;
        }
        if !self.user_attributes.is_empty() {
            state.serialize_entry("userAttributes", &self.user_attributes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SearchRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchRequest");
        debug_struct.field("placement", &self.placement);
        debug_struct.field("branch", &self.branch);
        debug_struct.field("query", &self.query);
        debug_struct.field("visitor_id", &self.visitor_id);
        debug_struct.field("user_info", &self.user_info);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("offset", &self.offset);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("canonical_filter", &self.canonical_filter);
        debug_struct.field("order_by", &self.order_by);
        debug_struct.field("facet_specs", &self.facet_specs);
        debug_struct.field("dynamic_facet_spec", &self.dynamic_facet_spec);
        debug_struct.field("boost_spec", &self.boost_spec);
        debug_struct.field("query_expansion_spec", &self.query_expansion_spec);
        debug_struct.field("variant_rollup_keys", &self.variant_rollup_keys);
        debug_struct.field("page_categories", &self.page_categories);
        debug_struct.field("search_mode", &self.search_mode);
        debug_struct.field("personalization_spec", &self.personalization_spec);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("spell_correction_spec", &self.spell_correction_spec);
        debug_struct.field("entity", &self.entity);
        debug_struct.field(
            "conversational_search_spec",
            &self.conversational_search_spec,
        );
        debug_struct.field("tile_navigation_spec", &self.tile_navigation_spec);
        debug_struct.field("language_code", &self.language_code);
        debug_struct.field("region_code", &self.region_code);
        debug_struct.field("place_id", &self.place_id);
        debug_struct.field("user_attributes", &self.user_attributes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SearchRequest].
pub mod search_request {
    #[allow(unused_imports)]
    use super::*;

    /// A facet specification to perform faceted search.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FacetSpec {
        /// Required. The facet key specification.
        pub facet_key: std::option::Option<crate::model::search_request::facet_spec::FacetKey>,

        /// Maximum of facet values that should be returned for this facet. If
        /// unspecified, defaults to 50. The maximum allowed value is 300. Values
        /// above 300 will be coerced to 300.
        ///
        /// If this field is negative, an INVALID_ARGUMENT is returned.
        pub limit: i32,

        /// List of keys to exclude when faceting.
        ///
        /// By default,
        /// [FacetKey.key][google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.key]
        /// is not excluded from the filter unless it is listed in this field.
        ///
        /// Listing a facet key in this field allows its values to appear as facet
        /// results, even when they are filtered out of search results. Using this
        /// field does not affect what search results are returned.
        ///
        /// For example, suppose there are 100 products with the color facet "Red"
        /// and 200 products with the color facet "Blue". A query containing the
        /// filter "colorFamilies:ANY("Red")" and having "colorFamilies" as
        /// [FacetKey.key][google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.key]
        /// would by default return only "Red" products in the search results, and
        /// also return "Red" with count 100 as the only color facet. Although there
        /// are also blue products available, "Blue" would not be shown as an
        /// available facet value.
        ///
        /// If "colorFamilies" is listed in "excludedFilterKeys", then the query
        /// returns the facet values "Red" with count 100 and "Blue" with count
        /// 200, because the "colorFamilies" key is now excluded from the filter.
        /// Because this field doesn't affect search results, the search results
        /// are still correctly filtered to return only "Red" products.
        ///
        /// A maximum of 100 values are allowed. Otherwise, an INVALID_ARGUMENT error
        /// is returned.
        ///
        /// [google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.key]: crate::model::search_request::facet_spec::FacetKey::key
        pub excluded_filter_keys: std::vec::Vec<std::string::String>,

        /// Enables dynamic position for this facet. If set to true, the position of
        /// this facet among all facets in the response is determined by Google
        /// Retail Search. It is ordered together with dynamic facets if dynamic
        /// facets is enabled. If set to false, the position of this facet in the
        /// response is the same as in the request, and it is ranked before
        /// the facets with dynamic position enable and all dynamic facets.
        ///
        /// For example, you may always want to have rating facet returned in
        /// the response, but it's not necessarily to always display the rating facet
        /// at the top. In that case, you can set enable_dynamic_position to true so
        /// that the position of rating facet in response is determined by
        /// Google Retail Search.
        ///
        /// Another example, assuming you have the following facets in the request:
        ///
        /// * "rating", enable_dynamic_position = true
        ///
        /// * "price", enable_dynamic_position = false
        ///
        /// * "brands", enable_dynamic_position = false
        ///
        ///
        /// And also you have a dynamic facets enable, which generates a facet
        /// "gender". Then, the final order of the facets in the response can be
        /// ("price", "brands", "rating", "gender") or ("price", "brands", "gender",
        /// "rating") depends on how Google Retail Search orders "gender" and
        /// "rating" facets. However, notice that "price" and "brands" are always
        /// ranked at first and second position because their enable_dynamic_position
        /// values are false.
        pub enable_dynamic_position: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FacetSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [facet_key][crate::model::search_request::FacetSpec::facet_key].
        pub fn set_facet_key<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::search_request::facet_spec::FacetKey>,
        {
            self.facet_key = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [facet_key][crate::model::search_request::FacetSpec::facet_key].
        pub fn set_or_clear_facet_key<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::search_request::facet_spec::FacetKey>,
        {
            self.facet_key = v.map(|x| x.into());
            self
        }

        /// Sets the value of [limit][crate::model::search_request::FacetSpec::limit].
        pub fn set_limit<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.limit = v.into();
            self
        }

        /// Sets the value of [excluded_filter_keys][crate::model::search_request::FacetSpec::excluded_filter_keys].
        pub fn set_excluded_filter_keys<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.excluded_filter_keys = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [enable_dynamic_position][crate::model::search_request::FacetSpec::enable_dynamic_position].
        pub fn set_enable_dynamic_position<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_dynamic_position = v.into();
            self
        }
    }

    impl wkt::message::Message for FacetSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.SearchRequest.FacetSpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FacetSpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __facet_key,
                __limit,
                __excluded_filter_keys,
                __enable_dynamic_position,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for FacetSpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "facetKey" => Ok(__FieldTag::__facet_key),
                                "facet_key" => Ok(__FieldTag::__facet_key),
                                "limit" => Ok(__FieldTag::__limit),
                                "excludedFilterKeys" => Ok(__FieldTag::__excluded_filter_keys),
                                "excluded_filter_keys" => Ok(__FieldTag::__excluded_filter_keys),
                                "enableDynamicPosition" => {
                                    Ok(__FieldTag::__enable_dynamic_position)
                                }
                                "enable_dynamic_position" => {
                                    Ok(__FieldTag::__enable_dynamic_position)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FacetSpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FacetSpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__facet_key => {
                                if !fields.insert(__FieldTag::__facet_key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for facet_key",
                                    ));
                                }
                                result.facet_key = map.next_value::<std::option::Option<
                                    crate::model::search_request::facet_spec::FacetKey,
                                >>()?;
                            }
                            __FieldTag::__limit => {
                                if !fields.insert(__FieldTag::__limit) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for limit",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.limit = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__excluded_filter_keys => {
                                if !fields.insert(__FieldTag::__excluded_filter_keys) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for excluded_filter_keys",
                                    ));
                                }
                                result.excluded_filter_keys = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__enable_dynamic_position => {
                                if !fields.insert(__FieldTag::__enable_dynamic_position) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_dynamic_position",
                                    ));
                                }
                                result.enable_dynamic_position = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for FacetSpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.facet_key.is_some() {
                state.serialize_entry("facetKey", &self.facet_key)?;
            }
            if !wkt::internal::is_default(&self.limit) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("limit", &__With(&self.limit))?;
            }
            if !self.excluded_filter_keys.is_empty() {
                state.serialize_entry("excludedFilterKeys", &self.excluded_filter_keys)?;
            }
            if !wkt::internal::is_default(&self.enable_dynamic_position) {
                state.serialize_entry("enableDynamicPosition", &self.enable_dynamic_position)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for FacetSpec {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("FacetSpec");
            debug_struct.field("facet_key", &self.facet_key);
            debug_struct.field("limit", &self.limit);
            debug_struct.field("excluded_filter_keys", &self.excluded_filter_keys);
            debug_struct.field("enable_dynamic_position", &self.enable_dynamic_position);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [FacetSpec].
    pub mod facet_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Specifies how a facet is computed.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct FacetKey {
            /// Required. Supported textual and numerical facet keys in
            /// [Product][google.cloud.retail.v2.Product] object, over which the facet
            /// values are computed. Facet key is case-sensitive.
            ///
            /// Allowed facet keys when
            /// [FacetKey.query][google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.query]
            /// is not specified:
            ///
            /// * textual_field =
            ///
            ///   * "brands"
            ///   * "categories"
            ///   * "genders"
            ///   * "ageGroups"
            ///   * "availability"
            ///   * "colorFamilies"
            ///   * "colors"
            ///   * "sizes"
            ///   * "materials"
            ///   * "patterns"
            ///   * "conditions"
            ///   * "attributes.key"
            ///   * "pickupInStore"
            ///   * "shipToStore"
            ///   * "sameDayDelivery"
            ///   * "nextDayDelivery"
            ///   * "customFulfillment1"
            ///   * "customFulfillment2"
            ///   * "customFulfillment3"
            ///   * "customFulfillment4"
            ///   * "customFulfillment5"
            ///   * "inventory(place_id,attributes.key)"
            /// * numerical_field =
            ///
            ///   * "price"
            ///   * "discount"
            ///   * "rating"
            ///   * "ratingCount"
            ///   * "attributes.key"
            ///   * "inventory(place_id,price)"
            ///   * "inventory(place_id,original_price)"
            ///   * "inventory(place_id,attributes.key)"
            ///
            /// [google.cloud.retail.v2.Product]: crate::model::Product
            /// [google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.query]: crate::model::search_request::facet_spec::FacetKey::query
            pub key: std::string::String,

            /// Set only if values should be bucketized into intervals. Must be set
            /// for facets with numerical values. Must not be set for facet with text
            /// values. Maximum number of intervals is 40.
            ///
            /// For all numerical facet keys that appear in the list of products from
            /// the catalog, the percentiles 0, 10, 30, 50, 70, 90, and 100 are
            /// computed from their distribution weekly. If the model assigns a high
            /// score to a numerical facet key and its intervals are not specified in
            /// the search request, these percentiles become the bounds
            /// for its intervals and are returned in the response. If the
            /// facet key intervals are specified in the request, then the specified
            /// intervals are returned instead.
            pub intervals: std::vec::Vec<crate::model::Interval>,

            /// Only get facet for the given restricted values. For example, when using
            /// "pickupInStore" as key and set restricted values to
            /// ["store123", "store456"], only facets for "store123" and "store456" are
            /// returned. Only supported on predefined textual fields, custom textual
            /// attributes and fulfillments. Maximum is 20.
            ///
            /// Must be set for the fulfillment facet keys:
            ///
            /// * pickupInStore
            ///
            /// * shipToStore
            ///
            /// * sameDayDelivery
            ///
            /// * nextDayDelivery
            ///
            /// * customFulfillment1
            ///
            /// * customFulfillment2
            ///
            /// * customFulfillment3
            ///
            /// * customFulfillment4
            ///
            /// * customFulfillment5
            ///
            pub restricted_values: std::vec::Vec<std::string::String>,

            /// Only get facet values that start with the given string prefix. For
            /// example, suppose "categories" has three values "Women > Shoe",
            /// "Women > Dress" and "Men > Shoe". If set "prefixes" to "Women", the
            /// "categories" facet gives only "Women > Shoe" and "Women > Dress".
            /// Only supported on textual fields. Maximum is 10.
            pub prefixes: std::vec::Vec<std::string::String>,

            /// Only get facet values that contains the given strings. For example,
            /// suppose "categories" has three values "Women > Shoe",
            /// "Women > Dress" and "Men > Shoe". If set "contains" to "Shoe", the
            /// "categories" facet gives only "Women > Shoe" and "Men > Shoe".
            /// Only supported on textual fields. Maximum is 10.
            pub contains: std::vec::Vec<std::string::String>,

            /// True to make facet keys case insensitive when getting faceting
            /// values with prefixes or contains; false otherwise.
            pub case_insensitive: bool,

            /// The order in which
            /// [SearchResponse.Facet.values][google.cloud.retail.v2.SearchResponse.Facet.values]
            /// are returned.
            ///
            /// Allowed values are:
            ///
            /// * "count desc", which means order by
            ///   [SearchResponse.Facet.values.count][google.cloud.retail.v2.SearchResponse.Facet.FacetValue.count]
            ///   descending.
            ///
            /// * "value desc", which means order by
            ///   [SearchResponse.Facet.values.value][google.cloud.retail.v2.SearchResponse.Facet.FacetValue.value]
            ///   descending.
            ///   Only applies to textual facets.
            ///
            ///
            /// If not set, textual values are sorted in [natural
            /// order](https://en.wikipedia.org/wiki/Natural_sort_order); numerical
            /// intervals are sorted in the order given by
            /// [FacetSpec.FacetKey.intervals][google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.intervals];
            /// [FulfillmentInfo.place_ids][google.cloud.retail.v2.FulfillmentInfo.place_ids]
            /// are sorted in the order given by
            /// [FacetSpec.FacetKey.restricted_values][google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.restricted_values].
            ///
            /// [google.cloud.retail.v2.FulfillmentInfo.place_ids]: crate::model::FulfillmentInfo::place_ids
            /// [google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.intervals]: crate::model::search_request::facet_spec::FacetKey::intervals
            /// [google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.restricted_values]: crate::model::search_request::facet_spec::FacetKey::restricted_values
            /// [google.cloud.retail.v2.SearchResponse.Facet.FacetValue.count]: crate::model::search_response::facet::FacetValue::count
            /// [google.cloud.retail.v2.SearchResponse.Facet.FacetValue.value]: crate::model::search_response::facet::FacetValue::facet_value
            /// [google.cloud.retail.v2.SearchResponse.Facet.values]: crate::model::search_response::Facet::values
            pub order_by: std::string::String,

            /// The query that is used to compute facet for the given facet key.
            /// When provided, it overrides the default behavior of facet
            /// computation. The query syntax is the same as a filter expression. See
            /// [SearchRequest.filter][google.cloud.retail.v2.SearchRequest.filter] for
            /// detail syntax and limitations. Notice that there is no limitation on
            /// [FacetKey.key][google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.key]
            /// when query is specified.
            ///
            /// In the response,
            /// [SearchResponse.Facet.values.value][google.cloud.retail.v2.SearchResponse.Facet.FacetValue.value]
            /// is always "1" and
            /// [SearchResponse.Facet.values.count][google.cloud.retail.v2.SearchResponse.Facet.FacetValue.count]
            /// is the number of results that match the query.
            ///
            /// For example, you can set a customized facet for "shipToStore",
            /// where
            /// [FacetKey.key][google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.key]
            /// is "customizedShipToStore", and
            /// [FacetKey.query][google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.query]
            /// is "availability: ANY(\"IN_STOCK\") AND shipToStore: ANY(\"123\")".
            /// Then the facet counts the products that are both in stock and ship
            /// to store "123".
            ///
            /// [google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.key]: crate::model::search_request::facet_spec::FacetKey::key
            /// [google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.query]: crate::model::search_request::facet_spec::FacetKey::query
            /// [google.cloud.retail.v2.SearchRequest.filter]: crate::model::SearchRequest::filter
            /// [google.cloud.retail.v2.SearchResponse.Facet.FacetValue.count]: crate::model::search_response::facet::FacetValue::count
            /// [google.cloud.retail.v2.SearchResponse.Facet.FacetValue.value]: crate::model::search_response::facet::FacetValue::facet_value
            pub query: std::string::String,

            /// Returns the min and max value for each numerical facet intervals.
            /// Ignored for textual facets.
            pub return_min_max: bool,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl FacetKey {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::search_request::facet_spec::FacetKey::key].
            pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.key = v.into();
                self
            }

            /// Sets the value of [intervals][crate::model::search_request::facet_spec::FacetKey::intervals].
            pub fn set_intervals<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::Interval>,
            {
                use std::iter::Iterator;
                self.intervals = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [restricted_values][crate::model::search_request::facet_spec::FacetKey::restricted_values].
            pub fn set_restricted_values<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.restricted_values = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [prefixes][crate::model::search_request::facet_spec::FacetKey::prefixes].
            pub fn set_prefixes<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.prefixes = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [contains][crate::model::search_request::facet_spec::FacetKey::contains].
            pub fn set_contains<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.contains = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [case_insensitive][crate::model::search_request::facet_spec::FacetKey::case_insensitive].
            pub fn set_case_insensitive<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.case_insensitive = v.into();
                self
            }

            /// Sets the value of [order_by][crate::model::search_request::facet_spec::FacetKey::order_by].
            pub fn set_order_by<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.order_by = v.into();
                self
            }

            /// Sets the value of [query][crate::model::search_request::facet_spec::FacetKey::query].
            pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.query = v.into();
                self
            }

            /// Sets the value of [return_min_max][crate::model::search_request::facet_spec::FacetKey::return_min_max].
            pub fn set_return_min_max<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.return_min_max = v.into();
                self
            }
        }

        impl wkt::message::Message for FacetKey {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for FacetKey {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __key,
                    __intervals,
                    __restricted_values,
                    __prefixes,
                    __contains,
                    __case_insensitive,
                    __order_by,
                    __query,
                    __return_min_max,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for FacetKey")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "key" => Ok(__FieldTag::__key),
                                    "intervals" => Ok(__FieldTag::__intervals),
                                    "restrictedValues" => Ok(__FieldTag::__restricted_values),
                                    "restricted_values" => Ok(__FieldTag::__restricted_values),
                                    "prefixes" => Ok(__FieldTag::__prefixes),
                                    "contains" => Ok(__FieldTag::__contains),
                                    "caseInsensitive" => Ok(__FieldTag::__case_insensitive),
                                    "case_insensitive" => Ok(__FieldTag::__case_insensitive),
                                    "orderBy" => Ok(__FieldTag::__order_by),
                                    "order_by" => Ok(__FieldTag::__order_by),
                                    "query" => Ok(__FieldTag::__query),
                                    "returnMinMax" => Ok(__FieldTag::__return_min_max),
                                    "return_min_max" => Ok(__FieldTag::__return_min_max),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = FacetKey;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct FacetKey")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__key => {
                                    if !fields.insert(__FieldTag::__key) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for key"),
                                        );
                                    }
                                    result.key = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__intervals => {
                                    if !fields.insert(__FieldTag::__intervals) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for intervals",
                                            ),
                                        );
                                    }
                                    result.intervals =
                                        map.next_value::<std::option::Option<
                                            std::vec::Vec<crate::model::Interval>,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__restricted_values => {
                                    if !fields.insert(__FieldTag::__restricted_values) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for restricted_values",
                                            ),
                                        );
                                    }
                                    result.restricted_values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__prefixes => {
                                    if !fields.insert(__FieldTag::__prefixes) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for prefixes",
                                            ),
                                        );
                                    }
                                    result.prefixes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__contains => {
                                    if !fields.insert(__FieldTag::__contains) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for contains",
                                            ),
                                        );
                                    }
                                    result.contains = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__case_insensitive => {
                                    if !fields.insert(__FieldTag::__case_insensitive) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for case_insensitive",
                                            ),
                                        );
                                    }
                                    result.case_insensitive = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__order_by => {
                                    if !fields.insert(__FieldTag::__order_by) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for order_by",
                                            ),
                                        );
                                    }
                                    result.order_by = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__query => {
                                    if !fields.insert(__FieldTag::__query) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for query"),
                                        );
                                    }
                                    result.query = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__return_min_max => {
                                    if !fields.insert(__FieldTag::__return_min_max) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for return_min_max",
                                            ),
                                        );
                                    }
                                    result.return_min_max = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for FacetKey {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.key.is_empty() {
                    state.serialize_entry("key", &self.key)?;
                }
                if !self.intervals.is_empty() {
                    state.serialize_entry("intervals", &self.intervals)?;
                }
                if !self.restricted_values.is_empty() {
                    state.serialize_entry("restrictedValues", &self.restricted_values)?;
                }
                if !self.prefixes.is_empty() {
                    state.serialize_entry("prefixes", &self.prefixes)?;
                }
                if !self.contains.is_empty() {
                    state.serialize_entry("contains", &self.contains)?;
                }
                if !wkt::internal::is_default(&self.case_insensitive) {
                    state.serialize_entry("caseInsensitive", &self.case_insensitive)?;
                }
                if !self.order_by.is_empty() {
                    state.serialize_entry("orderBy", &self.order_by)?;
                }
                if !self.query.is_empty() {
                    state.serialize_entry("query", &self.query)?;
                }
                if !wkt::internal::is_default(&self.return_min_max) {
                    state.serialize_entry("returnMinMax", &self.return_min_max)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for FacetKey {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("FacetKey");
                debug_struct.field("key", &self.key);
                debug_struct.field("intervals", &self.intervals);
                debug_struct.field("restricted_values", &self.restricted_values);
                debug_struct.field("prefixes", &self.prefixes);
                debug_struct.field("contains", &self.contains);
                debug_struct.field("case_insensitive", &self.case_insensitive);
                debug_struct.field("order_by", &self.order_by);
                debug_struct.field("query", &self.query);
                debug_struct.field("return_min_max", &self.return_min_max);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    /// The specifications of dynamically generated facets.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DynamicFacetSpec {
        /// Mode of the DynamicFacet feature.
        /// Defaults to
        /// [Mode.DISABLED][google.cloud.retail.v2.SearchRequest.DynamicFacetSpec.Mode.DISABLED]
        /// if it's unset.
        ///
        /// [google.cloud.retail.v2.SearchRequest.DynamicFacetSpec.Mode.DISABLED]: crate::model::search_request::dynamic_facet_spec::Mode::Disabled
        pub mode: crate::model::search_request::dynamic_facet_spec::Mode,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DynamicFacetSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [mode][crate::model::search_request::DynamicFacetSpec::mode].
        pub fn set_mode<
            T: std::convert::Into<crate::model::search_request::dynamic_facet_spec::Mode>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mode = v.into();
            self
        }
    }

    impl wkt::message::Message for DynamicFacetSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.SearchRequest.DynamicFacetSpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DynamicFacetSpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __mode,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DynamicFacetSpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "mode" => Ok(__FieldTag::__mode),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DynamicFacetSpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DynamicFacetSpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__mode => {
                                if !fields.insert(__FieldTag::__mode) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mode",
                                    ));
                                }
                                result.mode = map
                                    .next_value::<std::option::Option<
                                        crate::model::search_request::dynamic_facet_spec::Mode,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DynamicFacetSpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.mode) {
                state.serialize_entry("mode", &self.mode)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for DynamicFacetSpec {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("DynamicFacetSpec");
            debug_struct.field("mode", &self.mode);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [DynamicFacetSpec].
    pub mod dynamic_facet_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Enum to control DynamicFacet mode
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Mode {
            /// Default value.
            Unspecified,
            /// Disable Dynamic Facet.
            Disabled,
            /// Automatic mode built by Google Retail Search.
            Enabled,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Mode::value] or
            /// [Mode::name].
            UnknownValue(mode::UnknownValue),
        }

        #[doc(hidden)]
        pub mod mode {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Mode {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Disabled => std::option::Option::Some(1),
                    Self::Enabled => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                    Self::Disabled => std::option::Option::Some("DISABLED"),
                    Self::Enabled => std::option::Option::Some("ENABLED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Mode {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Mode {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Mode {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Disabled,
                    2 => Self::Enabled,
                    _ => Self::UnknownValue(mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Mode {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "MODE_UNSPECIFIED" => Self::Unspecified,
                    "DISABLED" => Self::Disabled,
                    "ENABLED" => Self::Enabled,
                    _ => Self::UnknownValue(mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Mode {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Disabled => serializer.serialize_i32(1),
                    Self::Enabled => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Mode {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                    ".google.cloud.retail.v2.SearchRequest.DynamicFacetSpec.Mode",
                ))
            }
        }
    }

    /// Boost specification to boost certain items.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BoostSpec {
        /// Condition boost specifications. If a product matches multiple conditions
        /// in the specifications, boost scores from these specifications are all
        /// applied and combined in a non-linear way. Maximum number of
        /// specifications is 20.
        pub condition_boost_specs:
            std::vec::Vec<crate::model::search_request::boost_spec::ConditionBoostSpec>,

        /// Whether to skip boostspec validation. If this field is set to true,
        /// invalid
        /// [BoostSpec.condition_boost_specs][google.cloud.retail.v2.SearchRequest.BoostSpec.condition_boost_specs]
        /// will be ignored and valid
        /// [BoostSpec.condition_boost_specs][google.cloud.retail.v2.SearchRequest.BoostSpec.condition_boost_specs]
        /// will still be applied.
        ///
        /// [google.cloud.retail.v2.SearchRequest.BoostSpec.condition_boost_specs]: crate::model::search_request::BoostSpec::condition_boost_specs
        pub skip_boost_spec_validation: std::option::Option<bool>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BoostSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [condition_boost_specs][crate::model::search_request::BoostSpec::condition_boost_specs].
        pub fn set_condition_boost_specs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::search_request::boost_spec::ConditionBoostSpec>,
        {
            use std::iter::Iterator;
            self.condition_boost_specs = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [skip_boost_spec_validation][crate::model::search_request::BoostSpec::skip_boost_spec_validation].
        pub fn set_skip_boost_spec_validation<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.skip_boost_spec_validation = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [skip_boost_spec_validation][crate::model::search_request::BoostSpec::skip_boost_spec_validation].
        pub fn set_or_clear_skip_boost_spec_validation<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.skip_boost_spec_validation = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for BoostSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.SearchRequest.BoostSpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BoostSpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __condition_boost_specs,
                __skip_boost_spec_validation,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BoostSpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "conditionBoostSpecs" => Ok(__FieldTag::__condition_boost_specs),
                                "condition_boost_specs" => Ok(__FieldTag::__condition_boost_specs),
                                "skipBoostSpecValidation" => {
                                    Ok(__FieldTag::__skip_boost_spec_validation)
                                }
                                "skip_boost_spec_validation" => {
                                    Ok(__FieldTag::__skip_boost_spec_validation)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BoostSpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BoostSpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__condition_boost_specs => {
                                if !fields.insert(__FieldTag::__condition_boost_specs) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for condition_boost_specs",
                                    ));
                                }
                                result.condition_boost_specs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::search_request::boost_spec::ConditionBoostSpec>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__skip_boost_spec_validation => {
                                if !fields.insert(__FieldTag::__skip_boost_spec_validation) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for skip_boost_spec_validation",
                                    ));
                                }
                                result.skip_boost_spec_validation =
                                    map.next_value::<std::option::Option<bool>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BoostSpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.condition_boost_specs.is_empty() {
                state.serialize_entry("conditionBoostSpecs", &self.condition_boost_specs)?;
            }
            if self.skip_boost_spec_validation.is_some() {
                state
                    .serialize_entry("skipBoostSpecValidation", &self.skip_boost_spec_validation)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for BoostSpec {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("BoostSpec");
            debug_struct.field("condition_boost_specs", &self.condition_boost_specs);
            debug_struct.field(
                "skip_boost_spec_validation",
                &self.skip_boost_spec_validation,
            );
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [BoostSpec].
    pub mod boost_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Boost applies to products which match a condition.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ConditionBoostSpec {
            /// An expression which specifies a boost condition. The syntax and
            /// supported fields are the same as a filter expression. See
            /// [SearchRequest.filter][google.cloud.retail.v2.SearchRequest.filter] for
            /// detail syntax and limitations.
            ///
            /// Examples:
            ///
            /// * To boost products with product ID "product_1" or "product_2", and
            ///   color
            ///   "Red" or "Blue":
            ///   * (id: ANY("product_1", "product_2")) AND (colorFamilies:
            ///     ANY("Red","Blue"))
            ///
            /// [google.cloud.retail.v2.SearchRequest.filter]: crate::model::SearchRequest::filter
            pub condition: std::string::String,

            /// Strength of the condition boost, which should be in [-1, 1]. Negative
            /// boost means demotion. Default is 0.0.
            ///
            /// Setting to 1.0 gives the item a big promotion. However, it does not
            /// necessarily mean that the boosted item will be the top result at all
            /// times, nor that other items will be excluded. Results could still be
            /// shown even when none of them matches the condition. And results that
            /// are significantly more relevant to the search query can still trump
            /// your heavily favored but irrelevant items.
            ///
            /// Setting to -1.0 gives the item a big demotion. However, results that
            /// are deeply relevant might still be shown. The item will have an
            /// upstream battle to get a fairly high ranking, but it is not blocked out
            /// completely.
            ///
            /// Setting to 0.0 means no boost applied. The boosting condition is
            /// ignored.
            pub boost: f32,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ConditionBoostSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [condition][crate::model::search_request::boost_spec::ConditionBoostSpec::condition].
            pub fn set_condition<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.condition = v.into();
                self
            }

            /// Sets the value of [boost][crate::model::search_request::boost_spec::ConditionBoostSpec::boost].
            pub fn set_boost<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                self.boost = v.into();
                self
            }
        }

        impl wkt::message::Message for ConditionBoostSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.retail.v2.SearchRequest.BoostSpec.ConditionBoostSpec"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ConditionBoostSpec {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __condition,
                    __boost,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ConditionBoostSpec")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "condition" => Ok(__FieldTag::__condition),
                                    "boost" => Ok(__FieldTag::__boost),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ConditionBoostSpec;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ConditionBoostSpec")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__condition => {
                                    if !fields.insert(__FieldTag::__condition) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for condition",
                                            ),
                                        );
                                    }
                                    result.condition = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__boost => {
                                    if !fields.insert(__FieldTag::__boost) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for boost"),
                                        );
                                    }
                                    struct __With(std::option::Option<f32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.boost =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ConditionBoostSpec {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.condition.is_empty() {
                    state.serialize_entry("condition", &self.condition)?;
                }
                if !wkt::internal::is_default(&self.boost) {
                    struct __With<'a>(&'a f32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("boost", &__With(&self.boost))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for ConditionBoostSpec {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("ConditionBoostSpec");
                debug_struct.field("condition", &self.condition);
                debug_struct.field("boost", &self.boost);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    /// Specification to determine under which conditions query expansion should
    /// occur.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct QueryExpansionSpec {
        /// The condition under which query expansion should occur. Default to
        /// [Condition.DISABLED][google.cloud.retail.v2.SearchRequest.QueryExpansionSpec.Condition.DISABLED].
        ///
        /// [google.cloud.retail.v2.SearchRequest.QueryExpansionSpec.Condition.DISABLED]: crate::model::search_request::query_expansion_spec::Condition::Disabled
        pub condition: crate::model::search_request::query_expansion_spec::Condition,

        /// Whether to pin unexpanded results. The default value is false. If this
        /// field is set to true,
        /// unexpanded products are always at the top of the search results, followed
        /// by the expanded results.
        pub pin_unexpanded_results: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QueryExpansionSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [condition][crate::model::search_request::QueryExpansionSpec::condition].
        pub fn set_condition<
            T: std::convert::Into<crate::model::search_request::query_expansion_spec::Condition>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.condition = v.into();
            self
        }

        /// Sets the value of [pin_unexpanded_results][crate::model::search_request::QueryExpansionSpec::pin_unexpanded_results].
        pub fn set_pin_unexpanded_results<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.pin_unexpanded_results = v.into();
            self
        }
    }

    impl wkt::message::Message for QueryExpansionSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.SearchRequest.QueryExpansionSpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for QueryExpansionSpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __condition,
                __pin_unexpanded_results,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for QueryExpansionSpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "condition" => Ok(__FieldTag::__condition),
                                "pinUnexpandedResults" => Ok(__FieldTag::__pin_unexpanded_results),
                                "pin_unexpanded_results" => {
                                    Ok(__FieldTag::__pin_unexpanded_results)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = QueryExpansionSpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct QueryExpansionSpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__condition => {
                                if !fields.insert(__FieldTag::__condition) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for condition",
                                    ));
                                }
                                result.condition = map.next_value::<std::option::Option<crate::model::search_request::query_expansion_spec::Condition>>()?.unwrap_or_default();
                            }
                            __FieldTag::__pin_unexpanded_results => {
                                if !fields.insert(__FieldTag::__pin_unexpanded_results) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for pin_unexpanded_results",
                                    ));
                                }
                                result.pin_unexpanded_results = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for QueryExpansionSpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.condition) {
                state.serialize_entry("condition", &self.condition)?;
            }
            if !wkt::internal::is_default(&self.pin_unexpanded_results) {
                state.serialize_entry("pinUnexpandedResults", &self.pin_unexpanded_results)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for QueryExpansionSpec {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("QueryExpansionSpec");
            debug_struct.field("condition", &self.condition);
            debug_struct.field("pin_unexpanded_results", &self.pin_unexpanded_results);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [QueryExpansionSpec].
    pub mod query_expansion_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Enum describing under which condition query expansion should occur.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Condition {
            /// Unspecified query expansion condition. In this case, server behavior
            /// defaults to
            /// [Condition.DISABLED][google.cloud.retail.v2.SearchRequest.QueryExpansionSpec.Condition.DISABLED].
            ///
            /// [google.cloud.retail.v2.SearchRequest.QueryExpansionSpec.Condition.DISABLED]: crate::model::search_request::query_expansion_spec::Condition::Disabled
            Unspecified,
            /// Disabled query expansion. Only the exact search query is used, even if
            /// [SearchResponse.total_size][google.cloud.retail.v2.SearchResponse.total_size]
            /// is zero.
            ///
            /// [google.cloud.retail.v2.SearchResponse.total_size]: crate::model::SearchResponse::total_size
            Disabled,
            /// Automatic query expansion built by Google Retail Search.
            Auto,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Condition::value] or
            /// [Condition::name].
            UnknownValue(condition::UnknownValue),
        }

        #[doc(hidden)]
        pub mod condition {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Condition {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Disabled => std::option::Option::Some(1),
                    Self::Auto => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("CONDITION_UNSPECIFIED"),
                    Self::Disabled => std::option::Option::Some("DISABLED"),
                    Self::Auto => std::option::Option::Some("AUTO"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Condition {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Condition {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Condition {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Disabled,
                    3 => Self::Auto,
                    _ => Self::UnknownValue(condition::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Condition {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CONDITION_UNSPECIFIED" => Self::Unspecified,
                    "DISABLED" => Self::Disabled,
                    "AUTO" => Self::Auto,
                    _ => Self::UnknownValue(condition::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Condition {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Disabled => serializer.serialize_i32(1),
                    Self::Auto => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Condition {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Condition>::new(
                    ".google.cloud.retail.v2.SearchRequest.QueryExpansionSpec.Condition",
                ))
            }
        }
    }

    /// The specification for personalization.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PersonalizationSpec {
        /// Defaults to
        /// [Mode.AUTO][google.cloud.retail.v2.SearchRequest.PersonalizationSpec.Mode.AUTO].
        ///
        /// [google.cloud.retail.v2.SearchRequest.PersonalizationSpec.Mode.AUTO]: crate::model::search_request::personalization_spec::Mode::Auto
        pub mode: crate::model::search_request::personalization_spec::Mode,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PersonalizationSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [mode][crate::model::search_request::PersonalizationSpec::mode].
        pub fn set_mode<
            T: std::convert::Into<crate::model::search_request::personalization_spec::Mode>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mode = v.into();
            self
        }
    }

    impl wkt::message::Message for PersonalizationSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.SearchRequest.PersonalizationSpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PersonalizationSpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __mode,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PersonalizationSpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "mode" => Ok(__FieldTag::__mode),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PersonalizationSpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PersonalizationSpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__mode => {
                                if !fields.insert(__FieldTag::__mode) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mode",
                                    ));
                                }
                                result.mode = map
                                    .next_value::<std::option::Option<
                                        crate::model::search_request::personalization_spec::Mode,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PersonalizationSpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.mode) {
                state.serialize_entry("mode", &self.mode)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PersonalizationSpec {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PersonalizationSpec");
            debug_struct.field("mode", &self.mode);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [PersonalizationSpec].
    pub mod personalization_spec {
        #[allow(unused_imports)]
        use super::*;

        /// The personalization mode of each search request.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Mode {
            /// Default value. In this case, server behavior defaults to
            /// [Mode.AUTO][google.cloud.retail.v2.SearchRequest.PersonalizationSpec.Mode.AUTO].
            ///
            /// [google.cloud.retail.v2.SearchRequest.PersonalizationSpec.Mode.AUTO]: crate::model::search_request::personalization_spec::Mode::Auto
            Unspecified,
            /// Let CRS decide whether to use personalization based on quality of user
            /// event data.
            Auto,
            /// Disable personalization.
            Disabled,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Mode::value] or
            /// [Mode::name].
            UnknownValue(mode::UnknownValue),
        }

        #[doc(hidden)]
        pub mod mode {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Mode {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Auto => std::option::Option::Some(1),
                    Self::Disabled => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                    Self::Auto => std::option::Option::Some("AUTO"),
                    Self::Disabled => std::option::Option::Some("DISABLED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Mode {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Mode {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Mode {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Auto,
                    2 => Self::Disabled,
                    _ => Self::UnknownValue(mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Mode {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "MODE_UNSPECIFIED" => Self::Unspecified,
                    "AUTO" => Self::Auto,
                    "DISABLED" => Self::Disabled,
                    _ => Self::UnknownValue(mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Mode {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Auto => serializer.serialize_i32(1),
                    Self::Disabled => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Mode {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                    ".google.cloud.retail.v2.SearchRequest.PersonalizationSpec.Mode",
                ))
            }
        }
    }

    /// The specification for query spell correction.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SpellCorrectionSpec {
        /// The mode under which spell correction should take effect to
        /// replace the original search query. Default to
        /// [Mode.AUTO][google.cloud.retail.v2.SearchRequest.SpellCorrectionSpec.Mode.AUTO].
        ///
        /// [google.cloud.retail.v2.SearchRequest.SpellCorrectionSpec.Mode.AUTO]: crate::model::search_request::spell_correction_spec::Mode::Auto
        pub mode: crate::model::search_request::spell_correction_spec::Mode,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SpellCorrectionSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [mode][crate::model::search_request::SpellCorrectionSpec::mode].
        pub fn set_mode<
            T: std::convert::Into<crate::model::search_request::spell_correction_spec::Mode>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mode = v.into();
            self
        }
    }

    impl wkt::message::Message for SpellCorrectionSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.SearchRequest.SpellCorrectionSpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SpellCorrectionSpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __mode,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SpellCorrectionSpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "mode" => Ok(__FieldTag::__mode),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SpellCorrectionSpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SpellCorrectionSpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__mode => {
                                if !fields.insert(__FieldTag::__mode) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mode",
                                    ));
                                }
                                result.mode = map
                                    .next_value::<std::option::Option<
                                        crate::model::search_request::spell_correction_spec::Mode,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SpellCorrectionSpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.mode) {
                state.serialize_entry("mode", &self.mode)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SpellCorrectionSpec {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SpellCorrectionSpec");
            debug_struct.field("mode", &self.mode);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [SpellCorrectionSpec].
    pub mod spell_correction_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Enum describing under which mode spell correction should occur.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Mode {
            /// Unspecified spell correction mode. In this case, server behavior
            /// defaults to
            /// [Mode.AUTO][google.cloud.retail.v2.SearchRequest.SpellCorrectionSpec.Mode.AUTO].
            ///
            /// [google.cloud.retail.v2.SearchRequest.SpellCorrectionSpec.Mode.AUTO]: crate::model::search_request::spell_correction_spec::Mode::Auto
            Unspecified,
            /// Google Retail Search will try to find a spell suggestion if there
            /// is any and put in the
            /// [SearchResponse.corrected_query][google.cloud.retail.v2.SearchResponse.corrected_query].
            /// The spell suggestion will not be used as the search query.
            ///
            /// [google.cloud.retail.v2.SearchResponse.corrected_query]: crate::model::SearchResponse::corrected_query
            SuggestionOnly,
            /// Automatic spell correction built by Google Retail Search. Search will
            /// be based on the corrected query if found.
            Auto,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Mode::value] or
            /// [Mode::name].
            UnknownValue(mode::UnknownValue),
        }

        #[doc(hidden)]
        pub mod mode {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Mode {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::SuggestionOnly => std::option::Option::Some(1),
                    Self::Auto => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                    Self::SuggestionOnly => std::option::Option::Some("SUGGESTION_ONLY"),
                    Self::Auto => std::option::Option::Some("AUTO"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Mode {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Mode {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Mode {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::SuggestionOnly,
                    2 => Self::Auto,
                    _ => Self::UnknownValue(mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Mode {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "MODE_UNSPECIFIED" => Self::Unspecified,
                    "SUGGESTION_ONLY" => Self::SuggestionOnly,
                    "AUTO" => Self::Auto,
                    _ => Self::UnknownValue(mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Mode {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::SuggestionOnly => serializer.serialize_i32(1),
                    Self::Auto => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Mode {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                    ".google.cloud.retail.v2.SearchRequest.SpellCorrectionSpec.Mode",
                ))
            }
        }
    }

    /// This field specifies all conversational related parameters addition to
    /// traditional retail search.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConversationalSearchSpec {
        /// This field specifies whether the customer would like to do conversational
        /// search. If this field is set to true, conversational related extra
        /// information will be returned from server side, including follow-up
        /// question, answer options, etc.
        pub followup_conversation_requested: bool,

        /// This field specifies the conversation id, which maintains the state of
        /// the conversation between client side and server side. Use the value from
        /// the previous [ConversationalSearchResult.conversation_id][]. For the
        /// initial request, this should be empty.
        pub conversation_id: std::string::String,

        /// This field specifies the current user answer during the conversational
        /// search. This can be either user selected from suggested answers or user
        /// input plain text.
        pub user_answer: std::option::Option<
            crate::model::search_request::conversational_search_spec::UserAnswer,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConversationalSearchSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [followup_conversation_requested][crate::model::search_request::ConversationalSearchSpec::followup_conversation_requested].
        pub fn set_followup_conversation_requested<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.followup_conversation_requested = v.into();
            self
        }

        /// Sets the value of [conversation_id][crate::model::search_request::ConversationalSearchSpec::conversation_id].
        pub fn set_conversation_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.conversation_id = v.into();
            self
        }

        /// Sets the value of [user_answer][crate::model::search_request::ConversationalSearchSpec::user_answer].
        pub fn set_user_answer<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::search_request::conversational_search_spec::UserAnswer,
                >,
        {
            self.user_answer = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [user_answer][crate::model::search_request::ConversationalSearchSpec::user_answer].
        pub fn set_or_clear_user_answer<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::search_request::conversational_search_spec::UserAnswer,
                >,
        {
            self.user_answer = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ConversationalSearchSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.SearchRequest.ConversationalSearchSpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ConversationalSearchSpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __followup_conversation_requested,
                __conversation_id,
                __user_answer,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ConversationalSearchSpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "followupConversationRequested" => {
                                    Ok(__FieldTag::__followup_conversation_requested)
                                }
                                "followup_conversation_requested" => {
                                    Ok(__FieldTag::__followup_conversation_requested)
                                }
                                "conversationId" => Ok(__FieldTag::__conversation_id),
                                "conversation_id" => Ok(__FieldTag::__conversation_id),
                                "userAnswer" => Ok(__FieldTag::__user_answer),
                                "user_answer" => Ok(__FieldTag::__user_answer),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ConversationalSearchSpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ConversationalSearchSpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__followup_conversation_requested => {
                                if !fields.insert(__FieldTag::__followup_conversation_requested) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for followup_conversation_requested",
                                    ));
                                }
                                result.followup_conversation_requested = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__conversation_id => {
                                if !fields.insert(__FieldTag::__conversation_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for conversation_id",
                                    ));
                                }
                                result.conversation_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__user_answer => {
                                if !fields.insert(__FieldTag::__user_answer) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for user_answer",
                                    ));
                                }
                                result.user_answer = map.next_value::<std::option::Option<crate::model::search_request::conversational_search_spec::UserAnswer>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ConversationalSearchSpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.followup_conversation_requested) {
                state.serialize_entry(
                    "followupConversationRequested",
                    &self.followup_conversation_requested,
                )?;
            }
            if !self.conversation_id.is_empty() {
                state.serialize_entry("conversationId", &self.conversation_id)?;
            }
            if self.user_answer.is_some() {
                state.serialize_entry("userAnswer", &self.user_answer)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ConversationalSearchSpec {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ConversationalSearchSpec");
            debug_struct.field(
                "followup_conversation_requested",
                &self.followup_conversation_requested,
            );
            debug_struct.field("conversation_id", &self.conversation_id);
            debug_struct.field("user_answer", &self.user_answer);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [ConversationalSearchSpec].
    pub mod conversational_search_spec {
        #[allow(unused_imports)]
        use super::*;

        /// This field specifies the current user answer during the conversational
        /// search. This can be either user selected from suggested answers or user
        /// input plain text.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct UserAnswer {
            /// This field specifies the type of user answer.
            pub r#type: std::option::Option<
                crate::model::search_request::conversational_search_spec::user_answer::Type,
            >,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl UserAnswer {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [r#type][crate::model::search_request::conversational_search_spec::UserAnswer::type].
            ///
            /// Note that all the setters affecting `r#type` are mutually
            /// exclusive.
            pub fn set_type<T: std::convert::Into<std::option::Option<crate::model::search_request::conversational_search_spec::user_answer::Type>>>(mut self, v: T) -> Self
            {
                self.r#type = v.into();
                self
            }

            /// The value of [r#type][crate::model::search_request::conversational_search_spec::UserAnswer::r#type]
            /// if it holds a `TextAnswer`, `None` if the field is not set or
            /// holds a different branch.
            pub fn text_answer(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.r#type.as_ref().and_then(|v| match v {
                    crate::model::search_request::conversational_search_spec::user_answer::Type::TextAnswer(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [r#type][crate::model::search_request::conversational_search_spec::UserAnswer::r#type]
            /// to hold a `TextAnswer`.
            ///
            /// Note that all the setters affecting `r#type` are
            /// mutually exclusive.
            pub fn set_text_answer<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = std::option::Option::Some(
                    crate::model::search_request::conversational_search_spec::user_answer::Type::TextAnswer(
                        v.into()
                    )
                );
                self
            }

            /// The value of [r#type][crate::model::search_request::conversational_search_spec::UserAnswer::r#type]
            /// if it holds a `SelectedAnswer`, `None` if the field is not set or
            /// holds a different branch.
            pub fn selected_answer(&self) -> std::option::Option<&std::boxed::Box<crate::model::search_request::conversational_search_spec::user_answer::SelectedAnswer>>{
                #[allow(unreachable_patterns)]
                self.r#type.as_ref().and_then(|v| match v {
                    crate::model::search_request::conversational_search_spec::user_answer::Type::SelectedAnswer(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [r#type][crate::model::search_request::conversational_search_spec::UserAnswer::r#type]
            /// to hold a `SelectedAnswer`.
            ///
            /// Note that all the setters affecting `r#type` are
            /// mutually exclusive.
            pub fn set_selected_answer<T: std::convert::Into<std::boxed::Box<crate::model::search_request::conversational_search_spec::user_answer::SelectedAnswer>>>(mut self, v: T) -> Self{
                self.r#type = std::option::Option::Some(
                    crate::model::search_request::conversational_search_spec::user_answer::Type::SelectedAnswer(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for UserAnswer {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.retail.v2.SearchRequest.ConversationalSearchSpec.UserAnswer"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for UserAnswer {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __text_answer,
                    __selected_answer,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for UserAnswer")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "textAnswer" => Ok(__FieldTag::__text_answer),
                                    "text_answer" => Ok(__FieldTag::__text_answer),
                                    "selectedAnswer" => Ok(__FieldTag::__selected_answer),
                                    "selected_answer" => Ok(__FieldTag::__selected_answer),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = UserAnswer;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct UserAnswer")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__text_answer => {
                                    if !fields.insert(__FieldTag::__text_answer) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for text_answer",
                                            ),
                                        );
                                    }
                                    if result.r#type.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `r#type`, a oneof with full ID .google.cloud.retail.v2.SearchRequest.ConversationalSearchSpec.UserAnswer.text_answer, latest field was textAnswer",
                                            ),
                                        );
                                    }
                                    result.r#type = std::option::Option::Some(
                                        crate::model::search_request::conversational_search_spec::user_answer::Type::TextAnswer(
                                            map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__selected_answer => {
                                    if !fields.insert(__FieldTag::__selected_answer) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for selected_answer",
                                            ),
                                        );
                                    }
                                    if result.r#type.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `r#type`, a oneof with full ID .google.cloud.retail.v2.SearchRequest.ConversationalSearchSpec.UserAnswer.selected_answer, latest field was selectedAnswer",
                                            ),
                                        );
                                    }
                                    result.r#type = std::option::Option::Some(
                                        crate::model::search_request::conversational_search_spec::user_answer::Type::SelectedAnswer(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::search_request::conversational_search_spec::user_answer::SelectedAnswer>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for UserAnswer {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.text_answer() {
                    state.serialize_entry("textAnswer", value)?;
                }
                if let Some(value) = self.selected_answer() {
                    state.serialize_entry("selectedAnswer", value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for UserAnswer {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("UserAnswer");
                debug_struct.field("r#type", &self.r#type);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [UserAnswer].
        pub mod user_answer {
            #[allow(unused_imports)]
            use super::*;

            /// This field specifies the selected answers during the conversational
            /// search.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct SelectedAnswer {
                /// This field is deprecated and should not be set.
                #[deprecated]
                pub product_attribute_values: std::vec::Vec<crate::model::ProductAttributeValue>,

                /// This field specifies the selected answer which is a attribute
                /// key-value.
                pub product_attribute_value:
                    std::option::Option<crate::model::ProductAttributeValue>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl SelectedAnswer {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [product_attribute_values][crate::model::search_request::conversational_search_spec::user_answer::SelectedAnswer::product_attribute_values].
                #[deprecated]
                pub fn set_product_attribute_values<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<crate::model::ProductAttributeValue>,
                {
                    use std::iter::Iterator;
                    self.product_attribute_values = v.into_iter().map(|i| i.into()).collect();
                    self
                }

                /// Sets the value of [product_attribute_value][crate::model::search_request::conversational_search_spec::user_answer::SelectedAnswer::product_attribute_value].
                pub fn set_product_attribute_value<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::ProductAttributeValue>,
                {
                    self.product_attribute_value = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [product_attribute_value][crate::model::search_request::conversational_search_spec::user_answer::SelectedAnswer::product_attribute_value].
                pub fn set_or_clear_product_attribute_value<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<crate::model::ProductAttributeValue>,
                {
                    self.product_attribute_value = v.map(|x| x.into());
                    self
                }
            }

            impl wkt::message::Message for SelectedAnswer {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.retail.v2.SearchRequest.ConversationalSearchSpec.UserAnswer.SelectedAnswer"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for SelectedAnswer {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __product_attribute_values,
                        __product_attribute_value,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for SelectedAnswer")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "productAttributeValues" => {
                                            Ok(__FieldTag::__product_attribute_values)
                                        }
                                        "product_attribute_values" => {
                                            Ok(__FieldTag::__product_attribute_values)
                                        }
                                        "productAttributeValue" => {
                                            Ok(__FieldTag::__product_attribute_value)
                                        }
                                        "product_attribute_value" => {
                                            Ok(__FieldTag::__product_attribute_value)
                                        }
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = SelectedAnswer;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct SelectedAnswer")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__product_attribute_values => {
                                        if !fields.insert(__FieldTag::__product_attribute_values) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for product_attribute_values",
                                                ),
                                            );
                                        }
                                        result.product_attribute_values = map
                                            .next_value::<std::option::Option<
                                                std::vec::Vec<crate::model::ProductAttributeValue>,
                                            >>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__product_attribute_value => {
                                        if !fields.insert(__FieldTag::__product_attribute_value) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for product_attribute_value",
                                                ),
                                            );
                                        }
                                        result.product_attribute_value = map
                                            .next_value::<std::option::Option<
                                                crate::model::ProductAttributeValue,
                                            >>()?;
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for SelectedAnswer {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.product_attribute_values.is_empty() {
                        state.serialize_entry(
                            "productAttributeValues",
                            &self.product_attribute_values,
                        )?;
                    }
                    if self.product_attribute_value.is_some() {
                        state.serialize_entry(
                            "productAttributeValue",
                            &self.product_attribute_value,
                        )?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for SelectedAnswer {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("SelectedAnswer");
                    debug_struct.field("product_attribute_values", &self.product_attribute_values);
                    debug_struct.field("product_attribute_value", &self.product_attribute_value);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// This field specifies the type of user answer.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Type {
                /// This field specifies the incremental input text from the user during
                /// the conversational search.
                TextAnswer(std::string::String),
                /// This field specifies the selected attributes during the
                /// conversational search. This should be a subset of
                /// [ConversationalSearchResult.suggested_answers][].
                SelectedAnswer(std::boxed::Box<crate::model::search_request::conversational_search_spec::user_answer::SelectedAnswer>),
            }
        }
    }

    /// This field specifies tile navigation related parameters.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TileNavigationSpec {
        /// This field specifies whether the customer would like to request tile
        /// navigation.
        pub tile_navigation_requested: bool,

        /// This optional field specifies the tiles which are already clicked in
        /// client side. While the feature works without this field set, particularly
        /// for an initial query, it is highly recommended to set this field because
        /// it can improve the quality of the search response and removes possible
        /// duplicate tiles.
        ///
        /// NOTE: This field is not being used for filtering search
        /// products. Client side should also put all the applied tiles in
        /// [SearchRequest.filter][google.cloud.retail.v2.SearchRequest.filter].
        ///
        /// [google.cloud.retail.v2.SearchRequest.filter]: crate::model::SearchRequest::filter
        pub applied_tiles: std::vec::Vec<crate::model::Tile>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TileNavigationSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [tile_navigation_requested][crate::model::search_request::TileNavigationSpec::tile_navigation_requested].
        pub fn set_tile_navigation_requested<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.tile_navigation_requested = v.into();
            self
        }

        /// Sets the value of [applied_tiles][crate::model::search_request::TileNavigationSpec::applied_tiles].
        pub fn set_applied_tiles<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Tile>,
        {
            use std::iter::Iterator;
            self.applied_tiles = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for TileNavigationSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.SearchRequest.TileNavigationSpec"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TileNavigationSpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __tile_navigation_requested,
                __applied_tiles,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TileNavigationSpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "tileNavigationRequested" => {
                                    Ok(__FieldTag::__tile_navigation_requested)
                                }
                                "tile_navigation_requested" => {
                                    Ok(__FieldTag::__tile_navigation_requested)
                                }
                                "appliedTiles" => Ok(__FieldTag::__applied_tiles),
                                "applied_tiles" => Ok(__FieldTag::__applied_tiles),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TileNavigationSpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TileNavigationSpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__tile_navigation_requested => {
                                if !fields.insert(__FieldTag::__tile_navigation_requested) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tile_navigation_requested",
                                    ));
                                }
                                result.tile_navigation_requested = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__applied_tiles => {
                                if !fields.insert(__FieldTag::__applied_tiles) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for applied_tiles",
                                    ));
                                }
                                result.applied_tiles = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Tile>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TileNavigationSpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.tile_navigation_requested) {
                state
                    .serialize_entry("tileNavigationRequested", &self.tile_navigation_requested)?;
            }
            if !self.applied_tiles.is_empty() {
                state.serialize_entry("appliedTiles", &self.applied_tiles)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for TileNavigationSpec {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("TileNavigationSpec");
            debug_struct.field("tile_navigation_requested", &self.tile_navigation_requested);
            debug_struct.field("applied_tiles", &self.applied_tiles);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The search mode of each search request.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SearchMode {
        /// Default value. In this case both product search and faceted search will
        /// be performed. Both
        /// [SearchResponse.SearchResult][google.cloud.retail.v2.SearchResponse.SearchResult]
        /// and [SearchResponse.Facet][google.cloud.retail.v2.SearchResponse.Facet]
        /// will be returned.
        ///
        /// [google.cloud.retail.v2.SearchResponse.Facet]: crate::model::search_response::Facet
        /// [google.cloud.retail.v2.SearchResponse.SearchResult]: crate::model::search_response::SearchResult
        Unspecified,
        /// Only product search will be performed. The faceted search will be
        /// disabled.
        ///
        /// Only
        /// [SearchResponse.SearchResult][google.cloud.retail.v2.SearchResponse.SearchResult]
        /// will be returned.
        /// [SearchResponse.Facet][google.cloud.retail.v2.SearchResponse.Facet] will
        /// not be returned, even if
        /// [SearchRequest.facet_specs][google.cloud.retail.v2.SearchRequest.facet_specs]
        /// or
        /// [SearchRequest.dynamic_facet_spec][google.cloud.retail.v2.SearchRequest.dynamic_facet_spec]
        /// is set.
        ///
        /// [google.cloud.retail.v2.SearchRequest.dynamic_facet_spec]: crate::model::SearchRequest::dynamic_facet_spec
        /// [google.cloud.retail.v2.SearchRequest.facet_specs]: crate::model::SearchRequest::facet_specs
        /// [google.cloud.retail.v2.SearchResponse.Facet]: crate::model::search_response::Facet
        /// [google.cloud.retail.v2.SearchResponse.SearchResult]: crate::model::search_response::SearchResult
        ProductSearchOnly,
        /// Only faceted search will be performed. The product search will be
        /// disabled.
        ///
        /// When in this mode, one or both of
        /// [SearchRequest.facet_specs][google.cloud.retail.v2.SearchRequest.facet_specs]
        /// and
        /// [SearchRequest.dynamic_facet_spec][google.cloud.retail.v2.SearchRequest.dynamic_facet_spec]
        /// should be set. Otherwise, an INVALID_ARGUMENT error is returned. Only
        /// [SearchResponse.Facet][google.cloud.retail.v2.SearchResponse.Facet] will
        /// be returned.
        /// [SearchResponse.SearchResult][google.cloud.retail.v2.SearchResponse.SearchResult]
        /// will not be returned.
        ///
        /// [google.cloud.retail.v2.SearchRequest.dynamic_facet_spec]: crate::model::SearchRequest::dynamic_facet_spec
        /// [google.cloud.retail.v2.SearchRequest.facet_specs]: crate::model::SearchRequest::facet_specs
        /// [google.cloud.retail.v2.SearchResponse.Facet]: crate::model::search_response::Facet
        /// [google.cloud.retail.v2.SearchResponse.SearchResult]: crate::model::search_response::SearchResult
        FacetedSearchOnly,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SearchMode::value] or
        /// [SearchMode::name].
        UnknownValue(search_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod search_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SearchMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ProductSearchOnly => std::option::Option::Some(1),
                Self::FacetedSearchOnly => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SEARCH_MODE_UNSPECIFIED"),
                Self::ProductSearchOnly => std::option::Option::Some("PRODUCT_SEARCH_ONLY"),
                Self::FacetedSearchOnly => std::option::Option::Some("FACETED_SEARCH_ONLY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SearchMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SearchMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SearchMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ProductSearchOnly,
                2 => Self::FacetedSearchOnly,
                _ => Self::UnknownValue(search_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SearchMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SEARCH_MODE_UNSPECIFIED" => Self::Unspecified,
                "PRODUCT_SEARCH_ONLY" => Self::ProductSearchOnly,
                "FACETED_SEARCH_ONLY" => Self::FacetedSearchOnly,
                _ => Self::UnknownValue(search_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SearchMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ProductSearchOnly => serializer.serialize_i32(1),
                Self::FacetedSearchOnly => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SearchMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SearchMode>::new(
                ".google.cloud.retail.v2.SearchRequest.SearchMode",
            ))
        }
    }
}

/// Response message for
/// [SearchService.Search][google.cloud.retail.v2.SearchService.Search] method.
///
/// [google.cloud.retail.v2.SearchService.Search]: crate::client::SearchService::search
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchResponse {
    /// A list of matched items. The order represents the ranking.
    pub results: std::vec::Vec<crate::model::search_response::SearchResult>,

    /// Results of facets requested by user.
    pub facets: std::vec::Vec<crate::model::search_response::Facet>,

    /// The estimated total count of matched items irrespective of pagination. The
    /// count of [results][google.cloud.retail.v2.SearchResponse.results] returned
    /// by pagination may be less than the
    /// [total_size][google.cloud.retail.v2.SearchResponse.total_size] that
    /// matches.
    ///
    /// [google.cloud.retail.v2.SearchResponse.results]: crate::model::SearchResponse::results
    /// [google.cloud.retail.v2.SearchResponse.total_size]: crate::model::SearchResponse::total_size
    pub total_size: i32,

    /// Contains the spell corrected query, if found. If the spell correction type
    /// is AUTOMATIC, then the search results are based on corrected_query.
    /// Otherwise the original query is used for search.
    pub corrected_query: std::string::String,

    /// A unique search token. This should be included in the
    /// [UserEvent][google.cloud.retail.v2.UserEvent] logs resulting from this
    /// search, which enables accurate attribution of search model performance.
    ///
    /// [google.cloud.retail.v2.UserEvent]: crate::model::UserEvent
    pub attribution_token: std::string::String,

    /// A token that can be sent as
    /// [SearchRequest.page_token][google.cloud.retail.v2.SearchRequest.page_token]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    ///
    /// [google.cloud.retail.v2.SearchRequest.page_token]: crate::model::SearchRequest::page_token
    pub next_page_token: std::string::String,

    /// Query expansion information for the returned results.
    pub query_expansion_info:
        std::option::Option<crate::model::search_response::QueryExpansionInfo>,

    /// The URI of a customer-defined redirect page. If redirect action is
    /// triggered, no search is performed, and only
    /// [redirect_uri][google.cloud.retail.v2.SearchResponse.redirect_uri] and
    /// [attribution_token][google.cloud.retail.v2.SearchResponse.attribution_token]
    /// are set in the response.
    ///
    /// [google.cloud.retail.v2.SearchResponse.attribution_token]: crate::model::SearchResponse::attribution_token
    /// [google.cloud.retail.v2.SearchResponse.redirect_uri]: crate::model::SearchResponse::redirect_uri
    pub redirect_uri: std::string::String,

    /// The fully qualified resource name of applied
    /// [controls](https://cloud.google.com/retail/docs/serving-control-rules).
    pub applied_controls: std::vec::Vec<std::string::String>,

    /// Metadata for pin controls which were applicable to the request.
    /// This contains two map fields, one for all matched pins and one for pins
    /// which were matched but not applied.
    ///
    /// The two maps are keyed by pin position, and the values are the product ids
    /// which were matched to that pin.
    pub pin_control_metadata: std::option::Option<crate::model::PinControlMetadata>,

    /// The invalid
    /// [SearchRequest.BoostSpec.condition_boost_specs][google.cloud.retail.v2.SearchRequest.BoostSpec.condition_boost_specs]
    /// that are not applied during serving.
    ///
    /// [google.cloud.retail.v2.SearchRequest.BoostSpec.condition_boost_specs]: crate::model::search_request::BoostSpec::condition_boost_specs
    pub invalid_condition_boost_specs:
        std::vec::Vec<crate::model::search_request::boost_spec::ConditionBoostSpec>,

    /// Metadata related to A/B testing experiment associated with this
    /// response. Only exists when an experiment is triggered.
    pub experiment_info: std::vec::Vec<crate::model::ExperimentInfo>,

    /// This field specifies all related information that is needed on client
    /// side for UI rendering of conversational retail search.
    pub conversational_search_result:
        std::option::Option<crate::model::search_response::ConversationalSearchResult>,

    /// This field specifies all related information for tile navigation that will
    /// be used in client side.
    pub tile_navigation_result:
        std::option::Option<crate::model::search_response::TileNavigationResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [results][crate::model::SearchResponse::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::search_response::SearchResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [facets][crate::model::SearchResponse::facets].
    pub fn set_facets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::search_response::Facet>,
    {
        use std::iter::Iterator;
        self.facets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [total_size][crate::model::SearchResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }

    /// Sets the value of [corrected_query][crate::model::SearchResponse::corrected_query].
    pub fn set_corrected_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.corrected_query = v.into();
        self
    }

    /// Sets the value of [attribution_token][crate::model::SearchResponse::attribution_token].
    pub fn set_attribution_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.attribution_token = v.into();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [query_expansion_info][crate::model::SearchResponse::query_expansion_info].
    pub fn set_query_expansion_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_response::QueryExpansionInfo>,
    {
        self.query_expansion_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_expansion_info][crate::model::SearchResponse::query_expansion_info].
    pub fn set_or_clear_query_expansion_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_response::QueryExpansionInfo>,
    {
        self.query_expansion_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [redirect_uri][crate::model::SearchResponse::redirect_uri].
    pub fn set_redirect_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.redirect_uri = v.into();
        self
    }

    /// Sets the value of [applied_controls][crate::model::SearchResponse::applied_controls].
    pub fn set_applied_controls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.applied_controls = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pin_control_metadata][crate::model::SearchResponse::pin_control_metadata].
    pub fn set_pin_control_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PinControlMetadata>,
    {
        self.pin_control_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pin_control_metadata][crate::model::SearchResponse::pin_control_metadata].
    pub fn set_or_clear_pin_control_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PinControlMetadata>,
    {
        self.pin_control_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [invalid_condition_boost_specs][crate::model::SearchResponse::invalid_condition_boost_specs].
    pub fn set_invalid_condition_boost_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::search_request::boost_spec::ConditionBoostSpec>,
    {
        use std::iter::Iterator;
        self.invalid_condition_boost_specs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [experiment_info][crate::model::SearchResponse::experiment_info].
    pub fn set_experiment_info<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExperimentInfo>,
    {
        use std::iter::Iterator;
        self.experiment_info = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [conversational_search_result][crate::model::SearchResponse::conversational_search_result].
    pub fn set_conversational_search_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_response::ConversationalSearchResult>,
    {
        self.conversational_search_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversational_search_result][crate::model::SearchResponse::conversational_search_result].
    pub fn set_or_clear_conversational_search_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_response::ConversationalSearchResult>,
    {
        self.conversational_search_result = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tile_navigation_result][crate::model::SearchResponse::tile_navigation_result].
    pub fn set_tile_navigation_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_response::TileNavigationResult>,
    {
        self.tile_navigation_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tile_navigation_result][crate::model::SearchResponse::tile_navigation_result].
    pub fn set_or_clear_tile_navigation_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_response::TileNavigationResult>,
    {
        self.tile_navigation_result = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SearchResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.SearchResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchResponse {
    type PageItem = crate::model::search_response::Facet;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.facets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __results,
            __facets,
            __total_size,
            __corrected_query,
            __attribution_token,
            __next_page_token,
            __query_expansion_info,
            __redirect_uri,
            __applied_controls,
            __pin_control_metadata,
            __invalid_condition_boost_specs,
            __experiment_info,
            __conversational_search_result,
            __tile_navigation_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "results" => Ok(__FieldTag::__results),
                            "facets" => Ok(__FieldTag::__facets),
                            "totalSize" => Ok(__FieldTag::__total_size),
                            "total_size" => Ok(__FieldTag::__total_size),
                            "correctedQuery" => Ok(__FieldTag::__corrected_query),
                            "corrected_query" => Ok(__FieldTag::__corrected_query),
                            "attributionToken" => Ok(__FieldTag::__attribution_token),
                            "attribution_token" => Ok(__FieldTag::__attribution_token),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "queryExpansionInfo" => Ok(__FieldTag::__query_expansion_info),
                            "query_expansion_info" => Ok(__FieldTag::__query_expansion_info),
                            "redirectUri" => Ok(__FieldTag::__redirect_uri),
                            "redirect_uri" => Ok(__FieldTag::__redirect_uri),
                            "appliedControls" => Ok(__FieldTag::__applied_controls),
                            "applied_controls" => Ok(__FieldTag::__applied_controls),
                            "pinControlMetadata" => Ok(__FieldTag::__pin_control_metadata),
                            "pin_control_metadata" => Ok(__FieldTag::__pin_control_metadata),
                            "invalidConditionBoostSpecs" => {
                                Ok(__FieldTag::__invalid_condition_boost_specs)
                            }
                            "invalid_condition_boost_specs" => {
                                Ok(__FieldTag::__invalid_condition_boost_specs)
                            }
                            "experimentInfo" => Ok(__FieldTag::__experiment_info),
                            "experiment_info" => Ok(__FieldTag::__experiment_info),
                            "conversationalSearchResult" => {
                                Ok(__FieldTag::__conversational_search_result)
                            }
                            "conversational_search_result" => {
                                Ok(__FieldTag::__conversational_search_result)
                            }
                            "tileNavigationResult" => Ok(__FieldTag::__tile_navigation_result),
                            "tile_navigation_result" => Ok(__FieldTag::__tile_navigation_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__results => {
                            if !fields.insert(__FieldTag::__results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for results",
                                ));
                            }
                            result.results = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::search_response::SearchResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__facets => {
                            if !fields.insert(__FieldTag::__facets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for facets",
                                ));
                            }
                            result.facets = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::search_response::Facet>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_size => {
                            if !fields.insert(__FieldTag::__total_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__corrected_query => {
                            if !fields.insert(__FieldTag::__corrected_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for corrected_query",
                                ));
                            }
                            result.corrected_query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attribution_token => {
                            if !fields.insert(__FieldTag::__attribution_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attribution_token",
                                ));
                            }
                            result.attribution_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_expansion_info => {
                            if !fields.insert(__FieldTag::__query_expansion_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_expansion_info",
                                ));
                            }
                            result.query_expansion_info = map.next_value::<std::option::Option<
                                crate::model::search_response::QueryExpansionInfo,
                            >>()?;
                        }
                        __FieldTag::__redirect_uri => {
                            if !fields.insert(__FieldTag::__redirect_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redirect_uri",
                                ));
                            }
                            result.redirect_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__applied_controls => {
                            if !fields.insert(__FieldTag::__applied_controls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for applied_controls",
                                ));
                            }
                            result.applied_controls = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__pin_control_metadata => {
                            if !fields.insert(__FieldTag::__pin_control_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pin_control_metadata",
                                ));
                            }
                            result.pin_control_metadata = map.next_value::<std::option::Option<crate::model::PinControlMetadata>>()?
                                ;
                        }
                        __FieldTag::__invalid_condition_boost_specs => {
                            if !fields.insert(__FieldTag::__invalid_condition_boost_specs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invalid_condition_boost_specs",
                                ));
                            }
                            result.invalid_condition_boost_specs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::search_request::boost_spec::ConditionBoostSpec>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__experiment_info => {
                            if !fields.insert(__FieldTag::__experiment_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for experiment_info",
                                ));
                            }
                            result.experiment_info =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ExperimentInfo>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conversational_search_result => {
                            if !fields.insert(__FieldTag::__conversational_search_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversational_search_result",
                                ));
                            }
                            result.conversational_search_result = map
                                .next_value::<std::option::Option<
                                    crate::model::search_response::ConversationalSearchResult,
                                >>()?;
                        }
                        __FieldTag::__tile_navigation_result => {
                            if !fields.insert(__FieldTag::__tile_navigation_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tile_navigation_result",
                                ));
                            }
                            result.tile_navigation_result = map.next_value::<std::option::Option<
                                crate::model::search_response::TileNavigationResult,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.results.is_empty() {
            state.serialize_entry("results", &self.results)?;
        }
        if !self.facets.is_empty() {
            state.serialize_entry("facets", &self.facets)?;
        }
        if !wkt::internal::is_default(&self.total_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalSize", &__With(&self.total_size))?;
        }
        if !self.corrected_query.is_empty() {
            state.serialize_entry("correctedQuery", &self.corrected_query)?;
        }
        if !self.attribution_token.is_empty() {
            state.serialize_entry("attributionToken", &self.attribution_token)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.query_expansion_info.is_some() {
            state.serialize_entry("queryExpansionInfo", &self.query_expansion_info)?;
        }
        if !self.redirect_uri.is_empty() {
            state.serialize_entry("redirectUri", &self.redirect_uri)?;
        }
        if !self.applied_controls.is_empty() {
            state.serialize_entry("appliedControls", &self.applied_controls)?;
        }
        if self.pin_control_metadata.is_some() {
            state.serialize_entry("pinControlMetadata", &self.pin_control_metadata)?;
        }
        if !self.invalid_condition_boost_specs.is_empty() {
            state.serialize_entry(
                "invalidConditionBoostSpecs",
                &self.invalid_condition_boost_specs,
            )?;
        }
        if !self.experiment_info.is_empty() {
            state.serialize_entry("experimentInfo", &self.experiment_info)?;
        }
        if self.conversational_search_result.is_some() {
            state.serialize_entry(
                "conversationalSearchResult",
                &self.conversational_search_result,
            )?;
        }
        if self.tile_navigation_result.is_some() {
            state.serialize_entry("tileNavigationResult", &self.tile_navigation_result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SearchResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchResponse");
        debug_struct.field("results", &self.results);
        debug_struct.field("facets", &self.facets);
        debug_struct.field("total_size", &self.total_size);
        debug_struct.field("corrected_query", &self.corrected_query);
        debug_struct.field("attribution_token", &self.attribution_token);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("query_expansion_info", &self.query_expansion_info);
        debug_struct.field("redirect_uri", &self.redirect_uri);
        debug_struct.field("applied_controls", &self.applied_controls);
        debug_struct.field("pin_control_metadata", &self.pin_control_metadata);
        debug_struct.field(
            "invalid_condition_boost_specs",
            &self.invalid_condition_boost_specs,
        );
        debug_struct.field("experiment_info", &self.experiment_info);
        debug_struct.field(
            "conversational_search_result",
            &self.conversational_search_result,
        );
        debug_struct.field("tile_navigation_result", &self.tile_navigation_result);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SearchResponse].
pub mod search_response {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the search results.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SearchResult {
        /// [Product.id][google.cloud.retail.v2.Product.id] of the searched
        /// [Product][google.cloud.retail.v2.Product].
        ///
        /// [google.cloud.retail.v2.Product]: crate::model::Product
        /// [google.cloud.retail.v2.Product.id]: crate::model::Product::id
        pub id: std::string::String,

        /// The product data snippet in the search response. Only
        /// [Product.name][google.cloud.retail.v2.Product.name] is guaranteed to be
        /// populated.
        ///
        /// [Product.variants][google.cloud.retail.v2.Product.variants] contains the
        /// product variants that match the search query. If there are multiple
        /// product variants matching the query, top 5 most relevant product variants
        /// are returned and ordered by relevancy.
        ///
        /// If relevancy can be deternmined, use
        /// [matching_variant_fields][google.cloud.retail.v2.SearchResponse.SearchResult.matching_variant_fields]
        /// to look up matched product variants fields. If relevancy cannot be
        /// determined, e.g. when searching "shoe" all products in a shoe product can
        /// be a match, 5 product variants are returned but order is meaningless.
        ///
        /// [google.cloud.retail.v2.Product.name]: crate::model::Product::name
        /// [google.cloud.retail.v2.Product.variants]: crate::model::Product::variants
        /// [google.cloud.retail.v2.SearchResponse.SearchResult.matching_variant_fields]: crate::model::search_response::SearchResult::matching_variant_fields
        pub product: std::option::Option<crate::model::Product>,

        /// The count of matched
        /// [variant][google.cloud.retail.v2.Product.Type.VARIANT]
        /// [Product][google.cloud.retail.v2.Product]s.
        ///
        /// [google.cloud.retail.v2.Product]: crate::model::Product
        /// [google.cloud.retail.v2.Product.Type.VARIANT]: crate::model::product::Type::Variant
        pub matching_variant_count: i32,

        /// If a [variant][google.cloud.retail.v2.Product.Type.VARIANT]
        /// [Product][google.cloud.retail.v2.Product] matches the search query, this
        /// map indicates which [Product][google.cloud.retail.v2.Product] fields are
        /// matched. The key is the
        /// [Product.name][google.cloud.retail.v2.Product.name], the value is a field
        /// mask of the matched [Product][google.cloud.retail.v2.Product] fields. If
        /// matched attributes cannot be determined, this map will be empty.
        ///
        /// For example, a key "sku1" with field mask
        /// "products.color_info" indicates there is a match between
        /// "sku1" [ColorInfo][google.cloud.retail.v2.ColorInfo] and the query.
        ///
        /// [google.cloud.retail.v2.ColorInfo]: crate::model::ColorInfo
        /// [google.cloud.retail.v2.Product]: crate::model::Product
        /// [google.cloud.retail.v2.Product.Type.VARIANT]: crate::model::product::Type::Variant
        /// [google.cloud.retail.v2.Product.name]: crate::model::Product::name
        pub matching_variant_fields: std::collections::HashMap<std::string::String, wkt::FieldMask>,

        /// The rollup matching
        /// [variant][google.cloud.retail.v2.Product.Type.VARIANT]
        /// [Product][google.cloud.retail.v2.Product] attributes. The key is one of
        /// the
        /// [SearchRequest.variant_rollup_keys][google.cloud.retail.v2.SearchRequest.variant_rollup_keys].
        /// The values are the merged and de-duplicated
        /// [Product][google.cloud.retail.v2.Product] attributes. Notice that the
        /// rollup values are respect filter. For example, when filtering by
        /// "colorFamilies:ANY(\"red\")" and rollup "colorFamilies", only "red" is
        /// returned.
        ///
        /// For textual and numerical attributes, the rollup values is a list of
        /// string or double values with type
        /// [google.protobuf.ListValue][google.protobuf.ListValue]. For example, if
        /// there are two variants with colors "red" and "blue", the rollup values
        /// are
        ///
        /// ```norust
        /// { key: "colorFamilies"
        ///   value {
        ///     list_value {
        ///       values { string_value: "red" }
        ///       values { string_value: "blue" }
        ///      }
        ///   }
        /// }
        /// ```
        ///
        /// For [FulfillmentInfo][google.cloud.retail.v2.FulfillmentInfo], the rollup
        /// values is a double value with type
        /// [google.protobuf.Value][google.protobuf.Value]. For example,
        /// `{key: "pickupInStore.store1" value { number_value: 10 }}` means a there
        /// are 10 variants in this product are available in the store "store1".
        ///
        /// [google.cloud.retail.v2.FulfillmentInfo]: crate::model::FulfillmentInfo
        /// [google.cloud.retail.v2.Product]: crate::model::Product
        /// [google.cloud.retail.v2.Product.Type.VARIANT]: crate::model::product::Type::Variant
        /// [google.cloud.retail.v2.SearchRequest.variant_rollup_keys]: crate::model::SearchRequest::variant_rollup_keys
        /// [google.protobuf.ListValue]: wkt::ListValue
        /// [google.protobuf.Value]: wkt::Value
        pub variant_rollup_values: std::collections::HashMap<std::string::String, wkt::Value>,

        /// Specifies previous events related to this product for this user based on
        /// [UserEvent][google.cloud.retail.v2.UserEvent] with same
        /// [SearchRequest.visitor_id][google.cloud.retail.v2.SearchRequest.visitor_id]
        /// or [UserInfo.user_id][google.cloud.retail.v2.UserInfo.user_id].
        ///
        /// This is set only when
        /// [SearchRequest.PersonalizationSpec.mode][google.cloud.retail.v2.SearchRequest.PersonalizationSpec.mode]
        /// is
        /// [SearchRequest.PersonalizationSpec.Mode.AUTO][google.cloud.retail.v2.SearchRequest.PersonalizationSpec.Mode.AUTO].
        ///
        /// Possible values:
        ///
        /// * `purchased`: Indicates that this product has been purchased before.
        ///
        /// [google.cloud.retail.v2.SearchRequest.PersonalizationSpec.Mode.AUTO]: crate::model::search_request::personalization_spec::Mode::Auto
        /// [google.cloud.retail.v2.SearchRequest.PersonalizationSpec.mode]: crate::model::search_request::PersonalizationSpec::mode
        /// [google.cloud.retail.v2.SearchRequest.visitor_id]: crate::model::SearchRequest::visitor_id
        /// [google.cloud.retail.v2.UserEvent]: crate::model::UserEvent
        /// [google.cloud.retail.v2.UserInfo.user_id]: crate::model::UserInfo::user_id
        pub personal_labels: std::vec::Vec<std::string::String>,

        /// Google provided available scores.
        pub model_scores: std::collections::HashMap<std::string::String, crate::model::DoubleList>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SearchResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::search_response::SearchResult::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [product][crate::model::search_response::SearchResult::product].
        pub fn set_product<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Product>,
        {
            self.product = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [product][crate::model::search_response::SearchResult::product].
        pub fn set_or_clear_product<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Product>,
        {
            self.product = v.map(|x| x.into());
            self
        }

        /// Sets the value of [matching_variant_count][crate::model::search_response::SearchResult::matching_variant_count].
        pub fn set_matching_variant_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.matching_variant_count = v.into();
            self
        }

        /// Sets the value of [matching_variant_fields][crate::model::search_response::SearchResult::matching_variant_fields].
        pub fn set_matching_variant_fields<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<wkt::FieldMask>,
        {
            use std::iter::Iterator;
            self.matching_variant_fields =
                v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [variant_rollup_values][crate::model::search_response::SearchResult::variant_rollup_values].
        pub fn set_variant_rollup_values<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<wkt::Value>,
        {
            use std::iter::Iterator;
            self.variant_rollup_values = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [personal_labels][crate::model::search_response::SearchResult::personal_labels].
        pub fn set_personal_labels<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.personal_labels = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [model_scores][crate::model::search_response::SearchResult::model_scores].
        pub fn set_model_scores<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::DoubleList>,
        {
            use std::iter::Iterator;
            self.model_scores = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for SearchResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.SearchResponse.SearchResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SearchResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                __product,
                __matching_variant_count,
                __matching_variant_fields,
                __variant_rollup_values,
                __personal_labels,
                __model_scores,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SearchResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                "product" => Ok(__FieldTag::__product),
                                "matchingVariantCount" => Ok(__FieldTag::__matching_variant_count),
                                "matching_variant_count" => {
                                    Ok(__FieldTag::__matching_variant_count)
                                }
                                "matchingVariantFields" => {
                                    Ok(__FieldTag::__matching_variant_fields)
                                }
                                "matching_variant_fields" => {
                                    Ok(__FieldTag::__matching_variant_fields)
                                }
                                "variantRollupValues" => Ok(__FieldTag::__variant_rollup_values),
                                "variant_rollup_values" => Ok(__FieldTag::__variant_rollup_values),
                                "personalLabels" => Ok(__FieldTag::__personal_labels),
                                "personal_labels" => Ok(__FieldTag::__personal_labels),
                                "modelScores" => Ok(__FieldTag::__model_scores),
                                "model_scores" => Ok(__FieldTag::__model_scores),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SearchResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SearchResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__product => {
                                if !fields.insert(__FieldTag::__product) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for product",
                                    ));
                                }
                                result.product =
                                    map.next_value::<std::option::Option<crate::model::Product>>()?;
                            }
                            __FieldTag::__matching_variant_count => {
                                if !fields.insert(__FieldTag::__matching_variant_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for matching_variant_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.matching_variant_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__matching_variant_fields => {
                                if !fields.insert(__FieldTag::__matching_variant_fields) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for matching_variant_fields",
                                    ));
                                }
                                result.matching_variant_fields = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            wkt::FieldMask,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__variant_rollup_values => {
                                if !fields.insert(__FieldTag::__variant_rollup_values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for variant_rollup_values",
                                    ));
                                }
                                result.variant_rollup_values = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<std::string::String, wkt::Value>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__personal_labels => {
                                if !fields.insert(__FieldTag::__personal_labels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for personal_labels",
                                    ));
                                }
                                result.personal_labels = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__model_scores => {
                                if !fields.insert(__FieldTag::__model_scores) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for model_scores",
                                    ));
                                }
                                result.model_scores = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            crate::model::DoubleList,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SearchResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if self.product.is_some() {
                state.serialize_entry("product", &self.product)?;
            }
            if !wkt::internal::is_default(&self.matching_variant_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "matchingVariantCount",
                    &__With(&self.matching_variant_count),
                )?;
            }
            if !self.matching_variant_fields.is_empty() {
                state.serialize_entry("matchingVariantFields", &self.matching_variant_fields)?;
            }
            if !self.variant_rollup_values.is_empty() {
                state.serialize_entry("variantRollupValues", &self.variant_rollup_values)?;
            }
            if !self.personal_labels.is_empty() {
                state.serialize_entry("personalLabels", &self.personal_labels)?;
            }
            if !self.model_scores.is_empty() {
                state.serialize_entry("modelScores", &self.model_scores)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SearchResult {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SearchResult");
            debug_struct.field("id", &self.id);
            debug_struct.field("product", &self.product);
            debug_struct.field("matching_variant_count", &self.matching_variant_count);
            debug_struct.field("matching_variant_fields", &self.matching_variant_fields);
            debug_struct.field("variant_rollup_values", &self.variant_rollup_values);
            debug_struct.field("personal_labels", &self.personal_labels);
            debug_struct.field("model_scores", &self.model_scores);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// A facet result.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Facet {
        /// The key for this facet. E.g., "colorFamilies" or "price" or
        /// "attributes.attr1".
        pub key: std::string::String,

        /// The facet values for this field.
        pub values: std::vec::Vec<crate::model::search_response::facet::FacetValue>,

        /// Whether the facet is dynamically generated.
        pub dynamic_facet: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Facet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key][crate::model::search_response::Facet::key].
        pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key = v.into();
            self
        }

        /// Sets the value of [values][crate::model::search_response::Facet::values].
        pub fn set_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::search_response::facet::FacetValue>,
        {
            use std::iter::Iterator;
            self.values = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [dynamic_facet][crate::model::search_response::Facet::dynamic_facet].
        pub fn set_dynamic_facet<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.dynamic_facet = v.into();
            self
        }
    }

    impl wkt::message::Message for Facet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.SearchResponse.Facet"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Facet {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __key,
                __values,
                __dynamic_facet,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Facet")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "key" => Ok(__FieldTag::__key),
                                "values" => Ok(__FieldTag::__values),
                                "dynamicFacet" => Ok(__FieldTag::__dynamic_facet),
                                "dynamic_facet" => Ok(__FieldTag::__dynamic_facet),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Facet;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Facet")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__key => {
                                if !fields.insert(__FieldTag::__key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for key",
                                    ));
                                }
                                result.key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__values => {
                                if !fields.insert(__FieldTag::__values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for values",
                                    ));
                                }
                                result.values = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::search_response::facet::FacetValue,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__dynamic_facet => {
                                if !fields.insert(__FieldTag::__dynamic_facet) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dynamic_facet",
                                    ));
                                }
                                result.dynamic_facet = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Facet {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.key.is_empty() {
                state.serialize_entry("key", &self.key)?;
            }
            if !self.values.is_empty() {
                state.serialize_entry("values", &self.values)?;
            }
            if !wkt::internal::is_default(&self.dynamic_facet) {
                state.serialize_entry("dynamicFacet", &self.dynamic_facet)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Facet {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Facet");
            debug_struct.field("key", &self.key);
            debug_struct.field("values", &self.values);
            debug_struct.field("dynamic_facet", &self.dynamic_facet);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Facet].
    pub mod facet {
        #[allow(unused_imports)]
        use super::*;

        /// A facet value which contains value names and their count.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct FacetValue {
            /// Number of items that have this facet value.
            pub count: i64,

            /// The minimum value in the
            /// [FacetValue.interval][google.cloud.retail.v2.SearchResponse.Facet.FacetValue.interval].
            /// Only supported on numerical facets and returned if
            /// [SearchRequest.FacetSpec.FacetKey.return_min_max][google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.return_min_max]
            /// is true.
            ///
            /// [google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.return_min_max]: crate::model::search_request::facet_spec::FacetKey::return_min_max
            /// [google.cloud.retail.v2.SearchResponse.Facet.FacetValue.interval]: crate::model::search_response::facet::FacetValue::facet_value
            pub min_value: f64,

            /// The maximum value in the
            /// [FacetValue.interval][google.cloud.retail.v2.SearchResponse.Facet.FacetValue.interval].
            /// Only supported on numerical facets and returned if
            /// [SearchRequest.FacetSpec.FacetKey.return_min_max][google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.return_min_max]
            /// is true.
            ///
            /// [google.cloud.retail.v2.SearchRequest.FacetSpec.FacetKey.return_min_max]: crate::model::search_request::facet_spec::FacetKey::return_min_max
            /// [google.cloud.retail.v2.SearchResponse.Facet.FacetValue.interval]: crate::model::search_response::facet::FacetValue::facet_value
            pub max_value: f64,

            /// A facet value which contains values.
            pub facet_value:
                std::option::Option<crate::model::search_response::facet::facet_value::FacetValue>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl FacetValue {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [count][crate::model::search_response::facet::FacetValue::count].
            pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
                self.count = v.into();
                self
            }

            /// Sets the value of [min_value][crate::model::search_response::facet::FacetValue::min_value].
            pub fn set_min_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.min_value = v.into();
                self
            }

            /// Sets the value of [max_value][crate::model::search_response::facet::FacetValue::max_value].
            pub fn set_max_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.max_value = v.into();
                self
            }

            /// Sets the value of [facet_value][crate::model::search_response::facet::FacetValue::facet_value].
            ///
            /// Note that all the setters affecting `facet_value` are mutually
            /// exclusive.
            pub fn set_facet_value<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::search_response::facet::facet_value::FacetValue,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.facet_value = v.into();
                self
            }

            /// The value of [facet_value][crate::model::search_response::facet::FacetValue::facet_value]
            /// if it holds a `Value`, `None` if the field is not set or
            /// holds a different branch.
            pub fn value(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.facet_value.as_ref().and_then(|v| match v {
                    crate::model::search_response::facet::facet_value::FacetValue::Value(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [facet_value][crate::model::search_response::facet::FacetValue::facet_value]
            /// to hold a `Value`.
            ///
            /// Note that all the setters affecting `facet_value` are
            /// mutually exclusive.
            pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.facet_value = std::option::Option::Some(
                    crate::model::search_response::facet::facet_value::FacetValue::Value(v.into()),
                );
                self
            }

            /// The value of [facet_value][crate::model::search_response::facet::FacetValue::facet_value]
            /// if it holds a `Interval`, `None` if the field is not set or
            /// holds a different branch.
            pub fn interval(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::Interval>> {
                #[allow(unreachable_patterns)]
                self.facet_value.as_ref().and_then(|v| match v {
                    crate::model::search_response::facet::facet_value::FacetValue::Interval(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [facet_value][crate::model::search_response::facet::FacetValue::facet_value]
            /// to hold a `Interval`.
            ///
            /// Note that all the setters affecting `facet_value` are
            /// mutually exclusive.
            pub fn set_interval<T: std::convert::Into<std::boxed::Box<crate::model::Interval>>>(
                mut self,
                v: T,
            ) -> Self {
                self.facet_value = std::option::Option::Some(
                    crate::model::search_response::facet::facet_value::FacetValue::Interval(
                        v.into(),
                    ),
                );
                self
            }
        }

        impl wkt::message::Message for FacetValue {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.retail.v2.SearchResponse.Facet.FacetValue"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for FacetValue {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __value,
                    __interval,
                    __count,
                    __min_value,
                    __max_value,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for FacetValue")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "value" => Ok(__FieldTag::__value),
                                    "interval" => Ok(__FieldTag::__interval),
                                    "count" => Ok(__FieldTag::__count),
                                    "minValue" => Ok(__FieldTag::__min_value),
                                    "min_value" => Ok(__FieldTag::__min_value),
                                    "maxValue" => Ok(__FieldTag::__max_value),
                                    "max_value" => Ok(__FieldTag::__max_value),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = FacetValue;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct FacetValue")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__value => {
                                    if !fields.insert(__FieldTag::__value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for value"),
                                        );
                                    }
                                    if result.facet_value.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `facet_value`, a oneof with full ID .google.cloud.retail.v2.SearchResponse.Facet.FacetValue.value, latest field was value",
                                            ),
                                        );
                                    }
                                    result.facet_value = std::option::Option::Some(
                                        crate::model::search_response::facet::facet_value::FacetValue::Value(
                                            map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__interval => {
                                    if !fields.insert(__FieldTag::__interval) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for interval",
                                            ),
                                        );
                                    }
                                    if result.facet_value.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `facet_value`, a oneof with full ID .google.cloud.retail.v2.SearchResponse.Facet.FacetValue.interval, latest field was interval",
                                            ),
                                        );
                                    }
                                    result.facet_value = std::option::Option::Some(
                                        crate::model::search_response::facet::facet_value::FacetValue::Interval(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::Interval>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__count => {
                                    if !fields.insert(__FieldTag::__count) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for count"),
                                        );
                                    }
                                    struct __With(std::option::Option<i64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.count =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__min_value => {
                                    if !fields.insert(__FieldTag::__min_value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for min_value",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.min_value =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__max_value => {
                                    if !fields.insert(__FieldTag::__max_value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for max_value",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.max_value =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for FacetValue {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.value() {
                    state.serialize_entry("value", value)?;
                }
                if let Some(value) = self.interval() {
                    state.serialize_entry("interval", value)?;
                }
                if !wkt::internal::is_default(&self.count) {
                    struct __With<'a>(&'a i64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("count", &__With(&self.count))?;
                }
                if !wkt::internal::is_default(&self.min_value) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("minValue", &__With(&self.min_value))?;
                }
                if !wkt::internal::is_default(&self.max_value) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("maxValue", &__With(&self.max_value))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for FacetValue {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("FacetValue");
                debug_struct.field("count", &self.count);
                debug_struct.field("min_value", &self.min_value);
                debug_struct.field("max_value", &self.max_value);
                debug_struct.field("facet_value", &self.facet_value);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [FacetValue].
        pub mod facet_value {
            #[allow(unused_imports)]
            use super::*;

            /// A facet value which contains values.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum FacetValue {
                /// Text value of a facet, such as "Black" for facet "colorFamilies".
                Value(std::string::String),
                /// Interval value for a facet, such as [10, 20) for facet "price".
                Interval(std::boxed::Box<crate::model::Interval>),
            }
        }
    }

    /// Information describing query expansion including whether expansion has
    /// occurred.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct QueryExpansionInfo {
        /// Bool describing whether query expansion has occurred.
        pub expanded_query: bool,

        /// Number of pinned results. This field will only be set when expansion
        /// happens and
        /// [SearchRequest.QueryExpansionSpec.pin_unexpanded_results][google.cloud.retail.v2.SearchRequest.QueryExpansionSpec.pin_unexpanded_results]
        /// is set to true.
        ///
        /// [google.cloud.retail.v2.SearchRequest.QueryExpansionSpec.pin_unexpanded_results]: crate::model::search_request::QueryExpansionSpec::pin_unexpanded_results
        pub pinned_result_count: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QueryExpansionInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [expanded_query][crate::model::search_response::QueryExpansionInfo::expanded_query].
        pub fn set_expanded_query<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.expanded_query = v.into();
            self
        }

        /// Sets the value of [pinned_result_count][crate::model::search_response::QueryExpansionInfo::pinned_result_count].
        pub fn set_pinned_result_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.pinned_result_count = v.into();
            self
        }
    }

    impl wkt::message::Message for QueryExpansionInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.SearchResponse.QueryExpansionInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for QueryExpansionInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __expanded_query,
                __pinned_result_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for QueryExpansionInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "expandedQuery" => Ok(__FieldTag::__expanded_query),
                                "expanded_query" => Ok(__FieldTag::__expanded_query),
                                "pinnedResultCount" => Ok(__FieldTag::__pinned_result_count),
                                "pinned_result_count" => Ok(__FieldTag::__pinned_result_count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = QueryExpansionInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct QueryExpansionInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__expanded_query => {
                                if !fields.insert(__FieldTag::__expanded_query) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for expanded_query",
                                    ));
                                }
                                result.expanded_query = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__pinned_result_count => {
                                if !fields.insert(__FieldTag::__pinned_result_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for pinned_result_count",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.pinned_result_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for QueryExpansionInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.expanded_query) {
                state.serialize_entry("expandedQuery", &self.expanded_query)?;
            }
            if !wkt::internal::is_default(&self.pinned_result_count) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("pinnedResultCount", &__With(&self.pinned_result_count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for QueryExpansionInfo {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("QueryExpansionInfo");
            debug_struct.field("expanded_query", &self.expanded_query);
            debug_struct.field("pinned_result_count", &self.pinned_result_count);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// This field specifies all related information that is needed on client
    /// side for UI rendering of conversational retail search.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConversationalSearchResult {
        /// Conversation UUID. This field will be stored in client side storage to
        /// maintain the conversation session with server and will be used for next
        /// search request's
        /// [SearchRequest.ConversationalSearchSpec.conversation_id][google.cloud.retail.v2.SearchRequest.ConversationalSearchSpec.conversation_id]
        /// to restore conversation state in server.
        ///
        /// [google.cloud.retail.v2.SearchRequest.ConversationalSearchSpec.conversation_id]: crate::model::search_request::ConversationalSearchSpec::conversation_id
        pub conversation_id: std::string::String,

        /// The current refined query for the conversational search. This field
        /// will be used in customer UI that the query in the search bar should be
        /// replaced with the refined query. For example, if
        /// [SearchRequest.query][google.cloud.retail.v2.SearchRequest.query] is
        /// `dress` and next
        /// [SearchRequest.ConversationalSearchSpec.UserAnswer.text_answer][google.cloud.retail.v2.SearchRequest.ConversationalSearchSpec.UserAnswer.text_answer]
        /// is `red color`, which does not match any product attribute value filters,
        /// the refined query will be `dress, red color`.
        ///
        /// [google.cloud.retail.v2.SearchRequest.ConversationalSearchSpec.UserAnswer.text_answer]: crate::model::search_request::conversational_search_spec::UserAnswer::type
        /// [google.cloud.retail.v2.SearchRequest.query]: crate::model::SearchRequest::query
        pub refined_query: std::string::String,

        /// This field is deprecated but will be kept for backward compatibility.
        /// There is expected to have only one additional filter and the value will
        /// be the same to the same as field `additional_filter`.
        #[deprecated]
        pub additional_filters: std::vec::Vec<
            crate::model::search_response::conversational_search_result::AdditionalFilter,
        >,

        /// The follow-up question. e.g., `What is the color?`
        pub followup_question: std::string::String,

        /// The answer options provided to client for the follow-up question.
        pub suggested_answers: std::vec::Vec<
            crate::model::search_response::conversational_search_result::SuggestedAnswer,
        >,

        /// This is the incremental additional filters implied from the current
        /// user answer. User should add the suggested addition filters to the
        /// previous
        /// [SearchRequest.filter][google.cloud.retail.v2.SearchRequest.filter],  and
        /// use the merged filter in the follow up search request.
        ///
        /// [google.cloud.retail.v2.SearchRequest.filter]: crate::model::SearchRequest::filter
        pub additional_filter: std::option::Option<
            crate::model::search_response::conversational_search_result::AdditionalFilter,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConversationalSearchResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [conversation_id][crate::model::search_response::ConversationalSearchResult::conversation_id].
        pub fn set_conversation_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.conversation_id = v.into();
            self
        }

        /// Sets the value of [refined_query][crate::model::search_response::ConversationalSearchResult::refined_query].
        pub fn set_refined_query<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.refined_query = v.into();
            self
        }

        /// Sets the value of [additional_filters][crate::model::search_response::ConversationalSearchResult::additional_filters].
        #[deprecated]
        pub fn set_additional_filters<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::search_response::conversational_search_result::AdditionalFilter,
                >,
        {
            use std::iter::Iterator;
            self.additional_filters = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [followup_question][crate::model::search_response::ConversationalSearchResult::followup_question].
        pub fn set_followup_question<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.followup_question = v.into();
            self
        }

        /// Sets the value of [suggested_answers][crate::model::search_response::ConversationalSearchResult::suggested_answers].
        pub fn set_suggested_answers<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::search_response::conversational_search_result::SuggestedAnswer,
                >,
        {
            use std::iter::Iterator;
            self.suggested_answers = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [additional_filter][crate::model::search_response::ConversationalSearchResult::additional_filter].
        pub fn set_additional_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::search_response::conversational_search_result::AdditionalFilter,
                >,
        {
            self.additional_filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [additional_filter][crate::model::search_response::ConversationalSearchResult::additional_filter].
        pub fn set_or_clear_additional_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::search_response::conversational_search_result::AdditionalFilter,
                >,
        {
            self.additional_filter = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ConversationalSearchResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.SearchResponse.ConversationalSearchResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ConversationalSearchResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __conversation_id,
                __refined_query,
                __additional_filters,
                __followup_question,
                __suggested_answers,
                __additional_filter,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ConversationalSearchResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "conversationId" => Ok(__FieldTag::__conversation_id),
                                "conversation_id" => Ok(__FieldTag::__conversation_id),
                                "refinedQuery" => Ok(__FieldTag::__refined_query),
                                "refined_query" => Ok(__FieldTag::__refined_query),
                                "additionalFilters" => Ok(__FieldTag::__additional_filters),
                                "additional_filters" => Ok(__FieldTag::__additional_filters),
                                "followupQuestion" => Ok(__FieldTag::__followup_question),
                                "followup_question" => Ok(__FieldTag::__followup_question),
                                "suggestedAnswers" => Ok(__FieldTag::__suggested_answers),
                                "suggested_answers" => Ok(__FieldTag::__suggested_answers),
                                "additionalFilter" => Ok(__FieldTag::__additional_filter),
                                "additional_filter" => Ok(__FieldTag::__additional_filter),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ConversationalSearchResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ConversationalSearchResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__conversation_id => {
                                if !fields.insert(__FieldTag::__conversation_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for conversation_id",
                                    ));
                                }
                                result.conversation_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__refined_query => {
                                if !fields.insert(__FieldTag::__refined_query) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for refined_query",
                                    ));
                                }
                                result.refined_query = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__additional_filters => {
                                if !fields.insert(__FieldTag::__additional_filters) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for additional_filters",
                                    ));
                                }
                                result.additional_filters = map.next_value::<std::option::Option<std::vec::Vec<crate::model::search_response::conversational_search_result::AdditionalFilter>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__followup_question => {
                                if !fields.insert(__FieldTag::__followup_question) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for followup_question",
                                    ));
                                }
                                result.followup_question = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__suggested_answers => {
                                if !fields.insert(__FieldTag::__suggested_answers) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for suggested_answers",
                                    ));
                                }
                                result.suggested_answers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::search_response::conversational_search_result::SuggestedAnswer>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__additional_filter => {
                                if !fields.insert(__FieldTag::__additional_filter) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for additional_filter",
                                    ));
                                }
                                result.additional_filter = map.next_value::<std::option::Option<crate::model::search_response::conversational_search_result::AdditionalFilter>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ConversationalSearchResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.conversation_id.is_empty() {
                state.serialize_entry("conversationId", &self.conversation_id)?;
            }
            if !self.refined_query.is_empty() {
                state.serialize_entry("refinedQuery", &self.refined_query)?;
            }
            if !self.additional_filters.is_empty() {
                state.serialize_entry("additionalFilters", &self.additional_filters)?;
            }
            if !self.followup_question.is_empty() {
                state.serialize_entry("followupQuestion", &self.followup_question)?;
            }
            if !self.suggested_answers.is_empty() {
                state.serialize_entry("suggestedAnswers", &self.suggested_answers)?;
            }
            if self.additional_filter.is_some() {
                state.serialize_entry("additionalFilter", &self.additional_filter)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ConversationalSearchResult {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ConversationalSearchResult");
            debug_struct.field("conversation_id", &self.conversation_id);
            debug_struct.field("refined_query", &self.refined_query);
            debug_struct.field("additional_filters", &self.additional_filters);
            debug_struct.field("followup_question", &self.followup_question);
            debug_struct.field("suggested_answers", &self.suggested_answers);
            debug_struct.field("additional_filter", &self.additional_filter);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [ConversationalSearchResult].
    pub mod conversational_search_result {
        #[allow(unused_imports)]
        use super::*;

        /// Suggested answers to the follow-up question.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct SuggestedAnswer {
            /// Product attribute value, including an attribute key and an
            /// attribute value. Other types can be added here in the future.
            pub product_attribute_value: std::option::Option<crate::model::ProductAttributeValue>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl SuggestedAnswer {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [product_attribute_value][crate::model::search_response::conversational_search_result::SuggestedAnswer::product_attribute_value].
            pub fn set_product_attribute_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::ProductAttributeValue>,
            {
                self.product_attribute_value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [product_attribute_value][crate::model::search_response::conversational_search_result::SuggestedAnswer::product_attribute_value].
            pub fn set_or_clear_product_attribute_value<T>(
                mut self,
                v: std::option::Option<T>,
            ) -> Self
            where
                T: std::convert::Into<crate::model::ProductAttributeValue>,
            {
                self.product_attribute_value = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for SuggestedAnswer {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.retail.v2.SearchResponse.ConversationalSearchResult.SuggestedAnswer"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for SuggestedAnswer {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __product_attribute_value,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for SuggestedAnswer")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "productAttributeValue" => {
                                        Ok(__FieldTag::__product_attribute_value)
                                    }
                                    "product_attribute_value" => {
                                        Ok(__FieldTag::__product_attribute_value)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = SuggestedAnswer;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct SuggestedAnswer")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__product_attribute_value => {
                                    if !fields.insert(__FieldTag::__product_attribute_value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for product_attribute_value",
                                            ),
                                        );
                                    }
                                    result.product_attribute_value =
                                        map.next_value::<std::option::Option<
                                            crate::model::ProductAttributeValue,
                                        >>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for SuggestedAnswer {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.product_attribute_value.is_some() {
                    state
                        .serialize_entry("productAttributeValue", &self.product_attribute_value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for SuggestedAnswer {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("SuggestedAnswer");
                debug_struct.field("product_attribute_value", &self.product_attribute_value);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Additional filter that client side need to apply.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct AdditionalFilter {
            /// Product attribute value, including an attribute key and an
            /// attribute value. Other types can be added here in the future.
            pub product_attribute_value: std::option::Option<crate::model::ProductAttributeValue>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl AdditionalFilter {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [product_attribute_value][crate::model::search_response::conversational_search_result::AdditionalFilter::product_attribute_value].
            pub fn set_product_attribute_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::ProductAttributeValue>,
            {
                self.product_attribute_value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [product_attribute_value][crate::model::search_response::conversational_search_result::AdditionalFilter::product_attribute_value].
            pub fn set_or_clear_product_attribute_value<T>(
                mut self,
                v: std::option::Option<T>,
            ) -> Self
            where
                T: std::convert::Into<crate::model::ProductAttributeValue>,
            {
                self.product_attribute_value = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for AdditionalFilter {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.retail.v2.SearchResponse.ConversationalSearchResult.AdditionalFilter"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for AdditionalFilter {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __product_attribute_value,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for AdditionalFilter")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "productAttributeValue" => {
                                        Ok(__FieldTag::__product_attribute_value)
                                    }
                                    "product_attribute_value" => {
                                        Ok(__FieldTag::__product_attribute_value)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = AdditionalFilter;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct AdditionalFilter")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__product_attribute_value => {
                                    if !fields.insert(__FieldTag::__product_attribute_value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for product_attribute_value",
                                            ),
                                        );
                                    }
                                    result.product_attribute_value =
                                        map.next_value::<std::option::Option<
                                            crate::model::ProductAttributeValue,
                                        >>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for AdditionalFilter {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.product_attribute_value.is_some() {
                    state
                        .serialize_entry("productAttributeValue", &self.product_attribute_value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for AdditionalFilter {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("AdditionalFilter");
                debug_struct.field("product_attribute_value", &self.product_attribute_value);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    /// This field specifies all related information for tile navigation that will
    /// be used in client side.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TileNavigationResult {
        /// The current tiles that are used for tile navigation, sorted by
        /// engagement.
        pub tiles: std::vec::Vec<crate::model::Tile>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TileNavigationResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [tiles][crate::model::search_response::TileNavigationResult::tiles].
        pub fn set_tiles<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Tile>,
        {
            use std::iter::Iterator;
            self.tiles = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for TileNavigationResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.SearchResponse.TileNavigationResult"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TileNavigationResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __tiles,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TileNavigationResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "tiles" => Ok(__FieldTag::__tiles),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TileNavigationResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TileNavigationResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__tiles => {
                                if !fields.insert(__FieldTag::__tiles) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tiles",
                                    ));
                                }
                                result.tiles = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Tile>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TileNavigationResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.tiles.is_empty() {
                state.serialize_entry("tiles", &self.tiles)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for TileNavigationResult {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("TileNavigationResult");
            debug_struct.field("tiles", &self.tiles);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Metadata for active A/B testing experiment.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExperimentInfo {
    /// The fully qualified resource name of the experiment that provides the
    /// serving config under test, should an active experiment exist. For example:
    /// `projects/*/locations/global/catalogs/default_catalog/experiments/experiment_id`
    pub experiment: std::string::String,

    /// Information associated with the specific experiment entity being recorded.
    pub experiment_metadata: std::option::Option<crate::model::experiment_info::ExperimentMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExperimentInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [experiment][crate::model::ExperimentInfo::experiment].
    pub fn set_experiment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.experiment = v.into();
        self
    }

    /// Sets the value of [experiment_metadata][crate::model::ExperimentInfo::experiment_metadata].
    ///
    /// Note that all the setters affecting `experiment_metadata` are mutually
    /// exclusive.
    pub fn set_experiment_metadata<
        T: std::convert::Into<std::option::Option<crate::model::experiment_info::ExperimentMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.experiment_metadata = v.into();
        self
    }

    /// The value of [experiment_metadata][crate::model::ExperimentInfo::experiment_metadata]
    /// if it holds a `ServingConfigExperiment`, `None` if the field is not set or
    /// holds a different branch.
    pub fn serving_config_experiment(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::experiment_info::ServingConfigExperiment>>
    {
        #[allow(unreachable_patterns)]
        self.experiment_metadata.as_ref().and_then(|v| match v {
            crate::model::experiment_info::ExperimentMetadata::ServingConfigExperiment(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [experiment_metadata][crate::model::ExperimentInfo::experiment_metadata]
    /// to hold a `ServingConfigExperiment`.
    ///
    /// Note that all the setters affecting `experiment_metadata` are
    /// mutually exclusive.
    pub fn set_serving_config_experiment<
        T: std::convert::Into<std::boxed::Box<crate::model::experiment_info::ServingConfigExperiment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.experiment_metadata = std::option::Option::Some(
            crate::model::experiment_info::ExperimentMetadata::ServingConfigExperiment(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExperimentInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ExperimentInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExperimentInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __serving_config_experiment,
            __experiment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExperimentInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "servingConfigExperiment" => {
                                Ok(__FieldTag::__serving_config_experiment)
                            }
                            "serving_config_experiment" => {
                                Ok(__FieldTag::__serving_config_experiment)
                            }
                            "experiment" => Ok(__FieldTag::__experiment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExperimentInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExperimentInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__serving_config_experiment => {
                            if !fields.insert(__FieldTag::__serving_config_experiment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serving_config_experiment",
                                ));
                            }
                            if result.experiment_metadata.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `experiment_metadata`, a oneof with full ID .google.cloud.retail.v2.ExperimentInfo.serving_config_experiment, latest field was servingConfigExperiment",
                                ));
                            }
                            result.experiment_metadata = std::option::Option::Some(
                                crate::model::experiment_info::ExperimentMetadata::ServingConfigExperiment(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::experiment_info::ServingConfigExperiment>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__experiment => {
                            if !fields.insert(__FieldTag::__experiment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for experiment",
                                ));
                            }
                            result.experiment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExperimentInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.serving_config_experiment() {
            state.serialize_entry("servingConfigExperiment", value)?;
        }
        if !self.experiment.is_empty() {
            state.serialize_entry("experiment", &self.experiment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExperimentInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExperimentInfo");
        debug_struct.field("experiment", &self.experiment);
        debug_struct.field("experiment_metadata", &self.experiment_metadata);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ExperimentInfo].
pub mod experiment_info {
    #[allow(unused_imports)]
    use super::*;

    /// Metadata for active serving config A/B tests.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ServingConfigExperiment {
        /// The fully qualified resource name of the original
        /// [SearchRequest.placement][google.cloud.retail.v2.SearchRequest.placement]
        /// in the search request prior to reassignment by experiment API. For
        /// example: `projects/*/locations/*/catalogs/*/servingConfigs/*`.
        ///
        /// [google.cloud.retail.v2.SearchRequest.placement]: crate::model::SearchRequest::placement
        pub original_serving_config: std::string::String,

        /// The fully qualified resource name of the serving config
        /// `Experiment.VariantArm.serving_config_id` responsible for generating
        /// the search response. For example:
        /// `projects/*/locations/*/catalogs/*/servingConfigs/*`.
        pub experiment_serving_config: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ServingConfigExperiment {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [original_serving_config][crate::model::experiment_info::ServingConfigExperiment::original_serving_config].
        pub fn set_original_serving_config<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.original_serving_config = v.into();
            self
        }

        /// Sets the value of [experiment_serving_config][crate::model::experiment_info::ServingConfigExperiment::experiment_serving_config].
        pub fn set_experiment_serving_config<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.experiment_serving_config = v.into();
            self
        }
    }

    impl wkt::message::Message for ServingConfigExperiment {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.retail.v2.ExperimentInfo.ServingConfigExperiment"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ServingConfigExperiment {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __original_serving_config,
                __experiment_serving_config,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ServingConfigExperiment")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "originalServingConfig" => {
                                    Ok(__FieldTag::__original_serving_config)
                                }
                                "original_serving_config" => {
                                    Ok(__FieldTag::__original_serving_config)
                                }
                                "experimentServingConfig" => {
                                    Ok(__FieldTag::__experiment_serving_config)
                                }
                                "experiment_serving_config" => {
                                    Ok(__FieldTag::__experiment_serving_config)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ServingConfigExperiment;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ServingConfigExperiment")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__original_serving_config => {
                                if !fields.insert(__FieldTag::__original_serving_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for original_serving_config",
                                    ));
                                }
                                result.original_serving_config = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__experiment_serving_config => {
                                if !fields.insert(__FieldTag::__experiment_serving_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for experiment_serving_config",
                                    ));
                                }
                                result.experiment_serving_config = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ServingConfigExperiment {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.original_serving_config.is_empty() {
                state.serialize_entry("originalServingConfig", &self.original_serving_config)?;
            }
            if !self.experiment_serving_config.is_empty() {
                state
                    .serialize_entry("experimentServingConfig", &self.experiment_serving_config)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ServingConfigExperiment {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ServingConfigExperiment");
            debug_struct.field("original_serving_config", &self.original_serving_config);
            debug_struct.field("experiment_serving_config", &self.experiment_serving_config);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Information associated with the specific experiment entity being recorded.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExperimentMetadata {
        /// A/B test between existing Cloud Retail Search
        /// [ServingConfig][google.cloud.retail.v2.ServingConfig]s.
        ///
        /// [google.cloud.retail.v2.ServingConfig]: crate::model::ServingConfig
        ServingConfigExperiment(
            std::boxed::Box<crate::model::experiment_info::ServingConfigExperiment>,
        ),
    }
}

/// Configures metadata that is used to generate serving time results (e.g.
/// search results or recommendation predictions).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ServingConfig {
    /// Immutable. Fully qualified name
    /// `projects/*/locations/global/catalogs/*/servingConfig/*`
    pub name: std::string::String,

    /// Required. The human readable serving config display name. Used in Retail
    /// UI.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
    pub display_name: std::string::String,

    /// The id of the model in the same [Catalog][google.cloud.retail.v2.Catalog]
    /// to use at serving time. Currently only RecommendationModels are supported:
    /// <https://cloud.google.com/retail/recommendations-ai/docs/create-models>
    /// Can be changed but only to a compatible model (e.g.
    /// others-you-may-like CTR to others-you-may-like CVR).
    ///
    /// Required when
    /// [solution_types][google.cloud.retail.v2.ServingConfig.solution_types] is
    /// [SOLUTION_TYPE_RECOMMENDATION][google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_RECOMMENDATION].
    ///
    /// [google.cloud.retail.v2.Catalog]: crate::model::Catalog
    /// [google.cloud.retail.v2.ServingConfig.solution_types]: crate::model::ServingConfig::solution_types
    /// [google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_RECOMMENDATION]: crate::model::SolutionType::Recommendation
    pub model_id: std::string::String,

    /// How much price ranking we want in serving results.
    /// Price reranking causes product items with a similar
    /// recommendation probability to be ordered by price, with the
    /// highest-priced items first. This setting could result in a decrease in
    /// click-through and conversion rates.
    /// Allowed values are:
    ///
    /// * `no-price-reranking`
    /// * `low-price-reranking`
    /// * `medium-price-reranking`
    /// * `high-price-reranking`
    ///
    /// If not specified, we choose default based on model type. Default value:
    /// `no-price-reranking`.
    ///
    /// Can only be set if
    /// [solution_types][google.cloud.retail.v2.ServingConfig.solution_types] is
    /// [SOLUTION_TYPE_RECOMMENDATION][google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_RECOMMENDATION].
    ///
    /// [google.cloud.retail.v2.ServingConfig.solution_types]: crate::model::ServingConfig::solution_types
    /// [google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_RECOMMENDATION]: crate::model::SolutionType::Recommendation
    pub price_reranking_level: std::string::String,

    /// Facet specifications for faceted search. If empty, no facets are returned.
    /// The ids refer to the ids of [Control][google.cloud.retail.v2.Control]
    /// resources with only the Facet control set. These controls are assumed to be
    /// in the same [Catalog][google.cloud.retail.v2.Catalog] as the
    /// [ServingConfig][google.cloud.retail.v2.ServingConfig].
    /// A maximum of 100 values are allowed. Otherwise, an INVALID_ARGUMENT error
    /// is returned.
    ///
    /// Can only be set if
    /// [solution_types][google.cloud.retail.v2.ServingConfig.solution_types] is
    /// [SOLUTION_TYPE_SEARCH][google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH].
    ///
    /// [google.cloud.retail.v2.Catalog]: crate::model::Catalog
    /// [google.cloud.retail.v2.Control]: crate::model::Control
    /// [google.cloud.retail.v2.ServingConfig]: crate::model::ServingConfig
    /// [google.cloud.retail.v2.ServingConfig.solution_types]: crate::model::ServingConfig::solution_types
    /// [google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH]: crate::model::SolutionType::Search
    pub facet_control_ids: std::vec::Vec<std::string::String>,

    /// The specification for dynamically generated facets. Notice that only
    /// textual facets can be dynamically generated.
    ///
    /// Can only be set if
    /// [solution_types][google.cloud.retail.v2.ServingConfig.solution_types] is
    /// [SOLUTION_TYPE_SEARCH][google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH].
    ///
    /// [google.cloud.retail.v2.ServingConfig.solution_types]: crate::model::ServingConfig::solution_types
    /// [google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH]: crate::model::SolutionType::Search
    pub dynamic_facet_spec: std::option::Option<crate::model::search_request::DynamicFacetSpec>,

    /// Condition boost specifications. If a product matches multiple conditions
    /// in the specifications, boost scores from these specifications are all
    /// applied and combined in a non-linear way. Maximum number of
    /// specifications is 100.
    ///
    /// Notice that if both
    /// [ServingConfig.boost_control_ids][google.cloud.retail.v2.ServingConfig.boost_control_ids]
    /// and
    /// [SearchRequest.boost_spec][google.cloud.retail.v2.SearchRequest.boost_spec]
    /// are set, the boost conditions from both places are evaluated. If a search
    /// request matches multiple boost conditions, the final boost score is equal
    /// to the sum of the boost scores from all matched boost conditions.
    ///
    /// Can only be set if
    /// [solution_types][google.cloud.retail.v2.ServingConfig.solution_types] is
    /// [SOLUTION_TYPE_SEARCH][google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH].
    ///
    /// [google.cloud.retail.v2.SearchRequest.boost_spec]: crate::model::SearchRequest::boost_spec
    /// [google.cloud.retail.v2.ServingConfig.boost_control_ids]: crate::model::ServingConfig::boost_control_ids
    /// [google.cloud.retail.v2.ServingConfig.solution_types]: crate::model::ServingConfig::solution_types
    /// [google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH]: crate::model::SolutionType::Search
    pub boost_control_ids: std::vec::Vec<std::string::String>,

    /// Condition filter specifications. If a product matches multiple conditions
    /// in the specifications, filters from these specifications are all
    /// applied and combined via the AND operator. Maximum number of
    /// specifications is 100.
    ///
    /// Can only be set if
    /// [solution_types][google.cloud.retail.v2.ServingConfig.solution_types] is
    /// [SOLUTION_TYPE_SEARCH][google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH].
    ///
    /// [google.cloud.retail.v2.ServingConfig.solution_types]: crate::model::ServingConfig::solution_types
    /// [google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH]: crate::model::SolutionType::Search
    pub filter_control_ids: std::vec::Vec<std::string::String>,

    /// Condition redirect specifications. Only the first triggered redirect action
    /// is applied, even if multiple apply. Maximum number of specifications is
    /// 1000.
    ///
    /// Can only be set if
    /// [solution_types][google.cloud.retail.v2.ServingConfig.solution_types] is
    /// [SOLUTION_TYPE_SEARCH][google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH].
    ///
    /// [google.cloud.retail.v2.ServingConfig.solution_types]: crate::model::ServingConfig::solution_types
    /// [google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH]: crate::model::SolutionType::Search
    pub redirect_control_ids: std::vec::Vec<std::string::String>,

    /// Condition synonyms specifications. If multiple syonyms conditions match,
    /// all matching synonyms control in the list will execute. Order of controls
    /// in the list will not matter. Maximum number of specifications is
    /// 100.
    ///
    /// Can only be set if
    /// [solution_types][google.cloud.retail.v2.ServingConfig.solution_types] is
    /// [SOLUTION_TYPE_SEARCH][google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH].
    ///
    /// [google.cloud.retail.v2.ServingConfig.solution_types]: crate::model::ServingConfig::solution_types
    /// [google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH]: crate::model::SolutionType::Search
    pub twoway_synonyms_control_ids: std::vec::Vec<std::string::String>,

    /// Condition oneway synonyms specifications. If multiple oneway synonyms
    /// conditions match, all matching oneway synonyms controls in the list will
    /// execute. Order of controls in the list will not matter. Maximum number of
    /// specifications is 100.
    ///
    /// Can only be set if
    /// [solution_types][google.cloud.retail.v2.ServingConfig.solution_types] is
    /// [SOLUTION_TYPE_SEARCH][google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH].
    ///
    /// [google.cloud.retail.v2.ServingConfig.solution_types]: crate::model::ServingConfig::solution_types
    /// [google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH]: crate::model::SolutionType::Search
    pub oneway_synonyms_control_ids: std::vec::Vec<std::string::String>,

    /// Condition do not associate specifications. If multiple do not associate
    /// conditions match, all matching do not associate controls in the list will
    /// execute.
    ///
    /// - Order does not matter.
    /// - Maximum number of specifications is 100.
    ///
    /// Can only be set if
    /// [solution_types][google.cloud.retail.v2.ServingConfig.solution_types] is
    /// [SOLUTION_TYPE_SEARCH][google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH].
    ///
    /// [google.cloud.retail.v2.ServingConfig.solution_types]: crate::model::ServingConfig::solution_types
    /// [google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH]: crate::model::SolutionType::Search
    pub do_not_associate_control_ids: std::vec::Vec<std::string::String>,

    /// Condition replacement specifications.
    ///
    /// - Applied according to the order in the list.
    /// - A previously replaced term can not be re-replaced.
    /// - Maximum number of specifications is 100.
    ///
    /// Can only be set if
    /// [solution_types][google.cloud.retail.v2.ServingConfig.solution_types] is
    /// [SOLUTION_TYPE_SEARCH][google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH].
    ///
    /// [google.cloud.retail.v2.ServingConfig.solution_types]: crate::model::ServingConfig::solution_types
    /// [google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH]: crate::model::SolutionType::Search
    pub replacement_control_ids: std::vec::Vec<std::string::String>,

    /// Condition ignore specifications. If multiple ignore
    /// conditions match, all matching ignore controls in the list will
    /// execute.
    ///
    /// - Order does not matter.
    /// - Maximum number of specifications is 100.
    ///
    /// Can only be set if
    /// [solution_types][google.cloud.retail.v2.ServingConfig.solution_types] is
    /// [SOLUTION_TYPE_SEARCH][google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH].
    ///
    /// [google.cloud.retail.v2.ServingConfig.solution_types]: crate::model::ServingConfig::solution_types
    /// [google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH]: crate::model::SolutionType::Search
    pub ignore_control_ids: std::vec::Vec<std::string::String>,

    /// How much diversity to use in recommendation model results e.g.
    /// `medium-diversity` or `high-diversity`. Currently supported values:
    ///
    /// * `no-diversity`
    /// * `low-diversity`
    /// * `medium-diversity`
    /// * `high-diversity`
    /// * `auto-diversity`
    ///
    /// If not specified, we choose default based on recommendation model
    /// type. Default value: `no-diversity`.
    ///
    /// Can only be set if
    /// [solution_types][google.cloud.retail.v2.ServingConfig.solution_types] is
    /// [SOLUTION_TYPE_RECOMMENDATION][google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_RECOMMENDATION].
    ///
    /// [google.cloud.retail.v2.ServingConfig.solution_types]: crate::model::ServingConfig::solution_types
    /// [google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_RECOMMENDATION]: crate::model::SolutionType::Recommendation
    pub diversity_level: std::string::String,

    /// What kind of diversity to use - data driven or rule based. If unset, the
    /// server behavior defaults to
    /// [RULE_BASED_DIVERSITY][google.cloud.retail.v2.ServingConfig.DiversityType.RULE_BASED_DIVERSITY].
    ///
    /// [google.cloud.retail.v2.ServingConfig.DiversityType.RULE_BASED_DIVERSITY]: crate::model::serving_config::DiversityType::RuleBasedDiversity
    pub diversity_type: crate::model::serving_config::DiversityType,

    /// Whether to add additional category filters on the `similar-items` model.
    /// If not specified, we enable it by default.
    /// Allowed values are:
    ///
    /// * `no-category-match`: No additional filtering of original results from
    ///   the model and the customer's filters.
    /// * `relaxed-category-match`: Only keep results with categories that match
    ///   at least one item categories in the PredictRequests's context item.
    ///   * If customer also sends filters in the PredictRequest, then the results
    ///     will satisfy both conditions (user given and category match).
    ///
    /// Can only be set if
    /// [solution_types][google.cloud.retail.v2.ServingConfig.solution_types] is
    /// [SOLUTION_TYPE_RECOMMENDATION][google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_RECOMMENDATION].
    ///
    /// [google.cloud.retail.v2.ServingConfig.solution_types]: crate::model::ServingConfig::solution_types
    /// [google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_RECOMMENDATION]: crate::model::SolutionType::Recommendation
    pub enable_category_filter_level: std::string::String,

    /// When the flag is enabled, the products in the denylist will not be filtered
    /// out in the recommendation filtering results.
    pub ignore_recs_denylist: bool,

    /// The specification for personalization spec.
    ///
    /// Can only be set if
    /// [solution_types][google.cloud.retail.v2.ServingConfig.solution_types] is
    /// [SOLUTION_TYPE_SEARCH][google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH].
    ///
    /// Notice that if both
    /// [ServingConfig.personalization_spec][google.cloud.retail.v2.ServingConfig.personalization_spec]
    /// and
    /// [SearchRequest.personalization_spec][google.cloud.retail.v2.SearchRequest.personalization_spec]
    /// are set.
    /// [SearchRequest.personalization_spec][google.cloud.retail.v2.SearchRequest.personalization_spec]
    /// will override
    /// [ServingConfig.personalization_spec][google.cloud.retail.v2.ServingConfig.personalization_spec].
    ///
    /// [google.cloud.retail.v2.SearchRequest.personalization_spec]: crate::model::SearchRequest::personalization_spec
    /// [google.cloud.retail.v2.ServingConfig.personalization_spec]: crate::model::ServingConfig::personalization_spec
    /// [google.cloud.retail.v2.ServingConfig.solution_types]: crate::model::ServingConfig::solution_types
    /// [google.cloud.retail.v2.SolutionType.SOLUTION_TYPE_SEARCH]: crate::model::SolutionType::Search
    pub personalization_spec:
        std::option::Option<crate::model::search_request::PersonalizationSpec>,

    /// Required. Immutable. Specifies the solution types that a serving config can
    /// be associated with. Currently we support setting only one type of solution.
    pub solution_types: std::vec::Vec<crate::model::SolutionType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ServingConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ServingConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [model_id][crate::model::ServingConfig::model_id].
    pub fn set_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_id = v.into();
        self
    }

    /// Sets the value of [price_reranking_level][crate::model::ServingConfig::price_reranking_level].
    pub fn set_price_reranking_level<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.price_reranking_level = v.into();
        self
    }

    /// Sets the value of [facet_control_ids][crate::model::ServingConfig::facet_control_ids].
    pub fn set_facet_control_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.facet_control_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dynamic_facet_spec][crate::model::ServingConfig::dynamic_facet_spec].
    pub fn set_dynamic_facet_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_request::DynamicFacetSpec>,
    {
        self.dynamic_facet_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dynamic_facet_spec][crate::model::ServingConfig::dynamic_facet_spec].
    pub fn set_or_clear_dynamic_facet_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_request::DynamicFacetSpec>,
    {
        self.dynamic_facet_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [boost_control_ids][crate::model::ServingConfig::boost_control_ids].
    pub fn set_boost_control_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.boost_control_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [filter_control_ids][crate::model::ServingConfig::filter_control_ids].
    pub fn set_filter_control_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.filter_control_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [redirect_control_ids][crate::model::ServingConfig::redirect_control_ids].
    pub fn set_redirect_control_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.redirect_control_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [twoway_synonyms_control_ids][crate::model::ServingConfig::twoway_synonyms_control_ids].
    pub fn set_twoway_synonyms_control_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.twoway_synonyms_control_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [oneway_synonyms_control_ids][crate::model::ServingConfig::oneway_synonyms_control_ids].
    pub fn set_oneway_synonyms_control_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.oneway_synonyms_control_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [do_not_associate_control_ids][crate::model::ServingConfig::do_not_associate_control_ids].
    pub fn set_do_not_associate_control_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.do_not_associate_control_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [replacement_control_ids][crate::model::ServingConfig::replacement_control_ids].
    pub fn set_replacement_control_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.replacement_control_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ignore_control_ids][crate::model::ServingConfig::ignore_control_ids].
    pub fn set_ignore_control_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ignore_control_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [diversity_level][crate::model::ServingConfig::diversity_level].
    pub fn set_diversity_level<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.diversity_level = v.into();
        self
    }

    /// Sets the value of [diversity_type][crate::model::ServingConfig::diversity_type].
    pub fn set_diversity_type<
        T: std::convert::Into<crate::model::serving_config::DiversityType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.diversity_type = v.into();
        self
    }

    /// Sets the value of [enable_category_filter_level][crate::model::ServingConfig::enable_category_filter_level].
    pub fn set_enable_category_filter_level<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_category_filter_level = v.into();
        self
    }

    /// Sets the value of [ignore_recs_denylist][crate::model::ServingConfig::ignore_recs_denylist].
    pub fn set_ignore_recs_denylist<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_recs_denylist = v.into();
        self
    }

    /// Sets the value of [personalization_spec][crate::model::ServingConfig::personalization_spec].
    pub fn set_personalization_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_request::PersonalizationSpec>,
    {
        self.personalization_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [personalization_spec][crate::model::ServingConfig::personalization_spec].
    pub fn set_or_clear_personalization_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_request::PersonalizationSpec>,
    {
        self.personalization_spec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [solution_types][crate::model::ServingConfig::solution_types].
    pub fn set_solution_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SolutionType>,
    {
        use std::iter::Iterator;
        self.solution_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ServingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ServingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ServingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __model_id,
            __price_reranking_level,
            __facet_control_ids,
            __dynamic_facet_spec,
            __boost_control_ids,
            __filter_control_ids,
            __redirect_control_ids,
            __twoway_synonyms_control_ids,
            __oneway_synonyms_control_ids,
            __do_not_associate_control_ids,
            __replacement_control_ids,
            __ignore_control_ids,
            __diversity_level,
            __diversity_type,
            __enable_category_filter_level,
            __ignore_recs_denylist,
            __personalization_spec,
            __solution_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "modelId" => Ok(__FieldTag::__model_id),
                            "model_id" => Ok(__FieldTag::__model_id),
                            "priceRerankingLevel" => Ok(__FieldTag::__price_reranking_level),
                            "price_reranking_level" => Ok(__FieldTag::__price_reranking_level),
                            "facetControlIds" => Ok(__FieldTag::__facet_control_ids),
                            "facet_control_ids" => Ok(__FieldTag::__facet_control_ids),
                            "dynamicFacetSpec" => Ok(__FieldTag::__dynamic_facet_spec),
                            "dynamic_facet_spec" => Ok(__FieldTag::__dynamic_facet_spec),
                            "boostControlIds" => Ok(__FieldTag::__boost_control_ids),
                            "boost_control_ids" => Ok(__FieldTag::__boost_control_ids),
                            "filterControlIds" => Ok(__FieldTag::__filter_control_ids),
                            "filter_control_ids" => Ok(__FieldTag::__filter_control_ids),
                            "redirectControlIds" => Ok(__FieldTag::__redirect_control_ids),
                            "redirect_control_ids" => Ok(__FieldTag::__redirect_control_ids),
                            "twowaySynonymsControlIds" => {
                                Ok(__FieldTag::__twoway_synonyms_control_ids)
                            }
                            "twoway_synonyms_control_ids" => {
                                Ok(__FieldTag::__twoway_synonyms_control_ids)
                            }
                            "onewaySynonymsControlIds" => {
                                Ok(__FieldTag::__oneway_synonyms_control_ids)
                            }
                            "oneway_synonyms_control_ids" => {
                                Ok(__FieldTag::__oneway_synonyms_control_ids)
                            }
                            "doNotAssociateControlIds" => {
                                Ok(__FieldTag::__do_not_associate_control_ids)
                            }
                            "do_not_associate_control_ids" => {
                                Ok(__FieldTag::__do_not_associate_control_ids)
                            }
                            "replacementControlIds" => Ok(__FieldTag::__replacement_control_ids),
                            "replacement_control_ids" => Ok(__FieldTag::__replacement_control_ids),
                            "ignoreControlIds" => Ok(__FieldTag::__ignore_control_ids),
                            "ignore_control_ids" => Ok(__FieldTag::__ignore_control_ids),
                            "diversityLevel" => Ok(__FieldTag::__diversity_level),
                            "diversity_level" => Ok(__FieldTag::__diversity_level),
                            "diversityType" => Ok(__FieldTag::__diversity_type),
                            "diversity_type" => Ok(__FieldTag::__diversity_type),
                            "enableCategoryFilterLevel" => {
                                Ok(__FieldTag::__enable_category_filter_level)
                            }
                            "enable_category_filter_level" => {
                                Ok(__FieldTag::__enable_category_filter_level)
                            }
                            "ignoreRecsDenylist" => Ok(__FieldTag::__ignore_recs_denylist),
                            "ignore_recs_denylist" => Ok(__FieldTag::__ignore_recs_denylist),
                            "personalizationSpec" => Ok(__FieldTag::__personalization_spec),
                            "personalization_spec" => Ok(__FieldTag::__personalization_spec),
                            "solutionTypes" => Ok(__FieldTag::__solution_types),
                            "solution_types" => Ok(__FieldTag::__solution_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ServingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model_id => {
                            if !fields.insert(__FieldTag::__model_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_id",
                                ));
                            }
                            result.model_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__price_reranking_level => {
                            if !fields.insert(__FieldTag::__price_reranking_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for price_reranking_level",
                                ));
                            }
                            result.price_reranking_level = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__facet_control_ids => {
                            if !fields.insert(__FieldTag::__facet_control_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for facet_control_ids",
                                ));
                            }
                            result.facet_control_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__dynamic_facet_spec => {
                            if !fields.insert(__FieldTag::__dynamic_facet_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dynamic_facet_spec",
                                ));
                            }
                            result.dynamic_facet_spec = map.next_value::<std::option::Option<
                                crate::model::search_request::DynamicFacetSpec,
                            >>()?;
                        }
                        __FieldTag::__boost_control_ids => {
                            if !fields.insert(__FieldTag::__boost_control_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boost_control_ids",
                                ));
                            }
                            result.boost_control_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__filter_control_ids => {
                            if !fields.insert(__FieldTag::__filter_control_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter_control_ids",
                                ));
                            }
                            result.filter_control_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__redirect_control_ids => {
                            if !fields.insert(__FieldTag::__redirect_control_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redirect_control_ids",
                                ));
                            }
                            result.redirect_control_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__twoway_synonyms_control_ids => {
                            if !fields.insert(__FieldTag::__twoway_synonyms_control_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for twoway_synonyms_control_ids",
                                ));
                            }
                            result.twoway_synonyms_control_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__oneway_synonyms_control_ids => {
                            if !fields.insert(__FieldTag::__oneway_synonyms_control_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oneway_synonyms_control_ids",
                                ));
                            }
                            result.oneway_synonyms_control_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__do_not_associate_control_ids => {
                            if !fields.insert(__FieldTag::__do_not_associate_control_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for do_not_associate_control_ids",
                                ));
                            }
                            result.do_not_associate_control_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__replacement_control_ids => {
                            if !fields.insert(__FieldTag::__replacement_control_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replacement_control_ids",
                                ));
                            }
                            result.replacement_control_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__ignore_control_ids => {
                            if !fields.insert(__FieldTag::__ignore_control_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_control_ids",
                                ));
                            }
                            result.ignore_control_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__diversity_level => {
                            if !fields.insert(__FieldTag::__diversity_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for diversity_level",
                                ));
                            }
                            result.diversity_level = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__diversity_type => {
                            if !fields.insert(__FieldTag::__diversity_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for diversity_type",
                                ));
                            }
                            result.diversity_type =
                                map.next_value::<std::option::Option<
                                    crate::model::serving_config::DiversityType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_category_filter_level => {
                            if !fields.insert(__FieldTag::__enable_category_filter_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_category_filter_level",
                                ));
                            }
                            result.enable_category_filter_level = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore_recs_denylist => {
                            if !fields.insert(__FieldTag::__ignore_recs_denylist) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_recs_denylist",
                                ));
                            }
                            result.ignore_recs_denylist = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__personalization_spec => {
                            if !fields.insert(__FieldTag::__personalization_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for personalization_spec",
                                ));
                            }
                            result.personalization_spec = map.next_value::<std::option::Option<
                                crate::model::search_request::PersonalizationSpec,
                            >>()?;
                        }
                        __FieldTag::__solution_types => {
                            if !fields.insert(__FieldTag::__solution_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for solution_types",
                                ));
                            }
                            result.solution_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SolutionType>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ServingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.model_id.is_empty() {
            state.serialize_entry("modelId", &self.model_id)?;
        }
        if !self.price_reranking_level.is_empty() {
            state.serialize_entry("priceRerankingLevel", &self.price_reranking_level)?;
        }
        if !self.facet_control_ids.is_empty() {
            state.serialize_entry("facetControlIds", &self.facet_control_ids)?;
        }
        if self.dynamic_facet_spec.is_some() {
            state.serialize_entry("dynamicFacetSpec", &self.dynamic_facet_spec)?;
        }
        if !self.boost_control_ids.is_empty() {
            state.serialize_entry("boostControlIds", &self.boost_control_ids)?;
        }
        if !self.filter_control_ids.is_empty() {
            state.serialize_entry("filterControlIds", &self.filter_control_ids)?;
        }
        if !self.redirect_control_ids.is_empty() {
            state.serialize_entry("redirectControlIds", &self.redirect_control_ids)?;
        }
        if !self.twoway_synonyms_control_ids.is_empty() {
            state.serialize_entry(
                "twowaySynonymsControlIds",
                &self.twoway_synonyms_control_ids,
            )?;
        }
        if !self.oneway_synonyms_control_ids.is_empty() {
            state.serialize_entry(
                "onewaySynonymsControlIds",
                &self.oneway_synonyms_control_ids,
            )?;
        }
        if !self.do_not_associate_control_ids.is_empty() {
            state.serialize_entry(
                "doNotAssociateControlIds",
                &self.do_not_associate_control_ids,
            )?;
        }
        if !self.replacement_control_ids.is_empty() {
            state.serialize_entry("replacementControlIds", &self.replacement_control_ids)?;
        }
        if !self.ignore_control_ids.is_empty() {
            state.serialize_entry("ignoreControlIds", &self.ignore_control_ids)?;
        }
        if !self.diversity_level.is_empty() {
            state.serialize_entry("diversityLevel", &self.diversity_level)?;
        }
        if !wkt::internal::is_default(&self.diversity_type) {
            state.serialize_entry("diversityType", &self.diversity_type)?;
        }
        if !self.enable_category_filter_level.is_empty() {
            state.serialize_entry(
                "enableCategoryFilterLevel",
                &self.enable_category_filter_level,
            )?;
        }
        if !wkt::internal::is_default(&self.ignore_recs_denylist) {
            state.serialize_entry("ignoreRecsDenylist", &self.ignore_recs_denylist)?;
        }
        if self.personalization_spec.is_some() {
            state.serialize_entry("personalizationSpec", &self.personalization_spec)?;
        }
        if !self.solution_types.is_empty() {
            state.serialize_entry("solutionTypes", &self.solution_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ServingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ServingConfig");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("model_id", &self.model_id);
        debug_struct.field("price_reranking_level", &self.price_reranking_level);
        debug_struct.field("facet_control_ids", &self.facet_control_ids);
        debug_struct.field("dynamic_facet_spec", &self.dynamic_facet_spec);
        debug_struct.field("boost_control_ids", &self.boost_control_ids);
        debug_struct.field("filter_control_ids", &self.filter_control_ids);
        debug_struct.field("redirect_control_ids", &self.redirect_control_ids);
        debug_struct.field(
            "twoway_synonyms_control_ids",
            &self.twoway_synonyms_control_ids,
        );
        debug_struct.field(
            "oneway_synonyms_control_ids",
            &self.oneway_synonyms_control_ids,
        );
        debug_struct.field(
            "do_not_associate_control_ids",
            &self.do_not_associate_control_ids,
        );
        debug_struct.field("replacement_control_ids", &self.replacement_control_ids);
        debug_struct.field("ignore_control_ids", &self.ignore_control_ids);
        debug_struct.field("diversity_level", &self.diversity_level);
        debug_struct.field("diversity_type", &self.diversity_type);
        debug_struct.field(
            "enable_category_filter_level",
            &self.enable_category_filter_level,
        );
        debug_struct.field("ignore_recs_denylist", &self.ignore_recs_denylist);
        debug_struct.field("personalization_spec", &self.personalization_spec);
        debug_struct.field("solution_types", &self.solution_types);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ServingConfig].
pub mod serving_config {
    #[allow(unused_imports)]
    use super::*;

    /// What type of diversity - data or rule based.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DiversityType {
        /// Default value.
        Unspecified,
        /// Rule based diversity.
        RuleBasedDiversity,
        /// Data driven diversity.
        DataDrivenDiversity,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DiversityType::value] or
        /// [DiversityType::name].
        UnknownValue(diversity_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod diversity_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DiversityType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::RuleBasedDiversity => std::option::Option::Some(2),
                Self::DataDrivenDiversity => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DIVERSITY_TYPE_UNSPECIFIED"),
                Self::RuleBasedDiversity => std::option::Option::Some("RULE_BASED_DIVERSITY"),
                Self::DataDrivenDiversity => std::option::Option::Some("DATA_DRIVEN_DIVERSITY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DiversityType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DiversityType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DiversityType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::RuleBasedDiversity,
                3 => Self::DataDrivenDiversity,
                _ => Self::UnknownValue(diversity_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DiversityType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DIVERSITY_TYPE_UNSPECIFIED" => Self::Unspecified,
                "RULE_BASED_DIVERSITY" => Self::RuleBasedDiversity,
                "DATA_DRIVEN_DIVERSITY" => Self::DataDrivenDiversity,
                _ => Self::UnknownValue(diversity_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DiversityType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::RuleBasedDiversity => serializer.serialize_i32(2),
                Self::DataDrivenDiversity => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DiversityType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DiversityType>::new(
                ".google.cloud.retail.v2.ServingConfig.DiversityType",
            ))
        }
    }
}

/// Request for CreateServingConfig method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateServingConfigRequest {
    /// Required. Full resource name of parent. Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}`
    pub parent: std::string::String,

    /// Required. The ServingConfig to create.
    pub serving_config: std::option::Option<crate::model::ServingConfig>,

    /// Required. The ID to use for the ServingConfig, which will become the final
    /// component of the ServingConfig's resource name.
    ///
    /// This value should be 4-63 characters, and valid characters
    /// are /[a-z][0-9]-_/.
    pub serving_config_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateServingConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateServingConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [serving_config][crate::model::CreateServingConfigRequest::serving_config].
    pub fn set_serving_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ServingConfig>,
    {
        self.serving_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [serving_config][crate::model::CreateServingConfigRequest::serving_config].
    pub fn set_or_clear_serving_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ServingConfig>,
    {
        self.serving_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [serving_config_id][crate::model::CreateServingConfigRequest::serving_config_id].
    pub fn set_serving_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.serving_config_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateServingConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.CreateServingConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateServingConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __serving_config,
            __serving_config_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateServingConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "servingConfig" => Ok(__FieldTag::__serving_config),
                            "serving_config" => Ok(__FieldTag::__serving_config),
                            "servingConfigId" => Ok(__FieldTag::__serving_config_id),
                            "serving_config_id" => Ok(__FieldTag::__serving_config_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateServingConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateServingConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__serving_config => {
                            if !fields.insert(__FieldTag::__serving_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serving_config",
                                ));
                            }
                            result.serving_config = map
                                .next_value::<std::option::Option<crate::model::ServingConfig>>()?;
                        }
                        __FieldTag::__serving_config_id => {
                            if !fields.insert(__FieldTag::__serving_config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serving_config_id",
                                ));
                            }
                            result.serving_config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateServingConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.serving_config.is_some() {
            state.serialize_entry("servingConfig", &self.serving_config)?;
        }
        if !self.serving_config_id.is_empty() {
            state.serialize_entry("servingConfigId", &self.serving_config_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateServingConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateServingConfigRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("serving_config", &self.serving_config);
        debug_struct.field("serving_config_id", &self.serving_config_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for UpdateServingConfig method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateServingConfigRequest {
    /// Required. The ServingConfig to update.
    pub serving_config: std::option::Option<crate::model::ServingConfig>,

    /// Indicates which fields in the provided
    /// [ServingConfig][google.cloud.retail.v2.ServingConfig] to update. The
    /// following are NOT supported:
    ///
    /// * [ServingConfig.name][google.cloud.retail.v2.ServingConfig.name]
    ///
    /// If not set, all supported fields are updated.
    ///
    /// [google.cloud.retail.v2.ServingConfig]: crate::model::ServingConfig
    /// [google.cloud.retail.v2.ServingConfig.name]: crate::model::ServingConfig::name
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateServingConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [serving_config][crate::model::UpdateServingConfigRequest::serving_config].
    pub fn set_serving_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ServingConfig>,
    {
        self.serving_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [serving_config][crate::model::UpdateServingConfigRequest::serving_config].
    pub fn set_or_clear_serving_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ServingConfig>,
    {
        self.serving_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateServingConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateServingConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateServingConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.UpdateServingConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateServingConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __serving_config,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateServingConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "servingConfig" => Ok(__FieldTag::__serving_config),
                            "serving_config" => Ok(__FieldTag::__serving_config),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateServingConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateServingConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__serving_config => {
                            if !fields.insert(__FieldTag::__serving_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serving_config",
                                ));
                            }
                            result.serving_config = map
                                .next_value::<std::option::Option<crate::model::ServingConfig>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateServingConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.serving_config.is_some() {
            state.serialize_entry("servingConfig", &self.serving_config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateServingConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateServingConfigRequest");
        debug_struct.field("serving_config", &self.serving_config);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for DeleteServingConfig method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteServingConfigRequest {
    /// Required. The resource name of the ServingConfig to delete. Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}/servingConfigs/{serving_config_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteServingConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteServingConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteServingConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.DeleteServingConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteServingConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteServingConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteServingConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteServingConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteServingConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteServingConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteServingConfigRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for GetServingConfig method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetServingConfigRequest {
    /// Required. The resource name of the ServingConfig to get. Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}/servingConfigs/{serving_config_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetServingConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetServingConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetServingConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.GetServingConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetServingConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetServingConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetServingConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetServingConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetServingConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetServingConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetServingConfigRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for ListServingConfigs method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListServingConfigsRequest {
    /// Required. The catalog resource name. Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}`
    pub parent: std::string::String,

    /// Optional. Maximum number of results to return. If unspecified, defaults
    /// to 100. If a value greater than 100 is provided, at most 100 results are
    /// returned.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListServingConfigs` call.
    /// Provide this to retrieve the subsequent page.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServingConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListServingConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListServingConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListServingConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListServingConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ListServingConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListServingConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListServingConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListServingConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListServingConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListServingConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListServingConfigsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListServingConfigsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for ListServingConfigs method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListServingConfigsResponse {
    /// All the ServingConfigs for a given catalog.
    pub serving_configs: std::vec::Vec<crate::model::ServingConfig>,

    /// Pagination token, if not returned indicates the last page.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServingConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [serving_configs][crate::model::ListServingConfigsResponse::serving_configs].
    pub fn set_serving_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ServingConfig>,
    {
        use std::iter::Iterator;
        self.serving_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListServingConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListServingConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ListServingConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListServingConfigsResponse {
    type PageItem = crate::model::ServingConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.serving_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListServingConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __serving_configs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListServingConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "servingConfigs" => Ok(__FieldTag::__serving_configs),
                            "serving_configs" => Ok(__FieldTag::__serving_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListServingConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListServingConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__serving_configs => {
                            if !fields.insert(__FieldTag::__serving_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serving_configs",
                                ));
                            }
                            result.serving_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ServingConfig>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListServingConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.serving_configs.is_empty() {
            state.serialize_entry("servingConfigs", &self.serving_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListServingConfigsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListServingConfigsResponse");
        debug_struct.field("serving_configs", &self.serving_configs);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for AddControl method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AddControlRequest {
    /// Required. The source ServingConfig resource name . Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}/servingConfigs/{serving_config_id}`
    pub serving_config: std::string::String,

    /// Required. The id of the control to apply. Assumed to be in the same catalog
    /// as the serving config - if id is not found a NOT_FOUND error is returned.
    pub control_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddControlRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [serving_config][crate::model::AddControlRequest::serving_config].
    pub fn set_serving_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.serving_config = v.into();
        self
    }

    /// Sets the value of [control_id][crate::model::AddControlRequest::control_id].
    pub fn set_control_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.control_id = v.into();
        self
    }
}

impl wkt::message::Message for AddControlRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.AddControlRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AddControlRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __serving_config,
            __control_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AddControlRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "servingConfig" => Ok(__FieldTag::__serving_config),
                            "serving_config" => Ok(__FieldTag::__serving_config),
                            "controlId" => Ok(__FieldTag::__control_id),
                            "control_id" => Ok(__FieldTag::__control_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AddControlRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AddControlRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__serving_config => {
                            if !fields.insert(__FieldTag::__serving_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serving_config",
                                ));
                            }
                            result.serving_config = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__control_id => {
                            if !fields.insert(__FieldTag::__control_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for control_id",
                                ));
                            }
                            result.control_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AddControlRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.serving_config.is_empty() {
            state.serialize_entry("servingConfig", &self.serving_config)?;
        }
        if !self.control_id.is_empty() {
            state.serialize_entry("controlId", &self.control_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AddControlRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AddControlRequest");
        debug_struct.field("serving_config", &self.serving_config);
        debug_struct.field("control_id", &self.control_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for RemoveControl method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoveControlRequest {
    /// Required. The source ServingConfig resource name . Format:
    /// `projects/{project_number}/locations/{location_id}/catalogs/{catalog_id}/servingConfigs/{serving_config_id}`
    pub serving_config: std::string::String,

    /// Required. The id of the control to apply. Assumed to be in the same catalog
    /// as the serving config.
    pub control_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveControlRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [serving_config][crate::model::RemoveControlRequest::serving_config].
    pub fn set_serving_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.serving_config = v.into();
        self
    }

    /// Sets the value of [control_id][crate::model::RemoveControlRequest::control_id].
    pub fn set_control_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.control_id = v.into();
        self
    }
}

impl wkt::message::Message for RemoveControlRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.RemoveControlRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RemoveControlRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __serving_config,
            __control_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RemoveControlRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "servingConfig" => Ok(__FieldTag::__serving_config),
                            "serving_config" => Ok(__FieldTag::__serving_config),
                            "controlId" => Ok(__FieldTag::__control_id),
                            "control_id" => Ok(__FieldTag::__control_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RemoveControlRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RemoveControlRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__serving_config => {
                            if !fields.insert(__FieldTag::__serving_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serving_config",
                                ));
                            }
                            result.serving_config = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__control_id => {
                            if !fields.insert(__FieldTag::__control_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for control_id",
                                ));
                            }
                            result.control_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RemoveControlRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.serving_config.is_empty() {
            state.serialize_entry("servingConfig", &self.serving_config)?;
        }
        if !self.control_id.is_empty() {
            state.serialize_entry("controlId", &self.control_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RemoveControlRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RemoveControlRequest");
        debug_struct.field("serving_config", &self.serving_config);
        debug_struct.field("control_id", &self.control_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// UserEvent captures all metadata information Retail API needs to know about
/// how end users interact with customers' website.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UserEvent {
    /// Required. User event type. Allowed values are:
    ///
    /// * `add-to-cart`: Products being added to cart.
    /// * `remove-from-cart`: Products being removed from cart.
    /// * `category-page-view`: Special pages such as sale or promotion pages
    ///   viewed.
    /// * `detail-page-view`: Products detail page viewed.
    /// * `home-page-view`: Homepage viewed.
    /// * `purchase-complete`: User finishing a purchase.
    /// * `search`: Product search.
    /// * `shopping-cart-page-view`: User viewing a shopping cart.
    pub event_type: std::string::String,

    /// Required. A unique identifier for tracking visitors.
    ///
    /// For example, this could be implemented with an HTTP cookie, which should be
    /// able to uniquely identify a visitor on a single device. This unique
    /// identifier should not change if the visitor log in/out of the website.
    ///
    /// Don't set the field to the same fixed ID for different users. This mixes
    /// the event history of those users together, which results in degraded model
    /// quality.
    ///
    /// The field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// The field should not contain PII or user-data. We recommend to use Google
    /// Analytics [Client
    /// ID](https://developers.google.com/analytics/devguides/collection/analyticsjs/field-reference#clientId)
    /// for this field.
    pub visitor_id: std::string::String,

    /// A unique identifier for tracking a visitor session with a length limit of
    /// 128 bytes. A session is an aggregation of an end user behavior in a time
    /// span.
    ///
    /// A general guideline to populate the session_id:
    ///
    /// 1. If user has no activity for 30 min, a new session_id should be assigned.
    /// 1. The session_id should be unique across users, suggest use uuid or add
    ///    visitor_id as prefix.
    pub session_id: std::string::String,

    /// Only required for
    /// [UserEventService.ImportUserEvents][google.cloud.retail.v2.UserEventService.ImportUserEvents]
    /// method. Timestamp of when the user event happened.
    ///
    /// [google.cloud.retail.v2.UserEventService.ImportUserEvents]: crate::client::UserEventService::import_user_events
    pub event_time: std::option::Option<wkt::Timestamp>,

    /// A list of identifiers for the independent experiment groups this user event
    /// belongs to. This is used to distinguish between user events associated with
    /// different experiment setups (e.g. using Retail API, using different
    /// recommendation models).
    pub experiment_ids: std::vec::Vec<std::string::String>,

    /// Highly recommended for user events that are the result of
    /// [PredictionService.Predict][google.cloud.retail.v2.PredictionService.Predict].
    /// This field enables accurate attribution of recommendation model
    /// performance.
    ///
    /// The value must be a valid
    /// [PredictResponse.attribution_token][google.cloud.retail.v2.PredictResponse.attribution_token]
    /// for user events that are the result of
    /// [PredictionService.Predict][google.cloud.retail.v2.PredictionService.Predict].
    /// The value must be a valid
    /// [SearchResponse.attribution_token][google.cloud.retail.v2.SearchResponse.attribution_token]
    /// for user events that are the result of
    /// [SearchService.Search][google.cloud.retail.v2.SearchService.Search].
    ///
    /// This token enables us to accurately attribute page view or purchase back to
    /// the event and the particular predict response containing this
    /// clicked/purchased product. If user clicks on product K in the
    /// recommendation results, pass
    /// [PredictResponse.attribution_token][google.cloud.retail.v2.PredictResponse.attribution_token]
    /// as a URL parameter to product K's page. When recording events on product
    /// K's page, log the
    /// [PredictResponse.attribution_token][google.cloud.retail.v2.PredictResponse.attribution_token]
    /// to this field.
    ///
    /// [google.cloud.retail.v2.PredictResponse.attribution_token]: crate::model::PredictResponse::attribution_token
    /// [google.cloud.retail.v2.PredictionService.Predict]: crate::client::PredictionService::predict
    /// [google.cloud.retail.v2.SearchResponse.attribution_token]: crate::model::SearchResponse::attribution_token
    /// [google.cloud.retail.v2.SearchService.Search]: crate::client::SearchService::search
    pub attribution_token: std::string::String,

    /// The main product details related to the event.
    ///
    /// This field is optional except for the following event types:
    ///
    /// * `add-to-cart`
    /// * `detail-page-view`
    /// * `purchase-complete`
    ///
    /// In a `search` event, this field represents the products returned to the end
    /// user on the current page (the end user may have not finished browsing the
    /// whole page yet). When a new page is returned to the end user, after
    /// pagination/filtering/ordering even for the same query, a new `search` event
    /// with different
    /// [product_details][google.cloud.retail.v2.UserEvent.product_details] is
    /// desired. The end user may have not finished browsing the whole page yet.
    ///
    /// [google.cloud.retail.v2.UserEvent.product_details]: crate::model::UserEvent::product_details
    pub product_details: std::vec::Vec<crate::model::ProductDetail>,

    /// The main auto-completion details related to the event.
    ///
    /// This field should be set for `search` event when autocomplete function is
    /// enabled and the user clicks a suggestion for search.
    pub completion_detail: std::option::Option<crate::model::CompletionDetail>,

    /// Extra user event features to include in the recommendation model.
    ///
    /// If you provide custom attributes for ingested user events, also include
    /// them in the user events that you associate with prediction requests. Custom
    /// attribute formatting must be consistent between imported events and events
    /// provided with prediction requests. This lets the Retail API use
    /// those custom attributes when training models and serving predictions, which
    /// helps improve recommendation quality.
    ///
    /// This field needs to pass all below criteria, otherwise an INVALID_ARGUMENT
    /// error is returned:
    ///
    /// * The key must be a UTF-8 encoded string with a length limit of 5,000
    ///   characters.
    /// * For text attributes, at most 400 values are allowed. Empty values are not
    ///   allowed. Each value must be a UTF-8 encoded string with a length limit of
    ///   256 characters.
    /// * For number attributes, at most 400 values are allowed.
    ///
    /// For product recommendations, an example of extra user information is
    /// traffic_channel, which is how a user arrives at the site. Users can arrive
    /// at the site by coming to the site directly, coming through Google
    /// search, or in other ways.
    pub attributes: std::collections::HashMap<std::string::String, crate::model::CustomAttribute>,

    /// The ID or name of the associated shopping cart. This ID is used
    /// to associate multiple items added or present in the cart before purchase.
    ///
    /// This can only be set for `add-to-cart`, `purchase-complete`, or
    /// `shopping-cart-page-view` events.
    pub cart_id: std::string::String,

    /// A transaction represents the entire purchase transaction.
    ///
    /// Required for `purchase-complete` events. Other event types should not set
    /// this field. Otherwise, an INVALID_ARGUMENT error is returned.
    pub purchase_transaction: std::option::Option<crate::model::PurchaseTransaction>,

    /// The user's search query.
    ///
    /// See [SearchRequest.query][google.cloud.retail.v2.SearchRequest.query] for
    /// definition.
    ///
    /// The value must be a UTF-8 encoded string with a length limit of 5,000
    /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// At least one of
    /// [search_query][google.cloud.retail.v2.UserEvent.search_query] or
    /// [page_categories][google.cloud.retail.v2.UserEvent.page_categories] is
    /// required for `search` events. Other event types should not set this field.
    /// Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// [google.cloud.retail.v2.SearchRequest.query]: crate::model::SearchRequest::query
    /// [google.cloud.retail.v2.UserEvent.page_categories]: crate::model::UserEvent::page_categories
    /// [google.cloud.retail.v2.UserEvent.search_query]: crate::model::UserEvent::search_query
    pub search_query: std::string::String,

    /// The filter syntax consists of an expression language for constructing a
    /// predicate from one or more fields of the products being filtered.
    ///
    /// See [SearchRequest.filter][google.cloud.retail.v2.SearchRequest.filter] for
    /// definition and syntax.
    ///
    /// The value must be a UTF-8 encoded string with a length limit of 1,000
    /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// [google.cloud.retail.v2.SearchRequest.filter]: crate::model::SearchRequest::filter
    pub filter: std::string::String,

    /// The order in which products are returned.
    ///
    /// See [SearchRequest.order_by][google.cloud.retail.v2.SearchRequest.order_by]
    /// for definition and syntax.
    ///
    /// The value must be a UTF-8 encoded string with a length limit of 1,000
    /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// This can only be set for `search` events. Other event types should not set
    /// this field. Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// [google.cloud.retail.v2.SearchRequest.order_by]: crate::model::SearchRequest::order_by
    pub order_by: std::string::String,

    /// An integer that specifies the current offset for pagination (the 0-indexed
    /// starting location, amongst the products deemed by the API as relevant).
    ///
    /// See [SearchRequest.offset][google.cloud.retail.v2.SearchRequest.offset] for
    /// definition.
    ///
    /// If this field is negative, an INVALID_ARGUMENT is returned.
    ///
    /// This can only be set for `search` events. Other event types should not set
    /// this field. Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// [google.cloud.retail.v2.SearchRequest.offset]: crate::model::SearchRequest::offset
    pub offset: i32,

    /// The categories associated with a category page.
    ///
    /// To represent full path of category, use '>' sign to separate different
    /// hierarchies. If '>' is part of the category name, replace it with
    /// other character(s).
    ///
    /// Category pages include special pages such as sales or promotions. For
    /// instance, a special sale page may have the category hierarchy:
    /// "pageCategories" : ["Sales > 2017 Black Friday Deals"].
    ///
    /// Required for `category-page-view` events. At least one of
    /// [search_query][google.cloud.retail.v2.UserEvent.search_query] or
    /// [page_categories][google.cloud.retail.v2.UserEvent.page_categories] is
    /// required for `search` events. Other event types should not set this field.
    /// Otherwise, an INVALID_ARGUMENT error is returned.
    ///
    /// [google.cloud.retail.v2.UserEvent.page_categories]: crate::model::UserEvent::page_categories
    /// [google.cloud.retail.v2.UserEvent.search_query]: crate::model::UserEvent::search_query
    pub page_categories: std::vec::Vec<std::string::String>,

    /// User information.
    pub user_info: std::option::Option<crate::model::UserInfo>,

    /// Complete URL (window.location.href) of the user's current page.
    ///
    /// When using the client side event reporting with JavaScript pixel and Google
    /// Tag Manager, this value is filled in automatically. Maximum length 5,000
    /// characters.
    pub uri: std::string::String,

    /// The referrer URL of the current page.
    ///
    /// When using the client side event reporting with JavaScript pixel and Google
    /// Tag Manager, this value is filled in automatically.
    pub referrer_uri: std::string::String,

    /// A unique ID of a web page view.
    ///
    /// This should be kept the same for all user events triggered from the same
    /// pageview. For example, an item detail page view could trigger multiple
    /// events as the user is browsing the page. The `pageViewId` property should
    /// be kept the same for all these events so that they can be grouped together
    /// properly.
    ///
    /// When using the client side event reporting with JavaScript pixel and Google
    /// Tag Manager, this value is filled in automatically.
    pub page_view_id: std::string::String,

    /// The entity for customers that may run multiple different entities, domains,
    /// sites or regions, for example, `Google US`, `Google Ads`, `Waymo`,
    /// `google.com`, `youtube.com`, etc.
    /// We recommend that you set this field to get better per-entity search,
    /// completion, and prediction results.
    pub entity: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [event_type][crate::model::UserEvent::event_type].
    pub fn set_event_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.event_type = v.into();
        self
    }

    /// Sets the value of [visitor_id][crate::model::UserEvent::visitor_id].
    pub fn set_visitor_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.visitor_id = v.into();
        self
    }

    /// Sets the value of [session_id][crate::model::UserEvent::session_id].
    pub fn set_session_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.session_id = v.into();
        self
    }

    /// Sets the value of [event_time][crate::model::UserEvent::event_time].
    pub fn set_event_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [event_time][crate::model::UserEvent::event_time].
    pub fn set_or_clear_event_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.event_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [experiment_ids][crate::model::UserEvent::experiment_ids].
    pub fn set_experiment_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.experiment_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [attribution_token][crate::model::UserEvent::attribution_token].
    pub fn set_attribution_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.attribution_token = v.into();
        self
    }

    /// Sets the value of [product_details][crate::model::UserEvent::product_details].
    pub fn set_product_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ProductDetail>,
    {
        use std::iter::Iterator;
        self.product_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [completion_detail][crate::model::UserEvent::completion_detail].
    pub fn set_completion_detail<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CompletionDetail>,
    {
        self.completion_detail = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [completion_detail][crate::model::UserEvent::completion_detail].
    pub fn set_or_clear_completion_detail<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CompletionDetail>,
    {
        self.completion_detail = v.map(|x| x.into());
        self
    }

    /// Sets the value of [attributes][crate::model::UserEvent::attributes].
    pub fn set_attributes<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::CustomAttribute>,
    {
        use std::iter::Iterator;
        self.attributes = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [cart_id][crate::model::UserEvent::cart_id].
    pub fn set_cart_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cart_id = v.into();
        self
    }

    /// Sets the value of [purchase_transaction][crate::model::UserEvent::purchase_transaction].
    pub fn set_purchase_transaction<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PurchaseTransaction>,
    {
        self.purchase_transaction = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [purchase_transaction][crate::model::UserEvent::purchase_transaction].
    pub fn set_or_clear_purchase_transaction<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PurchaseTransaction>,
    {
        self.purchase_transaction = v.map(|x| x.into());
        self
    }

    /// Sets the value of [search_query][crate::model::UserEvent::search_query].
    pub fn set_search_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.search_query = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::UserEvent::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::UserEvent::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [offset][crate::model::UserEvent::offset].
    pub fn set_offset<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.offset = v.into();
        self
    }

    /// Sets the value of [page_categories][crate::model::UserEvent::page_categories].
    pub fn set_page_categories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.page_categories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [user_info][crate::model::UserEvent::user_info].
    pub fn set_user_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserInfo>,
    {
        self.user_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user_info][crate::model::UserEvent::user_info].
    pub fn set_or_clear_user_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserInfo>,
    {
        self.user_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [uri][crate::model::UserEvent::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [referrer_uri][crate::model::UserEvent::referrer_uri].
    pub fn set_referrer_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.referrer_uri = v.into();
        self
    }

    /// Sets the value of [page_view_id][crate::model::UserEvent::page_view_id].
    pub fn set_page_view_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_view_id = v.into();
        self
    }

    /// Sets the value of [entity][crate::model::UserEvent::entity].
    pub fn set_entity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity = v.into();
        self
    }
}

impl wkt::message::Message for UserEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.UserEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UserEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __event_type,
            __visitor_id,
            __session_id,
            __event_time,
            __experiment_ids,
            __attribution_token,
            __product_details,
            __completion_detail,
            __attributes,
            __cart_id,
            __purchase_transaction,
            __search_query,
            __filter,
            __order_by,
            __offset,
            __page_categories,
            __user_info,
            __uri,
            __referrer_uri,
            __page_view_id,
            __entity,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UserEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "eventType" => Ok(__FieldTag::__event_type),
                            "event_type" => Ok(__FieldTag::__event_type),
                            "visitorId" => Ok(__FieldTag::__visitor_id),
                            "visitor_id" => Ok(__FieldTag::__visitor_id),
                            "sessionId" => Ok(__FieldTag::__session_id),
                            "session_id" => Ok(__FieldTag::__session_id),
                            "eventTime" => Ok(__FieldTag::__event_time),
                            "event_time" => Ok(__FieldTag::__event_time),
                            "experimentIds" => Ok(__FieldTag::__experiment_ids),
                            "experiment_ids" => Ok(__FieldTag::__experiment_ids),
                            "attributionToken" => Ok(__FieldTag::__attribution_token),
                            "attribution_token" => Ok(__FieldTag::__attribution_token),
                            "productDetails" => Ok(__FieldTag::__product_details),
                            "product_details" => Ok(__FieldTag::__product_details),
                            "completionDetail" => Ok(__FieldTag::__completion_detail),
                            "completion_detail" => Ok(__FieldTag::__completion_detail),
                            "attributes" => Ok(__FieldTag::__attributes),
                            "cartId" => Ok(__FieldTag::__cart_id),
                            "cart_id" => Ok(__FieldTag::__cart_id),
                            "purchaseTransaction" => Ok(__FieldTag::__purchase_transaction),
                            "purchase_transaction" => Ok(__FieldTag::__purchase_transaction),
                            "searchQuery" => Ok(__FieldTag::__search_query),
                            "search_query" => Ok(__FieldTag::__search_query),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "offset" => Ok(__FieldTag::__offset),
                            "pageCategories" => Ok(__FieldTag::__page_categories),
                            "page_categories" => Ok(__FieldTag::__page_categories),
                            "userInfo" => Ok(__FieldTag::__user_info),
                            "user_info" => Ok(__FieldTag::__user_info),
                            "uri" => Ok(__FieldTag::__uri),
                            "referrerUri" => Ok(__FieldTag::__referrer_uri),
                            "referrer_uri" => Ok(__FieldTag::__referrer_uri),
                            "pageViewId" => Ok(__FieldTag::__page_view_id),
                            "page_view_id" => Ok(__FieldTag::__page_view_id),
                            "entity" => Ok(__FieldTag::__entity),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UserEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UserEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__event_type => {
                            if !fields.insert(__FieldTag::__event_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_type",
                                ));
                            }
                            result.event_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__visitor_id => {
                            if !fields.insert(__FieldTag::__visitor_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for visitor_id",
                                ));
                            }
                            result.visitor_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__session_id => {
                            if !fields.insert(__FieldTag::__session_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_id",
                                ));
                            }
                            result.session_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__event_time => {
                            if !fields.insert(__FieldTag::__event_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_time",
                                ));
                            }
                            result.event_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__experiment_ids => {
                            if !fields.insert(__FieldTag::__experiment_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for experiment_ids",
                                ));
                            }
                            result.experiment_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__attribution_token => {
                            if !fields.insert(__FieldTag::__attribution_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attribution_token",
                                ));
                            }
                            result.attribution_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__product_details => {
                            if !fields.insert(__FieldTag::__product_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product_details",
                                ));
                            }
                            result.product_details = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ProductDetail>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__completion_detail => {
                            if !fields.insert(__FieldTag::__completion_detail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completion_detail",
                                ));
                            }
                            result.completion_detail = map
                                .next_value::<std::option::Option<crate::model::CompletionDetail>>(
                                )?;
                        }
                        __FieldTag::__attributes => {
                            if !fields.insert(__FieldTag::__attributes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attributes",
                                ));
                            }
                            result.attributes = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::CustomAttribute,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cart_id => {
                            if !fields.insert(__FieldTag::__cart_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cart_id",
                                ));
                            }
                            result.cart_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__purchase_transaction => {
                            if !fields.insert(__FieldTag::__purchase_transaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for purchase_transaction",
                                ));
                            }
                            result.purchase_transaction = map.next_value::<std::option::Option<crate::model::PurchaseTransaction>>()?
                                ;
                        }
                        __FieldTag::__search_query => {
                            if !fields.insert(__FieldTag::__search_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for search_query",
                                ));
                            }
                            result.search_query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__offset => {
                            if !fields.insert(__FieldTag::__offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for offset",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.offset = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_categories => {
                            if !fields.insert(__FieldTag::__page_categories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_categories",
                                ));
                            }
                            result.page_categories = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__user_info => {
                            if !fields.insert(__FieldTag::__user_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_info",
                                ));
                            }
                            result.user_info =
                                map.next_value::<std::option::Option<crate::model::UserInfo>>()?;
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__referrer_uri => {
                            if !fields.insert(__FieldTag::__referrer_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for referrer_uri",
                                ));
                            }
                            result.referrer_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_view_id => {
                            if !fields.insert(__FieldTag::__page_view_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_view_id",
                                ));
                            }
                            result.page_view_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity => {
                            if !fields.insert(__FieldTag::__entity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity",
                                ));
                            }
                            result.entity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UserEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.event_type.is_empty() {
            state.serialize_entry("eventType", &self.event_type)?;
        }
        if !self.visitor_id.is_empty() {
            state.serialize_entry("visitorId", &self.visitor_id)?;
        }
        if !self.session_id.is_empty() {
            state.serialize_entry("sessionId", &self.session_id)?;
        }
        if self.event_time.is_some() {
            state.serialize_entry("eventTime", &self.event_time)?;
        }
        if !self.experiment_ids.is_empty() {
            state.serialize_entry("experimentIds", &self.experiment_ids)?;
        }
        if !self.attribution_token.is_empty() {
            state.serialize_entry("attributionToken", &self.attribution_token)?;
        }
        if !self.product_details.is_empty() {
            state.serialize_entry("productDetails", &self.product_details)?;
        }
        if self.completion_detail.is_some() {
            state.serialize_entry("completionDetail", &self.completion_detail)?;
        }
        if !self.attributes.is_empty() {
            state.serialize_entry("attributes", &self.attributes)?;
        }
        if !self.cart_id.is_empty() {
            state.serialize_entry("cartId", &self.cart_id)?;
        }
        if self.purchase_transaction.is_some() {
            state.serialize_entry("purchaseTransaction", &self.purchase_transaction)?;
        }
        if !self.search_query.is_empty() {
            state.serialize_entry("searchQuery", &self.search_query)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !wkt::internal::is_default(&self.offset) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("offset", &__With(&self.offset))?;
        }
        if !self.page_categories.is_empty() {
            state.serialize_entry("pageCategories", &self.page_categories)?;
        }
        if self.user_info.is_some() {
            state.serialize_entry("userInfo", &self.user_info)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.referrer_uri.is_empty() {
            state.serialize_entry("referrerUri", &self.referrer_uri)?;
        }
        if !self.page_view_id.is_empty() {
            state.serialize_entry("pageViewId", &self.page_view_id)?;
        }
        if !self.entity.is_empty() {
            state.serialize_entry("entity", &self.entity)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UserEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UserEvent");
        debug_struct.field("event_type", &self.event_type);
        debug_struct.field("visitor_id", &self.visitor_id);
        debug_struct.field("session_id", &self.session_id);
        debug_struct.field("event_time", &self.event_time);
        debug_struct.field("experiment_ids", &self.experiment_ids);
        debug_struct.field("attribution_token", &self.attribution_token);
        debug_struct.field("product_details", &self.product_details);
        debug_struct.field("completion_detail", &self.completion_detail);
        debug_struct.field("attributes", &self.attributes);
        debug_struct.field("cart_id", &self.cart_id);
        debug_struct.field("purchase_transaction", &self.purchase_transaction);
        debug_struct.field("search_query", &self.search_query);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        debug_struct.field("offset", &self.offset);
        debug_struct.field("page_categories", &self.page_categories);
        debug_struct.field("user_info", &self.user_info);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("referrer_uri", &self.referrer_uri);
        debug_struct.field("page_view_id", &self.page_view_id);
        debug_struct.field("entity", &self.entity);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Detailed product information associated with a user event.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProductDetail {
    /// Required. [Product][google.cloud.retail.v2.Product] information.
    ///
    /// Required field(s):
    ///
    /// * [Product.id][google.cloud.retail.v2.Product.id]
    ///
    /// Optional override field(s):
    ///
    /// * [Product.price_info][google.cloud.retail.v2.Product.price_info]
    ///
    /// If any supported optional fields are provided, we will treat them as a full
    /// override when looking up product information from the catalog. Thus, it is
    /// important to ensure that the overriding fields are accurate and
    /// complete.
    ///
    /// All other product fields are ignored and instead populated via catalog
    /// lookup after event ingestion.
    ///
    /// [google.cloud.retail.v2.Product]: crate::model::Product
    /// [google.cloud.retail.v2.Product.id]: crate::model::Product::id
    /// [google.cloud.retail.v2.Product.price_info]: crate::model::Product::price_info
    pub product: std::option::Option<crate::model::Product>,

    /// Quantity of the product associated with the user event.
    ///
    /// For example, this field will be 2 if two products are added to the shopping
    /// cart for `purchase-complete` event. Required for `add-to-cart` and
    /// `purchase-complete` event types.
    pub quantity: std::option::Option<wkt::Int32Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProductDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [product][crate::model::ProductDetail::product].
    pub fn set_product<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Product>,
    {
        self.product = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [product][crate::model::ProductDetail::product].
    pub fn set_or_clear_product<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Product>,
    {
        self.product = v.map(|x| x.into());
        self
    }

    /// Sets the value of [quantity][crate::model::ProductDetail::quantity].
    pub fn set_quantity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.quantity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [quantity][crate::model::ProductDetail::quantity].
    pub fn set_or_clear_quantity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int32Value>,
    {
        self.quantity = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ProductDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.ProductDetail"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProductDetail {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __product,
            __quantity,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProductDetail")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "product" => Ok(__FieldTag::__product),
                            "quantity" => Ok(__FieldTag::__quantity),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProductDetail;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProductDetail")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__product => {
                            if !fields.insert(__FieldTag::__product) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for product",
                                ));
                            }
                            result.product =
                                map.next_value::<std::option::Option<crate::model::Product>>()?;
                        }
                        __FieldTag::__quantity => {
                            if !fields.insert(__FieldTag::__quantity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quantity",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int32Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.quantity = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProductDetail {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.product.is_some() {
            state.serialize_entry("product", &self.product)?;
        }
        if self.quantity.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int32Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("quantity", &__With(&self.quantity))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ProductDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProductDetail");
        debug_struct.field("product", &self.product);
        debug_struct.field("quantity", &self.quantity);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Detailed completion information including completion attribution token and
/// clicked completion info.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CompletionDetail {
    /// Completion attribution token in
    /// [CompleteQueryResponse.attribution_token][google.cloud.retail.v2.CompleteQueryResponse.attribution_token].
    ///
    /// [google.cloud.retail.v2.CompleteQueryResponse.attribution_token]: crate::model::CompleteQueryResponse::attribution_token
    pub completion_attribution_token: std::string::String,

    /// End user selected
    /// [CompleteQueryResponse.CompletionResult.suggestion][google.cloud.retail.v2.CompleteQueryResponse.CompletionResult.suggestion].
    ///
    /// [google.cloud.retail.v2.CompleteQueryResponse.CompletionResult.suggestion]: crate::model::complete_query_response::CompletionResult::suggestion
    pub selected_suggestion: std::string::String,

    /// End user selected
    /// [CompleteQueryResponse.CompletionResult.suggestion][google.cloud.retail.v2.CompleteQueryResponse.CompletionResult.suggestion]
    /// position, starting from 0.
    ///
    /// [google.cloud.retail.v2.CompleteQueryResponse.CompletionResult.suggestion]: crate::model::complete_query_response::CompletionResult::suggestion
    pub selected_position: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CompletionDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [completion_attribution_token][crate::model::CompletionDetail::completion_attribution_token].
    pub fn set_completion_attribution_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.completion_attribution_token = v.into();
        self
    }

    /// Sets the value of [selected_suggestion][crate::model::CompletionDetail::selected_suggestion].
    pub fn set_selected_suggestion<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.selected_suggestion = v.into();
        self
    }

    /// Sets the value of [selected_position][crate::model::CompletionDetail::selected_position].
    pub fn set_selected_position<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.selected_position = v.into();
        self
    }
}

impl wkt::message::Message for CompletionDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.CompletionDetail"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CompletionDetail {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __completion_attribution_token,
            __selected_suggestion,
            __selected_position,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompletionDetail")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "completionAttributionToken" => {
                                Ok(__FieldTag::__completion_attribution_token)
                            }
                            "completion_attribution_token" => {
                                Ok(__FieldTag::__completion_attribution_token)
                            }
                            "selectedSuggestion" => Ok(__FieldTag::__selected_suggestion),
                            "selected_suggestion" => Ok(__FieldTag::__selected_suggestion),
                            "selectedPosition" => Ok(__FieldTag::__selected_position),
                            "selected_position" => Ok(__FieldTag::__selected_position),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CompletionDetail;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompletionDetail")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__completion_attribution_token => {
                            if !fields.insert(__FieldTag::__completion_attribution_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for completion_attribution_token",
                                ));
                            }
                            result.completion_attribution_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__selected_suggestion => {
                            if !fields.insert(__FieldTag::__selected_suggestion) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for selected_suggestion",
                                ));
                            }
                            result.selected_suggestion = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__selected_position => {
                            if !fields.insert(__FieldTag::__selected_position) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for selected_position",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.selected_position =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CompletionDetail {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.completion_attribution_token.is_empty() {
            state.serialize_entry(
                "completionAttributionToken",
                &self.completion_attribution_token,
            )?;
        }
        if !self.selected_suggestion.is_empty() {
            state.serialize_entry("selectedSuggestion", &self.selected_suggestion)?;
        }
        if !wkt::internal::is_default(&self.selected_position) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("selectedPosition", &__With(&self.selected_position))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CompletionDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CompletionDetail");
        debug_struct.field(
            "completion_attribution_token",
            &self.completion_attribution_token,
        );
        debug_struct.field("selected_suggestion", &self.selected_suggestion);
        debug_struct.field("selected_position", &self.selected_position);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A transaction represents the entire purchase transaction.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PurchaseTransaction {
    /// The transaction ID with a length limit of 128 characters.
    pub id: std::string::String,

    /// Required. Total non-zero revenue or grand total associated with the
    /// transaction. This value include shipping, tax, or other adjustments to
    /// total revenue that you want to include as part of your revenue
    /// calculations.
    pub revenue: f32,

    /// All the taxes associated with the transaction.
    pub tax: f32,

    /// All the costs associated with the products. These can be manufacturing
    /// costs, shipping expenses not borne by the end user, or any other costs,
    /// such that:
    ///
    /// * Profit = [revenue][google.cloud.retail.v2.PurchaseTransaction.revenue] -
    ///   [tax][google.cloud.retail.v2.PurchaseTransaction.tax] -
    ///   [cost][google.cloud.retail.v2.PurchaseTransaction.cost]
    ///
    /// [google.cloud.retail.v2.PurchaseTransaction.cost]: crate::model::PurchaseTransaction::cost
    /// [google.cloud.retail.v2.PurchaseTransaction.revenue]: crate::model::PurchaseTransaction::revenue
    /// [google.cloud.retail.v2.PurchaseTransaction.tax]: crate::model::PurchaseTransaction::tax
    pub cost: f32,

    /// Required. Currency code. Use three-character ISO-4217 code.
    pub currency_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PurchaseTransaction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::PurchaseTransaction::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [revenue][crate::model::PurchaseTransaction::revenue].
    pub fn set_revenue<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.revenue = v.into();
        self
    }

    /// Sets the value of [tax][crate::model::PurchaseTransaction::tax].
    pub fn set_tax<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.tax = v.into();
        self
    }

    /// Sets the value of [cost][crate::model::PurchaseTransaction::cost].
    pub fn set_cost<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.cost = v.into();
        self
    }

    /// Sets the value of [currency_code][crate::model::PurchaseTransaction::currency_code].
    pub fn set_currency_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.currency_code = v.into();
        self
    }
}

impl wkt::message::Message for PurchaseTransaction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.PurchaseTransaction"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PurchaseTransaction {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __revenue,
            __tax,
            __cost,
            __currency_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PurchaseTransaction")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "revenue" => Ok(__FieldTag::__revenue),
                            "tax" => Ok(__FieldTag::__tax),
                            "cost" => Ok(__FieldTag::__cost),
                            "currencyCode" => Ok(__FieldTag::__currency_code),
                            "currency_code" => Ok(__FieldTag::__currency_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PurchaseTransaction;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PurchaseTransaction")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revenue => {
                            if !fields.insert(__FieldTag::__revenue) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revenue",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.revenue = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__tax => {
                            if !fields.insert(__FieldTag::__tax) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tax",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.tax = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cost => {
                            if !fields.insert(__FieldTag::__cost) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cost",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cost = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__currency_code => {
                            if !fields.insert(__FieldTag::__currency_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for currency_code",
                                ));
                            }
                            result.currency_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PurchaseTransaction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !wkt::internal::is_default(&self.revenue) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("revenue", &__With(&self.revenue))?;
        }
        if !wkt::internal::is_default(&self.tax) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("tax", &__With(&self.tax))?;
        }
        if !wkt::internal::is_default(&self.cost) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cost", &__With(&self.cost))?;
        }
        if !self.currency_code.is_empty() {
            state.serialize_entry("currencyCode", &self.currency_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PurchaseTransaction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PurchaseTransaction");
        debug_struct.field("id", &self.id);
        debug_struct.field("revenue", &self.revenue);
        debug_struct.field("tax", &self.tax);
        debug_struct.field("cost", &self.cost);
        debug_struct.field("currency_code", &self.currency_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for WriteUserEvent method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct WriteUserEventRequest {
    /// Required. The parent catalog resource name, such as
    /// `projects/1234/locations/global/catalogs/default_catalog`.
    pub parent: std::string::String,

    /// Required. User event to write.
    pub user_event: std::option::Option<crate::model::UserEvent>,

    /// If set to true, the user event will be written asynchronously after
    /// validation, and the API will respond without waiting for the write.
    /// Therefore, silent failures can occur even if the API returns success. In
    /// case of silent failures, error messages can be found in Stackdriver logs.
    pub write_async: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WriteUserEventRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::WriteUserEventRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [user_event][crate::model::WriteUserEventRequest::user_event].
    pub fn set_user_event<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserEvent>,
    {
        self.user_event = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user_event][crate::model::WriteUserEventRequest::user_event].
    pub fn set_or_clear_user_event<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserEvent>,
    {
        self.user_event = v.map(|x| x.into());
        self
    }

    /// Sets the value of [write_async][crate::model::WriteUserEventRequest::write_async].
    pub fn set_write_async<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.write_async = v.into();
        self
    }
}

impl wkt::message::Message for WriteUserEventRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.WriteUserEventRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WriteUserEventRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __user_event,
            __write_async,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WriteUserEventRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "userEvent" => Ok(__FieldTag::__user_event),
                            "user_event" => Ok(__FieldTag::__user_event),
                            "writeAsync" => Ok(__FieldTag::__write_async),
                            "write_async" => Ok(__FieldTag::__write_async),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WriteUserEventRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WriteUserEventRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_event => {
                            if !fields.insert(__FieldTag::__user_event) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_event",
                                ));
                            }
                            result.user_event =
                                map.next_value::<std::option::Option<crate::model::UserEvent>>()?;
                        }
                        __FieldTag::__write_async => {
                            if !fields.insert(__FieldTag::__write_async) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for write_async",
                                ));
                            }
                            result.write_async = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WriteUserEventRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.user_event.is_some() {
            state.serialize_entry("userEvent", &self.user_event)?;
        }
        if !wkt::internal::is_default(&self.write_async) {
            state.serialize_entry("writeAsync", &self.write_async)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for WriteUserEventRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WriteUserEventRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("user_event", &self.user_event);
        debug_struct.field("write_async", &self.write_async);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for CollectUserEvent method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CollectUserEventRequest {
    /// Required. The parent catalog name, such as
    /// `projects/1234/locations/global/catalogs/default_catalog`.
    pub parent: std::string::String,

    /// Required. URL encoded UserEvent proto with a length limit of 2,000,000
    /// characters.
    pub user_event: std::string::String,

    /// The URL including cgi-parameters but excluding the hash fragment with a
    /// length limit of 5,000 characters. This is often more useful than the
    /// referer URL, because many browsers only send the domain for 3rd party
    /// requests.
    pub uri: std::string::String,

    /// The event timestamp in milliseconds. This prevents browser caching of
    /// otherwise identical get requests. The name is abbreviated to reduce the
    /// payload bytes.
    pub ets: i64,

    /// An arbitrary serialized JSON string that contains necessary information
    /// that can comprise a user event. When this field is specified, the
    /// user_event field will be ignored. Note: line-delimited JSON is not
    /// supported, a single JSON only.
    pub raw_json: std::string::String,

    /// The rule that can convert the raw_json to a user event. It is needed
    /// only when the raw_json is set.
    pub conversion_rule:
        std::option::Option<crate::model::collect_user_event_request::ConversionRule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CollectUserEventRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CollectUserEventRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [user_event][crate::model::CollectUserEventRequest::user_event].
    pub fn set_user_event<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_event = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::CollectUserEventRequest::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [ets][crate::model::CollectUserEventRequest::ets].
    pub fn set_ets<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.ets = v.into();
        self
    }

    /// Sets the value of [raw_json][crate::model::CollectUserEventRequest::raw_json].
    pub fn set_raw_json<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.raw_json = v.into();
        self
    }

    /// Sets the value of [conversion_rule][crate::model::CollectUserEventRequest::conversion_rule].
    ///
    /// Note that all the setters affecting `conversion_rule` are mutually
    /// exclusive.
    pub fn set_conversion_rule<
        T: std::convert::Into<
                std::option::Option<crate::model::collect_user_event_request::ConversionRule>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conversion_rule = v.into();
        self
    }

    /// The value of [conversion_rule][crate::model::CollectUserEventRequest::conversion_rule]
    /// if it holds a `PrebuiltRule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn prebuilt_rule(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.conversion_rule.as_ref().and_then(|v| match v {
            crate::model::collect_user_event_request::ConversionRule::PrebuiltRule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [conversion_rule][crate::model::CollectUserEventRequest::conversion_rule]
    /// to hold a `PrebuiltRule`.
    ///
    /// Note that all the setters affecting `conversion_rule` are
    /// mutually exclusive.
    pub fn set_prebuilt_rule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.conversion_rule = std::option::Option::Some(
            crate::model::collect_user_event_request::ConversionRule::PrebuiltRule(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CollectUserEventRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.CollectUserEventRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CollectUserEventRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __prebuilt_rule,
            __parent,
            __user_event,
            __uri,
            __ets,
            __raw_json,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CollectUserEventRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "prebuiltRule" => Ok(__FieldTag::__prebuilt_rule),
                            "prebuilt_rule" => Ok(__FieldTag::__prebuilt_rule),
                            "parent" => Ok(__FieldTag::__parent),
                            "userEvent" => Ok(__FieldTag::__user_event),
                            "user_event" => Ok(__FieldTag::__user_event),
                            "uri" => Ok(__FieldTag::__uri),
                            "ets" => Ok(__FieldTag::__ets),
                            "rawJson" => Ok(__FieldTag::__raw_json),
                            "raw_json" => Ok(__FieldTag::__raw_json),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CollectUserEventRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CollectUserEventRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__prebuilt_rule => {
                            if !fields.insert(__FieldTag::__prebuilt_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for prebuilt_rule",
                                ));
                            }
                            if result.conversion_rule.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `conversion_rule`, a oneof with full ID .google.cloud.retail.v2.CollectUserEventRequest.prebuilt_rule, latest field was prebuiltRule",
                                ));
                            }
                            result.conversion_rule = std::option::Option::Some(
                                crate::model::collect_user_event_request::ConversionRule::PrebuiltRule(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_event => {
                            if !fields.insert(__FieldTag::__user_event) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_event",
                                ));
                            }
                            result.user_event = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ets => {
                            if !fields.insert(__FieldTag::__ets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ets",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.ets = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__raw_json => {
                            if !fields.insert(__FieldTag::__raw_json) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for raw_json",
                                ));
                            }
                            result.raw_json = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CollectUserEventRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.prebuilt_rule() {
            state.serialize_entry("prebuiltRule", value)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.user_event.is_empty() {
            state.serialize_entry("userEvent", &self.user_event)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !wkt::internal::is_default(&self.ets) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("ets", &__With(&self.ets))?;
        }
        if !self.raw_json.is_empty() {
            state.serialize_entry("rawJson", &self.raw_json)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CollectUserEventRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CollectUserEventRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("user_event", &self.user_event);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("ets", &self.ets);
        debug_struct.field("raw_json", &self.raw_json);
        debug_struct.field("conversion_rule", &self.conversion_rule);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CollectUserEventRequest].
pub mod collect_user_event_request {
    #[allow(unused_imports)]
    use super::*;

    /// The rule that can convert the raw_json to a user event. It is needed
    /// only when the raw_json is set.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConversionRule {
        /// The prebuilt rule name that can convert a specific type of raw_json.
        /// For example: "ga4_bq" rule for the GA4 user event schema.
        PrebuiltRule(std::string::String),
    }
}

/// Request message for RejoinUserEvents method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RejoinUserEventsRequest {
    /// Required. The parent catalog resource name, such as
    /// `projects/1234/locations/global/catalogs/default_catalog`.
    pub parent: std::string::String,

    /// The type of the user event rejoin to define the scope and range of the user
    /// events to be rejoined with the latest product catalog. Defaults to
    /// `USER_EVENT_REJOIN_SCOPE_UNSPECIFIED` if this field is not set, or set to
    /// an invalid integer value.
    pub user_event_rejoin_scope: crate::model::rejoin_user_events_request::UserEventRejoinScope,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RejoinUserEventsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::RejoinUserEventsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [user_event_rejoin_scope][crate::model::RejoinUserEventsRequest::user_event_rejoin_scope].
    pub fn set_user_event_rejoin_scope<
        T: std::convert::Into<crate::model::rejoin_user_events_request::UserEventRejoinScope>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_event_rejoin_scope = v.into();
        self
    }
}

impl wkt::message::Message for RejoinUserEventsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.RejoinUserEventsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RejoinUserEventsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __user_event_rejoin_scope,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RejoinUserEventsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "userEventRejoinScope" => Ok(__FieldTag::__user_event_rejoin_scope),
                            "user_event_rejoin_scope" => Ok(__FieldTag::__user_event_rejoin_scope),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RejoinUserEventsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RejoinUserEventsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_event_rejoin_scope => {
                            if !fields.insert(__FieldTag::__user_event_rejoin_scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_event_rejoin_scope",
                                ));
                            }
                            result.user_event_rejoin_scope = map
                                .next_value::<std::option::Option<
                                    crate::model::rejoin_user_events_request::UserEventRejoinScope,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RejoinUserEventsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.user_event_rejoin_scope) {
            state.serialize_entry("userEventRejoinScope", &self.user_event_rejoin_scope)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RejoinUserEventsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RejoinUserEventsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("user_event_rejoin_scope", &self.user_event_rejoin_scope);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [RejoinUserEventsRequest].
pub mod rejoin_user_events_request {
    #[allow(unused_imports)]
    use super::*;

    /// The scope of user events to be rejoined with the latest product catalog.
    /// If the rejoining aims at reducing number of unjoined events, set
    /// `UserEventRejoinScope` to `UNJOINED_EVENTS`.
    /// If the rejoining aims at correcting product catalog information in joined
    /// events, set `UserEventRejoinScope` to `JOINED_EVENTS`.
    /// If all events needs to be rejoined, set `UserEventRejoinScope` to
    /// `USER_EVENT_REJOIN_SCOPE_UNSPECIFIED`.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum UserEventRejoinScope {
        /// Rejoin all events with the latest product catalog, including both joined
        /// events and unjoined events.
        Unspecified,
        /// Only rejoin joined events with the latest product catalog.
        JoinedEvents,
        /// Only rejoin unjoined events with the latest product catalog.
        UnjoinedEvents,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [UserEventRejoinScope::value] or
        /// [UserEventRejoinScope::name].
        UnknownValue(user_event_rejoin_scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod user_event_rejoin_scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl UserEventRejoinScope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::JoinedEvents => std::option::Option::Some(1),
                Self::UnjoinedEvents => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("USER_EVENT_REJOIN_SCOPE_UNSPECIFIED")
                }
                Self::JoinedEvents => std::option::Option::Some("JOINED_EVENTS"),
                Self::UnjoinedEvents => std::option::Option::Some("UNJOINED_EVENTS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for UserEventRejoinScope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for UserEventRejoinScope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for UserEventRejoinScope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::JoinedEvents,
                2 => Self::UnjoinedEvents,
                _ => Self::UnknownValue(user_event_rejoin_scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for UserEventRejoinScope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "USER_EVENT_REJOIN_SCOPE_UNSPECIFIED" => Self::Unspecified,
                "JOINED_EVENTS" => Self::JoinedEvents,
                "UNJOINED_EVENTS" => Self::UnjoinedEvents,
                _ => Self::UnknownValue(user_event_rejoin_scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for UserEventRejoinScope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::JoinedEvents => serializer.serialize_i32(1),
                Self::UnjoinedEvents => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for UserEventRejoinScope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<UserEventRejoinScope>::new(
                ".google.cloud.retail.v2.RejoinUserEventsRequest.UserEventRejoinScope",
            ))
        }
    }
}

/// Response message for `RejoinUserEvents` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RejoinUserEventsResponse {
    /// Number of user events that were joined with latest product catalog.
    pub rejoined_user_events_count: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RejoinUserEventsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rejoined_user_events_count][crate::model::RejoinUserEventsResponse::rejoined_user_events_count].
    pub fn set_rejoined_user_events_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.rejoined_user_events_count = v.into();
        self
    }
}

impl wkt::message::Message for RejoinUserEventsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.RejoinUserEventsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RejoinUserEventsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rejoined_user_events_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RejoinUserEventsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rejoinedUserEventsCount" => {
                                Ok(__FieldTag::__rejoined_user_events_count)
                            }
                            "rejoined_user_events_count" => {
                                Ok(__FieldTag::__rejoined_user_events_count)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RejoinUserEventsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RejoinUserEventsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rejoined_user_events_count => {
                            if !fields.insert(__FieldTag::__rejoined_user_events_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rejoined_user_events_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.rejoined_user_events_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RejoinUserEventsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.rejoined_user_events_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "rejoinedUserEventsCount",
                &__With(&self.rejoined_user_events_count),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RejoinUserEventsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RejoinUserEventsResponse");
        debug_struct.field(
            "rejoined_user_events_count",
            &self.rejoined_user_events_count,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Metadata for `RejoinUserEvents` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RejoinUserEventsMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RejoinUserEventsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RejoinUserEventsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.retail.v2.RejoinUserEventsMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RejoinUserEventsMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RejoinUserEventsMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RejoinUserEventsMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RejoinUserEventsMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RejoinUserEventsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RejoinUserEventsMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RejoinUserEventsMetadata");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// At which level we offer configuration for attributes.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum AttributeConfigLevel {
    /// Value used when unset. In this case, server behavior defaults to
    /// [CATALOG_LEVEL_ATTRIBUTE_CONFIG][google.cloud.retail.v2.AttributeConfigLevel.CATALOG_LEVEL_ATTRIBUTE_CONFIG].
    ///
    /// [google.cloud.retail.v2.AttributeConfigLevel.CATALOG_LEVEL_ATTRIBUTE_CONFIG]: crate::model::AttributeConfigLevel::CatalogLevelAttributeConfig
    Unspecified,
    /// At this level, we honor the attribute configurations set in
    /// [Product.attributes][google.cloud.retail.v2.Product.attributes].
    ///
    /// [google.cloud.retail.v2.Product.attributes]: crate::model::Product::attributes
    ProductLevelAttributeConfig,
    /// At this level, we honor the attribute configurations set in
    /// `CatalogConfig.attribute_configs`.
    CatalogLevelAttributeConfig,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [AttributeConfigLevel::value] or
    /// [AttributeConfigLevel::name].
    UnknownValue(attribute_config_level::UnknownValue),
}

#[doc(hidden)]
pub mod attribute_config_level {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl AttributeConfigLevel {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::ProductLevelAttributeConfig => std::option::Option::Some(1),
            Self::CatalogLevelAttributeConfig => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("ATTRIBUTE_CONFIG_LEVEL_UNSPECIFIED"),
            Self::ProductLevelAttributeConfig => {
                std::option::Option::Some("PRODUCT_LEVEL_ATTRIBUTE_CONFIG")
            }
            Self::CatalogLevelAttributeConfig => {
                std::option::Option::Some("CATALOG_LEVEL_ATTRIBUTE_CONFIG")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for AttributeConfigLevel {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for AttributeConfigLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for AttributeConfigLevel {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::ProductLevelAttributeConfig,
            2 => Self::CatalogLevelAttributeConfig,
            _ => Self::UnknownValue(attribute_config_level::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for AttributeConfigLevel {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "ATTRIBUTE_CONFIG_LEVEL_UNSPECIFIED" => Self::Unspecified,
            "PRODUCT_LEVEL_ATTRIBUTE_CONFIG" => Self::ProductLevelAttributeConfig,
            "CATALOG_LEVEL_ATTRIBUTE_CONFIG" => Self::CatalogLevelAttributeConfig,
            _ => Self::UnknownValue(attribute_config_level::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for AttributeConfigLevel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::ProductLevelAttributeConfig => serializer.serialize_i32(1),
            Self::CatalogLevelAttributeConfig => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for AttributeConfigLevel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttributeConfigLevel>::new(
            ".google.cloud.retail.v2.AttributeConfigLevel",
        ))
    }
}

/// The type of solution.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SolutionType {
    /// Default value.
    Unspecified,
    /// Used for Recommendations AI.
    Recommendation,
    /// Used for Retail Search.
    Search,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SolutionType::value] or
    /// [SolutionType::name].
    UnknownValue(solution_type::UnknownValue),
}

#[doc(hidden)]
pub mod solution_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SolutionType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Recommendation => std::option::Option::Some(1),
            Self::Search => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SOLUTION_TYPE_UNSPECIFIED"),
            Self::Recommendation => std::option::Option::Some("SOLUTION_TYPE_RECOMMENDATION"),
            Self::Search => std::option::Option::Some("SOLUTION_TYPE_SEARCH"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SolutionType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SolutionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SolutionType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Recommendation,
            2 => Self::Search,
            _ => Self::UnknownValue(solution_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SolutionType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SOLUTION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "SOLUTION_TYPE_RECOMMENDATION" => Self::Recommendation,
            "SOLUTION_TYPE_SEARCH" => Self::Search,
            _ => Self::UnknownValue(solution_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SolutionType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Recommendation => serializer.serialize_i32(1),
            Self::Search => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SolutionType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SolutionType>::new(
            ".google.cloud.retail.v2.SolutionType",
        ))
    }
}

/// If filtering for recommendations is enabled.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum RecommendationsFilteringOption {
    /// Value used when unset.
    /// In this case, server behavior defaults to
    /// [RECOMMENDATIONS_FILTERING_DISABLED][google.cloud.retail.v2.RecommendationsFilteringOption.RECOMMENDATIONS_FILTERING_DISABLED].
    ///
    /// [google.cloud.retail.v2.RecommendationsFilteringOption.RECOMMENDATIONS_FILTERING_DISABLED]: crate::model::RecommendationsFilteringOption::RecommendationsFilteringDisabled
    Unspecified,
    /// Recommendation filtering is disabled.
    RecommendationsFilteringDisabled,
    /// Recommendation filtering is enabled.
    RecommendationsFilteringEnabled,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [RecommendationsFilteringOption::value] or
    /// [RecommendationsFilteringOption::name].
    UnknownValue(recommendations_filtering_option::UnknownValue),
}

#[doc(hidden)]
pub mod recommendations_filtering_option {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl RecommendationsFilteringOption {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::RecommendationsFilteringDisabled => std::option::Option::Some(1),
            Self::RecommendationsFilteringEnabled => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("RECOMMENDATIONS_FILTERING_OPTION_UNSPECIFIED")
            }
            Self::RecommendationsFilteringDisabled => {
                std::option::Option::Some("RECOMMENDATIONS_FILTERING_DISABLED")
            }
            Self::RecommendationsFilteringEnabled => {
                std::option::Option::Some("RECOMMENDATIONS_FILTERING_ENABLED")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for RecommendationsFilteringOption {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for RecommendationsFilteringOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for RecommendationsFilteringOption {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::RecommendationsFilteringDisabled,
            3 => Self::RecommendationsFilteringEnabled,
            _ => Self::UnknownValue(recommendations_filtering_option::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for RecommendationsFilteringOption {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "RECOMMENDATIONS_FILTERING_OPTION_UNSPECIFIED" => Self::Unspecified,
            "RECOMMENDATIONS_FILTERING_DISABLED" => Self::RecommendationsFilteringDisabled,
            "RECOMMENDATIONS_FILTERING_ENABLED" => Self::RecommendationsFilteringEnabled,
            _ => Self::UnknownValue(recommendations_filtering_option::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for RecommendationsFilteringOption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::RecommendationsFilteringDisabled => serializer.serialize_i32(1),
            Self::RecommendationsFilteringEnabled => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for RecommendationsFilteringOption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<RecommendationsFilteringOption>::new(
                ".google.cloud.retail.v2.RecommendationsFilteringOption",
            ),
        )
    }
}

/// The use case of Cloud Retail Search.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SearchSolutionUseCase {
    /// The value when it's unspecified. In this case, server behavior defaults to
    /// [SEARCH_SOLUTION_USE_CASE_SEARCH][google.cloud.retail.v2.SearchSolutionUseCase.SEARCH_SOLUTION_USE_CASE_SEARCH].
    ///
    /// [google.cloud.retail.v2.SearchSolutionUseCase.SEARCH_SOLUTION_USE_CASE_SEARCH]: crate::model::SearchSolutionUseCase::Search
    Unspecified,
    /// Search use case. Expects the traffic has a non-empty
    /// [query][google.cloud.retail.v2.SearchRequest.query].
    ///
    /// [google.cloud.retail.v2.SearchRequest.query]: crate::model::SearchRequest::query
    Search,
    /// Browse use case. Expects the traffic has an empty
    /// [query][google.cloud.retail.v2.SearchRequest.query].
    ///
    /// [google.cloud.retail.v2.SearchRequest.query]: crate::model::SearchRequest::query
    Browse,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SearchSolutionUseCase::value] or
    /// [SearchSolutionUseCase::name].
    UnknownValue(search_solution_use_case::UnknownValue),
}

#[doc(hidden)]
pub mod search_solution_use_case {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl SearchSolutionUseCase {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Search => std::option::Option::Some(1),
            Self::Browse => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SEARCH_SOLUTION_USE_CASE_UNSPECIFIED"),
            Self::Search => std::option::Option::Some("SEARCH_SOLUTION_USE_CASE_SEARCH"),
            Self::Browse => std::option::Option::Some("SEARCH_SOLUTION_USE_CASE_BROWSE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for SearchSolutionUseCase {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for SearchSolutionUseCase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for SearchSolutionUseCase {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Search,
            2 => Self::Browse,
            _ => Self::UnknownValue(search_solution_use_case::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for SearchSolutionUseCase {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SEARCH_SOLUTION_USE_CASE_UNSPECIFIED" => Self::Unspecified,
            "SEARCH_SOLUTION_USE_CASE_SEARCH" => Self::Search,
            "SEARCH_SOLUTION_USE_CASE_BROWSE" => Self::Browse,
            _ => Self::UnknownValue(search_solution_use_case::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for SearchSolutionUseCase {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Search => serializer.serialize_i32(1),
            Self::Browse => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for SearchSolutionUseCase {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SearchSolutionUseCase>::new(
            ".google.cloud.retail.v2.SearchSolutionUseCase",
        ))
    }
}
