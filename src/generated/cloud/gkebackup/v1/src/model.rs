// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Represents a request to perform a single point-in-time capture of
/// some portion of the state of a GKE cluster, the record of the backup
/// operation itself, and an anchor for the underlying artifacts that
/// comprise the Backup (the config backup and VolumeBackups).
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Backup {
    /// Output only. The fully qualified name of the Backup.
    /// `projects/*/locations/*/backupPlans/*/backups/*`
    pub name: std::string::String,

    /// Output only. Server generated global unique identifier of
    /// [UUID4](https://en.wikipedia.org/wiki/Universally_unique_identifier)
    pub uid: std::string::String,

    /// Output only. The timestamp when this Backup resource was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when this Backup resource was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. This flag indicates whether this Backup resource was created
    /// manually by a user or via a schedule in the BackupPlan. A value of True
    /// means that the Backup was created manually.
    pub manual: bool,

    /// Optional. A set of custom labels supplied by user.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Minimum age for this Backup (in days). If this field is set to a
    /// non-zero value, the Backup will be "locked" against deletion (either manual
    /// or automatic deletion) for the number of days provided (measured from the
    /// creation time of the Backup).  MUST be an integer value between 0-90
    /// (inclusive).
    ///
    /// Defaults to parent BackupPlan's
    /// [backup_delete_lock_days][google.cloud.gkebackup.v1.BackupPlan.RetentionPolicy.backup_delete_lock_days]
    /// setting and may only be increased
    /// (either at creation time or in a subsequent update).
    ///
    /// [google.cloud.gkebackup.v1.BackupPlan.RetentionPolicy.backup_delete_lock_days]: crate::model::backup_plan::RetentionPolicy::backup_delete_lock_days
    pub delete_lock_days: i32,

    /// Output only. The time at which an existing delete lock will expire for this
    /// backup (calculated from create_time +
    /// [delete_lock_days][google.cloud.gkebackup.v1.Backup.delete_lock_days]).
    ///
    /// [google.cloud.gkebackup.v1.Backup.delete_lock_days]: crate::model::Backup::delete_lock_days
    pub delete_lock_expire_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The age (in days) after which this Backup will be automatically
    /// deleted. Must be an integer value >= 0:
    ///
    /// - If 0, no automatic deletion will occur for this Backup.
    /// - If not 0, this must be >=
    ///   [delete_lock_days][google.cloud.gkebackup.v1.Backup.delete_lock_days] and
    ///   <= 365.
    ///
    /// Once a Backup is created, this value may only be increased.
    ///
    /// Defaults to the parent BackupPlan's
    /// [backup_retain_days][google.cloud.gkebackup.v1.BackupPlan.RetentionPolicy.backup_retain_days]
    /// value.
    ///
    /// [google.cloud.gkebackup.v1.Backup.delete_lock_days]: crate::model::Backup::delete_lock_days
    /// [google.cloud.gkebackup.v1.BackupPlan.RetentionPolicy.backup_retain_days]: crate::model::backup_plan::RetentionPolicy::backup_retain_days
    pub retain_days: i32,

    /// Output only. The time at which this Backup will be automatically deleted
    /// (calculated from create_time +
    /// [retain_days][google.cloud.gkebackup.v1.Backup.retain_days]).
    ///
    /// [google.cloud.gkebackup.v1.Backup.retain_days]: crate::model::Backup::retain_days
    pub retain_expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The customer managed encryption key that was used to encrypt
    /// the Backup's artifacts.  Inherited from the parent BackupPlan's
    /// [encryption_key][google.cloud.gkebackup.v1.BackupPlan.BackupConfig.encryption_key]
    /// value.
    ///
    /// [google.cloud.gkebackup.v1.BackupPlan.BackupConfig.encryption_key]: crate::model::backup_plan::BackupConfig::encryption_key
    pub encryption_key: std::option::Option<crate::model::EncryptionKey>,

    /// Output only. Whether or not the Backup contains volume data.  Controlled by
    /// the parent BackupPlan's
    /// [include_volume_data][google.cloud.gkebackup.v1.BackupPlan.BackupConfig.include_volume_data]
    /// value.
    ///
    /// [google.cloud.gkebackup.v1.BackupPlan.BackupConfig.include_volume_data]: crate::model::backup_plan::BackupConfig::include_volume_data
    pub contains_volume_data: bool,

    /// Output only. Whether or not the Backup contains Kubernetes Secrets.
    /// Controlled by the parent BackupPlan's
    /// [include_secrets][google.cloud.gkebackup.v1.BackupPlan.BackupConfig.include_secrets]
    /// value.
    ///
    /// [google.cloud.gkebackup.v1.BackupPlan.BackupConfig.include_secrets]: crate::model::backup_plan::BackupConfig::include_secrets
    pub contains_secrets: bool,

    /// Output only. Information about the GKE cluster from which this Backup was
    /// created.
    pub cluster_metadata: std::option::Option<crate::model::backup::ClusterMetadata>,

    /// Output only. Current state of the Backup
    pub state: crate::model::backup::State,

    /// Output only. Human-readable description of why the backup is in the current
    /// `state`. This field is only meant for human readability and should not be
    /// used programmatically as this field is not guaranteed to be consistent.
    pub state_reason: std::string::String,

    /// Output only. Completion time of the Backup
    pub complete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The total number of Kubernetes resources included in the
    /// Backup.
    pub resource_count: i32,

    /// Output only. The total number of volume backups contained in the Backup.
    pub volume_count: i32,

    /// Output only. The total size of the Backup in bytes = config backup size +
    /// sum(volume backup sizes)
    pub size_bytes: i64,

    /// Output only. `etag` is used for optimistic concurrency control as a way to
    /// help prevent simultaneous updates of a backup from overwriting each other.
    /// It is strongly suggested that systems make use of the `etag` in the
    /// read-modify-write cycle to perform backup updates in order to avoid
    /// race conditions: An `etag` is returned in the response to `GetBackup`,
    /// and systems are expected to put that etag in the request to
    /// `UpdateBackup` or `DeleteBackup` to ensure that their change will be
    /// applied to the same version of the resource.
    pub etag: std::string::String,

    /// Optional. User specified descriptive string for this Backup.
    pub description: std::string::String,

    /// Output only. The total number of Kubernetes Pods contained in the Backup.
    pub pod_count: i32,

    /// Output only. The size of the config backup in bytes.
    pub config_backup_size_bytes: i64,

    /// Output only. If false, Backup will fail when Backup for GKE detects
    /// Kubernetes configuration that is non-standard or
    /// requires additional setup to restore.
    ///
    /// Inherited from the parent BackupPlan's
    /// [permissive_mode][google.cloud.gkebackup.v1.BackupPlan.BackupConfig.permissive_mode]
    /// value.
    ///
    /// [google.cloud.gkebackup.v1.BackupPlan.BackupConfig.permissive_mode]: crate::model::backup_plan::BackupConfig::permissive_mode
    pub permissive_mode: bool,

    /// Output only. [Output Only] Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. [Output Only] Reserved for future use.
    pub satisfies_pzi: bool,

    /// Defines the "scope" of the Backup - which namespaced resources in the
    /// cluster were included in the Backup.  Inherited from the parent
    /// BackupPlan's
    /// [backup_scope][google.cloud.gkebackup.v1.BackupPlan.BackupConfig.backup_scope]
    /// value.
    ///
    /// [google.cloud.gkebackup.v1.BackupPlan.BackupConfig.backup_scope]: crate::model::backup_plan::BackupConfig::backup_scope
    pub backup_scope: std::option::Option<crate::model::backup::BackupScope>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Backup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Backup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Backup::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Backup::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Backup::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Backup::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Backup::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [manual][crate::model::Backup::manual].
    pub fn set_manual<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.manual = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Backup::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [delete_lock_days][crate::model::Backup::delete_lock_days].
    pub fn set_delete_lock_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.delete_lock_days = v.into();
        self
    }

    /// Sets the value of [delete_lock_expire_time][crate::model::Backup::delete_lock_expire_time].
    pub fn set_delete_lock_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_lock_expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_lock_expire_time][crate::model::Backup::delete_lock_expire_time].
    pub fn set_or_clear_delete_lock_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_lock_expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [retain_days][crate::model::Backup::retain_days].
    pub fn set_retain_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.retain_days = v.into();
        self
    }

    /// Sets the value of [retain_expire_time][crate::model::Backup::retain_expire_time].
    pub fn set_retain_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.retain_expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [retain_expire_time][crate::model::Backup::retain_expire_time].
    pub fn set_or_clear_retain_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.retain_expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption_key][crate::model::Backup::encryption_key].
    pub fn set_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionKey>,
    {
        self.encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_key][crate::model::Backup::encryption_key].
    pub fn set_or_clear_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionKey>,
    {
        self.encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [contains_volume_data][crate::model::Backup::contains_volume_data].
    pub fn set_contains_volume_data<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.contains_volume_data = v.into();
        self
    }

    /// Sets the value of [contains_secrets][crate::model::Backup::contains_secrets].
    pub fn set_contains_secrets<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.contains_secrets = v.into();
        self
    }

    /// Sets the value of [cluster_metadata][crate::model::Backup::cluster_metadata].
    pub fn set_cluster_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::backup::ClusterMetadata>,
    {
        self.cluster_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster_metadata][crate::model::Backup::cluster_metadata].
    pub fn set_or_clear_cluster_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::backup::ClusterMetadata>,
    {
        self.cluster_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Backup::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_reason][crate::model::Backup::state_reason].
    pub fn set_state_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_reason = v.into();
        self
    }

    /// Sets the value of [complete_time][crate::model::Backup::complete_time].
    pub fn set_complete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [complete_time][crate::model::Backup::complete_time].
    pub fn set_or_clear_complete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_count][crate::model::Backup::resource_count].
    pub fn set_resource_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.resource_count = v.into();
        self
    }

    /// Sets the value of [volume_count][crate::model::Backup::volume_count].
    pub fn set_volume_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.volume_count = v.into();
        self
    }

    /// Sets the value of [size_bytes][crate::model::Backup::size_bytes].
    pub fn set_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_bytes = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Backup::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Backup::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [pod_count][crate::model::Backup::pod_count].
    pub fn set_pod_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.pod_count = v.into();
        self
    }

    /// Sets the value of [config_backup_size_bytes][crate::model::Backup::config_backup_size_bytes].
    pub fn set_config_backup_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.config_backup_size_bytes = v.into();
        self
    }

    /// Sets the value of [permissive_mode][crate::model::Backup::permissive_mode].
    pub fn set_permissive_mode<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.permissive_mode = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Backup::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Backup::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }

    /// Sets the value of [backup_scope][crate::model::Backup::backup_scope].
    ///
    /// Note that all the setters affecting `backup_scope` are mutually
    /// exclusive.
    pub fn set_backup_scope<
        T: std::convert::Into<std::option::Option<crate::model::backup::BackupScope>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_scope = v.into();
        self
    }

    /// The value of [backup_scope][crate::model::Backup::backup_scope]
    /// if it holds a `AllNamespaces`, `None` if the field is not set or
    /// holds a different branch.
    pub fn all_namespaces(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.backup_scope.as_ref().and_then(|v| match v {
            crate::model::backup::BackupScope::AllNamespaces(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [backup_scope][crate::model::Backup::backup_scope]
    /// to hold a `AllNamespaces`.
    ///
    /// Note that all the setters affecting `backup_scope` are
    /// mutually exclusive.
    pub fn set_all_namespaces<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.backup_scope =
            std::option::Option::Some(crate::model::backup::BackupScope::AllNamespaces(v.into()));
        self
    }

    /// The value of [backup_scope][crate::model::Backup::backup_scope]
    /// if it holds a `SelectedNamespaces`, `None` if the field is not set or
    /// holds a different branch.
    pub fn selected_namespaces(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::Namespaces>> {
        #[allow(unreachable_patterns)]
        self.backup_scope.as_ref().and_then(|v| match v {
            crate::model::backup::BackupScope::SelectedNamespaces(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [backup_scope][crate::model::Backup::backup_scope]
    /// to hold a `SelectedNamespaces`.
    ///
    /// Note that all the setters affecting `backup_scope` are
    /// mutually exclusive.
    pub fn set_selected_namespaces<
        T: std::convert::Into<std::boxed::Box<crate::model::Namespaces>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_scope = std::option::Option::Some(
            crate::model::backup::BackupScope::SelectedNamespaces(v.into()),
        );
        self
    }

    /// The value of [backup_scope][crate::model::Backup::backup_scope]
    /// if it holds a `SelectedApplications`, `None` if the field is not set or
    /// holds a different branch.
    pub fn selected_applications(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::NamespacedNames>> {
        #[allow(unreachable_patterns)]
        self.backup_scope.as_ref().and_then(|v| match v {
            crate::model::backup::BackupScope::SelectedApplications(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [backup_scope][crate::model::Backup::backup_scope]
    /// to hold a `SelectedApplications`.
    ///
    /// Note that all the setters affecting `backup_scope` are
    /// mutually exclusive.
    pub fn set_selected_applications<
        T: std::convert::Into<std::boxed::Box<crate::model::NamespacedNames>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_scope = std::option::Option::Some(
            crate::model::backup::BackupScope::SelectedApplications(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Backup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.Backup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Backup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __create_time,
            __update_time,
            __manual,
            __labels,
            __delete_lock_days,
            __delete_lock_expire_time,
            __retain_days,
            __retain_expire_time,
            __encryption_key,
            __all_namespaces,
            __selected_namespaces,
            __selected_applications,
            __contains_volume_data,
            __contains_secrets,
            __cluster_metadata,
            __state,
            __state_reason,
            __complete_time,
            __resource_count,
            __volume_count,
            __size_bytes,
            __etag,
            __description,
            __pod_count,
            __config_backup_size_bytes,
            __permissive_mode,
            __satisfies_pzs,
            __satisfies_pzi,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Backup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "manual" => Ok(__FieldTag::__manual),
                            "labels" => Ok(__FieldTag::__labels),
                            "deleteLockDays" => Ok(__FieldTag::__delete_lock_days),
                            "delete_lock_days" => Ok(__FieldTag::__delete_lock_days),
                            "deleteLockExpireTime" => Ok(__FieldTag::__delete_lock_expire_time),
                            "delete_lock_expire_time" => Ok(__FieldTag::__delete_lock_expire_time),
                            "retainDays" => Ok(__FieldTag::__retain_days),
                            "retain_days" => Ok(__FieldTag::__retain_days),
                            "retainExpireTime" => Ok(__FieldTag::__retain_expire_time),
                            "retain_expire_time" => Ok(__FieldTag::__retain_expire_time),
                            "encryptionKey" => Ok(__FieldTag::__encryption_key),
                            "encryption_key" => Ok(__FieldTag::__encryption_key),
                            "allNamespaces" => Ok(__FieldTag::__all_namespaces),
                            "all_namespaces" => Ok(__FieldTag::__all_namespaces),
                            "selectedNamespaces" => Ok(__FieldTag::__selected_namespaces),
                            "selected_namespaces" => Ok(__FieldTag::__selected_namespaces),
                            "selectedApplications" => Ok(__FieldTag::__selected_applications),
                            "selected_applications" => Ok(__FieldTag::__selected_applications),
                            "containsVolumeData" => Ok(__FieldTag::__contains_volume_data),
                            "contains_volume_data" => Ok(__FieldTag::__contains_volume_data),
                            "containsSecrets" => Ok(__FieldTag::__contains_secrets),
                            "contains_secrets" => Ok(__FieldTag::__contains_secrets),
                            "clusterMetadata" => Ok(__FieldTag::__cluster_metadata),
                            "cluster_metadata" => Ok(__FieldTag::__cluster_metadata),
                            "state" => Ok(__FieldTag::__state),
                            "stateReason" => Ok(__FieldTag::__state_reason),
                            "state_reason" => Ok(__FieldTag::__state_reason),
                            "completeTime" => Ok(__FieldTag::__complete_time),
                            "complete_time" => Ok(__FieldTag::__complete_time),
                            "resourceCount" => Ok(__FieldTag::__resource_count),
                            "resource_count" => Ok(__FieldTag::__resource_count),
                            "volumeCount" => Ok(__FieldTag::__volume_count),
                            "volume_count" => Ok(__FieldTag::__volume_count),
                            "sizeBytes" => Ok(__FieldTag::__size_bytes),
                            "size_bytes" => Ok(__FieldTag::__size_bytes),
                            "etag" => Ok(__FieldTag::__etag),
                            "description" => Ok(__FieldTag::__description),
                            "podCount" => Ok(__FieldTag::__pod_count),
                            "pod_count" => Ok(__FieldTag::__pod_count),
                            "configBackupSizeBytes" => Ok(__FieldTag::__config_backup_size_bytes),
                            "config_backup_size_bytes" => {
                                Ok(__FieldTag::__config_backup_size_bytes)
                            }
                            "permissiveMode" => Ok(__FieldTag::__permissive_mode),
                            "permissive_mode" => Ok(__FieldTag::__permissive_mode),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Backup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Backup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__manual => {
                            if !fields.insert(__FieldTag::__manual) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for manual",
                                ));
                            }
                            result.manual = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__delete_lock_days => {
                            if !fields.insert(__FieldTag::__delete_lock_days) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_lock_days",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.delete_lock_days =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__delete_lock_expire_time => {
                            if !fields.insert(__FieldTag::__delete_lock_expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_lock_expire_time",
                                ));
                            }
                            result.delete_lock_expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__retain_days => {
                            if !fields.insert(__FieldTag::__retain_days) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retain_days",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.retain_days = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__retain_expire_time => {
                            if !fields.insert(__FieldTag::__retain_expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retain_expire_time",
                                ));
                            }
                            result.retain_expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__encryption_key => {
                            if !fields.insert(__FieldTag::__encryption_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_key",
                                ));
                            }
                            result.encryption_key = map
                                .next_value::<std::option::Option<crate::model::EncryptionKey>>()?;
                        }
                        __FieldTag::__all_namespaces => {
                            if !fields.insert(__FieldTag::__all_namespaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for all_namespaces",
                                ));
                            }
                            if result.backup_scope.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `backup_scope`, a oneof with full ID .google.cloud.gkebackup.v1.Backup.all_namespaces, latest field was allNamespaces",
                                ));
                            }
                            result.backup_scope = std::option::Option::Some(
                                crate::model::backup::BackupScope::AllNamespaces(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__selected_namespaces => {
                            if !fields.insert(__FieldTag::__selected_namespaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for selected_namespaces",
                                ));
                            }
                            if result.backup_scope.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `backup_scope`, a oneof with full ID .google.cloud.gkebackup.v1.Backup.selected_namespaces, latest field was selectedNamespaces",
                                ));
                            }
                            result.backup_scope = std::option::Option::Some(
                                crate::model::backup::BackupScope::SelectedNamespaces(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::Namespaces>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__selected_applications => {
                            if !fields.insert(__FieldTag::__selected_applications) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for selected_applications",
                                ));
                            }
                            if result.backup_scope.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `backup_scope`, a oneof with full ID .google.cloud.gkebackup.v1.Backup.selected_applications, latest field was selectedApplications",
                                ));
                            }
                            result.backup_scope = std::option::Option::Some(
                                crate::model::backup::BackupScope::SelectedApplications(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::NamespacedNames>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__contains_volume_data => {
                            if !fields.insert(__FieldTag::__contains_volume_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contains_volume_data",
                                ));
                            }
                            result.contains_volume_data = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__contains_secrets => {
                            if !fields.insert(__FieldTag::__contains_secrets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contains_secrets",
                                ));
                            }
                            result.contains_secrets = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_metadata => {
                            if !fields.insert(__FieldTag::__cluster_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_metadata",
                                ));
                            }
                            result.cluster_metadata = map.next_value::<std::option::Option<crate::model::backup::ClusterMetadata>>()?
                                ;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::backup::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_reason => {
                            if !fields.insert(__FieldTag::__state_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_reason",
                                ));
                            }
                            result.state_reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__complete_time => {
                            if !fields.insert(__FieldTag::__complete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for complete_time",
                                ));
                            }
                            result.complete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__resource_count => {
                            if !fields.insert(__FieldTag::__resource_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.resource_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__volume_count => {
                            if !fields.insert(__FieldTag::__volume_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.volume_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__size_bytes => {
                            if !fields.insert(__FieldTag::__size_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size_bytes = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod_count => {
                            if !fields.insert(__FieldTag::__pod_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pod_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__config_backup_size_bytes => {
                            if !fields.insert(__FieldTag::__config_backup_size_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_backup_size_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.config_backup_size_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__permissive_mode => {
                            if !fields.insert(__FieldTag::__permissive_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for permissive_mode",
                                ));
                            }
                            result.permissive_mode = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzi",
                                ));
                            }
                            result.satisfies_pzi = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Backup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.manual) {
            state.serialize_entry("manual", &self.manual)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.delete_lock_days) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("deleteLockDays", &__With(&self.delete_lock_days))?;
        }
        if self.delete_lock_expire_time.is_some() {
            state.serialize_entry("deleteLockExpireTime", &self.delete_lock_expire_time)?;
        }
        if !wkt::internal::is_default(&self.retain_days) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("retainDays", &__With(&self.retain_days))?;
        }
        if self.retain_expire_time.is_some() {
            state.serialize_entry("retainExpireTime", &self.retain_expire_time)?;
        }
        if self.encryption_key.is_some() {
            state.serialize_entry("encryptionKey", &self.encryption_key)?;
        }
        if let Some(value) = self.all_namespaces() {
            state.serialize_entry("allNamespaces", value)?;
        }
        if let Some(value) = self.selected_namespaces() {
            state.serialize_entry("selectedNamespaces", value)?;
        }
        if let Some(value) = self.selected_applications() {
            state.serialize_entry("selectedApplications", value)?;
        }
        if !wkt::internal::is_default(&self.contains_volume_data) {
            state.serialize_entry("containsVolumeData", &self.contains_volume_data)?;
        }
        if !wkt::internal::is_default(&self.contains_secrets) {
            state.serialize_entry("containsSecrets", &self.contains_secrets)?;
        }
        if self.cluster_metadata.is_some() {
            state.serialize_entry("clusterMetadata", &self.cluster_metadata)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_reason.is_empty() {
            state.serialize_entry("stateReason", &self.state_reason)?;
        }
        if self.complete_time.is_some() {
            state.serialize_entry("completeTime", &self.complete_time)?;
        }
        if !wkt::internal::is_default(&self.resource_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("resourceCount", &__With(&self.resource_count))?;
        }
        if !wkt::internal::is_default(&self.volume_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("volumeCount", &__With(&self.volume_count))?;
        }
        if !wkt::internal::is_default(&self.size_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sizeBytes", &__With(&self.size_bytes))?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.pod_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("podCount", &__With(&self.pod_count))?;
        }
        if !wkt::internal::is_default(&self.config_backup_size_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "configBackupSizeBytes",
                &__With(&self.config_backup_size_bytes),
            )?;
        }
        if !wkt::internal::is_default(&self.permissive_mode) {
            state.serialize_entry("permissiveMode", &self.permissive_mode)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzs) {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzi) {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Backup].
pub mod backup {
    #[allow(unused_imports)]
    use super::*;

    /// Information about the GKE cluster from which this Backup was created.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ClusterMetadata {
        /// Output only. The source cluster from which this Backup was created.
        /// Valid formats:
        ///
        /// - `projects/*/locations/*/clusters/*`
        /// - `projects/*/zones/*/clusters/*`
        ///
        /// This is inherited from the parent BackupPlan's
        /// [cluster][google.cloud.gkebackup.v1.BackupPlan.cluster] field.
        ///
        /// [google.cloud.gkebackup.v1.BackupPlan.cluster]: crate::model::BackupPlan::cluster
        pub cluster: std::string::String,

        /// Output only. The Kubernetes server version of the source cluster.
        pub k8s_version: std::string::String,

        /// Output only. A list of the Backup for GKE CRD versions found in the
        /// cluster.
        pub backup_crd_versions:
            std::collections::HashMap<std::string::String, std::string::String>,

        /// Platform-specific version
        pub platform_version:
            std::option::Option<crate::model::backup::cluster_metadata::PlatformVersion>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ClusterMetadata {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cluster][crate::model::backup::ClusterMetadata::cluster].
        pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cluster = v.into();
            self
        }

        /// Sets the value of [k8s_version][crate::model::backup::ClusterMetadata::k8s_version].
        pub fn set_k8s_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.k8s_version = v.into();
            self
        }

        /// Sets the value of [backup_crd_versions][crate::model::backup::ClusterMetadata::backup_crd_versions].
        pub fn set_backup_crd_versions<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.backup_crd_versions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [platform_version][crate::model::backup::ClusterMetadata::platform_version].
        ///
        /// Note that all the setters affecting `platform_version` are mutually
        /// exclusive.
        pub fn set_platform_version<
            T: std::convert::Into<
                    std::option::Option<crate::model::backup::cluster_metadata::PlatformVersion>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.platform_version = v.into();
            self
        }

        /// The value of [platform_version][crate::model::backup::ClusterMetadata::platform_version]
        /// if it holds a `GkeVersion`, `None` if the field is not set or
        /// holds a different branch.
        pub fn gke_version(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.platform_version.as_ref().and_then(|v| match v {
                crate::model::backup::cluster_metadata::PlatformVersion::GkeVersion(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [platform_version][crate::model::backup::ClusterMetadata::platform_version]
        /// to hold a `GkeVersion`.
        ///
        /// Note that all the setters affecting `platform_version` are
        /// mutually exclusive.
        pub fn set_gke_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.platform_version = std::option::Option::Some(
                crate::model::backup::cluster_metadata::PlatformVersion::GkeVersion(v.into()),
            );
            self
        }

        /// The value of [platform_version][crate::model::backup::ClusterMetadata::platform_version]
        /// if it holds a `AnthosVersion`, `None` if the field is not set or
        /// holds a different branch.
        pub fn anthos_version(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.platform_version.as_ref().and_then(|v| match v {
                crate::model::backup::cluster_metadata::PlatformVersion::AnthosVersion(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [platform_version][crate::model::backup::ClusterMetadata::platform_version]
        /// to hold a `AnthosVersion`.
        ///
        /// Note that all the setters affecting `platform_version` are
        /// mutually exclusive.
        pub fn set_anthos_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.platform_version = std::option::Option::Some(
                crate::model::backup::cluster_metadata::PlatformVersion::AnthosVersion(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for ClusterMetadata {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.gkebackup.v1.Backup.ClusterMetadata"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ClusterMetadata {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __cluster,
                __k8s_version,
                __backup_crd_versions,
                __gke_version,
                __anthos_version,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ClusterMetadata")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "cluster" => Ok(__FieldTag::__cluster),
                                "k8sVersion" => Ok(__FieldTag::__k8s_version),
                                "k8s_version" => Ok(__FieldTag::__k8s_version),
                                "backupCrdVersions" => Ok(__FieldTag::__backup_crd_versions),
                                "backup_crd_versions" => Ok(__FieldTag::__backup_crd_versions),
                                "gkeVersion" => Ok(__FieldTag::__gke_version),
                                "gke_version" => Ok(__FieldTag::__gke_version),
                                "anthosVersion" => Ok(__FieldTag::__anthos_version),
                                "anthos_version" => Ok(__FieldTag::__anthos_version),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ClusterMetadata;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ClusterMetadata")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__cluster => {
                                if !fields.insert(__FieldTag::__cluster) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cluster",
                                    ));
                                }
                                result.cluster = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__k8s_version => {
                                if !fields.insert(__FieldTag::__k8s_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for k8s_version",
                                    ));
                                }
                                result.k8s_version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__backup_crd_versions => {
                                if !fields.insert(__FieldTag::__backup_crd_versions) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for backup_crd_versions",
                                    ));
                                }
                                result.backup_crd_versions = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__gke_version => {
                                if !fields.insert(__FieldTag::__gke_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for gke_version",
                                    ));
                                }
                                if result.platform_version.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `platform_version`, a oneof with full ID .google.cloud.gkebackup.v1.Backup.ClusterMetadata.gke_version, latest field was gkeVersion",
                                    ));
                                }
                                result.platform_version = std::option::Option::Some(
                                    crate::model::backup::cluster_metadata::PlatformVersion::GkeVersion(
                                        map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__anthos_version => {
                                if !fields.insert(__FieldTag::__anthos_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for anthos_version",
                                    ));
                                }
                                if result.platform_version.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `platform_version`, a oneof with full ID .google.cloud.gkebackup.v1.Backup.ClusterMetadata.anthos_version, latest field was anthosVersion",
                                    ));
                                }
                                result.platform_version = std::option::Option::Some(
                                    crate::model::backup::cluster_metadata::PlatformVersion::AnthosVersion(
                                        map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ClusterMetadata {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.cluster.is_empty() {
                state.serialize_entry("cluster", &self.cluster)?;
            }
            if !self.k8s_version.is_empty() {
                state.serialize_entry("k8sVersion", &self.k8s_version)?;
            }
            if !self.backup_crd_versions.is_empty() {
                state.serialize_entry("backupCrdVersions", &self.backup_crd_versions)?;
            }
            if let Some(value) = self.gke_version() {
                state.serialize_entry("gkeVersion", value)?;
            }
            if let Some(value) = self.anthos_version() {
                state.serialize_entry("anthosVersion", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [ClusterMetadata].
    pub mod cluster_metadata {
        #[allow(unused_imports)]
        use super::*;

        /// Platform-specific version
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum PlatformVersion {
            /// Output only. GKE version
            GkeVersion(std::string::String),
            /// Output only. Anthos version
            AnthosVersion(std::string::String),
        }
    }

    /// State
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The Backup resource is in the process of being created.
        Unspecified,
        /// The Backup resource has been created and the associated BackupJob
        /// Kubernetes resource has been injected into the source cluster.
        Creating,
        /// The gkebackup agent in the cluster has begun executing the backup
        /// operation.
        InProgress,
        /// The backup operation has completed successfully.
        Succeeded,
        /// The backup operation has failed.
        Failed,
        /// This Backup resource (and its associated artifacts) is in the process
        /// of being deleted.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::InProgress => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Deleting => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::InProgress,
                3 => Self::Succeeded,
                4 => Self::Failed,
                5 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "IN_PROGRESS" => Self::InProgress,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::InProgress => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Deleting => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.gkebackup.v1.Backup.State",
            ))
        }
    }

    /// Defines the "scope" of the Backup - which namespaced resources in the
    /// cluster were included in the Backup.  Inherited from the parent
    /// BackupPlan's
    /// [backup_scope][google.cloud.gkebackup.v1.BackupPlan.BackupConfig.backup_scope]
    /// value.
    ///
    /// [google.cloud.gkebackup.v1.BackupPlan.BackupConfig.backup_scope]: crate::model::backup_plan::BackupConfig::backup_scope
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BackupScope {
        /// Output only. If True, all namespaces were included in the Backup.
        AllNamespaces(bool),
        /// Output only. If set, the list of namespaces that were included in the
        /// Backup.
        SelectedNamespaces(std::boxed::Box<crate::model::Namespaces>),
        /// Output only. If set, the list of ProtectedApplications whose resources
        /// were included in the Backup.
        SelectedApplications(std::boxed::Box<crate::model::NamespacedNames>),
    }
}

/// A BackupChannel imposes constraints on where clusters can be backed up.
/// The BackupChannel should be in the same project and region
/// as the cluster being backed up.
/// The backup can be created only in destination_project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupChannel {
    /// Identifier. The fully qualified name of the BackupChannel.
    /// `projects/*/locations/*/backupChannels/*`
    pub name: std::string::String,

    /// Required. Immutable. The project where Backups are allowed to be stored.
    /// The format is `projects/{projectId}` or `projects/{projectNumber}`.
    pub destination_project: std::string::String,

    /// Output only. Server generated global unique identifier of
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) format.
    pub uid: std::string::String,

    /// Output only. The timestamp when this BackupChannel resource was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when this BackupChannel resource was last
    /// updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. A set of custom labels supplied by user.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. User specified descriptive string for this BackupChannel.
    pub description: std::string::String,

    /// Output only. `etag` is used for optimistic concurrency control as a way to
    /// help prevent simultaneous updates of a BackupChannel from overwriting each
    /// other. It is strongly suggested that systems make use of the 'etag' in the
    /// read-modify-write cycle to perform BackupChannel updates in order to
    /// avoid race conditions: An `etag` is returned in the response to
    /// `GetBackupChannel`, and systems are expected to put that etag in the
    /// request to `UpdateBackupChannel` or `DeleteBackupChannel` to
    /// ensure that their change will be applied to the same version of the
    /// resource.
    pub etag: std::string::String,

    /// Output only. The project_id where Backups are allowed to be stored.
    /// Example Project ID: "my-project-id".
    /// This will be an OUTPUT_ONLY field to return the project_id of the
    /// destination project.
    pub destination_project_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupChannel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BackupChannel::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [destination_project][crate::model::BackupChannel::destination_project].
    pub fn set_destination_project<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_project = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::BackupChannel::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BackupChannel::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BackupChannel::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::BackupChannel::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::BackupChannel::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::BackupChannel::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::BackupChannel::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::BackupChannel::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [destination_project_id][crate::model::BackupChannel::destination_project_id].
    pub fn set_destination_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_project_id = v.into();
        self
    }
}

impl wkt::message::Message for BackupChannel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.BackupChannel"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupChannel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __destination_project,
            __uid,
            __create_time,
            __update_time,
            __labels,
            __description,
            __etag,
            __destination_project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupChannel")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "destinationProject" => Ok(__FieldTag::__destination_project),
                            "destination_project" => Ok(__FieldTag::__destination_project),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "description" => Ok(__FieldTag::__description),
                            "etag" => Ok(__FieldTag::__etag),
                            "destinationProjectId" => Ok(__FieldTag::__destination_project_id),
                            "destination_project_id" => Ok(__FieldTag::__destination_project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupChannel;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupChannel")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_project => {
                            if !fields.insert(__FieldTag::__destination_project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_project",
                                ));
                            }
                            result.destination_project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_project_id => {
                            if !fields.insert(__FieldTag::__destination_project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_project_id",
                                ));
                            }
                            result.destination_project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupChannel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.destination_project.is_empty() {
            state.serialize_entry("destinationProject", &self.destination_project)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.destination_project_id.is_empty() {
            state.serialize_entry("destinationProjectId", &self.destination_project_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines the configuration and scheduling for a "line" of Backups.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupPlan {
    /// Output only. The full name of the BackupPlan resource.
    /// Format: `projects/*/locations/*/backupPlans/*`
    pub name: std::string::String,

    /// Output only. Server generated global unique identifier of
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) format.
    pub uid: std::string::String,

    /// Output only. The timestamp when this BackupPlan resource was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when this BackupPlan resource was last
    /// updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User specified descriptive string for this BackupPlan.
    pub description: std::string::String,

    /// Required. Immutable. The source cluster from which Backups will be created
    /// via this BackupPlan. Valid formats:
    ///
    /// - `projects/*/locations/*/clusters/*`
    /// - `projects/*/zones/*/clusters/*`
    pub cluster: std::string::String,

    /// Optional. RetentionPolicy governs lifecycle of Backups created under this
    /// plan.
    pub retention_policy: std::option::Option<crate::model::backup_plan::RetentionPolicy>,

    /// Optional. A set of custom labels supplied by user.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Defines a schedule for automatic Backup creation via this
    /// BackupPlan.
    pub backup_schedule: std::option::Option<crate::model::backup_plan::Schedule>,

    /// Output only. `etag` is used for optimistic concurrency control as a way to
    /// help prevent simultaneous updates of a backup plan from overwriting each
    /// other. It is strongly suggested that systems make use of the 'etag' in the
    /// read-modify-write cycle to perform BackupPlan updates in order to avoid
    /// race conditions: An `etag` is returned in the response to `GetBackupPlan`,
    /// and systems are expected to put that etag in the request to
    /// `UpdateBackupPlan` or `DeleteBackupPlan` to ensure that their change
    /// will be applied to the same version of the resource.
    pub etag: std::string::String,

    /// Optional. This flag indicates whether this BackupPlan has been deactivated.
    /// Setting this field to True locks the BackupPlan such that no further
    /// updates will be allowed (except deletes), including the deactivated field
    /// itself. It also prevents any new Backups from being created via this
    /// BackupPlan (including scheduled Backups).
    ///
    /// Default: False
    pub deactivated: bool,

    /// Optional. Defines the configuration of Backups created via this BackupPlan.
    pub backup_config: std::option::Option<crate::model::backup_plan::BackupConfig>,

    /// Output only. The number of Kubernetes Pods backed up in the
    /// last successful Backup created via this BackupPlan.
    pub protected_pod_count: i32,

    /// Output only. State of the BackupPlan. This State field reflects the
    /// various stages a BackupPlan can be in
    /// during the Create operation. It will be set to "DEACTIVATED"
    /// if the BackupPlan is deactivated on an Update
    pub state: crate::model::backup_plan::State,

    /// Output only. Human-readable description of why BackupPlan is in the current
    /// `state`. This field is only meant for human readability and should not be
    /// used programmatically as this field is not guaranteed to be consistent.
    pub state_reason: std::string::String,

    /// Output only. A number that represents the current risk level of this
    /// BackupPlan from RPO perspective with 1 being no risk and 5 being highest
    /// risk.
    pub rpo_risk_level: i32,

    /// Output only. Human-readable description of why the BackupPlan is in the
    /// current rpo_risk_level and action items if any.
    pub rpo_risk_reason: std::string::String,

    /// Output only. The fully qualified name of the BackupChannel to be used to
    /// create a backup. This field is set only if the cluster being backed up is
    /// in a different project.
    /// `projects/*/locations/*/backupChannels/*`
    pub backup_channel: std::string::String,

    /// Output only. Completion time of the last successful Backup. This is sourced
    /// from a successful Backup's complete_time field. This field is added to
    /// maintain consistency with BackupPlanBinding to display last successful
    /// backup time.
    pub last_successful_backup_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupPlan {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BackupPlan::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::BackupPlan::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BackupPlan::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BackupPlan::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::BackupPlan::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::BackupPlan::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::BackupPlan::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::BackupPlan::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [retention_policy][crate::model::BackupPlan::retention_policy].
    pub fn set_retention_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::backup_plan::RetentionPolicy>,
    {
        self.retention_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [retention_policy][crate::model::BackupPlan::retention_policy].
    pub fn set_or_clear_retention_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::backup_plan::RetentionPolicy>,
    {
        self.retention_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::BackupPlan::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [backup_schedule][crate::model::BackupPlan::backup_schedule].
    pub fn set_backup_schedule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::backup_plan::Schedule>,
    {
        self.backup_schedule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_schedule][crate::model::BackupPlan::backup_schedule].
    pub fn set_or_clear_backup_schedule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::backup_plan::Schedule>,
    {
        self.backup_schedule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::BackupPlan::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [deactivated][crate::model::BackupPlan::deactivated].
    pub fn set_deactivated<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.deactivated = v.into();
        self
    }

    /// Sets the value of [backup_config][crate::model::BackupPlan::backup_config].
    pub fn set_backup_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::backup_plan::BackupConfig>,
    {
        self.backup_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_config][crate::model::BackupPlan::backup_config].
    pub fn set_or_clear_backup_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::backup_plan::BackupConfig>,
    {
        self.backup_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [protected_pod_count][crate::model::BackupPlan::protected_pod_count].
    pub fn set_protected_pod_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.protected_pod_count = v.into();
        self
    }

    /// Sets the value of [state][crate::model::BackupPlan::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup_plan::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_reason][crate::model::BackupPlan::state_reason].
    pub fn set_state_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_reason = v.into();
        self
    }

    /// Sets the value of [rpo_risk_level][crate::model::BackupPlan::rpo_risk_level].
    pub fn set_rpo_risk_level<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.rpo_risk_level = v.into();
        self
    }

    /// Sets the value of [rpo_risk_reason][crate::model::BackupPlan::rpo_risk_reason].
    pub fn set_rpo_risk_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rpo_risk_reason = v.into();
        self
    }

    /// Sets the value of [backup_channel][crate::model::BackupPlan::backup_channel].
    pub fn set_backup_channel<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_channel = v.into();
        self
    }

    /// Sets the value of [last_successful_backup_time][crate::model::BackupPlan::last_successful_backup_time].
    pub fn set_last_successful_backup_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_successful_backup_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_successful_backup_time][crate::model::BackupPlan::last_successful_backup_time].
    pub fn set_or_clear_last_successful_backup_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_successful_backup_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BackupPlan {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.BackupPlan"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupPlan {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __create_time,
            __update_time,
            __description,
            __cluster,
            __retention_policy,
            __labels,
            __backup_schedule,
            __etag,
            __deactivated,
            __backup_config,
            __protected_pod_count,
            __state,
            __state_reason,
            __rpo_risk_level,
            __rpo_risk_reason,
            __backup_channel,
            __last_successful_backup_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupPlan")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "description" => Ok(__FieldTag::__description),
                            "cluster" => Ok(__FieldTag::__cluster),
                            "retentionPolicy" => Ok(__FieldTag::__retention_policy),
                            "retention_policy" => Ok(__FieldTag::__retention_policy),
                            "labels" => Ok(__FieldTag::__labels),
                            "backupSchedule" => Ok(__FieldTag::__backup_schedule),
                            "backup_schedule" => Ok(__FieldTag::__backup_schedule),
                            "etag" => Ok(__FieldTag::__etag),
                            "deactivated" => Ok(__FieldTag::__deactivated),
                            "backupConfig" => Ok(__FieldTag::__backup_config),
                            "backup_config" => Ok(__FieldTag::__backup_config),
                            "protectedPodCount" => Ok(__FieldTag::__protected_pod_count),
                            "protected_pod_count" => Ok(__FieldTag::__protected_pod_count),
                            "state" => Ok(__FieldTag::__state),
                            "stateReason" => Ok(__FieldTag::__state_reason),
                            "state_reason" => Ok(__FieldTag::__state_reason),
                            "rpoRiskLevel" => Ok(__FieldTag::__rpo_risk_level),
                            "rpo_risk_level" => Ok(__FieldTag::__rpo_risk_level),
                            "rpoRiskReason" => Ok(__FieldTag::__rpo_risk_reason),
                            "rpo_risk_reason" => Ok(__FieldTag::__rpo_risk_reason),
                            "backupChannel" => Ok(__FieldTag::__backup_channel),
                            "backup_channel" => Ok(__FieldTag::__backup_channel),
                            "lastSuccessfulBackupTime" => {
                                Ok(__FieldTag::__last_successful_backup_time)
                            }
                            "last_successful_backup_time" => {
                                Ok(__FieldTag::__last_successful_backup_time)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupPlan;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupPlan")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__retention_policy => {
                            if !fields.insert(__FieldTag::__retention_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retention_policy",
                                ));
                            }
                            result.retention_policy = map.next_value::<std::option::Option<crate::model::backup_plan::RetentionPolicy>>()?
                                ;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_schedule => {
                            if !fields.insert(__FieldTag::__backup_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_schedule",
                                ));
                            }
                            result.backup_schedule = map.next_value::<std::option::Option<crate::model::backup_plan::Schedule>>()?
                                ;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deactivated => {
                            if !fields.insert(__FieldTag::__deactivated) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deactivated",
                                ));
                            }
                            result.deactivated = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_config => {
                            if !fields.insert(__FieldTag::__backup_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_config",
                                ));
                            }
                            result.backup_config = map.next_value::<std::option::Option<crate::model::backup_plan::BackupConfig>>()?
                                ;
                        }
                        __FieldTag::__protected_pod_count => {
                            if !fields.insert(__FieldTag::__protected_pod_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protected_pod_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.protected_pod_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::backup_plan::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state_reason => {
                            if !fields.insert(__FieldTag::__state_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_reason",
                                ));
                            }
                            result.state_reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rpo_risk_level => {
                            if !fields.insert(__FieldTag::__rpo_risk_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rpo_risk_level",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.rpo_risk_level =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__rpo_risk_reason => {
                            if !fields.insert(__FieldTag::__rpo_risk_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rpo_risk_reason",
                                ));
                            }
                            result.rpo_risk_reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_channel => {
                            if !fields.insert(__FieldTag::__backup_channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_channel",
                                ));
                            }
                            result.backup_channel = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_successful_backup_time => {
                            if !fields.insert(__FieldTag::__last_successful_backup_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_successful_backup_time",
                                ));
                            }
                            result.last_successful_backup_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupPlan {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.cluster.is_empty() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if self.retention_policy.is_some() {
            state.serialize_entry("retentionPolicy", &self.retention_policy)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.backup_schedule.is_some() {
            state.serialize_entry("backupSchedule", &self.backup_schedule)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.deactivated) {
            state.serialize_entry("deactivated", &self.deactivated)?;
        }
        if self.backup_config.is_some() {
            state.serialize_entry("backupConfig", &self.backup_config)?;
        }
        if !wkt::internal::is_default(&self.protected_pod_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("protectedPodCount", &__With(&self.protected_pod_count))?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_reason.is_empty() {
            state.serialize_entry("stateReason", &self.state_reason)?;
        }
        if !wkt::internal::is_default(&self.rpo_risk_level) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("rpoRiskLevel", &__With(&self.rpo_risk_level))?;
        }
        if !self.rpo_risk_reason.is_empty() {
            state.serialize_entry("rpoRiskReason", &self.rpo_risk_reason)?;
        }
        if !self.backup_channel.is_empty() {
            state.serialize_entry("backupChannel", &self.backup_channel)?;
        }
        if self.last_successful_backup_time.is_some() {
            state.serialize_entry(
                "lastSuccessfulBackupTime",
                &self.last_successful_backup_time,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BackupPlan].
pub mod backup_plan {
    #[allow(unused_imports)]
    use super::*;

    /// RetentionPolicy defines a Backup retention policy for a BackupPlan.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RetentionPolicy {
        /// Optional. Minimum age for Backups created via this BackupPlan (in days).
        /// This field MUST be an integer value between 0-90 (inclusive).
        /// A Backup created under this BackupPlan will NOT be deletable until it
        /// reaches Backup's (create_time + backup_delete_lock_days).
        /// Updating this field of a BackupPlan does NOT affect existing Backups
        /// under it. Backups created AFTER a successful update will inherit
        /// the new value.
        ///
        /// Default: 0 (no delete blocking)
        pub backup_delete_lock_days: i32,

        /// Optional. The default maximum age of a Backup created via this
        /// BackupPlan. This field MUST be an integer value >= 0 and <= 365. If
        /// specified, a Backup created under this BackupPlan will be automatically
        /// deleted after its age reaches (create_time + backup_retain_days). If not
        /// specified, Backups created under this BackupPlan will NOT be subject to
        /// automatic deletion. Updating this field does NOT affect existing Backups
        /// under it. Backups created AFTER a successful update will automatically
        /// pick up the new value. NOTE: backup_retain_days must be >=
        /// [backup_delete_lock_days][google.cloud.gkebackup.v1.BackupPlan.RetentionPolicy.backup_delete_lock_days].
        /// If
        /// [cron_schedule][google.cloud.gkebackup.v1.BackupPlan.Schedule.cron_schedule]
        /// is defined, then this must be
        /// <= 360 * the creation interval. If
        /// [rpo_config][google.cloud.gkebackup.v1.BackupPlan.Schedule.rpo_config] is
        /// defined, then this must be
        /// <= 360 * [target_rpo_minutes][Schedule.rpo_config.target_rpo_minutes] /
        /// (1440minutes/day).
        ///
        /// Default: 0 (no automatic deletion)
        ///
        /// [google.cloud.gkebackup.v1.BackupPlan.RetentionPolicy.backup_delete_lock_days]: crate::model::backup_plan::RetentionPolicy::backup_delete_lock_days
        /// [google.cloud.gkebackup.v1.BackupPlan.Schedule.cron_schedule]: crate::model::backup_plan::Schedule::cron_schedule
        /// [google.cloud.gkebackup.v1.BackupPlan.Schedule.rpo_config]: crate::model::backup_plan::Schedule::rpo_config
        pub backup_retain_days: i32,

        /// Optional. This flag denotes whether the retention policy of this
        /// BackupPlan is locked.  If set to True, no further update is allowed on
        /// this policy, including the `locked` field itself.
        ///
        /// Default: False
        pub locked: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RetentionPolicy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [backup_delete_lock_days][crate::model::backup_plan::RetentionPolicy::backup_delete_lock_days].
        pub fn set_backup_delete_lock_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.backup_delete_lock_days = v.into();
            self
        }

        /// Sets the value of [backup_retain_days][crate::model::backup_plan::RetentionPolicy::backup_retain_days].
        pub fn set_backup_retain_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.backup_retain_days = v.into();
            self
        }

        /// Sets the value of [locked][crate::model::backup_plan::RetentionPolicy::locked].
        pub fn set_locked<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.locked = v.into();
            self
        }
    }

    impl wkt::message::Message for RetentionPolicy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.gkebackup.v1.BackupPlan.RetentionPolicy"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RetentionPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __backup_delete_lock_days,
                __backup_retain_days,
                __locked,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RetentionPolicy")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "backupDeleteLockDays" => Ok(__FieldTag::__backup_delete_lock_days),
                                "backup_delete_lock_days" => {
                                    Ok(__FieldTag::__backup_delete_lock_days)
                                }
                                "backupRetainDays" => Ok(__FieldTag::__backup_retain_days),
                                "backup_retain_days" => Ok(__FieldTag::__backup_retain_days),
                                "locked" => Ok(__FieldTag::__locked),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RetentionPolicy;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RetentionPolicy")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__backup_delete_lock_days => {
                                if !fields.insert(__FieldTag::__backup_delete_lock_days) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for backup_delete_lock_days",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.backup_delete_lock_days =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__backup_retain_days => {
                                if !fields.insert(__FieldTag::__backup_retain_days) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for backup_retain_days",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.backup_retain_days =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__locked => {
                                if !fields.insert(__FieldTag::__locked) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for locked",
                                    ));
                                }
                                result.locked = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RetentionPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.backup_delete_lock_days) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "backupDeleteLockDays",
                    &__With(&self.backup_delete_lock_days),
                )?;
            }
            if !wkt::internal::is_default(&self.backup_retain_days) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("backupRetainDays", &__With(&self.backup_retain_days))?;
            }
            if !wkt::internal::is_default(&self.locked) {
                state.serialize_entry("locked", &self.locked)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines scheduling parameters for automatically creating Backups
    /// via this BackupPlan.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Schedule {
        /// Optional. A standard [cron](https://wikipedia.com/wiki/cron) string that
        /// defines a repeating schedule for creating Backups via this BackupPlan.
        /// This is mutually exclusive with the
        /// [rpo_config][google.cloud.gkebackup.v1.BackupPlan.Schedule.rpo_config]
        /// field since at most one schedule can be defined for a BackupPlan. If this
        /// is defined, then
        /// [backup_retain_days][google.cloud.gkebackup.v1.BackupPlan.RetentionPolicy.backup_retain_days]
        /// must also be defined.
        ///
        /// Default (empty): no automatic backup creation will occur.
        ///
        /// [google.cloud.gkebackup.v1.BackupPlan.RetentionPolicy.backup_retain_days]: crate::model::backup_plan::RetentionPolicy::backup_retain_days
        /// [google.cloud.gkebackup.v1.BackupPlan.Schedule.rpo_config]: crate::model::backup_plan::Schedule::rpo_config
        pub cron_schedule: std::string::String,

        /// Optional. This flag denotes whether automatic Backup creation is paused
        /// for this BackupPlan.
        ///
        /// Default: False
        pub paused: bool,

        /// Optional. Defines the RPO schedule configuration for this BackupPlan.
        /// This is mutually exclusive with the
        /// [cron_schedule][google.cloud.gkebackup.v1.BackupPlan.Schedule.cron_schedule]
        /// field since at most one schedule can be defined for a BackupPLan. If this
        /// is defined, then
        /// [backup_retain_days][google.cloud.gkebackup.v1.BackupPlan.RetentionPolicy.backup_retain_days]
        /// must also be defined.
        ///
        /// Default (empty): no automatic backup creation will occur.
        ///
        /// [google.cloud.gkebackup.v1.BackupPlan.RetentionPolicy.backup_retain_days]: crate::model::backup_plan::RetentionPolicy::backup_retain_days
        /// [google.cloud.gkebackup.v1.BackupPlan.Schedule.cron_schedule]: crate::model::backup_plan::Schedule::cron_schedule
        pub rpo_config: std::option::Option<crate::model::RpoConfig>,

        /// Output only. Start time of next scheduled backup under this BackupPlan by
        /// either cron_schedule or rpo config.
        pub next_scheduled_backup_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Schedule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cron_schedule][crate::model::backup_plan::Schedule::cron_schedule].
        pub fn set_cron_schedule<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.cron_schedule = v.into();
            self
        }

        /// Sets the value of [paused][crate::model::backup_plan::Schedule::paused].
        pub fn set_paused<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.paused = v.into();
            self
        }

        /// Sets the value of [rpo_config][crate::model::backup_plan::Schedule::rpo_config].
        pub fn set_rpo_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RpoConfig>,
        {
            self.rpo_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [rpo_config][crate::model::backup_plan::Schedule::rpo_config].
        pub fn set_or_clear_rpo_config<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RpoConfig>,
        {
            self.rpo_config = v.map(|x| x.into());
            self
        }

        /// Sets the value of [next_scheduled_backup_time][crate::model::backup_plan::Schedule::next_scheduled_backup_time].
        pub fn set_next_scheduled_backup_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.next_scheduled_backup_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [next_scheduled_backup_time][crate::model::backup_plan::Schedule::next_scheduled_backup_time].
        pub fn set_or_clear_next_scheduled_backup_time<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.next_scheduled_backup_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Schedule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.gkebackup.v1.BackupPlan.Schedule"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Schedule {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __cron_schedule,
                __paused,
                __rpo_config,
                __next_scheduled_backup_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Schedule")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "cronSchedule" => Ok(__FieldTag::__cron_schedule),
                                "cron_schedule" => Ok(__FieldTag::__cron_schedule),
                                "paused" => Ok(__FieldTag::__paused),
                                "rpoConfig" => Ok(__FieldTag::__rpo_config),
                                "rpo_config" => Ok(__FieldTag::__rpo_config),
                                "nextScheduledBackupTime" => {
                                    Ok(__FieldTag::__next_scheduled_backup_time)
                                }
                                "next_scheduled_backup_time" => {
                                    Ok(__FieldTag::__next_scheduled_backup_time)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Schedule;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Schedule")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__cron_schedule => {
                                if !fields.insert(__FieldTag::__cron_schedule) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cron_schedule",
                                    ));
                                }
                                result.cron_schedule = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__paused => {
                                if !fields.insert(__FieldTag::__paused) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for paused",
                                    ));
                                }
                                result.paused = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__rpo_config => {
                                if !fields.insert(__FieldTag::__rpo_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for rpo_config",
                                    ));
                                }
                                result.rpo_config = map
                                    .next_value::<std::option::Option<crate::model::RpoConfig>>()?;
                            }
                            __FieldTag::__next_scheduled_backup_time => {
                                if !fields.insert(__FieldTag::__next_scheduled_backup_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for next_scheduled_backup_time",
                                    ));
                                }
                                result.next_scheduled_backup_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Schedule {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.cron_schedule.is_empty() {
                state.serialize_entry("cronSchedule", &self.cron_schedule)?;
            }
            if !wkt::internal::is_default(&self.paused) {
                state.serialize_entry("paused", &self.paused)?;
            }
            if self.rpo_config.is_some() {
                state.serialize_entry("rpoConfig", &self.rpo_config)?;
            }
            if self.next_scheduled_backup_time.is_some() {
                state
                    .serialize_entry("nextScheduledBackupTime", &self.next_scheduled_backup_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// BackupConfig defines the configuration of Backups created via this
    /// BackupPlan.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BackupConfig {
        /// Optional. This flag specifies whether volume data should be backed up
        /// when PVCs are included in the scope of a Backup.
        ///
        /// Default: False
        pub include_volume_data: bool,

        /// Optional. This flag specifies whether Kubernetes Secret resources should
        /// be included when they fall into the scope of Backups.
        ///
        /// Default: False
        pub include_secrets: bool,

        /// Optional. This defines a customer managed encryption key that will be
        /// used to encrypt the "config" portion (the Kubernetes resources) of
        /// Backups created via this plan.
        ///
        /// Default (empty): Config backup artifacts will not be encrypted.
        pub encryption_key: std::option::Option<crate::model::EncryptionKey>,

        /// Optional. If false, Backups will fail when Backup for GKE detects
        /// Kubernetes configuration that is non-standard or
        /// requires additional setup to restore.
        ///
        /// Default: False
        pub permissive_mode: bool,

        /// This defines the "scope" of the Backup - which namespaced
        /// resources in the cluster will be included in a Backup.
        /// Exactly one of the fields of backup_scope MUST be specified.
        pub backup_scope:
            std::option::Option<crate::model::backup_plan::backup_config::BackupScope>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BackupConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [include_volume_data][crate::model::backup_plan::BackupConfig::include_volume_data].
        pub fn set_include_volume_data<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.include_volume_data = v.into();
            self
        }

        /// Sets the value of [include_secrets][crate::model::backup_plan::BackupConfig::include_secrets].
        pub fn set_include_secrets<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.include_secrets = v.into();
            self
        }

        /// Sets the value of [encryption_key][crate::model::backup_plan::BackupConfig::encryption_key].
        pub fn set_encryption_key<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::EncryptionKey>,
        {
            self.encryption_key = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [encryption_key][crate::model::backup_plan::BackupConfig::encryption_key].
        pub fn set_or_clear_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::EncryptionKey>,
        {
            self.encryption_key = v.map(|x| x.into());
            self
        }

        /// Sets the value of [permissive_mode][crate::model::backup_plan::BackupConfig::permissive_mode].
        pub fn set_permissive_mode<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.permissive_mode = v.into();
            self
        }

        /// Sets the value of [backup_scope][crate::model::backup_plan::BackupConfig::backup_scope].
        ///
        /// Note that all the setters affecting `backup_scope` are mutually
        /// exclusive.
        pub fn set_backup_scope<
            T: std::convert::Into<
                    std::option::Option<crate::model::backup_plan::backup_config::BackupScope>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.backup_scope = v.into();
            self
        }

        /// The value of [backup_scope][crate::model::backup_plan::BackupConfig::backup_scope]
        /// if it holds a `AllNamespaces`, `None` if the field is not set or
        /// holds a different branch.
        pub fn all_namespaces(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.backup_scope.as_ref().and_then(|v| match v {
                crate::model::backup_plan::backup_config::BackupScope::AllNamespaces(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [backup_scope][crate::model::backup_plan::BackupConfig::backup_scope]
        /// to hold a `AllNamespaces`.
        ///
        /// Note that all the setters affecting `backup_scope` are
        /// mutually exclusive.
        pub fn set_all_namespaces<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.backup_scope = std::option::Option::Some(
                crate::model::backup_plan::backup_config::BackupScope::AllNamespaces(v.into()),
            );
            self
        }

        /// The value of [backup_scope][crate::model::backup_plan::BackupConfig::backup_scope]
        /// if it holds a `SelectedNamespaces`, `None` if the field is not set or
        /// holds a different branch.
        pub fn selected_namespaces(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::Namespaces>> {
            #[allow(unreachable_patterns)]
            self.backup_scope.as_ref().and_then(|v| match v {
                crate::model::backup_plan::backup_config::BackupScope::SelectedNamespaces(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [backup_scope][crate::model::backup_plan::BackupConfig::backup_scope]
        /// to hold a `SelectedNamespaces`.
        ///
        /// Note that all the setters affecting `backup_scope` are
        /// mutually exclusive.
        pub fn set_selected_namespaces<
            T: std::convert::Into<std::boxed::Box<crate::model::Namespaces>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.backup_scope = std::option::Option::Some(
                crate::model::backup_plan::backup_config::BackupScope::SelectedNamespaces(v.into()),
            );
            self
        }

        /// The value of [backup_scope][crate::model::backup_plan::BackupConfig::backup_scope]
        /// if it holds a `SelectedApplications`, `None` if the field is not set or
        /// holds a different branch.
        pub fn selected_applications(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::NamespacedNames>> {
            #[allow(unreachable_patterns)]
            self.backup_scope.as_ref().and_then(|v| match v {
                crate::model::backup_plan::backup_config::BackupScope::SelectedApplications(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [backup_scope][crate::model::backup_plan::BackupConfig::backup_scope]
        /// to hold a `SelectedApplications`.
        ///
        /// Note that all the setters affecting `backup_scope` are
        /// mutually exclusive.
        pub fn set_selected_applications<
            T: std::convert::Into<std::boxed::Box<crate::model::NamespacedNames>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.backup_scope = std::option::Option::Some(
                crate::model::backup_plan::backup_config::BackupScope::SelectedApplications(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for BackupConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.gkebackup.v1.BackupPlan.BackupConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BackupConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __all_namespaces,
                __selected_namespaces,
                __selected_applications,
                __include_volume_data,
                __include_secrets,
                __encryption_key,
                __permissive_mode,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BackupConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "allNamespaces" => Ok(__FieldTag::__all_namespaces),
                                "all_namespaces" => Ok(__FieldTag::__all_namespaces),
                                "selectedNamespaces" => Ok(__FieldTag::__selected_namespaces),
                                "selected_namespaces" => Ok(__FieldTag::__selected_namespaces),
                                "selectedApplications" => Ok(__FieldTag::__selected_applications),
                                "selected_applications" => Ok(__FieldTag::__selected_applications),
                                "includeVolumeData" => Ok(__FieldTag::__include_volume_data),
                                "include_volume_data" => Ok(__FieldTag::__include_volume_data),
                                "includeSecrets" => Ok(__FieldTag::__include_secrets),
                                "include_secrets" => Ok(__FieldTag::__include_secrets),
                                "encryptionKey" => Ok(__FieldTag::__encryption_key),
                                "encryption_key" => Ok(__FieldTag::__encryption_key),
                                "permissiveMode" => Ok(__FieldTag::__permissive_mode),
                                "permissive_mode" => Ok(__FieldTag::__permissive_mode),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BackupConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BackupConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__all_namespaces => {
                                if !fields.insert(__FieldTag::__all_namespaces) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for all_namespaces",
                                    ));
                                }
                                if result.backup_scope.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `backup_scope`, a oneof with full ID .google.cloud.gkebackup.v1.BackupPlan.BackupConfig.all_namespaces, latest field was allNamespaces",
                                    ));
                                }
                                result.backup_scope = std::option::Option::Some(
                                    crate::model::backup_plan::backup_config::BackupScope::AllNamespaces(
                                        map.next_value::<std::option::Option<bool>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__selected_namespaces => {
                                if !fields.insert(__FieldTag::__selected_namespaces) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for selected_namespaces",
                                    ));
                                }
                                if result.backup_scope.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `backup_scope`, a oneof with full ID .google.cloud.gkebackup.v1.BackupPlan.BackupConfig.selected_namespaces, latest field was selectedNamespaces",
                                    ));
                                }
                                result.backup_scope = std::option::Option::Some(
                                    crate::model::backup_plan::backup_config::BackupScope::SelectedNamespaces(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::Namespaces>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__selected_applications => {
                                if !fields.insert(__FieldTag::__selected_applications) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for selected_applications",
                                    ));
                                }
                                if result.backup_scope.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `backup_scope`, a oneof with full ID .google.cloud.gkebackup.v1.BackupPlan.BackupConfig.selected_applications, latest field was selectedApplications",
                                    ));
                                }
                                result.backup_scope = std::option::Option::Some(
                                    crate::model::backup_plan::backup_config::BackupScope::SelectedApplications(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::NamespacedNames>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__include_volume_data => {
                                if !fields.insert(__FieldTag::__include_volume_data) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for include_volume_data",
                                    ));
                                }
                                result.include_volume_data = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__include_secrets => {
                                if !fields.insert(__FieldTag::__include_secrets) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for include_secrets",
                                    ));
                                }
                                result.include_secrets = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__encryption_key => {
                                if !fields.insert(__FieldTag::__encryption_key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for encryption_key",
                                    ));
                                }
                                result.encryption_key = map
                                    .next_value::<std::option::Option<crate::model::EncryptionKey>>(
                                    )?;
                            }
                            __FieldTag::__permissive_mode => {
                                if !fields.insert(__FieldTag::__permissive_mode) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for permissive_mode",
                                    ));
                                }
                                result.permissive_mode = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BackupConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.all_namespaces() {
                state.serialize_entry("allNamespaces", value)?;
            }
            if let Some(value) = self.selected_namespaces() {
                state.serialize_entry("selectedNamespaces", value)?;
            }
            if let Some(value) = self.selected_applications() {
                state.serialize_entry("selectedApplications", value)?;
            }
            if !wkt::internal::is_default(&self.include_volume_data) {
                state.serialize_entry("includeVolumeData", &self.include_volume_data)?;
            }
            if !wkt::internal::is_default(&self.include_secrets) {
                state.serialize_entry("includeSecrets", &self.include_secrets)?;
            }
            if self.encryption_key.is_some() {
                state.serialize_entry("encryptionKey", &self.encryption_key)?;
            }
            if !wkt::internal::is_default(&self.permissive_mode) {
                state.serialize_entry("permissiveMode", &self.permissive_mode)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [BackupConfig].
    pub mod backup_config {
        #[allow(unused_imports)]
        use super::*;

        /// This defines the "scope" of the Backup - which namespaced
        /// resources in the cluster will be included in a Backup.
        /// Exactly one of the fields of backup_scope MUST be specified.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum BackupScope {
            /// If True, include all namespaced resources
            AllNamespaces(bool),
            /// If set, include just the resources in the listed namespaces.
            SelectedNamespaces(std::boxed::Box<crate::model::Namespaces>),
            /// If set, include just the resources referenced by the listed
            /// ProtectedApplications.
            SelectedApplications(std::boxed::Box<crate::model::NamespacedNames>),
        }
    }

    /// State
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default first value for Enums.
        Unspecified,
        /// Waiting for cluster state to be RUNNING.
        ClusterPending,
        /// The BackupPlan is in the process of being created.
        Provisioning,
        /// The BackupPlan has successfully been created and is ready for Backups.
        Ready,
        /// BackupPlan creation has failed.
        Failed,
        /// The BackupPlan has been deactivated.
        Deactivated,
        /// The BackupPlan is in the process of being deleted.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ClusterPending => std::option::Option::Some(1),
                Self::Provisioning => std::option::Option::Some(2),
                Self::Ready => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Deactivated => std::option::Option::Some(5),
                Self::Deleting => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::ClusterPending => std::option::Option::Some("CLUSTER_PENDING"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Deactivated => std::option::Option::Some("DEACTIVATED"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ClusterPending,
                2 => Self::Provisioning,
                3 => Self::Ready,
                4 => Self::Failed,
                5 => Self::Deactivated,
                6 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CLUSTER_PENDING" => Self::ClusterPending,
                "PROVISIONING" => Self::Provisioning,
                "READY" => Self::Ready,
                "FAILED" => Self::Failed,
                "DEACTIVATED" => Self::Deactivated,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ClusterPending => serializer.serialize_i32(1),
                Self::Provisioning => serializer.serialize_i32(2),
                Self::Ready => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Deactivated => serializer.serialize_i32(5),
                Self::Deleting => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.gkebackup.v1.BackupPlan.State",
            ))
        }
    }
}

/// Defines RPO scheduling configuration for automatically creating
/// Backups via this BackupPlan.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RpoConfig {
    /// Required. Defines the target RPO for the BackupPlan in minutes, which means
    /// the target maximum data loss in time that is acceptable for this
    /// BackupPlan. This must be at least 60, i.e., 1 hour, and at most 86400,
    /// i.e., 60 days.
    pub target_rpo_minutes: i32,

    /// Optional. User specified time windows during which backup can NOT happen
    /// for this BackupPlan - backups should start and finish outside of any given
    /// exclusion window. Note: backup jobs will be scheduled to start and
    /// finish outside the duration of the window as much as possible, but
    /// running jobs will not get canceled when it runs into the window.
    /// All the time and date values in exclusion_windows entry in the API are in
    /// UTC.
    /// We only allow <=1 recurrence (daily or weekly) exclusion window for a
    /// BackupPlan while no restriction on number of single occurrence
    /// windows.
    pub exclusion_windows: std::vec::Vec<crate::model::ExclusionWindow>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RpoConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_rpo_minutes][crate::model::RpoConfig::target_rpo_minutes].
    pub fn set_target_rpo_minutes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.target_rpo_minutes = v.into();
        self
    }

    /// Sets the value of [exclusion_windows][crate::model::RpoConfig::exclusion_windows].
    pub fn set_exclusion_windows<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ExclusionWindow>,
    {
        use std::iter::Iterator;
        self.exclusion_windows = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for RpoConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.RpoConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RpoConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target_rpo_minutes,
            __exclusion_windows,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RpoConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targetRpoMinutes" => Ok(__FieldTag::__target_rpo_minutes),
                            "target_rpo_minutes" => Ok(__FieldTag::__target_rpo_minutes),
                            "exclusionWindows" => Ok(__FieldTag::__exclusion_windows),
                            "exclusion_windows" => Ok(__FieldTag::__exclusion_windows),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RpoConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RpoConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target_rpo_minutes => {
                            if !fields.insert(__FieldTag::__target_rpo_minutes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_rpo_minutes",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.target_rpo_minutes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__exclusion_windows => {
                            if !fields.insert(__FieldTag::__exclusion_windows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exclusion_windows",
                                ));
                            }
                            result.exclusion_windows =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ExclusionWindow>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RpoConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.target_rpo_minutes) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("targetRpoMinutes", &__With(&self.target_rpo_minutes))?;
        }
        if !self.exclusion_windows.is_empty() {
            state.serialize_entry("exclusionWindows", &self.exclusion_windows)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines a time window during which no backup should
/// happen. All time and date are in UTC.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExclusionWindow {
    /// Required. Specifies the start time of the window using time of the day in
    /// UTC.
    pub start_time: std::option::Option<gtype::model::TimeOfDay>,

    /// Required. Specifies duration of the window.
    /// Duration must be >= 5 minutes and < (target RPO - 20 minutes).
    /// Additional restrictions based on the recurrence type to allow some time for
    /// backup to happen:
    ///
    /// - single_occurrence_date:  no restriction, but UI may warn about this when
    ///   duration >= target RPO
    /// - daily window: duration < 24 hours
    /// - weekly window:
    ///   - days of week includes all seven days of a week: duration < 24 hours
    ///   - all other weekly window: duration < 168 hours (i.e., 24 * 7 hours)
    pub duration: std::option::Option<wkt::Duration>,

    /// Required. Specifies the day(s) on which the exclusion window takes
    /// effect. Exactly one of the fields MUST be specified.
    pub recurrence: std::option::Option<crate::model::exclusion_window::Recurrence>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExclusionWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::ExclusionWindow::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::ExclusionWindow::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [duration][crate::model::ExclusionWindow::duration].
    pub fn set_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [duration][crate::model::ExclusionWindow::duration].
    pub fn set_or_clear_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recurrence][crate::model::ExclusionWindow::recurrence].
    ///
    /// Note that all the setters affecting `recurrence` are mutually
    /// exclusive.
    pub fn set_recurrence<
        T: std::convert::Into<std::option::Option<crate::model::exclusion_window::Recurrence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.recurrence = v.into();
        self
    }

    /// The value of [recurrence][crate::model::ExclusionWindow::recurrence]
    /// if it holds a `SingleOccurrenceDate`, `None` if the field is not set or
    /// holds a different branch.
    pub fn single_occurrence_date(
        &self,
    ) -> std::option::Option<&std::boxed::Box<gtype::model::Date>> {
        #[allow(unreachable_patterns)]
        self.recurrence.as_ref().and_then(|v| match v {
            crate::model::exclusion_window::Recurrence::SingleOccurrenceDate(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [recurrence][crate::model::ExclusionWindow::recurrence]
    /// to hold a `SingleOccurrenceDate`.
    ///
    /// Note that all the setters affecting `recurrence` are
    /// mutually exclusive.
    pub fn set_single_occurrence_date<
        T: std::convert::Into<std::boxed::Box<gtype::model::Date>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.recurrence = std::option::Option::Some(
            crate::model::exclusion_window::Recurrence::SingleOccurrenceDate(v.into()),
        );
        self
    }

    /// The value of [recurrence][crate::model::ExclusionWindow::recurrence]
    /// if it holds a `Daily`, `None` if the field is not set or
    /// holds a different branch.
    pub fn daily(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.recurrence.as_ref().and_then(|v| match v {
            crate::model::exclusion_window::Recurrence::Daily(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [recurrence][crate::model::ExclusionWindow::recurrence]
    /// to hold a `Daily`.
    ///
    /// Note that all the setters affecting `recurrence` are
    /// mutually exclusive.
    pub fn set_daily<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.recurrence =
            std::option::Option::Some(crate::model::exclusion_window::Recurrence::Daily(v.into()));
        self
    }

    /// The value of [recurrence][crate::model::ExclusionWindow::recurrence]
    /// if it holds a `DaysOfWeek`, `None` if the field is not set or
    /// holds a different branch.
    pub fn days_of_week(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::exclusion_window::DayOfWeekList>> {
        #[allow(unreachable_patterns)]
        self.recurrence.as_ref().and_then(|v| match v {
            crate::model::exclusion_window::Recurrence::DaysOfWeek(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [recurrence][crate::model::ExclusionWindow::recurrence]
    /// to hold a `DaysOfWeek`.
    ///
    /// Note that all the setters affecting `recurrence` are
    /// mutually exclusive.
    pub fn set_days_of_week<
        T: std::convert::Into<std::boxed::Box<crate::model::exclusion_window::DayOfWeekList>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.recurrence = std::option::Option::Some(
            crate::model::exclusion_window::Recurrence::DaysOfWeek(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExclusionWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.ExclusionWindow"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExclusionWindow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __duration,
            __single_occurrence_date,
            __daily,
            __days_of_week,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExclusionWindow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "duration" => Ok(__FieldTag::__duration),
                            "singleOccurrenceDate" => Ok(__FieldTag::__single_occurrence_date),
                            "single_occurrence_date" => Ok(__FieldTag::__single_occurrence_date),
                            "daily" => Ok(__FieldTag::__daily),
                            "daysOfWeek" => Ok(__FieldTag::__days_of_week),
                            "days_of_week" => Ok(__FieldTag::__days_of_week),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExclusionWindow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExclusionWindow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<gtype::model::TimeOfDay>>()?;
                        }
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            result.duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__single_occurrence_date => {
                            if !fields.insert(__FieldTag::__single_occurrence_date) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for single_occurrence_date",
                                ));
                            }
                            if result.recurrence.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `recurrence`, a oneof with full ID .google.cloud.gkebackup.v1.ExclusionWindow.single_occurrence_date, latest field was singleOccurrenceDate",
                                ));
                            }
                            result.recurrence = std::option::Option::Some(
                                crate::model::exclusion_window::Recurrence::SingleOccurrenceDate(
                                    map.next_value::<std::option::Option<std::boxed::Box<gtype::model::Date>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__daily => {
                            if !fields.insert(__FieldTag::__daily) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for daily",
                                ));
                            }
                            if result.recurrence.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `recurrence`, a oneof with full ID .google.cloud.gkebackup.v1.ExclusionWindow.daily, latest field was daily",
                                ));
                            }
                            result.recurrence = std::option::Option::Some(
                                crate::model::exclusion_window::Recurrence::Daily(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__days_of_week => {
                            if !fields.insert(__FieldTag::__days_of_week) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for days_of_week",
                                ));
                            }
                            if result.recurrence.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `recurrence`, a oneof with full ID .google.cloud.gkebackup.v1.ExclusionWindow.days_of_week, latest field was daysOfWeek",
                                ));
                            }
                            result.recurrence = std::option::Option::Some(
                                crate::model::exclusion_window::Recurrence::DaysOfWeek(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::exclusion_window::DayOfWeekList,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExclusionWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.duration.is_some() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if let Some(value) = self.single_occurrence_date() {
            state.serialize_entry("singleOccurrenceDate", value)?;
        }
        if let Some(value) = self.daily() {
            state.serialize_entry("daily", value)?;
        }
        if let Some(value) = self.days_of_week() {
            state.serialize_entry("daysOfWeek", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExclusionWindow].
pub mod exclusion_window {
    #[allow(unused_imports)]
    use super::*;

    /// Holds repeated DaysOfWeek values as a container.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DayOfWeekList {
        /// Optional. A list of days of week.
        pub days_of_week: std::vec::Vec<gtype::model::DayOfWeek>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DayOfWeekList {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [days_of_week][crate::model::exclusion_window::DayOfWeekList::days_of_week].
        pub fn set_days_of_week<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<gtype::model::DayOfWeek>,
        {
            use std::iter::Iterator;
            self.days_of_week = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for DayOfWeekList {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.gkebackup.v1.ExclusionWindow.DayOfWeekList"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DayOfWeekList {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __days_of_week,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DayOfWeekList")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "daysOfWeek" => Ok(__FieldTag::__days_of_week),
                                "days_of_week" => Ok(__FieldTag::__days_of_week),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DayOfWeekList;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DayOfWeekList")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__days_of_week => {
                                if !fields.insert(__FieldTag::__days_of_week) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for days_of_week",
                                    ));
                                }
                                result.days_of_week = map.next_value::<std::option::Option<std::vec::Vec<gtype::model::DayOfWeek>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DayOfWeekList {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.days_of_week.is_empty() {
                state.serialize_entry("daysOfWeek", &self.days_of_week)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Required. Specifies the day(s) on which the exclusion window takes
    /// effect. Exactly one of the fields MUST be specified.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Recurrence {
        /// No recurrence. The exclusion window occurs only once and on this
        /// date in UTC.
        SingleOccurrenceDate(std::boxed::Box<gtype::model::Date>),
        /// The exclusion window occurs every day if set to "True".
        /// Specifying this field to "False" is an error.
        Daily(bool),
        /// The exclusion window occurs on these days of each week in UTC.
        DaysOfWeek(std::boxed::Box<crate::model::exclusion_window::DayOfWeekList>),
    }
}

/// A BackupPlanBinding binds a BackupPlan with a BackupChannel.
/// This resource is created automatically when a BackupPlan is created using a
/// BackupChannel. This also serves as a holder for cross-project fields
/// that need to be displayed in the current project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupPlanBinding {
    /// Identifier. The fully qualified name of the BackupPlanBinding.
    /// `projects/*/locations/*/backupChannels/*/backupPlanBindings/*`
    pub name: std::string::String,

    /// Output only. Server generated global unique identifier of
    /// [UUID4](https://en.wikipedia.org/wiki/Universally_unique_identifier)
    pub uid: std::string::String,

    /// Output only. The timestamp when this binding was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when this binding was created.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Immutable. The fully qualified name of the BackupPlan bound
    /// with the parent BackupChannel.
    /// `projects/*/locations/*/backupPlans/{backup_plan}`
    pub backup_plan: std::string::String,

    /// Output only. Immutable. The fully qualified name of the cluster that is
    /// being backed up Valid formats:
    ///
    /// - `projects/*/locations/*/clusters/*`
    /// - `projects/*/zones/*/clusters/*`
    pub cluster: std::string::String,

    /// Output only. Contains details about the backup plan/backup.
    pub backup_plan_details:
        std::option::Option<crate::model::backup_plan_binding::BackupPlanDetails>,

    /// Output only. `etag` is used for optimistic concurrency control as a way to
    /// help prevent simultaneous updates of a BackupPlanBinding from overwriting
    /// each other. It is strongly suggested that systems make use of the 'etag' in
    /// the read-modify-write cycle to perform BackupPlanBinding updates in
    /// order to avoid race conditions: An `etag` is returned in the response to
    /// `GetBackupPlanBinding`, and systems are expected to put that etag in
    /// the request to `UpdateBackupPlanBinding` or
    /// `DeleteBackupPlanBinding` to ensure that their change will be applied
    /// to the same version of the resource.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupPlanBinding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BackupPlanBinding::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::BackupPlanBinding::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BackupPlanBinding::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BackupPlanBinding::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::BackupPlanBinding::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::BackupPlanBinding::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_plan][crate::model::BackupPlanBinding::backup_plan].
    pub fn set_backup_plan<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_plan = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::BackupPlanBinding::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [backup_plan_details][crate::model::BackupPlanBinding::backup_plan_details].
    pub fn set_backup_plan_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::backup_plan_binding::BackupPlanDetails>,
    {
        self.backup_plan_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_plan_details][crate::model::BackupPlanBinding::backup_plan_details].
    pub fn set_or_clear_backup_plan_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::backup_plan_binding::BackupPlanDetails>,
    {
        self.backup_plan_details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::BackupPlanBinding::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for BackupPlanBinding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.BackupPlanBinding"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupPlanBinding {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __create_time,
            __update_time,
            __backup_plan,
            __cluster,
            __backup_plan_details,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupPlanBinding")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "backupPlan" => Ok(__FieldTag::__backup_plan),
                            "backup_plan" => Ok(__FieldTag::__backup_plan),
                            "cluster" => Ok(__FieldTag::__cluster),
                            "backupPlanDetails" => Ok(__FieldTag::__backup_plan_details),
                            "backup_plan_details" => Ok(__FieldTag::__backup_plan_details),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupPlanBinding;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupPlanBinding")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__backup_plan => {
                            if !fields.insert(__FieldTag::__backup_plan) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_plan",
                                ));
                            }
                            result.backup_plan = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_plan_details => {
                            if !fields.insert(__FieldTag::__backup_plan_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_plan_details",
                                ));
                            }
                            result.backup_plan_details = map.next_value::<std::option::Option<
                                crate::model::backup_plan_binding::BackupPlanDetails,
                            >>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupPlanBinding {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.backup_plan.is_empty() {
            state.serialize_entry("backupPlan", &self.backup_plan)?;
        }
        if !self.cluster.is_empty() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if self.backup_plan_details.is_some() {
            state.serialize_entry("backupPlanDetails", &self.backup_plan_details)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BackupPlanBinding].
pub mod backup_plan_binding {
    #[allow(unused_imports)]
    use super::*;

    /// Contains metadata about the backup plan/backup.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BackupPlanDetails {
        /// Output only. The number of Kubernetes Pods backed up in the
        /// last successful Backup created via this BackupPlan.
        pub protected_pod_count: i32,

        /// Output only. State of the BackupPlan.
        pub state: crate::model::backup_plan_binding::backup_plan_details::State,

        /// Output only. Completion time of the last successful Backup. This is
        /// sourced from a successful Backup's complete_time field.
        pub last_successful_backup_time: std::option::Option<wkt::Timestamp>,

        /// Output only. Start time of next scheduled backup under this BackupPlan by
        /// either cron_schedule or rpo config. This is sourced from BackupPlan.
        pub next_scheduled_backup_time: std::option::Option<wkt::Timestamp>,

        /// Output only. A number that represents the current risk level of this
        /// BackupPlan from RPO perspective with 1 being no risk and 5 being highest
        /// risk.
        pub rpo_risk_level: i32,

        /// Output only. The fully qualified name of the last successful Backup
        /// created under this BackupPlan.
        /// `projects/*/locations/*/backupPlans/*/backups/*`
        pub last_successful_backup: std::string::String,

        /// Output only. Contains details about the BackupConfig of Backups created
        /// via this BackupPlan.
        pub backup_config_details: std::option::Option<
            crate::model::backup_plan_binding::backup_plan_details::BackupConfigDetails,
        >,

        /// Output only. Contains details about the RetentionPolicy of Backups
        /// created via this BackupPlan.
        pub retention_policy_details: std::option::Option<
            crate::model::backup_plan_binding::backup_plan_details::RetentionPolicyDetails,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BackupPlanDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [protected_pod_count][crate::model::backup_plan_binding::BackupPlanDetails::protected_pod_count].
        pub fn set_protected_pod_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.protected_pod_count = v.into();
            self
        }

        /// Sets the value of [state][crate::model::backup_plan_binding::BackupPlanDetails::state].
        pub fn set_state<
            T: std::convert::Into<crate::model::backup_plan_binding::backup_plan_details::State>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [last_successful_backup_time][crate::model::backup_plan_binding::BackupPlanDetails::last_successful_backup_time].
        pub fn set_last_successful_backup_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.last_successful_backup_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [last_successful_backup_time][crate::model::backup_plan_binding::BackupPlanDetails::last_successful_backup_time].
        pub fn set_or_clear_last_successful_backup_time<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.last_successful_backup_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [next_scheduled_backup_time][crate::model::backup_plan_binding::BackupPlanDetails::next_scheduled_backup_time].
        pub fn set_next_scheduled_backup_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.next_scheduled_backup_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [next_scheduled_backup_time][crate::model::backup_plan_binding::BackupPlanDetails::next_scheduled_backup_time].
        pub fn set_or_clear_next_scheduled_backup_time<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.next_scheduled_backup_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [rpo_risk_level][crate::model::backup_plan_binding::BackupPlanDetails::rpo_risk_level].
        pub fn set_rpo_risk_level<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.rpo_risk_level = v.into();
            self
        }

        /// Sets the value of [last_successful_backup][crate::model::backup_plan_binding::BackupPlanDetails::last_successful_backup].
        pub fn set_last_successful_backup<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.last_successful_backup = v.into();
            self
        }

        /// Sets the value of [backup_config_details][crate::model::backup_plan_binding::BackupPlanDetails::backup_config_details].
        pub fn set_backup_config_details<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::backup_plan_binding::backup_plan_details::BackupConfigDetails,
                >,
        {
            self.backup_config_details = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [backup_config_details][crate::model::backup_plan_binding::BackupPlanDetails::backup_config_details].
        pub fn set_or_clear_backup_config_details<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::backup_plan_binding::backup_plan_details::BackupConfigDetails,
                >,
        {
            self.backup_config_details = v.map(|x| x.into());
            self
        }

        /// Sets the value of [retention_policy_details][crate::model::backup_plan_binding::BackupPlanDetails::retention_policy_details].
        pub fn set_retention_policy_details<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::backup_plan_binding::backup_plan_details::RetentionPolicyDetails,
                >,
        {
            self.retention_policy_details = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [retention_policy_details][crate::model::backup_plan_binding::BackupPlanDetails::retention_policy_details].
        pub fn set_or_clear_retention_policy_details<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::backup_plan_binding::backup_plan_details::RetentionPolicyDetails,
                >,
        {
            self.retention_policy_details = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for BackupPlanDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.gkebackup.v1.BackupPlanBinding.BackupPlanDetails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BackupPlanDetails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __protected_pod_count,
                __state,
                __last_successful_backup_time,
                __next_scheduled_backup_time,
                __rpo_risk_level,
                __last_successful_backup,
                __backup_config_details,
                __retention_policy_details,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BackupPlanDetails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "protectedPodCount" => Ok(__FieldTag::__protected_pod_count),
                                "protected_pod_count" => Ok(__FieldTag::__protected_pod_count),
                                "state" => Ok(__FieldTag::__state),
                                "lastSuccessfulBackupTime" => {
                                    Ok(__FieldTag::__last_successful_backup_time)
                                }
                                "last_successful_backup_time" => {
                                    Ok(__FieldTag::__last_successful_backup_time)
                                }
                                "nextScheduledBackupTime" => {
                                    Ok(__FieldTag::__next_scheduled_backup_time)
                                }
                                "next_scheduled_backup_time" => {
                                    Ok(__FieldTag::__next_scheduled_backup_time)
                                }
                                "rpoRiskLevel" => Ok(__FieldTag::__rpo_risk_level),
                                "rpo_risk_level" => Ok(__FieldTag::__rpo_risk_level),
                                "lastSuccessfulBackup" => Ok(__FieldTag::__last_successful_backup),
                                "last_successful_backup" => {
                                    Ok(__FieldTag::__last_successful_backup)
                                }
                                "backupConfigDetails" => Ok(__FieldTag::__backup_config_details),
                                "backup_config_details" => Ok(__FieldTag::__backup_config_details),
                                "retentionPolicyDetails" => {
                                    Ok(__FieldTag::__retention_policy_details)
                                }
                                "retention_policy_details" => {
                                    Ok(__FieldTag::__retention_policy_details)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BackupPlanDetails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BackupPlanDetails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__protected_pod_count => {
                                if !fields.insert(__FieldTag::__protected_pod_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for protected_pod_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.protected_pod_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map.next_value::<std::option::Option<crate::model::backup_plan_binding::backup_plan_details::State>>()?.unwrap_or_default();
                            }
                            __FieldTag::__last_successful_backup_time => {
                                if !fields.insert(__FieldTag::__last_successful_backup_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for last_successful_backup_time",
                                    ));
                                }
                                result.last_successful_backup_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__next_scheduled_backup_time => {
                                if !fields.insert(__FieldTag::__next_scheduled_backup_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for next_scheduled_backup_time",
                                    ));
                                }
                                result.next_scheduled_backup_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__rpo_risk_level => {
                                if !fields.insert(__FieldTag::__rpo_risk_level) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for rpo_risk_level",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.rpo_risk_level =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__last_successful_backup => {
                                if !fields.insert(__FieldTag::__last_successful_backup) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for last_successful_backup",
                                    ));
                                }
                                result.last_successful_backup = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__backup_config_details => {
                                if !fields.insert(__FieldTag::__backup_config_details) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for backup_config_details",
                                    ));
                                }
                                result.backup_config_details = map.next_value::<std::option::Option<crate::model::backup_plan_binding::backup_plan_details::BackupConfigDetails>>()?
                                    ;
                            }
                            __FieldTag::__retention_policy_details => {
                                if !fields.insert(__FieldTag::__retention_policy_details) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for retention_policy_details",
                                    ));
                                }
                                result.retention_policy_details = map.next_value::<std::option::Option<crate::model::backup_plan_binding::backup_plan_details::RetentionPolicyDetails>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BackupPlanDetails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.protected_pod_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("protectedPodCount", &__With(&self.protected_pod_count))?;
            }
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if self.last_successful_backup_time.is_some() {
                state.serialize_entry(
                    "lastSuccessfulBackupTime",
                    &self.last_successful_backup_time,
                )?;
            }
            if self.next_scheduled_backup_time.is_some() {
                state
                    .serialize_entry("nextScheduledBackupTime", &self.next_scheduled_backup_time)?;
            }
            if !wkt::internal::is_default(&self.rpo_risk_level) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("rpoRiskLevel", &__With(&self.rpo_risk_level))?;
            }
            if !self.last_successful_backup.is_empty() {
                state.serialize_entry("lastSuccessfulBackup", &self.last_successful_backup)?;
            }
            if self.backup_config_details.is_some() {
                state.serialize_entry("backupConfigDetails", &self.backup_config_details)?;
            }
            if self.retention_policy_details.is_some() {
                state.serialize_entry("retentionPolicyDetails", &self.retention_policy_details)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [BackupPlanDetails].
    pub mod backup_plan_details {
        #[allow(unused_imports)]
        use super::*;

        /// BackupConfigDetails defines the configuration of Backups created via this
        /// BackupPlan.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct BackupConfigDetails {

            /// Output only. This flag specifies whether volume data should be backed
            /// up when PVCs are included in the scope of a Backup.
            ///
            /// Default: False
            pub include_volume_data: bool,

            /// Output only. This flag specifies whether Kubernetes Secret resources
            /// should be included when they fall into the scope of Backups.
            ///
            /// Default: False
            pub include_secrets: bool,

            /// Output only. This defines a customer managed encryption key that will
            /// be used to encrypt the "config" portion (the Kubernetes resources) of
            /// Backups created via this plan.
            ///
            /// Default (empty): Config backup artifacts will not be encrypted.
            pub encryption_key: std::option::Option<crate::model::EncryptionKey>,

            /// This defines the "scope" of the Backup - which namespaced
            /// resources in the cluster will be included in a Backup.
            /// Exactly one of the fields of backup_scope MUST be specified.
            pub backup_scope: std::option::Option<crate::model::backup_plan_binding::backup_plan_details::backup_config_details::BackupScope>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl BackupConfigDetails {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [include_volume_data][crate::model::backup_plan_binding::backup_plan_details::BackupConfigDetails::include_volume_data].
            pub fn set_include_volume_data<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.include_volume_data = v.into();
                self
            }

            /// Sets the value of [include_secrets][crate::model::backup_plan_binding::backup_plan_details::BackupConfigDetails::include_secrets].
            pub fn set_include_secrets<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.include_secrets = v.into();
                self
            }

            /// Sets the value of [encryption_key][crate::model::backup_plan_binding::backup_plan_details::BackupConfigDetails::encryption_key].
            pub fn set_encryption_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::EncryptionKey>,
            {
                self.encryption_key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [encryption_key][crate::model::backup_plan_binding::backup_plan_details::BackupConfigDetails::encryption_key].
            pub fn set_or_clear_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::EncryptionKey>,
            {
                self.encryption_key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [backup_scope][crate::model::backup_plan_binding::backup_plan_details::BackupConfigDetails::backup_scope].
            ///
            /// Note that all the setters affecting `backup_scope` are mutually
            /// exclusive.
            pub fn set_backup_scope<T: std::convert::Into<std::option::Option<crate::model::backup_plan_binding::backup_plan_details::backup_config_details::BackupScope>>>(mut self, v: T) -> Self
            {
                self.backup_scope = v.into();
                self
            }

            /// The value of [backup_scope][crate::model::backup_plan_binding::backup_plan_details::BackupConfigDetails::backup_scope]
            /// if it holds a `AllNamespaces`, `None` if the field is not set or
            /// holds a different branch.
            pub fn all_namespaces(&self) -> std::option::Option<&bool> {
                #[allow(unreachable_patterns)]
                self.backup_scope.as_ref().and_then(|v| match v {
                    crate::model::backup_plan_binding::backup_plan_details::backup_config_details::BackupScope::AllNamespaces(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [backup_scope][crate::model::backup_plan_binding::backup_plan_details::BackupConfigDetails::backup_scope]
            /// to hold a `AllNamespaces`.
            ///
            /// Note that all the setters affecting `backup_scope` are
            /// mutually exclusive.
            pub fn set_all_namespaces<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.backup_scope = std::option::Option::Some(
                    crate::model::backup_plan_binding::backup_plan_details::backup_config_details::BackupScope::AllNamespaces(
                        v.into()
                    )
                );
                self
            }

            /// The value of [backup_scope][crate::model::backup_plan_binding::backup_plan_details::BackupConfigDetails::backup_scope]
            /// if it holds a `SelectedNamespaces`, `None` if the field is not set or
            /// holds a different branch.
            pub fn selected_namespaces(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::Namespaces>> {
                #[allow(unreachable_patterns)]
                self.backup_scope.as_ref().and_then(|v| match v {
                    crate::model::backup_plan_binding::backup_plan_details::backup_config_details::BackupScope::SelectedNamespaces(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [backup_scope][crate::model::backup_plan_binding::backup_plan_details::BackupConfigDetails::backup_scope]
            /// to hold a `SelectedNamespaces`.
            ///
            /// Note that all the setters affecting `backup_scope` are
            /// mutually exclusive.
            pub fn set_selected_namespaces<
                T: std::convert::Into<std::boxed::Box<crate::model::Namespaces>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.backup_scope = std::option::Option::Some(
                    crate::model::backup_plan_binding::backup_plan_details::backup_config_details::BackupScope::SelectedNamespaces(
                        v.into()
                    )
                );
                self
            }

            /// The value of [backup_scope][crate::model::backup_plan_binding::backup_plan_details::BackupConfigDetails::backup_scope]
            /// if it holds a `SelectedApplications`, `None` if the field is not set or
            /// holds a different branch.
            pub fn selected_applications(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::NamespacedNames>> {
                #[allow(unreachable_patterns)]
                self.backup_scope.as_ref().and_then(|v| match v {
                    crate::model::backup_plan_binding::backup_plan_details::backup_config_details::BackupScope::SelectedApplications(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [backup_scope][crate::model::backup_plan_binding::backup_plan_details::BackupConfigDetails::backup_scope]
            /// to hold a `SelectedApplications`.
            ///
            /// Note that all the setters affecting `backup_scope` are
            /// mutually exclusive.
            pub fn set_selected_applications<
                T: std::convert::Into<std::boxed::Box<crate::model::NamespacedNames>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.backup_scope = std::option::Option::Some(
                    crate::model::backup_plan_binding::backup_plan_details::backup_config_details::BackupScope::SelectedApplications(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for BackupConfigDetails {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.gkebackup.v1.BackupPlanBinding.BackupPlanDetails.BackupConfigDetails"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for BackupConfigDetails {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __all_namespaces,
                    __selected_namespaces,
                    __selected_applications,
                    __include_volume_data,
                    __include_secrets,
                    __encryption_key,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for BackupConfigDetails")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "allNamespaces" => Ok(__FieldTag::__all_namespaces),
                                    "all_namespaces" => Ok(__FieldTag::__all_namespaces),
                                    "selectedNamespaces" => Ok(__FieldTag::__selected_namespaces),
                                    "selected_namespaces" => Ok(__FieldTag::__selected_namespaces),
                                    "selectedApplications" => {
                                        Ok(__FieldTag::__selected_applications)
                                    }
                                    "selected_applications" => {
                                        Ok(__FieldTag::__selected_applications)
                                    }
                                    "includeVolumeData" => Ok(__FieldTag::__include_volume_data),
                                    "include_volume_data" => Ok(__FieldTag::__include_volume_data),
                                    "includeSecrets" => Ok(__FieldTag::__include_secrets),
                                    "include_secrets" => Ok(__FieldTag::__include_secrets),
                                    "encryptionKey" => Ok(__FieldTag::__encryption_key),
                                    "encryption_key" => Ok(__FieldTag::__encryption_key),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = BackupConfigDetails;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct BackupConfigDetails")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__all_namespaces => {
                                    if !fields.insert(__FieldTag::__all_namespaces) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for all_namespaces",
                                            ),
                                        );
                                    }
                                    if result.backup_scope.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `backup_scope`, a oneof with full ID .google.cloud.gkebackup.v1.BackupPlanBinding.BackupPlanDetails.BackupConfigDetails.all_namespaces, latest field was allNamespaces",
                                            ),
                                        );
                                    }
                                    result.backup_scope = std::option::Option::Some(
                                        crate::model::backup_plan_binding::backup_plan_details::backup_config_details::BackupScope::AllNamespaces(
                                            map.next_value::<std::option::Option<bool>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__selected_namespaces => {
                                    if !fields.insert(__FieldTag::__selected_namespaces) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for selected_namespaces",
                                            ),
                                        );
                                    }
                                    if result.backup_scope.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `backup_scope`, a oneof with full ID .google.cloud.gkebackup.v1.BackupPlanBinding.BackupPlanDetails.BackupConfigDetails.selected_namespaces, latest field was selectedNamespaces",
                                            ),
                                        );
                                    }
                                    result.backup_scope = std::option::Option::Some(
                                        crate::model::backup_plan_binding::backup_plan_details::backup_config_details::BackupScope::SelectedNamespaces(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::Namespaces>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__selected_applications => {
                                    if !fields.insert(__FieldTag::__selected_applications) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for selected_applications",
                                            ),
                                        );
                                    }
                                    if result.backup_scope.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `backup_scope`, a oneof with full ID .google.cloud.gkebackup.v1.BackupPlanBinding.BackupPlanDetails.BackupConfigDetails.selected_applications, latest field was selectedApplications",
                                            ),
                                        );
                                    }
                                    result.backup_scope = std::option::Option::Some(
                                        crate::model::backup_plan_binding::backup_plan_details::backup_config_details::BackupScope::SelectedApplications(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::NamespacedNames>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__include_volume_data => {
                                    if !fields.insert(__FieldTag::__include_volume_data) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for include_volume_data",
                                            ),
                                        );
                                    }
                                    result.include_volume_data = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__include_secrets => {
                                    if !fields.insert(__FieldTag::__include_secrets) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for include_secrets",
                                            ),
                                        );
                                    }
                                    result.include_secrets = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__encryption_key => {
                                    if !fields.insert(__FieldTag::__encryption_key) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for encryption_key",
                                            ),
                                        );
                                    }
                                    result.encryption_key = map.next_value::<std::option::Option<crate::model::EncryptionKey>>()?
                                        ;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for BackupConfigDetails {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.all_namespaces() {
                    state.serialize_entry("allNamespaces", value)?;
                }
                if let Some(value) = self.selected_namespaces() {
                    state.serialize_entry("selectedNamespaces", value)?;
                }
                if let Some(value) = self.selected_applications() {
                    state.serialize_entry("selectedApplications", value)?;
                }
                if !wkt::internal::is_default(&self.include_volume_data) {
                    state.serialize_entry("includeVolumeData", &self.include_volume_data)?;
                }
                if !wkt::internal::is_default(&self.include_secrets) {
                    state.serialize_entry("includeSecrets", &self.include_secrets)?;
                }
                if self.encryption_key.is_some() {
                    state.serialize_entry("encryptionKey", &self.encryption_key)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [BackupConfigDetails].
        pub mod backup_config_details {
            #[allow(unused_imports)]
            use super::*;

            /// This defines the "scope" of the Backup - which namespaced
            /// resources in the cluster will be included in a Backup.
            /// Exactly one of the fields of backup_scope MUST be specified.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum BackupScope {
                /// Output only. If True, include all namespaced resources
                AllNamespaces(bool),
                /// Output only. If set, include just the resources in the listed
                /// namespaces.
                SelectedNamespaces(std::boxed::Box<crate::model::Namespaces>),
                /// Output only. If set, include just the resources referenced by the
                /// listed ProtectedApplications.
                SelectedApplications(std::boxed::Box<crate::model::NamespacedNames>),
            }
        }

        /// RetentionPolicyDetails defines a Backup retention policy for a
        /// BackupPlan.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct RetentionPolicyDetails {
            /// Optional. Minimum age for Backups created via this BackupPlan (in
            /// days). This field MUST be an integer value between 0-90 (inclusive). A
            /// Backup created under this BackupPlan will NOT be deletable until it
            /// reaches Backup's (create_time + backup_delete_lock_days).
            /// Updating this field of a BackupPlan does NOT affect existing Backups
            /// under it. Backups created AFTER a successful update will inherit
            /// the new value.
            ///
            /// Default: 0 (no delete blocking)
            pub backup_delete_lock_days: i32,

            /// Optional. The default maximum age of a Backup created via this
            /// BackupPlan. This field MUST be an integer value >= 0 and <= 365. If
            /// specified, a Backup created under this BackupPlan will be automatically
            /// deleted after its age reaches (create_time + backup_retain_days). If
            /// not specified, Backups created under this BackupPlan will NOT be
            /// subject to automatic deletion.
            /// Default: 0 (no automatic deletion)
            pub backup_retain_days: i32,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl RetentionPolicyDetails {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [backup_delete_lock_days][crate::model::backup_plan_binding::backup_plan_details::RetentionPolicyDetails::backup_delete_lock_days].
            pub fn set_backup_delete_lock_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.backup_delete_lock_days = v.into();
                self
            }

            /// Sets the value of [backup_retain_days][crate::model::backup_plan_binding::backup_plan_details::RetentionPolicyDetails::backup_retain_days].
            pub fn set_backup_retain_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.backup_retain_days = v.into();
                self
            }
        }

        impl wkt::message::Message for RetentionPolicyDetails {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.gkebackup.v1.BackupPlanBinding.BackupPlanDetails.RetentionPolicyDetails"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for RetentionPolicyDetails {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __backup_delete_lock_days,
                    __backup_retain_days,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for RetentionPolicyDetails")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "backupDeleteLockDays" => {
                                        Ok(__FieldTag::__backup_delete_lock_days)
                                    }
                                    "backup_delete_lock_days" => {
                                        Ok(__FieldTag::__backup_delete_lock_days)
                                    }
                                    "backupRetainDays" => Ok(__FieldTag::__backup_retain_days),
                                    "backup_retain_days" => Ok(__FieldTag::__backup_retain_days),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = RetentionPolicyDetails;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct RetentionPolicyDetails")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__backup_delete_lock_days => {
                                    if !fields.insert(__FieldTag::__backup_delete_lock_days) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for backup_delete_lock_days",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.backup_delete_lock_days =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__backup_retain_days => {
                                    if !fields.insert(__FieldTag::__backup_retain_days) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for backup_retain_days",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.backup_retain_days =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for RetentionPolicyDetails {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.backup_delete_lock_days) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry(
                        "backupDeleteLockDays",
                        &__With(&self.backup_delete_lock_days),
                    )?;
                }
                if !wkt::internal::is_default(&self.backup_retain_days) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("backupRetainDays", &__With(&self.backup_retain_days))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// State
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// Default first value for Enums.
            Unspecified,
            /// Waiting for cluster state to be RUNNING.
            ClusterPending,
            /// The BackupPlan is in the process of being created.
            Provisioning,
            /// The BackupPlan has successfully been created and is ready for Backups.
            Ready,
            /// BackupPlan creation has failed.
            Failed,
            /// The BackupPlan has been deactivated.
            Deactivated,
            /// The BackupPlan is in the process of being deleted.
            Deleting,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::ClusterPending => std::option::Option::Some(1),
                    Self::Provisioning => std::option::Option::Some(2),
                    Self::Ready => std::option::Option::Some(3),
                    Self::Failed => std::option::Option::Some(4),
                    Self::Deactivated => std::option::Option::Some(5),
                    Self::Deleting => std::option::Option::Some(6),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::ClusterPending => std::option::Option::Some("CLUSTER_PENDING"),
                    Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                    Self::Ready => std::option::Option::Some("READY"),
                    Self::Failed => std::option::Option::Some("FAILED"),
                    Self::Deactivated => std::option::Option::Some("DEACTIVATED"),
                    Self::Deleting => std::option::Option::Some("DELETING"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::ClusterPending,
                    2 => Self::Provisioning,
                    3 => Self::Ready,
                    4 => Self::Failed,
                    5 => Self::Deactivated,
                    6 => Self::Deleting,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "CLUSTER_PENDING" => Self::ClusterPending,
                    "PROVISIONING" => Self::Provisioning,
                    "READY" => Self::Ready,
                    "FAILED" => Self::Failed,
                    "DEACTIVATED" => Self::Deactivated,
                    "DELETING" => Self::Deleting,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::ClusterPending => serializer.serialize_i32(1),
                    Self::Provisioning => serializer.serialize_i32(2),
                    Self::Ready => serializer.serialize_i32(3),
                    Self::Failed => serializer.serialize_i32(4),
                    Self::Deactivated => serializer.serialize_i32(5),
                    Self::Deleting => serializer.serialize_i32(6),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.cloud.gkebackup.v1.BackupPlanBinding.BackupPlanDetails.State",
                ))
            }
        }
    }
}

/// A list of Kubernetes Namespaces.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Namespaces {
    /// Optional. A list of Kubernetes Namespaces.
    pub namespaces: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Namespaces {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [namespaces][crate::model::Namespaces::namespaces].
    pub fn set_namespaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.namespaces = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Namespaces {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.Namespaces"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Namespaces {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __namespaces,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Namespaces")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "namespaces" => Ok(__FieldTag::__namespaces),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Namespaces;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Namespaces")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__namespaces => {
                            if !fields.insert(__FieldTag::__namespaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for namespaces",
                                ));
                            }
                            result.namespaces = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Namespaces {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.namespaces.is_empty() {
            state.serialize_entry("namespaces", &self.namespaces)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A reference to a namespaced resource in Kubernetes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NamespacedName {
    /// Optional. The Namespace of the Kubernetes resource.
    pub namespace: std::string::String,

    /// Optional. The name of the Kubernetes resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NamespacedName {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [namespace][crate::model::NamespacedName::namespace].
    pub fn set_namespace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.namespace = v.into();
        self
    }

    /// Sets the value of [name][crate::model::NamespacedName::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for NamespacedName {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.NamespacedName"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NamespacedName {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __namespace,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NamespacedName")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "namespace" => Ok(__FieldTag::__namespace),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NamespacedName;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NamespacedName")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__namespace => {
                            if !fields.insert(__FieldTag::__namespace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for namespace",
                                ));
                            }
                            result.namespace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NamespacedName {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.namespace.is_empty() {
            state.serialize_entry("namespace", &self.namespace)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A list of namespaced Kubernetes resources.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NamespacedNames {
    /// Optional. A list of namespaced Kubernetes resources.
    pub namespaced_names: std::vec::Vec<crate::model::NamespacedName>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NamespacedNames {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [namespaced_names][crate::model::NamespacedNames::namespaced_names].
    pub fn set_namespaced_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NamespacedName>,
    {
        use std::iter::Iterator;
        self.namespaced_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NamespacedNames {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.NamespacedNames"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NamespacedNames {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __namespaced_names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NamespacedNames")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "namespacedNames" => Ok(__FieldTag::__namespaced_names),
                            "namespaced_names" => Ok(__FieldTag::__namespaced_names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NamespacedNames;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NamespacedNames")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__namespaced_names => {
                            if !fields.insert(__FieldTag::__namespaced_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for namespaced_names",
                                ));
                            }
                            result.namespaced_names =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::NamespacedName>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NamespacedNames {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.namespaced_names.is_empty() {
            state.serialize_entry("namespacedNames", &self.namespaced_names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defined a customer managed encryption key that will be used to encrypt Backup
/// artifacts.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EncryptionKey {
    /// Optional. Google Cloud KMS encryption key. Format:
    /// `projects/*/locations/*/keyRings/*/cryptoKeys/*`
    pub gcp_kms_encryption_key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EncryptionKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcp_kms_encryption_key][crate::model::EncryptionKey::gcp_kms_encryption_key].
    pub fn set_gcp_kms_encryption_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.gcp_kms_encryption_key = v.into();
        self
    }
}

impl wkt::message::Message for EncryptionKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.EncryptionKey"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EncryptionKey {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcp_kms_encryption_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EncryptionKey")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcpKmsEncryptionKey" => Ok(__FieldTag::__gcp_kms_encryption_key),
                            "gcp_kms_encryption_key" => Ok(__FieldTag::__gcp_kms_encryption_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EncryptionKey;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EncryptionKey")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcp_kms_encryption_key => {
                            if !fields.insert(__FieldTag::__gcp_kms_encryption_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_kms_encryption_key",
                                ));
                            }
                            result.gcp_kms_encryption_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EncryptionKey {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.gcp_kms_encryption_key.is_empty() {
            state.serialize_entry("gcpKmsEncryptionKey", &self.gcp_kms_encryption_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message to encapsulate VolumeType enum.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VolumeTypeEnum {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VolumeTypeEnum {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for VolumeTypeEnum {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.VolumeTypeEnum"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VolumeTypeEnum {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VolumeTypeEnum")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VolumeTypeEnum;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VolumeTypeEnum")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VolumeTypeEnum {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VolumeTypeEnum].
pub mod volume_type_enum {
    #[allow(unused_imports)]
    use super::*;

    /// Supported volume types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VolumeType {
        /// Default
        Unspecified,
        /// Compute Engine Persistent Disk volume
        GcePersistentDisk,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VolumeType::value] or
        /// [VolumeType::name].
        UnknownValue(volume_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod volume_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VolumeType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GcePersistentDisk => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VOLUME_TYPE_UNSPECIFIED"),
                Self::GcePersistentDisk => std::option::Option::Some("GCE_PERSISTENT_DISK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VolumeType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VolumeType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VolumeType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GcePersistentDisk,
                _ => Self::UnknownValue(volume_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VolumeType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VOLUME_TYPE_UNSPECIFIED" => Self::Unspecified,
                "GCE_PERSISTENT_DISK" => Self::GcePersistentDisk,
                _ => Self::UnknownValue(volume_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VolumeType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GcePersistentDisk => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VolumeType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VolumeType>::new(
                ".google.cloud.gkebackup.v1.VolumeTypeEnum.VolumeType",
            ))
        }
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have
    /// [google.longrunning.Operation.error][google.longrunning.Operation.error]
    /// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to `Code.CANCELLED`.
    ///
    /// [google.longrunning.Operation.error]: longrunning::model::Operation::result
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for CreateBackupPlan.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateBackupPlanRequest {
    /// Required. The location within which to create the BackupPlan.
    /// Format: `projects/*/locations/*`
    pub parent: std::string::String,

    /// Required. The BackupPlan resource object to create.
    pub backup_plan: std::option::Option<crate::model::BackupPlan>,

    /// Required. The client-provided short name for the BackupPlan resource.
    /// This name must:
    ///
    /// - be between 1 and 63 characters long (inclusive)
    /// - consist of only lower-case ASCII letters, numbers, and dashes
    /// - start with a lower-case letter
    /// - end with a lower-case letter or number
    /// - be unique within the set of BackupPlans in this location
    pub backup_plan_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBackupPlanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupPlanRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_plan][crate::model::CreateBackupPlanRequest::backup_plan].
    pub fn set_backup_plan<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupPlan>,
    {
        self.backup_plan = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_plan][crate::model::CreateBackupPlanRequest::backup_plan].
    pub fn set_or_clear_backup_plan<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupPlan>,
    {
        self.backup_plan = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_plan_id][crate::model::CreateBackupPlanRequest::backup_plan_id].
    pub fn set_backup_plan_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_plan_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateBackupPlanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.CreateBackupPlanRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateBackupPlanRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __backup_plan,
            __backup_plan_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBackupPlanRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "backupPlan" => Ok(__FieldTag::__backup_plan),
                            "backup_plan" => Ok(__FieldTag::__backup_plan),
                            "backupPlanId" => Ok(__FieldTag::__backup_plan_id),
                            "backup_plan_id" => Ok(__FieldTag::__backup_plan_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateBackupPlanRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBackupPlanRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_plan => {
                            if !fields.insert(__FieldTag::__backup_plan) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_plan",
                                ));
                            }
                            result.backup_plan =
                                map.next_value::<std::option::Option<crate::model::BackupPlan>>()?;
                        }
                        __FieldTag::__backup_plan_id => {
                            if !fields.insert(__FieldTag::__backup_plan_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_plan_id",
                                ));
                            }
                            result.backup_plan_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateBackupPlanRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.backup_plan.is_some() {
            state.serialize_entry("backupPlan", &self.backup_plan)?;
        }
        if !self.backup_plan_id.is_empty() {
            state.serialize_entry("backupPlanId", &self.backup_plan_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListBackupPlans.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupPlansRequest {
    /// Required. The location that contains the BackupPlans to list.
    /// Format: `projects/*/locations/*`
    pub parent: std::string::String,

    /// Optional. The target number of results to return in a single response.
    /// If not specified, a default value will be chosen by the service.
    /// Note that the response may include a partial list and a caller should
    /// only rely on the response's
    /// [next_page_token][google.cloud.gkebackup.v1.ListBackupPlansResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkebackup.v1.ListBackupPlansResponse.next_page_token]: crate::model::ListBackupPlansResponse::next_page_token
    pub page_size: i32,

    /// Optional. The value of
    /// [next_page_token][google.cloud.gkebackup.v1.ListBackupPlansResponse.next_page_token]
    /// received from a previous `ListBackupPlans` call.
    /// Provide this to retrieve the subsequent page in a multi-page list of
    /// results. When paginating, all other parameters provided to
    /// `ListBackupPlans` must match the call that provided the page token.
    ///
    /// [google.cloud.gkebackup.v1.ListBackupPlansResponse.next_page_token]: crate::model::ListBackupPlansResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Field match expression used to filter the results.
    pub filter: std::string::String,

    /// Optional. Field by which to sort the results.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupPlansRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupPlansRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupPlansRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupPlansRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupPlansRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupPlansRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupPlansRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.ListBackupPlansRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupPlansRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupPlansRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupPlansRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupPlansRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupPlansRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListBackupPlans.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupPlansResponse {
    /// The list of BackupPlans matching the given criteria.
    pub backup_plans: std::vec::Vec<crate::model::BackupPlan>,

    /// A token which may be sent as
    /// [page_token][google.cloud.gkebackup.v1.ListBackupPlansRequest.page_token]
    /// in a subsequent `ListBackupPlans` call to retrieve the next page of
    /// results. If this field is omitted or empty, then there are no more results
    /// to return.
    ///
    /// [google.cloud.gkebackup.v1.ListBackupPlansRequest.page_token]: crate::model::ListBackupPlansRequest::page_token
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupPlansResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_plans][crate::model::ListBackupPlansResponse::backup_plans].
    pub fn set_backup_plans<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupPlan>,
    {
        use std::iter::Iterator;
        self.backup_plans = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupPlansResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupPlansResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupPlansResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.ListBackupPlansResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupPlansResponse {
    type PageItem = crate::model::BackupPlan;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backup_plans
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupPlansResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_plans,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupPlansResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupPlans" => Ok(__FieldTag::__backup_plans),
                            "backup_plans" => Ok(__FieldTag::__backup_plans),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupPlansResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupPlansResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_plans => {
                            if !fields.insert(__FieldTag::__backup_plans) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_plans",
                                ));
                            }
                            result.backup_plans = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BackupPlan>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupPlansResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backup_plans.is_empty() {
            state.serialize_entry("backupPlans", &self.backup_plans)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetBackupPlan.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBackupPlanRequest {
    /// Required. Fully qualified BackupPlan name.
    /// Format: `projects/*/locations/*/backupPlans/*`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupPlanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupPlanRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupPlanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.GetBackupPlanRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBackupPlanRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBackupPlanRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBackupPlanRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBackupPlanRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBackupPlanRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for UpdateBackupPlan.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateBackupPlanRequest {
    /// Required. A new version of the BackupPlan resource that contains updated
    /// fields. This may be sparsely populated if an `update_mask` is provided.
    pub backup_plan: std::option::Option<crate::model::BackupPlan>,

    /// Optional. This is used to specify the fields to be overwritten in the
    /// BackupPlan targeted for update. The values for each of these
    /// updated fields will be taken from the `backup_plan` provided
    /// with this request. Field names are relative to the root of the resource
    /// (e.g., `description`, `backup_config.include_volume_data`, etc.)
    /// If no `update_mask` is provided, all fields in `backup_plan` will be
    /// written to the target BackupPlan resource.
    /// Note that OUTPUT_ONLY and IMMUTABLE fields in `backup_plan` are ignored
    /// and are not used to update the target BackupPlan.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBackupPlanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_plan][crate::model::UpdateBackupPlanRequest::backup_plan].
    pub fn set_backup_plan<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupPlan>,
    {
        self.backup_plan = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_plan][crate::model::UpdateBackupPlanRequest::backup_plan].
    pub fn set_or_clear_backup_plan<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupPlan>,
    {
        self.backup_plan = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupPlanRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateBackupPlanRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateBackupPlanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.UpdateBackupPlanRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateBackupPlanRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_plan,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateBackupPlanRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupPlan" => Ok(__FieldTag::__backup_plan),
                            "backup_plan" => Ok(__FieldTag::__backup_plan),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateBackupPlanRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateBackupPlanRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_plan => {
                            if !fields.insert(__FieldTag::__backup_plan) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_plan",
                                ));
                            }
                            result.backup_plan =
                                map.next_value::<std::option::Option<crate::model::BackupPlan>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateBackupPlanRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.backup_plan.is_some() {
            state.serialize_entry("backupPlan", &self.backup_plan)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for DeleteBackupPlan.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteBackupPlanRequest {
    /// Required. Fully qualified BackupPlan name.
    /// Format: `projects/*/locations/*/backupPlans/*`
    pub name: std::string::String,

    /// Optional. If provided, this value must match the current value of the
    /// target BackupPlan's [etag][google.cloud.gkebackup.v1.BackupPlan.etag] field
    /// or the request is rejected.
    ///
    /// [google.cloud.gkebackup.v1.BackupPlan.etag]: crate::model::BackupPlan::etag
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupPlanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupPlanRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteBackupPlanRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupPlanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.DeleteBackupPlanRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteBackupPlanRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteBackupPlanRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteBackupPlanRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteBackupPlanRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteBackupPlanRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for CreateBackupChannel.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateBackupChannelRequest {
    /// Required. The location within which to create the BackupChannel.
    /// Format: `projects/*/locations/*`
    pub parent: std::string::String,

    /// Required. The BackupChannel resource object to create.
    pub backup_channel: std::option::Option<crate::model::BackupChannel>,

    /// Optional. The client-provided short name for the BackupChannel resource.
    /// This name must:
    ///
    /// - be between 1 and 63 characters long (inclusive)
    /// - consist of only lower-case ASCII letters, numbers, and dashes
    /// - start with a lower-case letter
    /// - end with a lower-case letter or number
    /// - be unique within the set of BackupChannels in this location
    ///   If the user does not provide a name, a uuid will be used as the name.
    pub backup_channel_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBackupChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupChannelRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_channel][crate::model::CreateBackupChannelRequest::backup_channel].
    pub fn set_backup_channel<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupChannel>,
    {
        self.backup_channel = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_channel][crate::model::CreateBackupChannelRequest::backup_channel].
    pub fn set_or_clear_backup_channel<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupChannel>,
    {
        self.backup_channel = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_channel_id][crate::model::CreateBackupChannelRequest::backup_channel_id].
    pub fn set_backup_channel_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_channel_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateBackupChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.CreateBackupChannelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateBackupChannelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __backup_channel,
            __backup_channel_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBackupChannelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "backupChannel" => Ok(__FieldTag::__backup_channel),
                            "backup_channel" => Ok(__FieldTag::__backup_channel),
                            "backupChannelId" => Ok(__FieldTag::__backup_channel_id),
                            "backup_channel_id" => Ok(__FieldTag::__backup_channel_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateBackupChannelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBackupChannelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_channel => {
                            if !fields.insert(__FieldTag::__backup_channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_channel",
                                ));
                            }
                            result.backup_channel = map
                                .next_value::<std::option::Option<crate::model::BackupChannel>>()?;
                        }
                        __FieldTag::__backup_channel_id => {
                            if !fields.insert(__FieldTag::__backup_channel_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_channel_id",
                                ));
                            }
                            result.backup_channel_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateBackupChannelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.backup_channel.is_some() {
            state.serialize_entry("backupChannel", &self.backup_channel)?;
        }
        if !self.backup_channel_id.is_empty() {
            state.serialize_entry("backupChannelId", &self.backup_channel_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListBackupChannels.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupChannelsRequest {
    /// Required. The location that contains the BackupChannels to list.
    /// Format: `projects/*/locations/*`
    pub parent: std::string::String,

    /// Optional. The target number of results to return in a single response.
    /// If not specified, a default value will be chosen by the service.
    /// Note that the response may include a partial list and a caller should
    /// only rely on the response's
    /// [next_page_token][google.cloud.gkebackup.v1.ListBackupChannelsResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkebackup.v1.ListBackupChannelsResponse.next_page_token]: crate::model::ListBackupChannelsResponse::next_page_token
    pub page_size: i32,

    /// Optional. The value of
    /// [next_page_token][google.cloud.gkebackup.v1.ListBackupChannelsResponse.next_page_token]
    /// received from a previous `ListBackupChannels` call.
    /// Provide this to retrieve the subsequent page in a multi-page list of
    /// results. When paginating, all other parameters provided to
    /// `ListBackupChannels` must match the call that provided the page
    /// token.
    ///
    /// [google.cloud.gkebackup.v1.ListBackupChannelsResponse.next_page_token]: crate::model::ListBackupChannelsResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Field match expression used to filter the results.
    pub filter: std::string::String,

    /// Optional. Field by which to sort the results.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupChannelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupChannelsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupChannelsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupChannelsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupChannelsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupChannelsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupChannelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.ListBackupChannelsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupChannelsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupChannelsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupChannelsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupChannelsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupChannelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListBackupChannels.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupChannelsResponse {
    /// The list of BackupChannels matching the given criteria.
    pub backup_channels: std::vec::Vec<crate::model::BackupChannel>,

    /// A token which may be sent as
    /// [page_token][google.cloud.gkebackup.v1.ListBackupChannelsRequest.page_token]
    /// in a subsequent `ListBackupChannels` call to retrieve the next page of
    /// results. If this field is omitted or empty, then there are no more results
    /// to return.
    ///
    /// [google.cloud.gkebackup.v1.ListBackupChannelsRequest.page_token]: crate::model::ListBackupChannelsRequest::page_token
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupChannelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_channels][crate::model::ListBackupChannelsResponse::backup_channels].
    pub fn set_backup_channels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupChannel>,
    {
        use std::iter::Iterator;
        self.backup_channels = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupChannelsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupChannelsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupChannelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.ListBackupChannelsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupChannelsResponse {
    type PageItem = crate::model::BackupChannel;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backup_channels
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupChannelsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_channels,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupChannelsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupChannels" => Ok(__FieldTag::__backup_channels),
                            "backup_channels" => Ok(__FieldTag::__backup_channels),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupChannelsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupChannelsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_channels => {
                            if !fields.insert(__FieldTag::__backup_channels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_channels",
                                ));
                            }
                            result.backup_channels = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BackupChannel>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupChannelsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backup_channels.is_empty() {
            state.serialize_entry("backupChannels", &self.backup_channels)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetBackupChannel.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBackupChannelRequest {
    /// Required. Fully qualified BackupChannel name.
    /// Format: `projects/*/locations/*/backupChannels/*`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupChannelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.GetBackupChannelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBackupChannelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBackupChannelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBackupChannelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBackupChannelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBackupChannelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for UpdateBackupChannel.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateBackupChannelRequest {
    /// Required. A new version of the BackupChannel resource that contains updated
    /// fields. This may be sparsely populated if an `update_mask` is provided.
    pub backup_channel: std::option::Option<crate::model::BackupChannel>,

    /// Optional. This is used to specify the fields to be overwritten in the
    /// BackupChannel targeted for update. The values for each of these
    /// updated fields will be taken from the `backup_channel` provided
    /// with this request. Field names are relative to the root of the resource
    /// (e.g., `description`, `labels`, etc.)
    /// If no `update_mask` is provided, all fields in `backup_channel` will
    /// be written to the target BackupChannel resource. Note that
    /// OUTPUT_ONLY and IMMUTABLE fields in `backup_channel` are ignored and
    /// are not used to update the target BackupChannel.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBackupChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_channel][crate::model::UpdateBackupChannelRequest::backup_channel].
    pub fn set_backup_channel<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupChannel>,
    {
        self.backup_channel = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_channel][crate::model::UpdateBackupChannelRequest::backup_channel].
    pub fn set_or_clear_backup_channel<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupChannel>,
    {
        self.backup_channel = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupChannelRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateBackupChannelRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateBackupChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.UpdateBackupChannelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateBackupChannelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_channel,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateBackupChannelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupChannel" => Ok(__FieldTag::__backup_channel),
                            "backup_channel" => Ok(__FieldTag::__backup_channel),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateBackupChannelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateBackupChannelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_channel => {
                            if !fields.insert(__FieldTag::__backup_channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_channel",
                                ));
                            }
                            result.backup_channel = map
                                .next_value::<std::option::Option<crate::model::BackupChannel>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateBackupChannelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.backup_channel.is_some() {
            state.serialize_entry("backupChannel", &self.backup_channel)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for DeleteBackupChannel.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteBackupChannelRequest {
    /// Required. Fully qualified BackupChannel name.
    /// Format: `projects/*/locations/*/backupChannels/*`
    pub name: std::string::String,

    /// Optional. If provided, this value must match the current value of the
    /// target BackupChannel's [etag][google.cloud.gkebackup.v1.BackupChannel.etag]
    /// field or the request is rejected.
    ///
    /// [google.cloud.gkebackup.v1.BackupChannel.etag]: crate::model::BackupChannel::etag
    pub etag: std::string::String,

    /// Optional. If set to true, any BackupPlanAssociations below this
    /// BackupChannel will also be deleted. Otherwise, the request will only
    /// succeed if the BackupChannel has no BackupPlanAssociations.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupChannelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteBackupChannelRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteBackupChannelRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.DeleteBackupChannelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteBackupChannelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteBackupChannelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteBackupChannelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteBackupChannelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteBackupChannelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListBackupPlanBindings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupPlanBindingsRequest {
    /// Required. The BackupChannel that contains the BackupPlanBindings to list.
    /// Format: `projects/*/locations/*/backupChannels/*`
    pub parent: std::string::String,

    /// Optional. The target number of results to return in a single response.
    /// If not specified, a default value will be chosen by the service.
    /// Note that the response may include a partial list and a caller should
    /// only rely on the response's
    /// [next_page_token][google.cloud.gkebackup.v1.ListBackupPlanBindingsResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkebackup.v1.ListBackupPlanBindingsResponse.next_page_token]: crate::model::ListBackupPlanBindingsResponse::next_page_token
    pub page_size: i32,

    /// Optional. The value of
    /// [next_page_token][google.cloud.gkebackup.v1.ListBackupPlanBindingsResponse.next_page_token]
    /// received from a previous `ListBackupPlanBindings` call.
    /// Provide this to retrieve the subsequent page in a multi-page list of
    /// results. When paginating, all other parameters provided to
    /// `ListBackupPlanBindings` must match the call that provided the page
    /// token.
    ///
    /// [google.cloud.gkebackup.v1.ListBackupPlanBindingsResponse.next_page_token]: crate::model::ListBackupPlanBindingsResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Field match expression used to filter the results.
    pub filter: std::string::String,

    /// Optional. Field by which to sort the results.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupPlanBindingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupPlanBindingsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupPlanBindingsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupPlanBindingsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupPlanBindingsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupPlanBindingsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupPlanBindingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.ListBackupPlanBindingsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupPlanBindingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupPlanBindingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupPlanBindingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupPlanBindingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupPlanBindingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListBackupPlanBindings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupPlanBindingsResponse {
    /// The list of BackupPlanBindings matching the given criteria.
    pub backup_plan_bindings: std::vec::Vec<crate::model::BackupPlanBinding>,

    /// A token which may be sent as
    /// [page_token][google.cloud.gkebackup.v1.ListBackupPlanBindingsRequest.page_token]
    /// in a subsequent `ListBackupPlanBindingss` call to retrieve the next page of
    /// results. If this field is omitted or empty, then there are no more results
    /// to return.
    ///
    /// [google.cloud.gkebackup.v1.ListBackupPlanBindingsRequest.page_token]: crate::model::ListBackupPlanBindingsRequest::page_token
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupPlanBindingsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_plan_bindings][crate::model::ListBackupPlanBindingsResponse::backup_plan_bindings].
    pub fn set_backup_plan_bindings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupPlanBinding>,
    {
        use std::iter::Iterator;
        self.backup_plan_bindings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupPlanBindingsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupPlanBindingsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupPlanBindingsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.ListBackupPlanBindingsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupPlanBindingsResponse {
    type PageItem = crate::model::BackupPlanBinding;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backup_plan_bindings
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupPlanBindingsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_plan_bindings,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupPlanBindingsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupPlanBindings" => Ok(__FieldTag::__backup_plan_bindings),
                            "backup_plan_bindings" => Ok(__FieldTag::__backup_plan_bindings),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupPlanBindingsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupPlanBindingsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_plan_bindings => {
                            if !fields.insert(__FieldTag::__backup_plan_bindings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_plan_bindings",
                                ));
                            }
                            result.backup_plan_bindings =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::BackupPlanBinding>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupPlanBindingsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backup_plan_bindings.is_empty() {
            state.serialize_entry("backupPlanBindings", &self.backup_plan_bindings)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetBackupPlanBinding.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBackupPlanBindingRequest {
    /// Required. Fully qualified BackupPlanBinding name.
    /// Format:
    /// `projects/*/locations/*/backupChannels/*/backupPlanBindings/*`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupPlanBindingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupPlanBindingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupPlanBindingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.GetBackupPlanBindingRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBackupPlanBindingRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBackupPlanBindingRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBackupPlanBindingRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBackupPlanBindingRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBackupPlanBindingRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for CreateBackup.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateBackupRequest {
    /// Required. The BackupPlan within which to create the Backup.
    /// Format: `projects/*/locations/*/backupPlans/*`
    pub parent: std::string::String,

    /// Optional. The Backup resource to create.
    pub backup: std::option::Option<crate::model::Backup>,

    /// Optional. The client-provided short name for the Backup resource.
    /// This name must:
    ///
    /// - be between 1 and 63 characters long (inclusive)
    /// - consist of only lower-case ASCII letters, numbers, and dashes
    /// - start with a lower-case letter
    /// - end with a lower-case letter or number
    /// - be unique within the set of Backups in this BackupPlan
    pub backup_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup][crate::model::CreateBackupRequest::backup].
    pub fn set_backup<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Backup>,
    {
        self.backup = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup][crate::model::CreateBackupRequest::backup].
    pub fn set_or_clear_backup<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Backup>,
    {
        self.backup = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_id][crate::model::CreateBackupRequest::backup_id].
    pub fn set_backup_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.CreateBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __backup,
            __backup_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "backup" => Ok(__FieldTag::__backup),
                            "backupId" => Ok(__FieldTag::__backup_id),
                            "backup_id" => Ok(__FieldTag::__backup_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup => {
                            if !fields.insert(__FieldTag::__backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup",
                                ));
                            }
                            result.backup =
                                map.next_value::<std::option::Option<crate::model::Backup>>()?;
                        }
                        __FieldTag::__backup_id => {
                            if !fields.insert(__FieldTag::__backup_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_id",
                                ));
                            }
                            result.backup_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.backup.is_some() {
            state.serialize_entry("backup", &self.backup)?;
        }
        if !self.backup_id.is_empty() {
            state.serialize_entry("backupId", &self.backup_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListBackups.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupsRequest {
    /// Required. The BackupPlan that contains the Backups to list.
    /// Format: `projects/*/locations/*/backupPlans/*`
    pub parent: std::string::String,

    /// Optional. The target number of results to return in a single response.
    /// If not specified, a default value will be chosen by the service.
    /// Note that the response may include a partial list and a caller should
    /// only rely on the response's
    /// [next_page_token][google.cloud.gkebackup.v1.ListBackupsResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkebackup.v1.ListBackupsResponse.next_page_token]: crate::model::ListBackupsResponse::next_page_token
    pub page_size: i32,

    /// Optional. The value of
    /// [next_page_token][google.cloud.gkebackup.v1.ListBackupsResponse.next_page_token]
    /// received from a previous `ListBackups` call.
    /// Provide this to retrieve the subsequent page in a multi-page list of
    /// results. When paginating, all other parameters provided to
    /// `ListBackups` must match the call that provided the page token.
    ///
    /// [google.cloud.gkebackup.v1.ListBackupsResponse.next_page_token]: crate::model::ListBackupsResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Field match expression used to filter the results.
    pub filter: std::string::String,

    /// Optional. Field by which to sort the results.
    pub order_by: std::string::String,

    /// Optional. If set to true, the response will return partial results when
    /// some regions are unreachable and the unreachable field will be populated.
    pub return_partial_success: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [return_partial_success][crate::model::ListBackupsRequest::return_partial_success].
    pub fn set_return_partial_success<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.return_partial_success = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.ListBackupsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            __return_partial_success,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "returnPartialSuccess" => Ok(__FieldTag::__return_partial_success),
                            "return_partial_success" => Ok(__FieldTag::__return_partial_success),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__return_partial_success => {
                            if !fields.insert(__FieldTag::__return_partial_success) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for return_partial_success",
                                ));
                            }
                            result.return_partial_success = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !wkt::internal::is_default(&self.return_partial_success) {
            state.serialize_entry("returnPartialSuccess", &self.return_partial_success)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListBackups.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupsResponse {
    /// The list of Backups matching the given criteria.
    pub backups: std::vec::Vec<crate::model::Backup>,

    /// A token which may be sent as
    /// [page_token][google.cloud.gkebackup.v1.ListBackupsRequest.page_token] in a
    /// subsequent `ListBackups` call to retrieve the next page of results. If this
    /// field is omitted or empty, then there are no more results to return.
    ///
    /// [google.cloud.gkebackup.v1.ListBackupsRequest.page_token]: crate::model::ListBackupsRequest::page_token
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backups][crate::model::ListBackupsResponse::backups].
    pub fn set_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Backup>,
    {
        use std::iter::Iterator;
        self.backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.ListBackupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupsResponse {
    type PageItem = crate::model::Backup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backups,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backups" => Ok(__FieldTag::__backups),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backups => {
                            if !fields.insert(__FieldTag::__backups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backups",
                                ));
                            }
                            result.backups = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Backup>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backups.is_empty() {
            state.serialize_entry("backups", &self.backups)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetBackup.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBackupRequest {
    /// Required. Full name of the Backup resource.
    /// Format: `projects/*/locations/*/backupPlans/*/backups/*`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.GetBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for UpdateBackup.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateBackupRequest {
    /// Required. A new version of the Backup resource that contains updated
    /// fields. This may be sparsely populated if an `update_mask` is provided.
    pub backup: std::option::Option<crate::model::Backup>,

    /// Optional. This is used to specify the fields to be overwritten in the
    /// Backup targeted for update. The values for each of these
    /// updated fields will be taken from the `backup_plan` provided
    /// with this request. Field names are relative to the root of the resource.
    /// If no `update_mask` is provided, all fields in `backup` will be
    /// written to the target Backup resource.
    /// Note that OUTPUT_ONLY and IMMUTABLE fields in `backup` are ignored
    /// and are not used to update the target Backup.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup][crate::model::UpdateBackupRequest::backup].
    pub fn set_backup<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Backup>,
    {
        self.backup = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup][crate::model::UpdateBackupRequest::backup].
    pub fn set_or_clear_backup<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Backup>,
    {
        self.backup = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateBackupRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.UpdateBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backup" => Ok(__FieldTag::__backup),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup => {
                            if !fields.insert(__FieldTag::__backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup",
                                ));
                            }
                            result.backup =
                                map.next_value::<std::option::Option<crate::model::Backup>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.backup.is_some() {
            state.serialize_entry("backup", &self.backup)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for DeleteBackup.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteBackupRequest {
    /// Required. Name of the Backup resource.
    /// Format: `projects/*/locations/*/backupPlans/*/backups/*`
    pub name: std::string::String,

    /// Optional. If provided, this value must match the current value of the
    /// target Backup's [etag][google.cloud.gkebackup.v1.Backup.etag] field or the
    /// request is rejected.
    ///
    /// [google.cloud.gkebackup.v1.Backup.etag]: crate::model::Backup::etag
    pub etag: std::string::String,

    /// Optional. If set to true, any VolumeBackups below this Backup will also be
    /// deleted. Otherwise, the request will only succeed if the Backup has no
    /// VolumeBackups.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteBackupRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteBackupRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.DeleteBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListVolumeBackups.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVolumeBackupsRequest {
    /// Required. The Backup that contains the VolumeBackups to list.
    /// Format: `projects/*/locations/*/backupPlans/*/backups/*`
    pub parent: std::string::String,

    /// Optional. The target number of results to return in a single response.
    /// If not specified, a default value will be chosen by the service.
    /// Note that the response may include a partial list and a caller should
    /// only rely on the response's
    /// [next_page_token][google.cloud.gkebackup.v1.ListVolumeBackupsResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkebackup.v1.ListVolumeBackupsResponse.next_page_token]: crate::model::ListVolumeBackupsResponse::next_page_token
    pub page_size: i32,

    /// Optional. The value of
    /// [next_page_token][google.cloud.gkebackup.v1.ListVolumeBackupsResponse.next_page_token]
    /// received from a previous `ListVolumeBackups` call.
    /// Provide this to retrieve the subsequent page in a multi-page list of
    /// results. When paginating, all other parameters provided to
    /// `ListVolumeBackups` must match the call that provided the page token.
    ///
    /// [google.cloud.gkebackup.v1.ListVolumeBackupsResponse.next_page_token]: crate::model::ListVolumeBackupsResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Field match expression used to filter the results.
    pub filter: std::string::String,

    /// Optional. Field by which to sort the results.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVolumeBackupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVolumeBackupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVolumeBackupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVolumeBackupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListVolumeBackupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListVolumeBackupsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListVolumeBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.ListVolumeBackupsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVolumeBackupsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVolumeBackupsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVolumeBackupsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVolumeBackupsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVolumeBackupsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListVolumeBackups.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVolumeBackupsResponse {
    /// The list of VolumeBackups matching the given criteria.
    pub volume_backups: std::vec::Vec<crate::model::VolumeBackup>,

    /// A token which may be sent as
    /// [page_token][google.cloud.gkebackup.v1.ListVolumeBackupsRequest.page_token]
    /// in a subsequent `ListVolumeBackups` call to retrieve the next page of
    /// results. If this field is omitted or empty, then there are no more results
    /// to return.
    ///
    /// [google.cloud.gkebackup.v1.ListVolumeBackupsRequest.page_token]: crate::model::ListVolumeBackupsRequest::page_token
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVolumeBackupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [volume_backups][crate::model::ListVolumeBackupsResponse::volume_backups].
    pub fn set_volume_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VolumeBackup>,
    {
        use std::iter::Iterator;
        self.volume_backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVolumeBackupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListVolumeBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.ListVolumeBackupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVolumeBackupsResponse {
    type PageItem = crate::model::VolumeBackup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.volume_backups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVolumeBackupsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __volume_backups,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVolumeBackupsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "volumeBackups" => Ok(__FieldTag::__volume_backups),
                            "volume_backups" => Ok(__FieldTag::__volume_backups),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVolumeBackupsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVolumeBackupsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__volume_backups => {
                            if !fields.insert(__FieldTag::__volume_backups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_backups",
                                ));
                            }
                            result.volume_backups = map.next_value::<std::option::Option<std::vec::Vec<crate::model::VolumeBackup>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVolumeBackupsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.volume_backups.is_empty() {
            state.serialize_entry("volumeBackups", &self.volume_backups)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetVolumeBackup.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVolumeBackupRequest {
    /// Required. Full name of the VolumeBackup resource.
    /// Format: `projects/*/locations/*/backupPlans/*/backups/*/volumeBackups/*`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVolumeBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVolumeBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVolumeBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.GetVolumeBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetVolumeBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetVolumeBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetVolumeBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetVolumeBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetVolumeBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for CreateRestorePlan.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateRestorePlanRequest {
    /// Required. The location within which to create the RestorePlan.
    /// Format: `projects/*/locations/*`
    pub parent: std::string::String,

    /// Required. The RestorePlan resource object to create.
    pub restore_plan: std::option::Option<crate::model::RestorePlan>,

    /// Required. The client-provided short name for the RestorePlan resource.
    /// This name must:
    ///
    /// - be between 1 and 63 characters long (inclusive)
    /// - consist of only lower-case ASCII letters, numbers, and dashes
    /// - start with a lower-case letter
    /// - end with a lower-case letter or number
    /// - be unique within the set of RestorePlans in this location
    pub restore_plan_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateRestorePlanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateRestorePlanRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [restore_plan][crate::model::CreateRestorePlanRequest::restore_plan].
    pub fn set_restore_plan<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RestorePlan>,
    {
        self.restore_plan = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [restore_plan][crate::model::CreateRestorePlanRequest::restore_plan].
    pub fn set_or_clear_restore_plan<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RestorePlan>,
    {
        self.restore_plan = v.map(|x| x.into());
        self
    }

    /// Sets the value of [restore_plan_id][crate::model::CreateRestorePlanRequest::restore_plan_id].
    pub fn set_restore_plan_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.restore_plan_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateRestorePlanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.CreateRestorePlanRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateRestorePlanRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __restore_plan,
            __restore_plan_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateRestorePlanRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "restorePlan" => Ok(__FieldTag::__restore_plan),
                            "restore_plan" => Ok(__FieldTag::__restore_plan),
                            "restorePlanId" => Ok(__FieldTag::__restore_plan_id),
                            "restore_plan_id" => Ok(__FieldTag::__restore_plan_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateRestorePlanRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateRestorePlanRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__restore_plan => {
                            if !fields.insert(__FieldTag::__restore_plan) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_plan",
                                ));
                            }
                            result.restore_plan =
                                map.next_value::<std::option::Option<crate::model::RestorePlan>>()?;
                        }
                        __FieldTag::__restore_plan_id => {
                            if !fields.insert(__FieldTag::__restore_plan_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_plan_id",
                                ));
                            }
                            result.restore_plan_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateRestorePlanRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.restore_plan.is_some() {
            state.serialize_entry("restorePlan", &self.restore_plan)?;
        }
        if !self.restore_plan_id.is_empty() {
            state.serialize_entry("restorePlanId", &self.restore_plan_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListRestorePlans.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRestorePlansRequest {
    /// Required. The location that contains the RestorePlans to list.
    /// Format: `projects/*/locations/*`
    pub parent: std::string::String,

    /// Optional. The target number of results to return in a single response.
    /// If not specified, a default value will be chosen by the service.
    /// Note that the response may include a partial list and a caller should
    /// only rely on the response's
    /// [next_page_token][google.cloud.gkebackup.v1.ListRestorePlansResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkebackup.v1.ListRestorePlansResponse.next_page_token]: crate::model::ListRestorePlansResponse::next_page_token
    pub page_size: i32,

    /// Optional. The value of
    /// [next_page_token][google.cloud.gkebackup.v1.ListRestorePlansResponse.next_page_token]
    /// received from a previous `ListRestorePlans` call.
    /// Provide this to retrieve the subsequent page in a multi-page list of
    /// results. When paginating, all other parameters provided to
    /// `ListRestorePlans` must match the call that provided the page token.
    ///
    /// [google.cloud.gkebackup.v1.ListRestorePlansResponse.next_page_token]: crate::model::ListRestorePlansResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Field match expression used to filter the results.
    pub filter: std::string::String,

    /// Optional. Field by which to sort the results.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRestorePlansRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRestorePlansRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRestorePlansRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRestorePlansRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListRestorePlansRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListRestorePlansRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListRestorePlansRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.ListRestorePlansRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRestorePlansRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRestorePlansRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRestorePlansRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRestorePlansRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRestorePlansRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListRestorePlans.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRestorePlansResponse {
    /// The list of RestorePlans matching the given criteria.
    pub restore_plans: std::vec::Vec<crate::model::RestorePlan>,

    /// A token which may be sent as
    /// [page_token][google.cloud.gkebackup.v1.ListRestorePlansRequest.page_token]
    /// in a subsequent `ListRestorePlans` call to retrieve the next page of
    /// results. If this field is omitted or empty, then there are no more results
    /// to return.
    ///
    /// [google.cloud.gkebackup.v1.ListRestorePlansRequest.page_token]: crate::model::ListRestorePlansRequest::page_token
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRestorePlansResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [restore_plans][crate::model::ListRestorePlansResponse::restore_plans].
    pub fn set_restore_plans<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RestorePlan>,
    {
        use std::iter::Iterator;
        self.restore_plans = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRestorePlansResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListRestorePlansResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListRestorePlansResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.ListRestorePlansResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRestorePlansResponse {
    type PageItem = crate::model::RestorePlan;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.restore_plans
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRestorePlansResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __restore_plans,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRestorePlansResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "restorePlans" => Ok(__FieldTag::__restore_plans),
                            "restore_plans" => Ok(__FieldTag::__restore_plans),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRestorePlansResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRestorePlansResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__restore_plans => {
                            if !fields.insert(__FieldTag::__restore_plans) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_plans",
                                ));
                            }
                            result.restore_plans = map.next_value::<std::option::Option<std::vec::Vec<crate::model::RestorePlan>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRestorePlansResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.restore_plans.is_empty() {
            state.serialize_entry("restorePlans", &self.restore_plans)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetRestorePlan.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetRestorePlanRequest {
    /// Required. Fully qualified RestorePlan name.
    /// Format: `projects/*/locations/*/restorePlans/*`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRestorePlanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRestorePlanRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRestorePlanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.GetRestorePlanRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetRestorePlanRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetRestorePlanRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetRestorePlanRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetRestorePlanRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetRestorePlanRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for UpdateRestorePlan.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateRestorePlanRequest {
    /// Required. A new version of the RestorePlan resource that contains updated
    /// fields. This may be sparsely populated if an `update_mask` is provided.
    pub restore_plan: std::option::Option<crate::model::RestorePlan>,

    /// Optional. This is used to specify the fields to be overwritten in the
    /// RestorePlan targeted for update. The values for each of these
    /// updated fields will be taken from the `restore_plan` provided
    /// with this request. Field names are relative to the root of the resource.
    /// If no `update_mask` is provided, all fields in `restore_plan` will be
    /// written to the target RestorePlan resource.
    /// Note that OUTPUT_ONLY and IMMUTABLE fields in `restore_plan` are ignored
    /// and are not used to update the target RestorePlan.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateRestorePlanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [restore_plan][crate::model::UpdateRestorePlanRequest::restore_plan].
    pub fn set_restore_plan<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RestorePlan>,
    {
        self.restore_plan = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [restore_plan][crate::model::UpdateRestorePlanRequest::restore_plan].
    pub fn set_or_clear_restore_plan<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RestorePlan>,
    {
        self.restore_plan = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateRestorePlanRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateRestorePlanRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateRestorePlanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.UpdateRestorePlanRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateRestorePlanRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __restore_plan,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateRestorePlanRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "restorePlan" => Ok(__FieldTag::__restore_plan),
                            "restore_plan" => Ok(__FieldTag::__restore_plan),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateRestorePlanRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateRestorePlanRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__restore_plan => {
                            if !fields.insert(__FieldTag::__restore_plan) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_plan",
                                ));
                            }
                            result.restore_plan =
                                map.next_value::<std::option::Option<crate::model::RestorePlan>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateRestorePlanRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.restore_plan.is_some() {
            state.serialize_entry("restorePlan", &self.restore_plan)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for DeleteRestorePlan.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteRestorePlanRequest {
    /// Required. Fully qualified RestorePlan name.
    /// Format: `projects/*/locations/*/restorePlans/*`
    pub name: std::string::String,

    /// Optional. If provided, this value must match the current value of the
    /// target RestorePlan's [etag][google.cloud.gkebackup.v1.RestorePlan.etag]
    /// field or the request is rejected.
    ///
    /// [google.cloud.gkebackup.v1.RestorePlan.etag]: crate::model::RestorePlan::etag
    pub etag: std::string::String,

    /// Optional. If set to true, any Restores below this RestorePlan will also be
    /// deleted. Otherwise, the request will only succeed if the RestorePlan has no
    /// Restores.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteRestorePlanRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteRestorePlanRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteRestorePlanRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteRestorePlanRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRestorePlanRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.DeleteRestorePlanRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteRestorePlanRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteRestorePlanRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteRestorePlanRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteRestorePlanRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteRestorePlanRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for CreateRestoreChannel.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateRestoreChannelRequest {
    /// Required. The location within which to create the RestoreChannel.
    /// Format: `projects/*/locations/*`
    pub parent: std::string::String,

    /// Required. The RestoreChannel resource object to create.
    pub restore_channel: std::option::Option<crate::model::RestoreChannel>,

    /// Optional. The client-provided short name for the RestoreChannel resource.
    /// This name must:
    ///
    /// - be between 1 and 63 characters long (inclusive)
    /// - consist of only lower-case ASCII letters, numbers, and dashes
    /// - start with a lower-case letter
    /// - end with a lower-case letter or number
    /// - be unique within the set of RestoreChannels in this location
    ///   If the user does not provide a name, a uuid will be used as the name.
    pub restore_channel_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateRestoreChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateRestoreChannelRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [restore_channel][crate::model::CreateRestoreChannelRequest::restore_channel].
    pub fn set_restore_channel<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RestoreChannel>,
    {
        self.restore_channel = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [restore_channel][crate::model::CreateRestoreChannelRequest::restore_channel].
    pub fn set_or_clear_restore_channel<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RestoreChannel>,
    {
        self.restore_channel = v.map(|x| x.into());
        self
    }

    /// Sets the value of [restore_channel_id][crate::model::CreateRestoreChannelRequest::restore_channel_id].
    pub fn set_restore_channel_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.restore_channel_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateRestoreChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.CreateRestoreChannelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateRestoreChannelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __restore_channel,
            __restore_channel_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateRestoreChannelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "restoreChannel" => Ok(__FieldTag::__restore_channel),
                            "restore_channel" => Ok(__FieldTag::__restore_channel),
                            "restoreChannelId" => Ok(__FieldTag::__restore_channel_id),
                            "restore_channel_id" => Ok(__FieldTag::__restore_channel_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateRestoreChannelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateRestoreChannelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__restore_channel => {
                            if !fields.insert(__FieldTag::__restore_channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_channel",
                                ));
                            }
                            result.restore_channel = map
                                .next_value::<std::option::Option<crate::model::RestoreChannel>>(
                                )?;
                        }
                        __FieldTag::__restore_channel_id => {
                            if !fields.insert(__FieldTag::__restore_channel_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_channel_id",
                                ));
                            }
                            result.restore_channel_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateRestoreChannelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.restore_channel.is_some() {
            state.serialize_entry("restoreChannel", &self.restore_channel)?;
        }
        if !self.restore_channel_id.is_empty() {
            state.serialize_entry("restoreChannelId", &self.restore_channel_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListRestoreChannels.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRestoreChannelsRequest {
    /// Required. The location that contains the RestoreChannels to list.
    /// Format: `projects/*/locations/*`
    pub parent: std::string::String,

    /// Optional. The target number of results to return in a single response.
    /// If not specified, a default value will be chosen by the service.
    /// Note that the response may include a partial list and a caller should
    /// only rely on the response's
    /// [next_page_token][google.cloud.gkebackup.v1.ListRestoreChannelsResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkebackup.v1.ListRestoreChannelsResponse.next_page_token]: crate::model::ListRestoreChannelsResponse::next_page_token
    pub page_size: i32,

    /// Optional. The value of
    /// [next_page_token][google.cloud.gkebackup.v1.ListRestoreChannelsResponse.next_page_token]
    /// received from a previous `ListRestoreChannels` call.
    /// Provide this to retrieve the subsequent page in a multi-page list of
    /// results. When paginating, all other parameters provided to
    /// `ListRestoreChannels` must match the call that provided the page
    /// token.
    ///
    /// [google.cloud.gkebackup.v1.ListRestoreChannelsResponse.next_page_token]: crate::model::ListRestoreChannelsResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Field match expression used to filter the results.
    pub filter: std::string::String,

    /// Optional. Field by which to sort the results.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRestoreChannelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRestoreChannelsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRestoreChannelsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRestoreChannelsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListRestoreChannelsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListRestoreChannelsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListRestoreChannelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.ListRestoreChannelsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRestoreChannelsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRestoreChannelsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRestoreChannelsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRestoreChannelsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRestoreChannelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListRestoreChannels.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRestoreChannelsResponse {
    /// The list of RestoreChannels matching the given criteria.
    pub restore_channels: std::vec::Vec<crate::model::RestoreChannel>,

    /// A token which may be sent as
    /// [page_token][google.cloud.gkebackup.v1.ListRestoreChannelsRequest.page_token]
    /// in a subsequent `ListRestoreChannels` call to retrieve the next page of
    /// results. If this field is omitted or empty, then there are no more results
    /// to return.
    ///
    /// [google.cloud.gkebackup.v1.ListRestoreChannelsRequest.page_token]: crate::model::ListRestoreChannelsRequest::page_token
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRestoreChannelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [restore_channels][crate::model::ListRestoreChannelsResponse::restore_channels].
    pub fn set_restore_channels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RestoreChannel>,
    {
        use std::iter::Iterator;
        self.restore_channels = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRestoreChannelsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListRestoreChannelsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListRestoreChannelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.ListRestoreChannelsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRestoreChannelsResponse {
    type PageItem = crate::model::RestoreChannel;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.restore_channels
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRestoreChannelsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __restore_channels,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRestoreChannelsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "restoreChannels" => Ok(__FieldTag::__restore_channels),
                            "restore_channels" => Ok(__FieldTag::__restore_channels),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRestoreChannelsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRestoreChannelsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__restore_channels => {
                            if !fields.insert(__FieldTag::__restore_channels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_channels",
                                ));
                            }
                            result.restore_channels =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RestoreChannel>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRestoreChannelsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.restore_channels.is_empty() {
            state.serialize_entry("restoreChannels", &self.restore_channels)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetRestoreChannel.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetRestoreChannelRequest {
    /// Required. Fully qualified RestoreChannel name.
    /// Format: `projects/*/locations/*/restoreChannels/*`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRestoreChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRestoreChannelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRestoreChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.GetRestoreChannelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetRestoreChannelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetRestoreChannelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetRestoreChannelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetRestoreChannelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetRestoreChannelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for UpdateRestoreChannel.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateRestoreChannelRequest {
    /// Required. A new version of the RestoreChannel resource that contains
    /// updated fields. This may be sparsely populated if an `update_mask` is
    /// provided.
    pub restore_channel: std::option::Option<crate::model::RestoreChannel>,

    /// Optional. This is used to specify the fields to be overwritten in the
    /// RestoreChannel targeted for update. The values for each of these
    /// updated fields will be taken from the `restore_channel` provided
    /// with this request. Field names are relative to the root of the resource
    /// (e.g., `description`, `destination_project_id`, etc.)
    /// If no `update_mask` is provided, all fields in `restore_channel` will
    /// be written to the target RestoreChannel resource. Note that
    /// OUTPUT_ONLY and IMMUTABLE fields in `restore_channel` are ignored and
    /// are not used to update the target RestoreChannel.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateRestoreChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [restore_channel][crate::model::UpdateRestoreChannelRequest::restore_channel].
    pub fn set_restore_channel<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RestoreChannel>,
    {
        self.restore_channel = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [restore_channel][crate::model::UpdateRestoreChannelRequest::restore_channel].
    pub fn set_or_clear_restore_channel<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RestoreChannel>,
    {
        self.restore_channel = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateRestoreChannelRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateRestoreChannelRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateRestoreChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.UpdateRestoreChannelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateRestoreChannelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __restore_channel,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateRestoreChannelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "restoreChannel" => Ok(__FieldTag::__restore_channel),
                            "restore_channel" => Ok(__FieldTag::__restore_channel),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateRestoreChannelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateRestoreChannelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__restore_channel => {
                            if !fields.insert(__FieldTag::__restore_channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_channel",
                                ));
                            }
                            result.restore_channel = map
                                .next_value::<std::option::Option<crate::model::RestoreChannel>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateRestoreChannelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.restore_channel.is_some() {
            state.serialize_entry("restoreChannel", &self.restore_channel)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for DeleteRestoreChannel.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteRestoreChannelRequest {
    /// Required. Fully qualified RestoreChannel name.
    /// Format: `projects/*/locations/*/restoreChannels/*`
    pub name: std::string::String,

    /// Optional. If provided, this value must match the current value of the
    /// target RestoreChannel's
    /// [etag][google.cloud.gkebackup.v1.RestoreChannel.etag] field or the request
    /// is rejected.
    ///
    /// [google.cloud.gkebackup.v1.RestoreChannel.etag]: crate::model::RestoreChannel::etag
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteRestoreChannelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteRestoreChannelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteRestoreChannelRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRestoreChannelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.DeleteRestoreChannelRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteRestoreChannelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteRestoreChannelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteRestoreChannelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteRestoreChannelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteRestoreChannelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListRestorePlanBindings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRestorePlanBindingsRequest {
    /// Required. The RestoreChannel that contains the ListRestorePlanBindings to
    /// list. Format: `projects/*/locations/*/restoreChannels/*`
    pub parent: std::string::String,

    /// Optional. The target number of results to return in a single response.
    /// If not specified, a default value will be chosen by the service.
    /// Note that the response may include a partial list and a caller should
    /// only rely on the response's
    /// [next_page_token][google.cloud.gkebackup.v1.ListRestorePlanBindingsResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkebackup.v1.ListRestorePlanBindingsResponse.next_page_token]: crate::model::ListRestorePlanBindingsResponse::next_page_token
    pub page_size: i32,

    /// Optional. The value of
    /// [next_page_token][google.cloud.gkebackup.v1.ListRestorePlanBindingsResponse.next_page_token]
    /// received from a previous `ListRestorePlanBindings` call.
    /// Provide this to retrieve the subsequent page in a multi-page list of
    /// results. When paginating, all other parameters provided to
    /// `ListRestorePlanBindings` must match the call that provided the page
    /// token.
    ///
    /// [google.cloud.gkebackup.v1.ListRestorePlanBindingsResponse.next_page_token]: crate::model::ListRestorePlanBindingsResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Field match expression used to filter the results.
    pub filter: std::string::String,

    /// Optional. Field by which to sort the results.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRestorePlanBindingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRestorePlanBindingsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRestorePlanBindingsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRestorePlanBindingsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListRestorePlanBindingsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListRestorePlanBindingsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListRestorePlanBindingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.ListRestorePlanBindingsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRestorePlanBindingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRestorePlanBindingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRestorePlanBindingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRestorePlanBindingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRestorePlanBindingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListRestorePlanBindings.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRestorePlanBindingsResponse {
    /// The list of RestorePlanBindings matching the given criteria.
    pub restore_plan_bindings: std::vec::Vec<crate::model::RestorePlanBinding>,

    /// A token which may be sent as
    /// [page_token][google.cloud.gkebackup.v1.ListRestorePlanBindingsRequest.page_token]
    /// in a subsequent `ListRestorePlanBindings` call to retrieve the next page of
    /// results. If this field is omitted or empty, then there are no more results
    /// to return.
    ///
    /// [google.cloud.gkebackup.v1.ListRestorePlanBindingsRequest.page_token]: crate::model::ListRestorePlanBindingsRequest::page_token
    pub next_page_token: std::string::String,

    /// Unordered list. Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRestorePlanBindingsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [restore_plan_bindings][crate::model::ListRestorePlanBindingsResponse::restore_plan_bindings].
    pub fn set_restore_plan_bindings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RestorePlanBinding>,
    {
        use std::iter::Iterator;
        self.restore_plan_bindings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRestorePlanBindingsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListRestorePlanBindingsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListRestorePlanBindingsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.ListRestorePlanBindingsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRestorePlanBindingsResponse {
    type PageItem = crate::model::RestorePlanBinding;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.restore_plan_bindings
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRestorePlanBindingsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __restore_plan_bindings,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRestorePlanBindingsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "restorePlanBindings" => Ok(__FieldTag::__restore_plan_bindings),
                            "restore_plan_bindings" => Ok(__FieldTag::__restore_plan_bindings),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRestorePlanBindingsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRestorePlanBindingsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__restore_plan_bindings => {
                            if !fields.insert(__FieldTag::__restore_plan_bindings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_plan_bindings",
                                ));
                            }
                            result.restore_plan_bindings = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::RestorePlanBinding>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRestorePlanBindingsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.restore_plan_bindings.is_empty() {
            state.serialize_entry("restorePlanBindings", &self.restore_plan_bindings)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetRestorePlanBinding.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetRestorePlanBindingRequest {
    /// Required. Fully qualified RestorePlanBinding name.
    /// Format:
    /// `projects/*/locations/*/restoreChannels/*/restorePlanBindings/*`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRestorePlanBindingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRestorePlanBindingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRestorePlanBindingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.GetRestorePlanBindingRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetRestorePlanBindingRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetRestorePlanBindingRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetRestorePlanBindingRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetRestorePlanBindingRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetRestorePlanBindingRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for CreateRestore.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateRestoreRequest {
    /// Required. The RestorePlan within which to create the Restore.
    /// Format: `projects/*/locations/*/restorePlans/*`
    pub parent: std::string::String,

    /// Required. The restore resource to create.
    pub restore: std::option::Option<crate::model::Restore>,

    /// Required. The client-provided short name for the Restore resource.
    /// This name must:
    ///
    /// - be between 1 and 63 characters long (inclusive)
    /// - consist of only lower-case ASCII letters, numbers, and dashes
    /// - start with a lower-case letter
    /// - end with a lower-case letter or number
    /// - be unique within the set of Restores in this RestorePlan.
    pub restore_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateRestoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateRestoreRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [restore][crate::model::CreateRestoreRequest::restore].
    pub fn set_restore<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Restore>,
    {
        self.restore = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [restore][crate::model::CreateRestoreRequest::restore].
    pub fn set_or_clear_restore<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Restore>,
    {
        self.restore = v.map(|x| x.into());
        self
    }

    /// Sets the value of [restore_id][crate::model::CreateRestoreRequest::restore_id].
    pub fn set_restore_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.restore_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateRestoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.CreateRestoreRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateRestoreRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __restore,
            __restore_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateRestoreRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "restore" => Ok(__FieldTag::__restore),
                            "restoreId" => Ok(__FieldTag::__restore_id),
                            "restore_id" => Ok(__FieldTag::__restore_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateRestoreRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateRestoreRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__restore => {
                            if !fields.insert(__FieldTag::__restore) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore",
                                ));
                            }
                            result.restore =
                                map.next_value::<std::option::Option<crate::model::Restore>>()?;
                        }
                        __FieldTag::__restore_id => {
                            if !fields.insert(__FieldTag::__restore_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_id",
                                ));
                            }
                            result.restore_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateRestoreRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.restore.is_some() {
            state.serialize_entry("restore", &self.restore)?;
        }
        if !self.restore_id.is_empty() {
            state.serialize_entry("restoreId", &self.restore_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListRestores.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRestoresRequest {
    /// Required. The RestorePlan that contains the Restores to list.
    /// Format: `projects/*/locations/*/restorePlans/*`
    pub parent: std::string::String,

    /// Optional. The target number of results to return in a single response.
    /// If not specified, a default value will be chosen by the service.
    /// Note that the response may include a partial list and a caller should
    /// only rely on the response's
    /// [next_page_token][google.cloud.gkebackup.v1.ListRestoresResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkebackup.v1.ListRestoresResponse.next_page_token]: crate::model::ListRestoresResponse::next_page_token
    pub page_size: i32,

    /// Optional. The value of
    /// [next_page_token][google.cloud.gkebackup.v1.ListRestoresResponse.next_page_token]
    /// received from a previous `ListRestores` call.
    /// Provide this to retrieve the subsequent page in a multi-page list of
    /// results. When paginating, all other parameters provided to `ListRestores`
    /// must match the call that provided the page token.
    ///
    /// [google.cloud.gkebackup.v1.ListRestoresResponse.next_page_token]: crate::model::ListRestoresResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Field match expression used to filter the results.
    pub filter: std::string::String,

    /// Optional. Field by which to sort the results.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRestoresRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRestoresRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRestoresRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRestoresRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListRestoresRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListRestoresRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListRestoresRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.ListRestoresRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRestoresRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRestoresRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRestoresRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRestoresRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRestoresRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListRestores.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRestoresResponse {
    /// The list of Restores matching the given criteria.
    pub restores: std::vec::Vec<crate::model::Restore>,

    /// A token which may be sent as
    /// [page_token][google.cloud.gkebackup.v1.ListRestoresRequest.page_token] in a
    /// subsequent `ListRestores` call to retrieve the next page of results. If
    /// this field is omitted or empty, then there are no more results to return.
    ///
    /// [google.cloud.gkebackup.v1.ListRestoresRequest.page_token]: crate::model::ListRestoresRequest::page_token
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRestoresResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [restores][crate::model::ListRestoresResponse::restores].
    pub fn set_restores<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Restore>,
    {
        use std::iter::Iterator;
        self.restores = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRestoresResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListRestoresResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListRestoresResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.ListRestoresResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRestoresResponse {
    type PageItem = crate::model::Restore;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.restores
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRestoresResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __restores,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRestoresResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "restores" => Ok(__FieldTag::__restores),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRestoresResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRestoresResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__restores => {
                            if !fields.insert(__FieldTag::__restores) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restores",
                                ));
                            }
                            result.restores = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Restore>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRestoresResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.restores.is_empty() {
            state.serialize_entry("restores", &self.restores)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetRestore.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetRestoreRequest {
    /// Required. Name of the restore resource.
    /// Format: `projects/*/locations/*/restorePlans/*/restores/*`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRestoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRestoreRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRestoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.GetRestoreRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetRestoreRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetRestoreRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetRestoreRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetRestoreRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetRestoreRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for UpdateRestore.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateRestoreRequest {
    /// Required. A new version of the Restore resource that contains updated
    /// fields. This may be sparsely populated if an `update_mask` is provided.
    pub restore: std::option::Option<crate::model::Restore>,

    /// Optional. This is used to specify the fields to be overwritten in the
    /// Restore targeted for update. The values for each of these
    /// updated fields will be taken from the `restore` provided
    /// with this request. Field names are relative to the root of the resource.
    /// If no `update_mask` is provided, all fields in `restore` will be
    /// written to the target Restore resource.
    /// Note that OUTPUT_ONLY and IMMUTABLE fields in `restore` are ignored
    /// and are not used to update the target Restore.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateRestoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [restore][crate::model::UpdateRestoreRequest::restore].
    pub fn set_restore<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Restore>,
    {
        self.restore = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [restore][crate::model::UpdateRestoreRequest::restore].
    pub fn set_or_clear_restore<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Restore>,
    {
        self.restore = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateRestoreRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateRestoreRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateRestoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.UpdateRestoreRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateRestoreRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __restore,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateRestoreRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "restore" => Ok(__FieldTag::__restore),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateRestoreRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateRestoreRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__restore => {
                            if !fields.insert(__FieldTag::__restore) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore",
                                ));
                            }
                            result.restore =
                                map.next_value::<std::option::Option<crate::model::Restore>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateRestoreRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.restore.is_some() {
            state.serialize_entry("restore", &self.restore)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for DeleteRestore.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteRestoreRequest {
    /// Required. Full name of the Restore
    /// Format: `projects/*/locations/*/restorePlans/*/restores/*`
    pub name: std::string::String,

    /// Optional. If provided, this value must match the current value of the
    /// target Restore's [etag][google.cloud.gkebackup.v1.Restore.etag] field or
    /// the request is rejected.
    ///
    /// [google.cloud.gkebackup.v1.Restore.etag]: crate::model::Restore::etag
    pub etag: std::string::String,

    /// Optional. If set to true, any VolumeRestores below this restore will also
    /// be deleted. Otherwise, the request will only succeed if the restore has no
    /// VolumeRestores.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteRestoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteRestoreRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteRestoreRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteRestoreRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRestoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.DeleteRestoreRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteRestoreRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteRestoreRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteRestoreRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteRestoreRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteRestoreRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListVolumeRestores.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVolumeRestoresRequest {
    /// Required. The Restore that contains the VolumeRestores to list.
    /// Format: `projects/*/locations/*/restorePlans/*/restores/*`
    pub parent: std::string::String,

    /// Optional. The target number of results to return in a single response.
    /// If not specified, a default value will be chosen by the service.
    /// Note that the response may include a partial list and a caller should
    /// only rely on the response's
    /// [next_page_token][google.cloud.gkebackup.v1.ListVolumeRestoresResponse.next_page_token]
    /// to determine if there are more instances left to be queried.
    ///
    /// [google.cloud.gkebackup.v1.ListVolumeRestoresResponse.next_page_token]: crate::model::ListVolumeRestoresResponse::next_page_token
    pub page_size: i32,

    /// Optional. The value of
    /// [next_page_token][google.cloud.gkebackup.v1.ListVolumeRestoresResponse.next_page_token]
    /// received from a previous `ListVolumeRestores` call.
    /// Provide this to retrieve the subsequent page in a multi-page list of
    /// results. When paginating, all other parameters provided to
    /// `ListVolumeRestores` must match the call that provided the page token.
    ///
    /// [google.cloud.gkebackup.v1.ListVolumeRestoresResponse.next_page_token]: crate::model::ListVolumeRestoresResponse::next_page_token
    pub page_token: std::string::String,

    /// Optional. Field match expression used to filter the results.
    pub filter: std::string::String,

    /// Optional. Field by which to sort the results.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVolumeRestoresRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVolumeRestoresRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVolumeRestoresRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVolumeRestoresRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListVolumeRestoresRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListVolumeRestoresRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListVolumeRestoresRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.ListVolumeRestoresRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVolumeRestoresRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVolumeRestoresRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVolumeRestoresRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVolumeRestoresRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVolumeRestoresRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListVolumeRestores.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVolumeRestoresResponse {
    /// The list of VolumeRestores matching the given criteria.
    pub volume_restores: std::vec::Vec<crate::model::VolumeRestore>,

    /// A token which may be sent as
    /// [page_token][google.cloud.gkebackup.v1.ListVolumeRestoresRequest.page_token]
    /// in a subsequent `ListVolumeRestores` call to retrieve the next page of
    /// results. If this field is omitted or empty, then there are no more results
    /// to return.
    ///
    /// [google.cloud.gkebackup.v1.ListVolumeRestoresRequest.page_token]: crate::model::ListVolumeRestoresRequest::page_token
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVolumeRestoresResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [volume_restores][crate::model::ListVolumeRestoresResponse::volume_restores].
    pub fn set_volume_restores<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VolumeRestore>,
    {
        use std::iter::Iterator;
        self.volume_restores = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVolumeRestoresResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListVolumeRestoresResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.ListVolumeRestoresResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVolumeRestoresResponse {
    type PageItem = crate::model::VolumeRestore;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.volume_restores
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVolumeRestoresResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __volume_restores,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVolumeRestoresResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "volumeRestores" => Ok(__FieldTag::__volume_restores),
                            "volume_restores" => Ok(__FieldTag::__volume_restores),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVolumeRestoresResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVolumeRestoresResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__volume_restores => {
                            if !fields.insert(__FieldTag::__volume_restores) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_restores",
                                ));
                            }
                            result.volume_restores = map.next_value::<std::option::Option<std::vec::Vec<crate::model::VolumeRestore>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVolumeRestoresResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.volume_restores.is_empty() {
            state.serialize_entry("volumeRestores", &self.volume_restores)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetVolumeRestore.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVolumeRestoreRequest {
    /// Required. Full name of the VolumeRestore resource.
    /// Format: `projects/*/locations/*/restorePlans/*/restores/*/volumeRestores/*`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVolumeRestoreRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVolumeRestoreRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVolumeRestoreRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.GetVolumeRestoreRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetVolumeRestoreRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetVolumeRestoreRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetVolumeRestoreRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetVolumeRestoreRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetVolumeRestoreRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetBackupIndexDownloadUrl.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBackupIndexDownloadUrlRequest {
    /// Required. Full name of Backup resource.
    /// Format:
    /// projects/{project}/locations/{location}/backupPlans/{backup_plan}/backups/{backup}
    pub backup: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupIndexDownloadUrlRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup][crate::model::GetBackupIndexDownloadUrlRequest::backup].
    pub fn set_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupIndexDownloadUrlRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.GetBackupIndexDownloadUrlRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBackupIndexDownloadUrlRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBackupIndexDownloadUrlRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backup" => Ok(__FieldTag::__backup),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBackupIndexDownloadUrlRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBackupIndexDownloadUrlRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup => {
                            if !fields.insert(__FieldTag::__backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup",
                                ));
                            }
                            result.backup = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBackupIndexDownloadUrlRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backup.is_empty() {
            state.serialize_entry("backup", &self.backup)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for GetBackupIndexDownloadUrl.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBackupIndexDownloadUrlResponse {
    /// Required. The signed URL for downloading the backup index.
    pub signed_url: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupIndexDownloadUrlResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [signed_url][crate::model::GetBackupIndexDownloadUrlResponse::signed_url].
    pub fn set_signed_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.signed_url = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupIndexDownloadUrlResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.GetBackupIndexDownloadUrlResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBackupIndexDownloadUrlResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __signed_url,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBackupIndexDownloadUrlResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "signedUrl" => Ok(__FieldTag::__signed_url),
                            "signed_url" => Ok(__FieldTag::__signed_url),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBackupIndexDownloadUrlResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBackupIndexDownloadUrlResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__signed_url => {
                            if !fields.insert(__FieldTag::__signed_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for signed_url",
                                ));
                            }
                            result.signed_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBackupIndexDownloadUrlResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.signed_url.is_empty() {
            state.serialize_entry("signedUrl", &self.signed_url)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents both a request to Restore some portion of a Backup into
/// a target GKE cluster and a record of the restore operation itself.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Restore {
    /// Output only. The full name of the Restore resource.
    /// Format: `projects/*/locations/*/restorePlans/*/restores/*`
    pub name: std::string::String,

    /// Output only. Server generated global unique identifier of
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) format.
    pub uid: std::string::String,

    /// Output only. The timestamp when this Restore resource was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when this Restore resource was last
    /// updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User specified descriptive string for this Restore.
    pub description: std::string::String,

    /// Required. Immutable. A reference to the
    /// [Backup][google.cloud.gkebackup.v1.Backup] used as the source from which
    /// this Restore will restore. Note that this Backup must be a sub-resource of
    /// the RestorePlan's
    /// [backup_plan][google.cloud.gkebackup.v1.RestorePlan.backup_plan]. Format:
    /// `projects/*/locations/*/backupPlans/*/backups/*`.
    ///
    /// [google.cloud.gkebackup.v1.Backup]: crate::model::Backup
    /// [google.cloud.gkebackup.v1.RestorePlan.backup_plan]: crate::model::RestorePlan::backup_plan
    pub backup: std::string::String,

    /// Output only. The target cluster into which this Restore will restore data.
    /// Valid formats:
    ///
    /// - `projects/*/locations/*/clusters/*`
    /// - `projects/*/zones/*/clusters/*`
    ///
    /// Inherited from parent RestorePlan's
    /// [cluster][google.cloud.gkebackup.v1.RestorePlan.cluster] value.
    ///
    /// [google.cloud.gkebackup.v1.RestorePlan.cluster]: crate::model::RestorePlan::cluster
    pub cluster: std::string::String,

    /// Output only. Configuration of the Restore.  Inherited from parent
    /// RestorePlan's
    /// [restore_config][google.cloud.gkebackup.v1.RestorePlan.restore_config].
    ///
    /// [google.cloud.gkebackup.v1.RestorePlan.restore_config]: crate::model::RestorePlan::restore_config
    pub restore_config: std::option::Option<crate::model::RestoreConfig>,

    /// A set of custom labels supplied by user.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The current state of the Restore.
    pub state: crate::model::restore::State,

    /// Output only. Human-readable description of why the Restore is in its
    /// current state. This field is only meant for human readability and should
    /// not be used programmatically as this field is not guaranteed to be
    /// consistent.
    pub state_reason: std::string::String,

    /// Output only. Timestamp of when the restore operation completed.
    pub complete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Number of resources restored during the restore execution.
    pub resources_restored_count: i32,

    /// Output only. Number of resources excluded during the restore execution.
    pub resources_excluded_count: i32,

    /// Output only. Number of resources that failed to be restored during the
    /// restore execution.
    pub resources_failed_count: i32,

    /// Output only. Number of volumes restored during the restore execution.
    pub volumes_restored_count: i32,

    /// Output only. `etag` is used for optimistic concurrency control as a way to
    /// help prevent simultaneous updates of a restore from overwriting each other.
    /// It is strongly suggested that systems make use of the `etag` in the
    /// read-modify-write cycle to perform restore updates in order to avoid
    /// race conditions: An `etag` is returned in the response to `GetRestore`,
    /// and systems are expected to put that etag in the request to
    /// `UpdateRestore` or `DeleteRestore` to ensure that their change will be
    /// applied to the same version of the resource.
    pub etag: std::string::String,

    /// Optional. Immutable. Filters resources for `Restore`. If not specified, the
    /// scope of the restore will remain the same as defined in the `RestorePlan`.
    /// If this is specified and no resources are matched by the
    /// `inclusion_filters` or everything is excluded by the `exclusion_filters`,
    /// nothing will be restored. This filter can only be specified if the value of
    /// [namespaced_resource_restore_mode][google.cloud.gkebackup.v1.RestoreConfig.namespaced_resource_restore_mode]
    /// is set to `MERGE_SKIP_ON_CONFLICT`, `MERGE_REPLACE_VOLUME_ON_CONFLICT` or
    /// `MERGE_REPLACE_ON_CONFLICT`.
    ///
    /// [google.cloud.gkebackup.v1.RestoreConfig.namespaced_resource_restore_mode]: crate::model::RestoreConfig::namespaced_resource_restore_mode
    pub filter: std::option::Option<crate::model::restore::Filter>,

    /// Optional. Immutable. Overrides the volume data restore policies selected in
    /// the Restore Config for override-scoped resources.
    pub volume_data_restore_policy_overrides:
        std::vec::Vec<crate::model::VolumeDataRestorePolicyOverride>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Restore {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Restore::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Restore::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Restore::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Restore::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Restore::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Restore::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::Restore::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [backup][crate::model::Restore::backup].
    pub fn set_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::Restore::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [restore_config][crate::model::Restore::restore_config].
    pub fn set_restore_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RestoreConfig>,
    {
        self.restore_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [restore_config][crate::model::Restore::restore_config].
    pub fn set_or_clear_restore_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RestoreConfig>,
    {
        self.restore_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Restore::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::Restore::state].
    pub fn set_state<T: std::convert::Into<crate::model::restore::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_reason][crate::model::Restore::state_reason].
    pub fn set_state_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_reason = v.into();
        self
    }

    /// Sets the value of [complete_time][crate::model::Restore::complete_time].
    pub fn set_complete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [complete_time][crate::model::Restore::complete_time].
    pub fn set_or_clear_complete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resources_restored_count][crate::model::Restore::resources_restored_count].
    pub fn set_resources_restored_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.resources_restored_count = v.into();
        self
    }

    /// Sets the value of [resources_excluded_count][crate::model::Restore::resources_excluded_count].
    pub fn set_resources_excluded_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.resources_excluded_count = v.into();
        self
    }

    /// Sets the value of [resources_failed_count][crate::model::Restore::resources_failed_count].
    pub fn set_resources_failed_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.resources_failed_count = v.into();
        self
    }

    /// Sets the value of [volumes_restored_count][crate::model::Restore::volumes_restored_count].
    pub fn set_volumes_restored_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.volumes_restored_count = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Restore::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::Restore::filter].
    pub fn set_filter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::restore::Filter>,
    {
        self.filter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [filter][crate::model::Restore::filter].
    pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::restore::Filter>,
    {
        self.filter = v.map(|x| x.into());
        self
    }

    /// Sets the value of [volume_data_restore_policy_overrides][crate::model::Restore::volume_data_restore_policy_overrides].
    pub fn set_volume_data_restore_policy_overrides<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VolumeDataRestorePolicyOverride>,
    {
        use std::iter::Iterator;
        self.volume_data_restore_policy_overrides = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Restore {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.Restore"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Restore {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __create_time,
            __update_time,
            __description,
            __backup,
            __cluster,
            __restore_config,
            __labels,
            __state,
            __state_reason,
            __complete_time,
            __resources_restored_count,
            __resources_excluded_count,
            __resources_failed_count,
            __volumes_restored_count,
            __etag,
            __filter,
            __volume_data_restore_policy_overrides,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Restore")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "description" => Ok(__FieldTag::__description),
                            "backup" => Ok(__FieldTag::__backup),
                            "cluster" => Ok(__FieldTag::__cluster),
                            "restoreConfig" => Ok(__FieldTag::__restore_config),
                            "restore_config" => Ok(__FieldTag::__restore_config),
                            "labels" => Ok(__FieldTag::__labels),
                            "state" => Ok(__FieldTag::__state),
                            "stateReason" => Ok(__FieldTag::__state_reason),
                            "state_reason" => Ok(__FieldTag::__state_reason),
                            "completeTime" => Ok(__FieldTag::__complete_time),
                            "complete_time" => Ok(__FieldTag::__complete_time),
                            "resourcesRestoredCount" => Ok(__FieldTag::__resources_restored_count),
                            "resources_restored_count" => {
                                Ok(__FieldTag::__resources_restored_count)
                            }
                            "resourcesExcludedCount" => Ok(__FieldTag::__resources_excluded_count),
                            "resources_excluded_count" => {
                                Ok(__FieldTag::__resources_excluded_count)
                            }
                            "resourcesFailedCount" => Ok(__FieldTag::__resources_failed_count),
                            "resources_failed_count" => Ok(__FieldTag::__resources_failed_count),
                            "volumesRestoredCount" => Ok(__FieldTag::__volumes_restored_count),
                            "volumes_restored_count" => Ok(__FieldTag::__volumes_restored_count),
                            "etag" => Ok(__FieldTag::__etag),
                            "filter" => Ok(__FieldTag::__filter),
                            "volumeDataRestorePolicyOverrides" => {
                                Ok(__FieldTag::__volume_data_restore_policy_overrides)
                            }
                            "volume_data_restore_policy_overrides" => {
                                Ok(__FieldTag::__volume_data_restore_policy_overrides)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Restore;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Restore")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup => {
                            if !fields.insert(__FieldTag::__backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup",
                                ));
                            }
                            result.backup = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__restore_config => {
                            if !fields.insert(__FieldTag::__restore_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_config",
                                ));
                            }
                            result.restore_config = map
                                .next_value::<std::option::Option<crate::model::RestoreConfig>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::restore::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_reason => {
                            if !fields.insert(__FieldTag::__state_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_reason",
                                ));
                            }
                            result.state_reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__complete_time => {
                            if !fields.insert(__FieldTag::__complete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for complete_time",
                                ));
                            }
                            result.complete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__resources_restored_count => {
                            if !fields.insert(__FieldTag::__resources_restored_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resources_restored_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.resources_restored_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__resources_excluded_count => {
                            if !fields.insert(__FieldTag::__resources_excluded_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resources_excluded_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.resources_excluded_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__resources_failed_count => {
                            if !fields.insert(__FieldTag::__resources_failed_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resources_failed_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.resources_failed_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__volumes_restored_count => {
                            if !fields.insert(__FieldTag::__volumes_restored_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volumes_restored_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.volumes_restored_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<crate::model::restore::Filter>>(
                                )?;
                        }
                        __FieldTag::__volume_data_restore_policy_overrides => {
                            if !fields.insert(__FieldTag::__volume_data_restore_policy_overrides) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_data_restore_policy_overrides",
                                ));
                            }
                            result.volume_data_restore_policy_overrides = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::VolumeDataRestorePolicyOverride>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Restore {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.backup.is_empty() {
            state.serialize_entry("backup", &self.backup)?;
        }
        if !self.cluster.is_empty() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if self.restore_config.is_some() {
            state.serialize_entry("restoreConfig", &self.restore_config)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_reason.is_empty() {
            state.serialize_entry("stateReason", &self.state_reason)?;
        }
        if self.complete_time.is_some() {
            state.serialize_entry("completeTime", &self.complete_time)?;
        }
        if !wkt::internal::is_default(&self.resources_restored_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "resourcesRestoredCount",
                &__With(&self.resources_restored_count),
            )?;
        }
        if !wkt::internal::is_default(&self.resources_excluded_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "resourcesExcludedCount",
                &__With(&self.resources_excluded_count),
            )?;
        }
        if !wkt::internal::is_default(&self.resources_failed_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "resourcesFailedCount",
                &__With(&self.resources_failed_count),
            )?;
        }
        if !wkt::internal::is_default(&self.volumes_restored_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "volumesRestoredCount",
                &__With(&self.volumes_restored_count),
            )?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.filter.is_some() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.volume_data_restore_policy_overrides.is_empty() {
            state.serialize_entry(
                "volumeDataRestorePolicyOverrides",
                &self.volume_data_restore_policy_overrides,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Restore].
pub mod restore {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the filter for `Restore`. This filter can be used to further
    /// refine the resource selection of the `Restore` beyond the coarse-grained
    /// scope defined in the `RestorePlan`. `exclusion_filters` take precedence
    /// over `inclusion_filters`. If a resource matches both `inclusion_filters`
    /// and `exclusion_filters`, it will not be restored.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Filter {
        /// Optional. Selects resources for restoration. If specified, only resources
        /// which match `inclusion_filters` will be selected for restoration. A
        /// resource will be selected if it matches any `ResourceSelector` of the
        /// `inclusion_filters`.
        pub inclusion_filters: std::vec::Vec<crate::model::ResourceSelector>,

        /// Optional. Excludes resources from restoration. If specified,
        /// a resource will not be restored if it matches
        /// any `ResourceSelector` of the `exclusion_filters`.
        pub exclusion_filters: std::vec::Vec<crate::model::ResourceSelector>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Filter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [inclusion_filters][crate::model::restore::Filter::inclusion_filters].
        pub fn set_inclusion_filters<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ResourceSelector>,
        {
            use std::iter::Iterator;
            self.inclusion_filters = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [exclusion_filters][crate::model::restore::Filter::exclusion_filters].
        pub fn set_exclusion_filters<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ResourceSelector>,
        {
            use std::iter::Iterator;
            self.exclusion_filters = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Filter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.gkebackup.v1.Restore.Filter"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Filter {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __inclusion_filters,
                __exclusion_filters,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Filter")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "inclusionFilters" => Ok(__FieldTag::__inclusion_filters),
                                "inclusion_filters" => Ok(__FieldTag::__inclusion_filters),
                                "exclusionFilters" => Ok(__FieldTag::__exclusion_filters),
                                "exclusion_filters" => Ok(__FieldTag::__exclusion_filters),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Filter;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Filter")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__inclusion_filters => {
                                if !fields.insert(__FieldTag::__inclusion_filters) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for inclusion_filters",
                                    ));
                                }
                                result.inclusion_filters = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::ResourceSelector>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__exclusion_filters => {
                                if !fields.insert(__FieldTag::__exclusion_filters) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for exclusion_filters",
                                    ));
                                }
                                result.exclusion_filters = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::ResourceSelector>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Filter {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.inclusion_filters.is_empty() {
                state.serialize_entry("inclusionFilters", &self.inclusion_filters)?;
            }
            if !self.exclusion_filters.is_empty() {
                state.serialize_entry("exclusionFilters", &self.exclusion_filters)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Possible values for state of the Restore.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The Restore resource is in the process of being created.
        Unspecified,
        /// The Restore resource has been created and the associated RestoreJob
        /// Kubernetes resource has been injected into target cluster.
        Creating,
        /// The gkebackup agent in the cluster has begun executing the restore
        /// operation.
        InProgress,
        /// The restore operation has completed successfully. Restored workloads may
        /// not yet be operational.
        Succeeded,
        /// The restore operation has failed.
        Failed,
        /// This Restore resource is in the process of being deleted.
        Deleting,
        /// The Kubernetes resources created by this Restore are being
        /// validated.
        Validating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::InProgress => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Deleting => std::option::Option::Some(5),
                Self::Validating => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Validating => std::option::Option::Some("VALIDATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::InProgress,
                3 => Self::Succeeded,
                4 => Self::Failed,
                5 => Self::Deleting,
                6 => Self::Validating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "IN_PROGRESS" => Self::InProgress,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "DELETING" => Self::Deleting,
                "VALIDATING" => Self::Validating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::InProgress => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Deleting => serializer.serialize_i32(5),
                Self::Validating => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.gkebackup.v1.Restore.State",
            ))
        }
    }
}

/// Configuration of a restore.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RestoreConfig {
    /// Optional. Specifies the mechanism to be used to restore volume data.
    /// Default: VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED (will be treated as
    /// NO_VOLUME_DATA_RESTORATION).
    pub volume_data_restore_policy: crate::model::restore_config::VolumeDataRestorePolicy,

    /// Optional. Defines the behavior for handling the situation where
    /// cluster-scoped resources being restored already exist in the target
    /// cluster. This MUST be set to a value other than
    /// CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED if
    /// [cluster_resource_restore_scope][google.cloud.gkebackup.v1.RestoreConfig.cluster_resource_restore_scope]
    /// is not empty.
    ///
    /// [google.cloud.gkebackup.v1.RestoreConfig.cluster_resource_restore_scope]: crate::model::RestoreConfig::cluster_resource_restore_scope
    pub cluster_resource_conflict_policy:
        crate::model::restore_config::ClusterResourceConflictPolicy,

    /// Optional. Defines the behavior for handling the situation where sets of
    /// namespaced resources being restored already exist in the target cluster.
    /// This MUST be set to a value other than
    /// NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED.
    pub namespaced_resource_restore_mode:
        crate::model::restore_config::NamespacedResourceRestoreMode,

    /// Optional. Identifies the cluster-scoped resources to restore from the
    /// Backup. Not specifying it means NO cluster resource will be restored.
    pub cluster_resource_restore_scope:
        std::option::Option<crate::model::restore_config::ClusterResourceRestoreScope>,

    /// Optional. A list of transformation rules to be applied against Kubernetes
    /// resources as they are selected for restoration from a Backup. Rules are
    /// executed in order defined - this order matters, as changes made by a rule
    /// may impact the filtering logic of subsequent rules. An empty list means no
    /// substitution will occur.
    pub substitution_rules: std::vec::Vec<crate::model::restore_config::SubstitutionRule>,

    /// Optional. A list of transformation rules to be applied against Kubernetes
    /// resources as they are selected for restoration from a Backup. Rules are
    /// executed in order defined - this order matters, as changes made by a rule
    /// may impact the filtering logic of subsequent rules. An empty list means no
    /// transformation will occur.
    pub transformation_rules: std::vec::Vec<crate::model::restore_config::TransformationRule>,

    /// Optional. A table that binds volumes by their scope to a restore policy.
    /// Bindings must have a unique scope. Any volumes not scoped in the bindings
    /// are subject to the policy defined in volume_data_restore_policy.
    pub volume_data_restore_policy_bindings:
        std::vec::Vec<crate::model::restore_config::VolumeDataRestorePolicyBinding>,

    /// Optional. RestoreOrder contains custom ordering to use on a Restore.
    pub restore_order: std::option::Option<crate::model::restore_config::RestoreOrder>,

    /// Specifies the namespaced resources to restore from the Backup.
    /// Only one of the entries may be specified. If not specified, NO namespaced
    /// resources will be restored.
    ///
    /// Note: Resources will never be restored into *managed* namespaces such as
    /// `kube-system`, `kube-public`, or `kube-node-lease`. These namespaces
    /// are silently skipped when
    /// [all_namespaces][google.cloud.gkebackup.v1.RestoreConfig.all_namespaces] is
    /// selected. Listing them explicitly will result in an error.
    ///
    /// [google.cloud.gkebackup.v1.RestoreConfig.all_namespaces]: crate::model::RestoreConfig::namespaced_resource_restore_scope
    pub namespaced_resource_restore_scope:
        std::option::Option<crate::model::restore_config::NamespacedResourceRestoreScope>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [volume_data_restore_policy][crate::model::RestoreConfig::volume_data_restore_policy].
    pub fn set_volume_data_restore_policy<
        T: std::convert::Into<crate::model::restore_config::VolumeDataRestorePolicy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.volume_data_restore_policy = v.into();
        self
    }

    /// Sets the value of [cluster_resource_conflict_policy][crate::model::RestoreConfig::cluster_resource_conflict_policy].
    pub fn set_cluster_resource_conflict_policy<
        T: std::convert::Into<crate::model::restore_config::ClusterResourceConflictPolicy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_resource_conflict_policy = v.into();
        self
    }

    /// Sets the value of [namespaced_resource_restore_mode][crate::model::RestoreConfig::namespaced_resource_restore_mode].
    pub fn set_namespaced_resource_restore_mode<
        T: std::convert::Into<crate::model::restore_config::NamespacedResourceRestoreMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.namespaced_resource_restore_mode = v.into();
        self
    }

    /// Sets the value of [cluster_resource_restore_scope][crate::model::RestoreConfig::cluster_resource_restore_scope].
    pub fn set_cluster_resource_restore_scope<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::restore_config::ClusterResourceRestoreScope>,
    {
        self.cluster_resource_restore_scope = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster_resource_restore_scope][crate::model::RestoreConfig::cluster_resource_restore_scope].
    pub fn set_or_clear_cluster_resource_restore_scope<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::restore_config::ClusterResourceRestoreScope>,
    {
        self.cluster_resource_restore_scope = v.map(|x| x.into());
        self
    }

    /// Sets the value of [substitution_rules][crate::model::RestoreConfig::substitution_rules].
    pub fn set_substitution_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::restore_config::SubstitutionRule>,
    {
        use std::iter::Iterator;
        self.substitution_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [transformation_rules][crate::model::RestoreConfig::transformation_rules].
    pub fn set_transformation_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::restore_config::TransformationRule>,
    {
        use std::iter::Iterator;
        self.transformation_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [volume_data_restore_policy_bindings][crate::model::RestoreConfig::volume_data_restore_policy_bindings].
    pub fn set_volume_data_restore_policy_bindings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::restore_config::VolumeDataRestorePolicyBinding>,
    {
        use std::iter::Iterator;
        self.volume_data_restore_policy_bindings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [restore_order][crate::model::RestoreConfig::restore_order].
    pub fn set_restore_order<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::restore_config::RestoreOrder>,
    {
        self.restore_order = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [restore_order][crate::model::RestoreConfig::restore_order].
    pub fn set_or_clear_restore_order<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::restore_config::RestoreOrder>,
    {
        self.restore_order = v.map(|x| x.into());
        self
    }

    /// Sets the value of [namespaced_resource_restore_scope][crate::model::RestoreConfig::namespaced_resource_restore_scope].
    ///
    /// Note that all the setters affecting `namespaced_resource_restore_scope` are mutually
    /// exclusive.
    pub fn set_namespaced_resource_restore_scope<
        T: std::convert::Into<
                std::option::Option<crate::model::restore_config::NamespacedResourceRestoreScope>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.namespaced_resource_restore_scope = v.into();
        self
    }

    /// The value of [namespaced_resource_restore_scope][crate::model::RestoreConfig::namespaced_resource_restore_scope]
    /// if it holds a `AllNamespaces`, `None` if the field is not set or
    /// holds a different branch.
    pub fn all_namespaces(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.namespaced_resource_restore_scope
            .as_ref()
            .and_then(|v| match v {
                crate::model::restore_config::NamespacedResourceRestoreScope::AllNamespaces(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
    }

    /// Sets the value of [namespaced_resource_restore_scope][crate::model::RestoreConfig::namespaced_resource_restore_scope]
    /// to hold a `AllNamespaces`.
    ///
    /// Note that all the setters affecting `namespaced_resource_restore_scope` are
    /// mutually exclusive.
    pub fn set_all_namespaces<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.namespaced_resource_restore_scope = std::option::Option::Some(
            crate::model::restore_config::NamespacedResourceRestoreScope::AllNamespaces(v.into()),
        );
        self
    }

    /// The value of [namespaced_resource_restore_scope][crate::model::RestoreConfig::namespaced_resource_restore_scope]
    /// if it holds a `SelectedNamespaces`, `None` if the field is not set or
    /// holds a different branch.
    pub fn selected_namespaces(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::Namespaces>> {
        #[allow(unreachable_patterns)]
        self.namespaced_resource_restore_scope.as_ref().and_then(|v| match v {
            crate::model::restore_config::NamespacedResourceRestoreScope::SelectedNamespaces(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [namespaced_resource_restore_scope][crate::model::RestoreConfig::namespaced_resource_restore_scope]
    /// to hold a `SelectedNamespaces`.
    ///
    /// Note that all the setters affecting `namespaced_resource_restore_scope` are
    /// mutually exclusive.
    pub fn set_selected_namespaces<
        T: std::convert::Into<std::boxed::Box<crate::model::Namespaces>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.namespaced_resource_restore_scope = std::option::Option::Some(
            crate::model::restore_config::NamespacedResourceRestoreScope::SelectedNamespaces(
                v.into(),
            ),
        );
        self
    }

    /// The value of [namespaced_resource_restore_scope][crate::model::RestoreConfig::namespaced_resource_restore_scope]
    /// if it holds a `SelectedApplications`, `None` if the field is not set or
    /// holds a different branch.
    pub fn selected_applications(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::NamespacedNames>> {
        #[allow(unreachable_patterns)]
        self.namespaced_resource_restore_scope.as_ref().and_then(|v| match v {
            crate::model::restore_config::NamespacedResourceRestoreScope::SelectedApplications(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [namespaced_resource_restore_scope][crate::model::RestoreConfig::namespaced_resource_restore_scope]
    /// to hold a `SelectedApplications`.
    ///
    /// Note that all the setters affecting `namespaced_resource_restore_scope` are
    /// mutually exclusive.
    pub fn set_selected_applications<
        T: std::convert::Into<std::boxed::Box<crate::model::NamespacedNames>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.namespaced_resource_restore_scope = std::option::Option::Some(
            crate::model::restore_config::NamespacedResourceRestoreScope::SelectedApplications(
                v.into(),
            ),
        );
        self
    }

    /// The value of [namespaced_resource_restore_scope][crate::model::RestoreConfig::namespaced_resource_restore_scope]
    /// if it holds a `NoNamespaces`, `None` if the field is not set or
    /// holds a different branch.
    pub fn no_namespaces(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.namespaced_resource_restore_scope
            .as_ref()
            .and_then(|v| match v {
                crate::model::restore_config::NamespacedResourceRestoreScope::NoNamespaces(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
    }

    /// Sets the value of [namespaced_resource_restore_scope][crate::model::RestoreConfig::namespaced_resource_restore_scope]
    /// to hold a `NoNamespaces`.
    ///
    /// Note that all the setters affecting `namespaced_resource_restore_scope` are
    /// mutually exclusive.
    pub fn set_no_namespaces<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.namespaced_resource_restore_scope = std::option::Option::Some(
            crate::model::restore_config::NamespacedResourceRestoreScope::NoNamespaces(v.into()),
        );
        self
    }

    /// The value of [namespaced_resource_restore_scope][crate::model::RestoreConfig::namespaced_resource_restore_scope]
    /// if it holds a `ExcludedNamespaces`, `None` if the field is not set or
    /// holds a different branch.
    pub fn excluded_namespaces(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::Namespaces>> {
        #[allow(unreachable_patterns)]
        self.namespaced_resource_restore_scope.as_ref().and_then(|v| match v {
            crate::model::restore_config::NamespacedResourceRestoreScope::ExcludedNamespaces(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [namespaced_resource_restore_scope][crate::model::RestoreConfig::namespaced_resource_restore_scope]
    /// to hold a `ExcludedNamespaces`.
    ///
    /// Note that all the setters affecting `namespaced_resource_restore_scope` are
    /// mutually exclusive.
    pub fn set_excluded_namespaces<
        T: std::convert::Into<std::boxed::Box<crate::model::Namespaces>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.namespaced_resource_restore_scope = std::option::Option::Some(
            crate::model::restore_config::NamespacedResourceRestoreScope::ExcludedNamespaces(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for RestoreConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.RestoreConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestoreConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __volume_data_restore_policy,
            __cluster_resource_conflict_policy,
            __namespaced_resource_restore_mode,
            __cluster_resource_restore_scope,
            __all_namespaces,
            __selected_namespaces,
            __selected_applications,
            __no_namespaces,
            __excluded_namespaces,
            __substitution_rules,
            __transformation_rules,
            __volume_data_restore_policy_bindings,
            __restore_order,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestoreConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "volumeDataRestorePolicy" => {
                                Ok(__FieldTag::__volume_data_restore_policy)
                            }
                            "volume_data_restore_policy" => {
                                Ok(__FieldTag::__volume_data_restore_policy)
                            }
                            "clusterResourceConflictPolicy" => {
                                Ok(__FieldTag::__cluster_resource_conflict_policy)
                            }
                            "cluster_resource_conflict_policy" => {
                                Ok(__FieldTag::__cluster_resource_conflict_policy)
                            }
                            "namespacedResourceRestoreMode" => {
                                Ok(__FieldTag::__namespaced_resource_restore_mode)
                            }
                            "namespaced_resource_restore_mode" => {
                                Ok(__FieldTag::__namespaced_resource_restore_mode)
                            }
                            "clusterResourceRestoreScope" => {
                                Ok(__FieldTag::__cluster_resource_restore_scope)
                            }
                            "cluster_resource_restore_scope" => {
                                Ok(__FieldTag::__cluster_resource_restore_scope)
                            }
                            "allNamespaces" => Ok(__FieldTag::__all_namespaces),
                            "all_namespaces" => Ok(__FieldTag::__all_namespaces),
                            "selectedNamespaces" => Ok(__FieldTag::__selected_namespaces),
                            "selected_namespaces" => Ok(__FieldTag::__selected_namespaces),
                            "selectedApplications" => Ok(__FieldTag::__selected_applications),
                            "selected_applications" => Ok(__FieldTag::__selected_applications),
                            "noNamespaces" => Ok(__FieldTag::__no_namespaces),
                            "no_namespaces" => Ok(__FieldTag::__no_namespaces),
                            "excludedNamespaces" => Ok(__FieldTag::__excluded_namespaces),
                            "excluded_namespaces" => Ok(__FieldTag::__excluded_namespaces),
                            "substitutionRules" => Ok(__FieldTag::__substitution_rules),
                            "substitution_rules" => Ok(__FieldTag::__substitution_rules),
                            "transformationRules" => Ok(__FieldTag::__transformation_rules),
                            "transformation_rules" => Ok(__FieldTag::__transformation_rules),
                            "volumeDataRestorePolicyBindings" => {
                                Ok(__FieldTag::__volume_data_restore_policy_bindings)
                            }
                            "volume_data_restore_policy_bindings" => {
                                Ok(__FieldTag::__volume_data_restore_policy_bindings)
                            }
                            "restoreOrder" => Ok(__FieldTag::__restore_order),
                            "restore_order" => Ok(__FieldTag::__restore_order),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestoreConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestoreConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__volume_data_restore_policy => {
                            if !fields.insert(__FieldTag::__volume_data_restore_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_data_restore_policy",
                                ));
                            }
                            result.volume_data_restore_policy = map
                                .next_value::<std::option::Option<
                                    crate::model::restore_config::VolumeDataRestorePolicy,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_resource_conflict_policy => {
                            if !fields.insert(__FieldTag::__cluster_resource_conflict_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_resource_conflict_policy",
                                ));
                            }
                            result.cluster_resource_conflict_policy = map
                                .next_value::<std::option::Option<
                                    crate::model::restore_config::ClusterResourceConflictPolicy,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__namespaced_resource_restore_mode => {
                            if !fields.insert(__FieldTag::__namespaced_resource_restore_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for namespaced_resource_restore_mode",
                                ));
                            }
                            result.namespaced_resource_restore_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::restore_config::NamespacedResourceRestoreMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_resource_restore_scope => {
                            if !fields.insert(__FieldTag::__cluster_resource_restore_scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_resource_restore_scope",
                                ));
                            }
                            result.cluster_resource_restore_scope = map
                                .next_value::<std::option::Option<
                                    crate::model::restore_config::ClusterResourceRestoreScope,
                                >>()?;
                        }
                        __FieldTag::__all_namespaces => {
                            if !fields.insert(__FieldTag::__all_namespaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for all_namespaces",
                                ));
                            }
                            if result.namespaced_resource_restore_scope.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `namespaced_resource_restore_scope`, a oneof with full ID .google.cloud.gkebackup.v1.RestoreConfig.all_namespaces, latest field was allNamespaces",
                                ));
                            }
                            result.namespaced_resource_restore_scope = std::option::Option::Some(
                                crate::model::restore_config::NamespacedResourceRestoreScope::AllNamespaces(
                                    map.next_value::<std::option::Option<bool>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__selected_namespaces => {
                            if !fields.insert(__FieldTag::__selected_namespaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for selected_namespaces",
                                ));
                            }
                            if result.namespaced_resource_restore_scope.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `namespaced_resource_restore_scope`, a oneof with full ID .google.cloud.gkebackup.v1.RestoreConfig.selected_namespaces, latest field was selectedNamespaces",
                                ));
                            }
                            result.namespaced_resource_restore_scope = std::option::Option::Some(
                                crate::model::restore_config::NamespacedResourceRestoreScope::SelectedNamespaces(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::Namespaces>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__selected_applications => {
                            if !fields.insert(__FieldTag::__selected_applications) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for selected_applications",
                                ));
                            }
                            if result.namespaced_resource_restore_scope.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `namespaced_resource_restore_scope`, a oneof with full ID .google.cloud.gkebackup.v1.RestoreConfig.selected_applications, latest field was selectedApplications",
                                ));
                            }
                            result.namespaced_resource_restore_scope = std::option::Option::Some(
                                crate::model::restore_config::NamespacedResourceRestoreScope::SelectedApplications(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::NamespacedNames>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__no_namespaces => {
                            if !fields.insert(__FieldTag::__no_namespaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for no_namespaces",
                                ));
                            }
                            if result.namespaced_resource_restore_scope.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `namespaced_resource_restore_scope`, a oneof with full ID .google.cloud.gkebackup.v1.RestoreConfig.no_namespaces, latest field was noNamespaces",
                                ));
                            }
                            result.namespaced_resource_restore_scope = std::option::Option::Some(
                                crate::model::restore_config::NamespacedResourceRestoreScope::NoNamespaces(
                                    map.next_value::<std::option::Option<bool>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__excluded_namespaces => {
                            if !fields.insert(__FieldTag::__excluded_namespaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for excluded_namespaces",
                                ));
                            }
                            if result.namespaced_resource_restore_scope.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `namespaced_resource_restore_scope`, a oneof with full ID .google.cloud.gkebackup.v1.RestoreConfig.excluded_namespaces, latest field was excludedNamespaces",
                                ));
                            }
                            result.namespaced_resource_restore_scope = std::option::Option::Some(
                                crate::model::restore_config::NamespacedResourceRestoreScope::ExcludedNamespaces(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::Namespaces>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__substitution_rules => {
                            if !fields.insert(__FieldTag::__substitution_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for substitution_rules",
                                ));
                            }
                            result.substitution_rules = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::restore_config::SubstitutionRule>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transformation_rules => {
                            if !fields.insert(__FieldTag::__transformation_rules) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transformation_rules",
                                ));
                            }
                            result.transformation_rules = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::restore_config::TransformationRule>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__volume_data_restore_policy_bindings => {
                            if !fields.insert(__FieldTag::__volume_data_restore_policy_bindings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_data_restore_policy_bindings",
                                ));
                            }
                            result.volume_data_restore_policy_bindings = map.next_value::<std::option::Option<std::vec::Vec<crate::model::restore_config::VolumeDataRestorePolicyBinding>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__restore_order => {
                            if !fields.insert(__FieldTag::__restore_order) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_order",
                                ));
                            }
                            result.restore_order = map.next_value::<std::option::Option<crate::model::restore_config::RestoreOrder>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestoreConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.volume_data_restore_policy) {
            state.serialize_entry("volumeDataRestorePolicy", &self.volume_data_restore_policy)?;
        }
        if !wkt::internal::is_default(&self.cluster_resource_conflict_policy) {
            state.serialize_entry(
                "clusterResourceConflictPolicy",
                &self.cluster_resource_conflict_policy,
            )?;
        }
        if !wkt::internal::is_default(&self.namespaced_resource_restore_mode) {
            state.serialize_entry(
                "namespacedResourceRestoreMode",
                &self.namespaced_resource_restore_mode,
            )?;
        }
        if self.cluster_resource_restore_scope.is_some() {
            state.serialize_entry(
                "clusterResourceRestoreScope",
                &self.cluster_resource_restore_scope,
            )?;
        }
        if let Some(value) = self.all_namespaces() {
            state.serialize_entry("allNamespaces", value)?;
        }
        if let Some(value) = self.selected_namespaces() {
            state.serialize_entry("selectedNamespaces", value)?;
        }
        if let Some(value) = self.selected_applications() {
            state.serialize_entry("selectedApplications", value)?;
        }
        if let Some(value) = self.no_namespaces() {
            state.serialize_entry("noNamespaces", value)?;
        }
        if let Some(value) = self.excluded_namespaces() {
            state.serialize_entry("excludedNamespaces", value)?;
        }
        if !self.substitution_rules.is_empty() {
            state.serialize_entry("substitutionRules", &self.substitution_rules)?;
        }
        if !self.transformation_rules.is_empty() {
            state.serialize_entry("transformationRules", &self.transformation_rules)?;
        }
        if !self.volume_data_restore_policy_bindings.is_empty() {
            state.serialize_entry(
                "volumeDataRestorePolicyBindings",
                &self.volume_data_restore_policy_bindings,
            )?;
        }
        if self.restore_order.is_some() {
            state.serialize_entry("restoreOrder", &self.restore_order)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RestoreConfig].
pub mod restore_config {
    #[allow(unused_imports)]
    use super::*;

    /// This is a direct map to the Kubernetes GroupKind type
    /// [GroupKind](https://godoc.org/k8s.io/apimachinery/pkg/runtime/schema#GroupKind)
    /// and is used for identifying specific "types" of resources to restore.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GroupKind {
        /// Optional. API group string of a Kubernetes resource, e.g.
        /// "apiextensions.k8s.io", "storage.k8s.io", etc.
        /// Note: use empty string for core API group.
        pub resource_group: std::string::String,

        /// Optional. Kind of a Kubernetes resource, must be in UpperCamelCase
        /// (PascalCase) and singular form. E.g. "CustomResourceDefinition",
        /// "StorageClass", etc.
        pub resource_kind: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GroupKind {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [resource_group][crate::model::restore_config::GroupKind::resource_group].
        pub fn set_resource_group<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.resource_group = v.into();
            self
        }

        /// Sets the value of [resource_kind][crate::model::restore_config::GroupKind::resource_kind].
        pub fn set_resource_kind<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.resource_kind = v.into();
            self
        }
    }

    impl wkt::message::Message for GroupKind {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.gkebackup.v1.RestoreConfig.GroupKind"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GroupKind {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __resource_group,
                __resource_kind,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GroupKind")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "resourceGroup" => Ok(__FieldTag::__resource_group),
                                "resource_group" => Ok(__FieldTag::__resource_group),
                                "resourceKind" => Ok(__FieldTag::__resource_kind),
                                "resource_kind" => Ok(__FieldTag::__resource_kind),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GroupKind;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GroupKind")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__resource_group => {
                                if !fields.insert(__FieldTag::__resource_group) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for resource_group",
                                    ));
                                }
                                result.resource_group = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__resource_kind => {
                                if !fields.insert(__FieldTag::__resource_kind) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for resource_kind",
                                    ));
                                }
                                result.resource_kind = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GroupKind {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.resource_group.is_empty() {
                state.serialize_entry("resourceGroup", &self.resource_group)?;
            }
            if !self.resource_kind.is_empty() {
                state.serialize_entry("resourceKind", &self.resource_kind)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines the scope of cluster-scoped resources to restore.
    ///
    /// Some group kinds are not reasonable choices for a restore, and will cause
    /// an error if selected here. Any scope selection that would restore
    /// "all valid" resources automatically excludes these group kinds.
    ///
    /// - Node
    /// - ComponentStatus
    /// - gkebackup.gke.io/BackupJob
    /// - gkebackup.gke.io/RestoreJob
    /// - metrics.k8s.io/NodeMetrics
    /// - migration.k8s.io/StorageState
    /// - migration.k8s.io/StorageVersionMigration
    /// - snapshot.storage.k8s.io/VolumeSnapshotContent
    /// - storage.k8s.io/CSINode
    /// - storage.k8s.io/VolumeAttachment
    ///
    /// Some group kinds are driven by restore configuration elsewhere,
    /// and will cause an error if selected here.
    ///
    /// - Namespace
    /// - PersistentVolume
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ClusterResourceRestoreScope {
        /// Optional. A list of cluster-scoped resource group kinds to restore from
        /// the backup. If specified, only the selected resources will be restored.
        /// Mutually exclusive to any other field in the message.
        pub selected_group_kinds: std::vec::Vec<crate::model::restore_config::GroupKind>,

        /// Optional. A list of cluster-scoped resource group kinds to NOT restore
        /// from the backup. If specified, all valid cluster-scoped resources will be
        /// restored except for those specified in the list.
        /// Mutually exclusive to any other field in the message.
        pub excluded_group_kinds: std::vec::Vec<crate::model::restore_config::GroupKind>,

        /// Optional. If True, all valid cluster-scoped resources will be restored.
        /// Mutually exclusive to any other field in the message.
        pub all_group_kinds: bool,

        /// Optional. If True, no cluster-scoped resources will be restored.
        /// This has the same restore scope as if the message is not defined.
        /// Mutually exclusive to any other field in the message.
        pub no_group_kinds: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ClusterResourceRestoreScope {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [selected_group_kinds][crate::model::restore_config::ClusterResourceRestoreScope::selected_group_kinds].
        pub fn set_selected_group_kinds<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::restore_config::GroupKind>,
        {
            use std::iter::Iterator;
            self.selected_group_kinds = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [excluded_group_kinds][crate::model::restore_config::ClusterResourceRestoreScope::excluded_group_kinds].
        pub fn set_excluded_group_kinds<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::restore_config::GroupKind>,
        {
            use std::iter::Iterator;
            self.excluded_group_kinds = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [all_group_kinds][crate::model::restore_config::ClusterResourceRestoreScope::all_group_kinds].
        pub fn set_all_group_kinds<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.all_group_kinds = v.into();
            self
        }

        /// Sets the value of [no_group_kinds][crate::model::restore_config::ClusterResourceRestoreScope::no_group_kinds].
        pub fn set_no_group_kinds<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.no_group_kinds = v.into();
            self
        }
    }

    impl wkt::message::Message for ClusterResourceRestoreScope {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.gkebackup.v1.RestoreConfig.ClusterResourceRestoreScope"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ClusterResourceRestoreScope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __selected_group_kinds,
                __excluded_group_kinds,
                __all_group_kinds,
                __no_group_kinds,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ClusterResourceRestoreScope")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "selectedGroupKinds" => Ok(__FieldTag::__selected_group_kinds),
                                "selected_group_kinds" => Ok(__FieldTag::__selected_group_kinds),
                                "excludedGroupKinds" => Ok(__FieldTag::__excluded_group_kinds),
                                "excluded_group_kinds" => Ok(__FieldTag::__excluded_group_kinds),
                                "allGroupKinds" => Ok(__FieldTag::__all_group_kinds),
                                "all_group_kinds" => Ok(__FieldTag::__all_group_kinds),
                                "noGroupKinds" => Ok(__FieldTag::__no_group_kinds),
                                "no_group_kinds" => Ok(__FieldTag::__no_group_kinds),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ClusterResourceRestoreScope;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ClusterResourceRestoreScope")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__selected_group_kinds => {
                                if !fields.insert(__FieldTag::__selected_group_kinds) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for selected_group_kinds",
                                    ));
                                }
                                result.selected_group_kinds = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::restore_config::GroupKind>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__excluded_group_kinds => {
                                if !fields.insert(__FieldTag::__excluded_group_kinds) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for excluded_group_kinds",
                                    ));
                                }
                                result.excluded_group_kinds = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::restore_config::GroupKind>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__all_group_kinds => {
                                if !fields.insert(__FieldTag::__all_group_kinds) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for all_group_kinds",
                                    ));
                                }
                                result.all_group_kinds = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__no_group_kinds => {
                                if !fields.insert(__FieldTag::__no_group_kinds) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for no_group_kinds",
                                    ));
                                }
                                result.no_group_kinds = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ClusterResourceRestoreScope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.selected_group_kinds.is_empty() {
                state.serialize_entry("selectedGroupKinds", &self.selected_group_kinds)?;
            }
            if !self.excluded_group_kinds.is_empty() {
                state.serialize_entry("excludedGroupKinds", &self.excluded_group_kinds)?;
            }
            if !wkt::internal::is_default(&self.all_group_kinds) {
                state.serialize_entry("allGroupKinds", &self.all_group_kinds)?;
            }
            if !wkt::internal::is_default(&self.no_group_kinds) {
                state.serialize_entry("noGroupKinds", &self.no_group_kinds)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A transformation rule to be applied against Kubernetes resources as they
    /// are selected for restoration from a Backup. A rule contains both filtering
    /// logic (which resources are subject to substitution) and substitution logic.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SubstitutionRule {
        /// Optional. (Filtering parameter) Any resource subject to substitution must
        /// be contained within one of the listed Kubernetes Namespace in the Backup.
        /// If this field is not provided, no namespace filtering will be performed
        /// (all resources in all Namespaces, including all cluster-scoped resources,
        /// will be candidates for substitution).
        /// To mix cluster-scoped and namespaced resources in the same rule, use an
        /// empty string ("") as one of the target namespaces.
        pub target_namespaces: std::vec::Vec<std::string::String>,

        /// Optional. (Filtering parameter) Any resource subject to substitution must
        /// belong to one of the listed "types". If this field is not provided, no
        /// type filtering will be performed (all resources of all types matching
        /// previous filtering parameters will be candidates for substitution).
        pub target_group_kinds: std::vec::Vec<crate::model::restore_config::GroupKind>,

        /// Required. This is a [JSONPath]
        /// (<https://kubernetes.io/docs/reference/kubectl/jsonpath/>)
        /// expression that matches specific fields of candidate
        /// resources and it operates as both a filtering parameter (resources that
        /// are not matched with this expression will not be candidates for
        /// substitution) as well as a field identifier (identifies exactly which
        /// fields out of the candidate resources will be modified).
        pub target_json_path: std::string::String,

        /// Optional. (Filtering parameter) This is a [regular expression]
        /// (<https://en.wikipedia.org/wiki/Regular_expression>)
        /// that is compared against the fields matched by the target_json_path
        /// expression (and must also have passed the previous filters).
        /// Substitution will not be performed against fields whose
        /// value does not match this expression. If this field is NOT specified,
        /// then ALL fields matched by the target_json_path expression will undergo
        /// substitution. Note that an empty (e.g., "", rather than unspecified)
        /// value for this field will only match empty fields.
        pub original_value_pattern: std::string::String,

        /// Optional. This is the new value to set for any fields that pass the
        /// filtering and selection criteria. To remove a value from a Kubernetes
        /// resource, either leave this field unspecified, or set it to the empty
        /// string ("").
        pub new_value: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SubstitutionRule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [target_namespaces][crate::model::restore_config::SubstitutionRule::target_namespaces].
        pub fn set_target_namespaces<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.target_namespaces = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [target_group_kinds][crate::model::restore_config::SubstitutionRule::target_group_kinds].
        pub fn set_target_group_kinds<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::restore_config::GroupKind>,
        {
            use std::iter::Iterator;
            self.target_group_kinds = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [target_json_path][crate::model::restore_config::SubstitutionRule::target_json_path].
        pub fn set_target_json_path<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.target_json_path = v.into();
            self
        }

        /// Sets the value of [original_value_pattern][crate::model::restore_config::SubstitutionRule::original_value_pattern].
        pub fn set_original_value_pattern<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.original_value_pattern = v.into();
            self
        }

        /// Sets the value of [new_value][crate::model::restore_config::SubstitutionRule::new_value].
        pub fn set_new_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.new_value = v.into();
            self
        }
    }

    impl wkt::message::Message for SubstitutionRule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.gkebackup.v1.RestoreConfig.SubstitutionRule"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SubstitutionRule {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __target_namespaces,
                __target_group_kinds,
                __target_json_path,
                __original_value_pattern,
                __new_value,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SubstitutionRule")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "targetNamespaces" => Ok(__FieldTag::__target_namespaces),
                                "target_namespaces" => Ok(__FieldTag::__target_namespaces),
                                "targetGroupKinds" => Ok(__FieldTag::__target_group_kinds),
                                "target_group_kinds" => Ok(__FieldTag::__target_group_kinds),
                                "targetJsonPath" => Ok(__FieldTag::__target_json_path),
                                "target_json_path" => Ok(__FieldTag::__target_json_path),
                                "originalValuePattern" => Ok(__FieldTag::__original_value_pattern),
                                "original_value_pattern" => {
                                    Ok(__FieldTag::__original_value_pattern)
                                }
                                "newValue" => Ok(__FieldTag::__new_value),
                                "new_value" => Ok(__FieldTag::__new_value),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SubstitutionRule;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SubstitutionRule")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__target_namespaces => {
                                if !fields.insert(__FieldTag::__target_namespaces) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for target_namespaces",
                                    ));
                                }
                                result.target_namespaces = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__target_group_kinds => {
                                if !fields.insert(__FieldTag::__target_group_kinds) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for target_group_kinds",
                                    ));
                                }
                                result.target_group_kinds = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::restore_config::GroupKind>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__target_json_path => {
                                if !fields.insert(__FieldTag::__target_json_path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for target_json_path",
                                    ));
                                }
                                result.target_json_path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__original_value_pattern => {
                                if !fields.insert(__FieldTag::__original_value_pattern) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for original_value_pattern",
                                    ));
                                }
                                result.original_value_pattern = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__new_value => {
                                if !fields.insert(__FieldTag::__new_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for new_value",
                                    ));
                                }
                                result.new_value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SubstitutionRule {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.target_namespaces.is_empty() {
                state.serialize_entry("targetNamespaces", &self.target_namespaces)?;
            }
            if !self.target_group_kinds.is_empty() {
                state.serialize_entry("targetGroupKinds", &self.target_group_kinds)?;
            }
            if !self.target_json_path.is_empty() {
                state.serialize_entry("targetJsonPath", &self.target_json_path)?;
            }
            if !self.original_value_pattern.is_empty() {
                state.serialize_entry("originalValuePattern", &self.original_value_pattern)?;
            }
            if !self.new_value.is_empty() {
                state.serialize_entry("newValue", &self.new_value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// TransformationRuleAction defines a TransformationRule action based on the
    /// JSON Patch RFC (<https://www.rfc-editor.org/rfc/rfc6902>)
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TransformationRuleAction {
        /// Required. op specifies the operation to perform.
        pub op: crate::model::restore_config::transformation_rule_action::Op,

        /// Optional. A string containing a JSON Pointer value that references the
        /// location in the target document to move the value from.
        pub from_path: std::string::String,

        /// Optional. A string containing a JSON-Pointer value that references a
        /// location within the target document where the operation is performed.
        pub path: std::string::String,

        /// Optional. A string that specifies the desired value in string format to
        /// use for transformation.
        pub value: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TransformationRuleAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [op][crate::model::restore_config::TransformationRuleAction::op].
        pub fn set_op<
            T: std::convert::Into<crate::model::restore_config::transformation_rule_action::Op>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.op = v.into();
            self
        }

        /// Sets the value of [from_path][crate::model::restore_config::TransformationRuleAction::from_path].
        pub fn set_from_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.from_path = v.into();
            self
        }

        /// Sets the value of [path][crate::model::restore_config::TransformationRuleAction::path].
        pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.path = v.into();
            self
        }

        /// Sets the value of [value][crate::model::restore_config::TransformationRuleAction::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for TransformationRuleAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.gkebackup.v1.RestoreConfig.TransformationRuleAction"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TransformationRuleAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __op,
                __from_path,
                __path,
                __value,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TransformationRuleAction")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "op" => Ok(__FieldTag::__op),
                                "fromPath" => Ok(__FieldTag::__from_path),
                                "from_path" => Ok(__FieldTag::__from_path),
                                "path" => Ok(__FieldTag::__path),
                                "value" => Ok(__FieldTag::__value),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TransformationRuleAction;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TransformationRuleAction")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__op => {
                                if !fields.insert(__FieldTag::__op) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for op",
                                    ));
                                }
                                result.op = map.next_value::<std::option::Option<crate::model::restore_config::transformation_rule_action::Op>>()?.unwrap_or_default();
                            }
                            __FieldTag::__from_path => {
                                if !fields.insert(__FieldTag::__from_path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for from_path",
                                    ));
                                }
                                result.from_path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__path => {
                                if !fields.insert(__FieldTag::__path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for path",
                                    ));
                                }
                                result.path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__value => {
                                if !fields.insert(__FieldTag::__value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for value",
                                    ));
                                }
                                result.value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TransformationRuleAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.op) {
                state.serialize_entry("op", &self.op)?;
            }
            if !self.from_path.is_empty() {
                state.serialize_entry("fromPath", &self.from_path)?;
            }
            if !self.path.is_empty() {
                state.serialize_entry("path", &self.path)?;
            }
            if !self.value.is_empty() {
                state.serialize_entry("value", &self.value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [TransformationRuleAction].
    pub mod transformation_rule_action {
        #[allow(unused_imports)]
        use super::*;

        /// Possible values for operations of a transformation rule action.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Op {
            /// Unspecified operation
            Unspecified,
            /// The "remove" operation removes the value at the target location.
            Remove,
            /// The "move" operation removes the value at a specified location and
            /// adds it to the target location.
            Move,
            /// The "copy" operation copies the value at a specified location to the
            /// target location.
            Copy,
            /// The "add" operation performs one of the following functions,
            /// depending upon what the target location references:
            ///
            /// 1. If the target location specifies an array index, a new value is
            ///    inserted into the array at the specified index.
            /// 1. If the target location specifies an object member that does not
            ///    already exist, a new member is added to the object.
            /// 1. If the target location specifies an object member that does exist,
            ///    that member's value is replaced.
            Add,
            /// The "test" operation tests that a value at the target location is
            /// equal to a specified value.
            Test,
            /// The "replace" operation replaces the value at the target location
            /// with a new value.  The operation object MUST contain a "value" member
            /// whose content specifies the replacement value.
            Replace,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Op::value] or
            /// [Op::name].
            UnknownValue(op::UnknownValue),
        }

        #[doc(hidden)]
        pub mod op {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Op {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Remove => std::option::Option::Some(1),
                    Self::Move => std::option::Option::Some(2),
                    Self::Copy => std::option::Option::Some(3),
                    Self::Add => std::option::Option::Some(4),
                    Self::Test => std::option::Option::Some(5),
                    Self::Replace => std::option::Option::Some(6),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("OP_UNSPECIFIED"),
                    Self::Remove => std::option::Option::Some("REMOVE"),
                    Self::Move => std::option::Option::Some("MOVE"),
                    Self::Copy => std::option::Option::Some("COPY"),
                    Self::Add => std::option::Option::Some("ADD"),
                    Self::Test => std::option::Option::Some("TEST"),
                    Self::Replace => std::option::Option::Some("REPLACE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Op {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Op {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Op {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Remove,
                    2 => Self::Move,
                    3 => Self::Copy,
                    4 => Self::Add,
                    5 => Self::Test,
                    6 => Self::Replace,
                    _ => Self::UnknownValue(op::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Op {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "OP_UNSPECIFIED" => Self::Unspecified,
                    "REMOVE" => Self::Remove,
                    "MOVE" => Self::Move,
                    "COPY" => Self::Copy,
                    "ADD" => Self::Add,
                    "TEST" => Self::Test,
                    "REPLACE" => Self::Replace,
                    _ => Self::UnknownValue(op::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Op {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Remove => serializer.serialize_i32(1),
                    Self::Move => serializer.serialize_i32(2),
                    Self::Copy => serializer.serialize_i32(3),
                    Self::Add => serializer.serialize_i32(4),
                    Self::Test => serializer.serialize_i32(5),
                    Self::Replace => serializer.serialize_i32(6),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Op {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Op>::new(
                    ".google.cloud.gkebackup.v1.RestoreConfig.TransformationRuleAction.Op",
                ))
            }
        }
    }

    /// ResourceFilter specifies matching criteria to limit the scope of a
    /// change to a specific set of kubernetes resources that are selected for
    /// restoration from a backup.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ResourceFilter {
        /// Optional. (Filtering parameter) Any resource subject to transformation
        /// must be contained within one of the listed Kubernetes Namespace in the
        /// Backup. If this field is not provided, no namespace filtering will be
        /// performed (all resources in all Namespaces, including all cluster-scoped
        /// resources, will be candidates for transformation).
        pub namespaces: std::vec::Vec<std::string::String>,

        /// Optional. (Filtering parameter) Any resource subject to transformation
        /// must belong to one of the listed "types". If this field is not provided,
        /// no type filtering will be performed (all resources of all types matching
        /// previous filtering parameters will be candidates for transformation).
        pub group_kinds: std::vec::Vec<crate::model::restore_config::GroupKind>,

        /// Optional. This is a [JSONPath]
        /// (<https://github.com/json-path/JsonPath/blob/master/README.md>)
        /// expression that matches specific fields of candidate
        /// resources and it operates as a filtering parameter (resources that
        /// are not matched with this expression will not be candidates for
        /// transformation).
        pub json_path: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ResourceFilter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [namespaces][crate::model::restore_config::ResourceFilter::namespaces].
        pub fn set_namespaces<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.namespaces = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [group_kinds][crate::model::restore_config::ResourceFilter::group_kinds].
        pub fn set_group_kinds<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::restore_config::GroupKind>,
        {
            use std::iter::Iterator;
            self.group_kinds = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [json_path][crate::model::restore_config::ResourceFilter::json_path].
        pub fn set_json_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.json_path = v.into();
            self
        }
    }

    impl wkt::message::Message for ResourceFilter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.gkebackup.v1.RestoreConfig.ResourceFilter"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ResourceFilter {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __namespaces,
                __group_kinds,
                __json_path,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ResourceFilter")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "namespaces" => Ok(__FieldTag::__namespaces),
                                "groupKinds" => Ok(__FieldTag::__group_kinds),
                                "group_kinds" => Ok(__FieldTag::__group_kinds),
                                "jsonPath" => Ok(__FieldTag::__json_path),
                                "json_path" => Ok(__FieldTag::__json_path),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ResourceFilter;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ResourceFilter")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__namespaces => {
                                if !fields.insert(__FieldTag::__namespaces) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for namespaces",
                                    ));
                                }
                                result.namespaces = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__group_kinds => {
                                if !fields.insert(__FieldTag::__group_kinds) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for group_kinds",
                                    ));
                                }
                                result.group_kinds = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::restore_config::GroupKind>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__json_path => {
                                if !fields.insert(__FieldTag::__json_path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for json_path",
                                    ));
                                }
                                result.json_path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ResourceFilter {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.namespaces.is_empty() {
                state.serialize_entry("namespaces", &self.namespaces)?;
            }
            if !self.group_kinds.is_empty() {
                state.serialize_entry("groupKinds", &self.group_kinds)?;
            }
            if !self.json_path.is_empty() {
                state.serialize_entry("jsonPath", &self.json_path)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A transformation rule to be applied against Kubernetes resources as they
    /// are selected for restoration from a Backup. A rule contains both filtering
    /// logic (which resources are subject to transform) and transformation logic.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TransformationRule {
        /// Required. A list of transformation rule actions to take against candidate
        /// resources. Actions are executed in order defined - this order matters, as
        /// they could potentially interfere with each other and the first operation
        /// could affect the outcome of the second operation.
        pub field_actions: std::vec::Vec<crate::model::restore_config::TransformationRuleAction>,

        /// Optional. This field is used to specify a set of fields that should be
        /// used to determine which resources in backup should be acted upon by the
        /// supplied transformation rule actions, and this will ensure that only
        /// specific resources are affected by transformation rule actions.
        pub resource_filter: std::option::Option<crate::model::restore_config::ResourceFilter>,

        /// Optional. The description is a user specified string description of the
        /// transformation rule.
        pub description: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TransformationRule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [field_actions][crate::model::restore_config::TransformationRule::field_actions].
        pub fn set_field_actions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::restore_config::TransformationRuleAction>,
        {
            use std::iter::Iterator;
            self.field_actions = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [resource_filter][crate::model::restore_config::TransformationRule::resource_filter].
        pub fn set_resource_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::restore_config::ResourceFilter>,
        {
            self.resource_filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [resource_filter][crate::model::restore_config::TransformationRule::resource_filter].
        pub fn set_or_clear_resource_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::restore_config::ResourceFilter>,
        {
            self.resource_filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [description][crate::model::restore_config::TransformationRule::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }
    }

    impl wkt::message::Message for TransformationRule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.gkebackup.v1.RestoreConfig.TransformationRule"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TransformationRule {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __field_actions,
                __resource_filter,
                __description,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TransformationRule")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "fieldActions" => Ok(__FieldTag::__field_actions),
                                "field_actions" => Ok(__FieldTag::__field_actions),
                                "resourceFilter" => Ok(__FieldTag::__resource_filter),
                                "resource_filter" => Ok(__FieldTag::__resource_filter),
                                "description" => Ok(__FieldTag::__description),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TransformationRule;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TransformationRule")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__field_actions => {
                                if !fields.insert(__FieldTag::__field_actions) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for field_actions",
                                    ));
                                }
                                result.field_actions = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::restore_config::TransformationRuleAction,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__resource_filter => {
                                if !fields.insert(__FieldTag::__resource_filter) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for resource_filter",
                                    ));
                                }
                                result.resource_filter = map.next_value::<std::option::Option<
                                    crate::model::restore_config::ResourceFilter,
                                >>()?;
                            }
                            __FieldTag::__description => {
                                if !fields.insert(__FieldTag::__description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for description",
                                    ));
                                }
                                result.description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TransformationRule {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.field_actions.is_empty() {
                state.serialize_entry("fieldActions", &self.field_actions)?;
            }
            if self.resource_filter.is_some() {
                state.serialize_entry("resourceFilter", &self.resource_filter)?;
            }
            if !self.description.is_empty() {
                state.serialize_entry("description", &self.description)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Binds resources in the scope to the given VolumeDataRestorePolicy.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct VolumeDataRestorePolicyBinding {
        /// Required. The VolumeDataRestorePolicy to apply when restoring volumes in
        /// scope.
        pub policy: crate::model::restore_config::VolumeDataRestorePolicy,

        pub scope: std::option::Option<
            crate::model::restore_config::volume_data_restore_policy_binding::Scope,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl VolumeDataRestorePolicyBinding {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [policy][crate::model::restore_config::VolumeDataRestorePolicyBinding::policy].
        pub fn set_policy<
            T: std::convert::Into<crate::model::restore_config::VolumeDataRestorePolicy>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.policy = v.into();
            self
        }

        /// Sets the value of [scope][crate::model::restore_config::VolumeDataRestorePolicyBinding::scope].
        ///
        /// Note that all the setters affecting `scope` are mutually
        /// exclusive.
        pub fn set_scope<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::restore_config::volume_data_restore_policy_binding::Scope,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.scope = v.into();
            self
        }

        /// The value of [scope][crate::model::restore_config::VolumeDataRestorePolicyBinding::scope]
        /// if it holds a `VolumeType`, `None` if the field is not set or
        /// holds a different branch.
        pub fn volume_type(
            &self,
        ) -> std::option::Option<&crate::model::volume_type_enum::VolumeType> {
            #[allow(unreachable_patterns)]
            self.scope.as_ref().and_then(|v| match v {
                crate::model::restore_config::volume_data_restore_policy_binding::Scope::VolumeType(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [scope][crate::model::restore_config::VolumeDataRestorePolicyBinding::scope]
        /// to hold a `VolumeType`.
        ///
        /// Note that all the setters affecting `scope` are
        /// mutually exclusive.
        pub fn set_volume_type<
            T: std::convert::Into<crate::model::volume_type_enum::VolumeType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.scope = std::option::Option::Some(
                crate::model::restore_config::volume_data_restore_policy_binding::Scope::VolumeType(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for VolumeDataRestorePolicyBinding {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.gkebackup.v1.RestoreConfig.VolumeDataRestorePolicyBinding"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for VolumeDataRestorePolicyBinding {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __policy,
                __volume_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for VolumeDataRestorePolicyBinding")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "policy" => Ok(__FieldTag::__policy),
                                "volumeType" => Ok(__FieldTag::__volume_type),
                                "volume_type" => Ok(__FieldTag::__volume_type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = VolumeDataRestorePolicyBinding;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct VolumeDataRestorePolicyBinding")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__policy => {
                                if !fields.insert(__FieldTag::__policy) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for policy",
                                    ));
                                }
                                result.policy = map
                                    .next_value::<std::option::Option<
                                        crate::model::restore_config::VolumeDataRestorePolicy,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__volume_type => {
                                if !fields.insert(__FieldTag::__volume_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for volume_type",
                                    ));
                                }
                                if result.scope.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `scope`, a oneof with full ID .google.cloud.gkebackup.v1.RestoreConfig.VolumeDataRestorePolicyBinding.volume_type, latest field was volumeType",
                                    ));
                                }
                                result.scope = std::option::Option::Some(
                                    crate::model::restore_config::volume_data_restore_policy_binding::Scope::VolumeType(
                                        map.next_value::<std::option::Option<crate::model::volume_type_enum::VolumeType>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for VolumeDataRestorePolicyBinding {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.policy) {
                state.serialize_entry("policy", &self.policy)?;
            }
            if let Some(value) = self.volume_type() {
                state.serialize_entry("volumeType", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [VolumeDataRestorePolicyBinding].
    pub mod volume_data_restore_policy_binding {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Scope {
            /// The volume type, as determined by the PVC's bound PV,
            /// to apply the policy to.
            VolumeType(crate::model::volume_type_enum::VolumeType),
        }
    }

    /// Allows customers to specify dependencies between resources
    /// that Backup for GKE can use to compute a resasonable restore order.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RestoreOrder {
        /// Optional. Contains a list of group kind dependency pairs provided
        /// by the customer, that is used by Backup for GKE to
        /// generate a group kind restore order.
        pub group_kind_dependencies:
            std::vec::Vec<crate::model::restore_config::restore_order::GroupKindDependency>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RestoreOrder {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [group_kind_dependencies][crate::model::restore_config::RestoreOrder::group_kind_dependencies].
        pub fn set_group_kind_dependencies<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::restore_config::restore_order::GroupKindDependency>,
        {
            use std::iter::Iterator;
            self.group_kind_dependencies = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for RestoreOrder {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.gkebackup.v1.RestoreConfig.RestoreOrder"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RestoreOrder {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __group_kind_dependencies,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RestoreOrder")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "groupKindDependencies" => {
                                    Ok(__FieldTag::__group_kind_dependencies)
                                }
                                "group_kind_dependencies" => {
                                    Ok(__FieldTag::__group_kind_dependencies)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RestoreOrder;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RestoreOrder")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__group_kind_dependencies => {
                                if !fields.insert(__FieldTag::__group_kind_dependencies) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for group_kind_dependencies",
                                    ));
                                }
                                result.group_kind_dependencies = map.next_value::<std::option::Option<std::vec::Vec<crate::model::restore_config::restore_order::GroupKindDependency>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RestoreOrder {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.group_kind_dependencies.is_empty() {
                state.serialize_entry("groupKindDependencies", &self.group_kind_dependencies)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [RestoreOrder].
    pub mod restore_order {
        #[allow(unused_imports)]
        use super::*;

        /// Defines a dependency between two group kinds.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct GroupKindDependency {
            /// Required. The satisfying group kind must be restored first
            /// in order to satisfy the dependency.
            pub satisfying: std::option::Option<crate::model::restore_config::GroupKind>,

            /// Required. The requiring group kind requires that the other
            /// group kind be restored first.
            pub requiring: std::option::Option<crate::model::restore_config::GroupKind>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl GroupKindDependency {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [satisfying][crate::model::restore_config::restore_order::GroupKindDependency::satisfying].
            pub fn set_satisfying<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::restore_config::GroupKind>,
            {
                self.satisfying = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [satisfying][crate::model::restore_config::restore_order::GroupKindDependency::satisfying].
            pub fn set_or_clear_satisfying<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::restore_config::GroupKind>,
            {
                self.satisfying = v.map(|x| x.into());
                self
            }

            /// Sets the value of [requiring][crate::model::restore_config::restore_order::GroupKindDependency::requiring].
            pub fn set_requiring<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::restore_config::GroupKind>,
            {
                self.requiring = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [requiring][crate::model::restore_config::restore_order::GroupKindDependency::requiring].
            pub fn set_or_clear_requiring<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::restore_config::GroupKind>,
            {
                self.requiring = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for GroupKindDependency {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.gkebackup.v1.RestoreConfig.RestoreOrder.GroupKindDependency"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for GroupKindDependency {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __satisfying,
                    __requiring,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for GroupKindDependency")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "satisfying" => Ok(__FieldTag::__satisfying),
                                    "requiring" => Ok(__FieldTag::__requiring),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = GroupKindDependency;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct GroupKindDependency")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__satisfying => {
                                    if !fields.insert(__FieldTag::__satisfying) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for satisfying",
                                            ),
                                        );
                                    }
                                    result.satisfying = map
                                        .next_value::<std::option::Option<
                                            crate::model::restore_config::GroupKind,
                                        >>()?;
                                }
                                __FieldTag::__requiring => {
                                    if !fields.insert(__FieldTag::__requiring) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for requiring",
                                            ),
                                        );
                                    }
                                    result.requiring = map
                                        .next_value::<std::option::Option<
                                            crate::model::restore_config::GroupKind,
                                        >>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for GroupKindDependency {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.satisfying.is_some() {
                    state.serialize_entry("satisfying", &self.satisfying)?;
                }
                if self.requiring.is_some() {
                    state.serialize_entry("requiring", &self.requiring)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// Defines how volume data should be restored.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VolumeDataRestorePolicy {
        /// Unspecified (illegal).
        Unspecified,
        /// For each PVC to be restored, create a new underlying volume and PV
        /// from the corresponding VolumeBackup contained within the Backup.
        RestoreVolumeDataFromBackup,
        /// For each PVC to be restored, attempt to reuse the original PV contained
        /// in the Backup (with its original underlying volume). This option
        /// is likely only usable when restoring a workload to its original cluster.
        ReuseVolumeHandleFromBackup,
        /// For each PVC to be restored, create PVC without any particular
        /// action to restore data. In this case, the normal Kubernetes provisioning
        /// logic would kick in, and this would likely result in either dynamically
        /// provisioning blank PVs or binding to statically provisioned PVs.
        NoVolumeDataRestoration,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VolumeDataRestorePolicy::value] or
        /// [VolumeDataRestorePolicy::name].
        UnknownValue(volume_data_restore_policy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod volume_data_restore_policy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VolumeDataRestorePolicy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::RestoreVolumeDataFromBackup => std::option::Option::Some(1),
                Self::ReuseVolumeHandleFromBackup => std::option::Option::Some(2),
                Self::NoVolumeDataRestoration => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED")
                }
                Self::RestoreVolumeDataFromBackup => {
                    std::option::Option::Some("RESTORE_VOLUME_DATA_FROM_BACKUP")
                }
                Self::ReuseVolumeHandleFromBackup => {
                    std::option::Option::Some("REUSE_VOLUME_HANDLE_FROM_BACKUP")
                }
                Self::NoVolumeDataRestoration => {
                    std::option::Option::Some("NO_VOLUME_DATA_RESTORATION")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VolumeDataRestorePolicy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VolumeDataRestorePolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VolumeDataRestorePolicy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::RestoreVolumeDataFromBackup,
                2 => Self::ReuseVolumeHandleFromBackup,
                3 => Self::NoVolumeDataRestoration,
                _ => Self::UnknownValue(volume_data_restore_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VolumeDataRestorePolicy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED" => Self::Unspecified,
                "RESTORE_VOLUME_DATA_FROM_BACKUP" => Self::RestoreVolumeDataFromBackup,
                "REUSE_VOLUME_HANDLE_FROM_BACKUP" => Self::ReuseVolumeHandleFromBackup,
                "NO_VOLUME_DATA_RESTORATION" => Self::NoVolumeDataRestoration,
                _ => Self::UnknownValue(volume_data_restore_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VolumeDataRestorePolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::RestoreVolumeDataFromBackup => serializer.serialize_i32(1),
                Self::ReuseVolumeHandleFromBackup => serializer.serialize_i32(2),
                Self::NoVolumeDataRestoration => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VolumeDataRestorePolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<VolumeDataRestorePolicy>::new(
                    ".google.cloud.gkebackup.v1.RestoreConfig.VolumeDataRestorePolicy",
                ),
            )
        }
    }

    /// Defines the behavior for handling the situation where cluster-scoped
    /// resources being restored already exist in the target cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ClusterResourceConflictPolicy {
        /// Unspecified. Only allowed if no cluster-scoped resources will be
        /// restored.
        Unspecified,
        /// Do not attempt to restore the conflicting resource.
        UseExistingVersion,
        /// Delete the existing version before re-creating it from the Backup.
        /// This is a dangerous option which could cause unintentional
        /// data loss if used inappropriately. For example, deleting a CRD will
        /// cause Kubernetes to delete all CRs of that type.
        UseBackupVersion,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ClusterResourceConflictPolicy::value] or
        /// [ClusterResourceConflictPolicy::name].
        UnknownValue(cluster_resource_conflict_policy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod cluster_resource_conflict_policy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ClusterResourceConflictPolicy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::UseExistingVersion => std::option::Option::Some(1),
                Self::UseBackupVersion => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED")
                }
                Self::UseExistingVersion => std::option::Option::Some("USE_EXISTING_VERSION"),
                Self::UseBackupVersion => std::option::Option::Some("USE_BACKUP_VERSION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ClusterResourceConflictPolicy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ClusterResourceConflictPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ClusterResourceConflictPolicy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::UseExistingVersion,
                2 => Self::UseBackupVersion,
                _ => Self::UnknownValue(cluster_resource_conflict_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ClusterResourceConflictPolicy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED" => Self::Unspecified,
                "USE_EXISTING_VERSION" => Self::UseExistingVersion,
                "USE_BACKUP_VERSION" => Self::UseBackupVersion,
                _ => Self::UnknownValue(cluster_resource_conflict_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ClusterResourceConflictPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::UseExistingVersion => serializer.serialize_i32(1),
                Self::UseBackupVersion => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ClusterResourceConflictPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<ClusterResourceConflictPolicy>::new(
                    ".google.cloud.gkebackup.v1.RestoreConfig.ClusterResourceConflictPolicy",
                ),
            )
        }
    }

    /// Defines the behavior for handling the situation where sets of namespaced
    /// resources being restored already exist in the target cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NamespacedResourceRestoreMode {
        /// Unspecified (invalid).
        Unspecified,
        /// When conflicting top-level resources (either Namespaces or
        /// ProtectedApplications, depending upon the scope) are encountered, this
        /// will first trigger a delete of the conflicting resource AND ALL OF ITS
        /// REFERENCED RESOURCES (e.g., all resources in the Namespace or all
        /// resources referenced by the ProtectedApplication) before restoring the
        /// resources from the Backup. This mode should only be used when you are
        /// intending to revert some portion of a cluster to an earlier state.
        DeleteAndRestore,
        /// If conflicting top-level resources (either Namespaces or
        /// ProtectedApplications, depending upon the scope) are encountered at the
        /// beginning of a restore process, the Restore will fail.  If a conflict
        /// occurs during the restore process itself (e.g., because an out of band
        /// process creates conflicting resources), a conflict will be reported.
        FailOnConflict,
        /// This mode merges the backup and the target cluster and skips the
        /// conflicting resources. If a single resource to restore exists in the
        /// cluster before restoration, the resource will be skipped, otherwise it
        /// will be restored.
        MergeSkipOnConflict,
        /// This mode merges the backup and the target cluster and skips the
        /// conflicting resources except volume data. If a PVC to restore already
        /// exists, this mode will restore/reconnect the volume without overwriting
        /// the PVC. It is similar to MERGE_SKIP_ON_CONFLICT except that it will
        /// apply the volume data policy for the conflicting PVCs:
        ///
        /// - RESTORE_VOLUME_DATA_FROM_BACKUP: restore data only and respect the
        ///   reclaim policy of the original PV;
        /// - REUSE_VOLUME_HANDLE_FROM_BACKUP: reconnect and respect the reclaim
        ///   policy of the original PV;
        /// - NO_VOLUME_DATA_RESTORATION: new provision and respect the reclaim
        ///   policy of the original PV.
        ///   Note that this mode could cause data loss as the original PV can be
        ///   retained or deleted depending on its reclaim policy.
        MergeReplaceVolumeOnConflict,
        /// This mode merges the backup and the target cluster and replaces the
        /// conflicting resources with the ones in the backup. If a single resource
        /// to restore exists in the cluster before restoration, the resource will be
        /// replaced with the one from the backup. To replace an existing resource,
        /// the first attempt is to update the resource to match the one from the
        /// backup; if the update fails, the second attempt is to delete the resource
        /// and restore it from the backup.
        /// Note that this mode could cause data loss as it replaces the existing
        /// resources in the target cluster, and the original PV can be retained or
        /// deleted depending on its reclaim policy.
        MergeReplaceOnConflict,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [NamespacedResourceRestoreMode::value] or
        /// [NamespacedResourceRestoreMode::name].
        UnknownValue(namespaced_resource_restore_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod namespaced_resource_restore_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl NamespacedResourceRestoreMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::DeleteAndRestore => std::option::Option::Some(1),
                Self::FailOnConflict => std::option::Option::Some(2),
                Self::MergeSkipOnConflict => std::option::Option::Some(3),
                Self::MergeReplaceVolumeOnConflict => std::option::Option::Some(4),
                Self::MergeReplaceOnConflict => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED")
                }
                Self::DeleteAndRestore => std::option::Option::Some("DELETE_AND_RESTORE"),
                Self::FailOnConflict => std::option::Option::Some("FAIL_ON_CONFLICT"),
                Self::MergeSkipOnConflict => std::option::Option::Some("MERGE_SKIP_ON_CONFLICT"),
                Self::MergeReplaceVolumeOnConflict => {
                    std::option::Option::Some("MERGE_REPLACE_VOLUME_ON_CONFLICT")
                }
                Self::MergeReplaceOnConflict => {
                    std::option::Option::Some("MERGE_REPLACE_ON_CONFLICT")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for NamespacedResourceRestoreMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for NamespacedResourceRestoreMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for NamespacedResourceRestoreMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::DeleteAndRestore,
                2 => Self::FailOnConflict,
                3 => Self::MergeSkipOnConflict,
                4 => Self::MergeReplaceVolumeOnConflict,
                5 => Self::MergeReplaceOnConflict,
                _ => Self::UnknownValue(namespaced_resource_restore_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for NamespacedResourceRestoreMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED" => Self::Unspecified,
                "DELETE_AND_RESTORE" => Self::DeleteAndRestore,
                "FAIL_ON_CONFLICT" => Self::FailOnConflict,
                "MERGE_SKIP_ON_CONFLICT" => Self::MergeSkipOnConflict,
                "MERGE_REPLACE_VOLUME_ON_CONFLICT" => Self::MergeReplaceVolumeOnConflict,
                "MERGE_REPLACE_ON_CONFLICT" => Self::MergeReplaceOnConflict,
                _ => Self::UnknownValue(namespaced_resource_restore_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for NamespacedResourceRestoreMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::DeleteAndRestore => serializer.serialize_i32(1),
                Self::FailOnConflict => serializer.serialize_i32(2),
                Self::MergeSkipOnConflict => serializer.serialize_i32(3),
                Self::MergeReplaceVolumeOnConflict => serializer.serialize_i32(4),
                Self::MergeReplaceOnConflict => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for NamespacedResourceRestoreMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<NamespacedResourceRestoreMode>::new(
                    ".google.cloud.gkebackup.v1.RestoreConfig.NamespacedResourceRestoreMode",
                ),
            )
        }
    }

    /// Specifies the namespaced resources to restore from the Backup.
    /// Only one of the entries may be specified. If not specified, NO namespaced
    /// resources will be restored.
    ///
    /// Note: Resources will never be restored into *managed* namespaces such as
    /// `kube-system`, `kube-public`, or `kube-node-lease`. These namespaces
    /// are silently skipped when
    /// [all_namespaces][google.cloud.gkebackup.v1.RestoreConfig.all_namespaces] is
    /// selected. Listing them explicitly will result in an error.
    ///
    /// [google.cloud.gkebackup.v1.RestoreConfig.all_namespaces]: crate::model::RestoreConfig::namespaced_resource_restore_scope
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NamespacedResourceRestoreScope {
        /// Restore all namespaced resources in the Backup if set to "True".
        /// Specifying this field to "False" is an error.
        AllNamespaces(bool),
        /// A list of selected Namespaces to restore from the Backup. The listed
        /// Namespaces and all resources contained in them will be restored.
        SelectedNamespaces(std::boxed::Box<crate::model::Namespaces>),
        /// A list of selected ProtectedApplications to restore. The listed
        /// ProtectedApplications and all the resources to which they refer will be
        /// restored.
        SelectedApplications(std::boxed::Box<crate::model::NamespacedNames>),
        /// Do not restore any namespaced resources if set to "True".
        /// Specifying this field to "False" is not allowed.
        NoNamespaces(bool),
        /// A list of selected namespaces excluded from restoration. All
        /// namespaces except those in this list will be restored.
        ExcludedNamespaces(std::boxed::Box<crate::model::Namespaces>),
    }
}

/// Defines a selector to identify a single or a group of resources.
/// Conditions in the selector are optional, but at least one field
/// should be set to a non-empty value. If a condition is not specified,
/// no restrictions will be applied on that dimension.
/// If more than one condition is specified, a resource will be selected
/// if and only if all conditions are met.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceSelector {
    /// Optional. Selects resources using their Kubernetes GroupKinds. If
    /// specified, only resources of provided GroupKind will be selected.
    pub group_kind: std::option::Option<crate::model::restore_config::GroupKind>,

    /// Optional. Selects resources using their resource names. If specified,
    /// only resources with the provided name will be selected.
    pub name: std::string::String,

    /// Optional. Selects resources using their namespaces. This only applies to
    /// namespace scoped resources and cannot be used for selecting
    /// cluster scoped resources. If specified, only resources in the provided
    /// namespace will be selected. If not specified, the filter will apply to
    /// both cluster scoped and namespace scoped resources (e.g. name or label).
    /// The [Namespace](https://pkg.go.dev/k8s.io/api/core/v1#Namespace) resource
    /// itself will be restored if and only if any resources within the namespace
    /// are restored.
    pub namespace: std::string::String,

    /// Optional. Selects resources using Kubernetes
    /// [labels](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/).
    /// If specified, a resource will be selected if and only if the resource
    /// has all of the provided labels and all the label values match.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceSelector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group_kind][crate::model::ResourceSelector::group_kind].
    pub fn set_group_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::restore_config::GroupKind>,
    {
        self.group_kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [group_kind][crate::model::ResourceSelector::group_kind].
    pub fn set_or_clear_group_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::restore_config::GroupKind>,
    {
        self.group_kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::ResourceSelector::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [namespace][crate::model::ResourceSelector::namespace].
    pub fn set_namespace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.namespace = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ResourceSelector::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ResourceSelector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.ResourceSelector"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResourceSelector {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __group_kind,
            __name,
            __namespace,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceSelector")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "groupKind" => Ok(__FieldTag::__group_kind),
                            "group_kind" => Ok(__FieldTag::__group_kind),
                            "name" => Ok(__FieldTag::__name),
                            "namespace" => Ok(__FieldTag::__namespace),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResourceSelector;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceSelector")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__group_kind => {
                            if !fields.insert(__FieldTag::__group_kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group_kind",
                                ));
                            }
                            result.group_kind = map.next_value::<std::option::Option<crate::model::restore_config::GroupKind>>()?
                                ;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__namespace => {
                            if !fields.insert(__FieldTag::__namespace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for namespace",
                                ));
                            }
                            result.namespace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResourceSelector {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.group_kind.is_some() {
            state.serialize_entry("groupKind", &self.group_kind)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.namespace.is_empty() {
            state.serialize_entry("namespace", &self.namespace)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines an override to apply a VolumeDataRestorePolicy for scoped resources.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VolumeDataRestorePolicyOverride {
    /// Required. The VolumeDataRestorePolicy to apply when restoring volumes in
    /// scope.
    pub policy: crate::model::restore_config::VolumeDataRestorePolicy,

    pub scope: std::option::Option<crate::model::volume_data_restore_policy_override::Scope>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VolumeDataRestorePolicyOverride {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy][crate::model::VolumeDataRestorePolicyOverride::policy].
    pub fn set_policy<
        T: std::convert::Into<crate::model::restore_config::VolumeDataRestorePolicy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.policy = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::VolumeDataRestorePolicyOverride::scope].
    ///
    /// Note that all the setters affecting `scope` are mutually
    /// exclusive.
    pub fn set_scope<
        T: std::convert::Into<
                std::option::Option<crate::model::volume_data_restore_policy_override::Scope>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scope = v.into();
        self
    }

    /// The value of [scope][crate::model::VolumeDataRestorePolicyOverride::scope]
    /// if it holds a `SelectedPvcs`, `None` if the field is not set or
    /// holds a different branch.
    pub fn selected_pvcs(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::NamespacedNames>> {
        #[allow(unreachable_patterns)]
        self.scope.as_ref().and_then(|v| match v {
            crate::model::volume_data_restore_policy_override::Scope::SelectedPvcs(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [scope][crate::model::VolumeDataRestorePolicyOverride::scope]
    /// to hold a `SelectedPvcs`.
    ///
    /// Note that all the setters affecting `scope` are
    /// mutually exclusive.
    pub fn set_selected_pvcs<
        T: std::convert::Into<std::boxed::Box<crate::model::NamespacedNames>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scope = std::option::Option::Some(
            crate::model::volume_data_restore_policy_override::Scope::SelectedPvcs(v.into()),
        );
        self
    }
}

impl wkt::message::Message for VolumeDataRestorePolicyOverride {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.VolumeDataRestorePolicyOverride"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VolumeDataRestorePolicyOverride {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __policy,
            __selected_pvcs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VolumeDataRestorePolicyOverride")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "policy" => Ok(__FieldTag::__policy),
                            "selectedPvcs" => Ok(__FieldTag::__selected_pvcs),
                            "selected_pvcs" => Ok(__FieldTag::__selected_pvcs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VolumeDataRestorePolicyOverride;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VolumeDataRestorePolicyOverride")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy",
                                ));
                            }
                            result.policy = map
                                .next_value::<std::option::Option<
                                    crate::model::restore_config::VolumeDataRestorePolicy,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__selected_pvcs => {
                            if !fields.insert(__FieldTag::__selected_pvcs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for selected_pvcs",
                                ));
                            }
                            if result.scope.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `scope`, a oneof with full ID .google.cloud.gkebackup.v1.VolumeDataRestorePolicyOverride.selected_pvcs, latest field was selectedPvcs",
                                ));
                            }
                            result.scope = std::option::Option::Some(
                                crate::model::volume_data_restore_policy_override::Scope::SelectedPvcs(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::NamespacedNames>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VolumeDataRestorePolicyOverride {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.policy) {
            state.serialize_entry("policy", &self.policy)?;
        }
        if let Some(value) = self.selected_pvcs() {
            state.serialize_entry("selectedPvcs", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VolumeDataRestorePolicyOverride].
pub mod volume_data_restore_policy_override {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scope {
        /// A list of PVCs to apply the policy override to.
        SelectedPvcs(std::boxed::Box<crate::model::NamespacedNames>),
    }
}

/// A RestoreChannel imposes constraints on where backups can be restored.
/// The RestoreChannel should be in the same project and region
/// as the backups. The backups can only be restored in the
/// `destination_project`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RestoreChannel {
    /// Identifier. The fully qualified name of the RestoreChannel.
    /// `projects/*/locations/*/restoreChannels/*`
    pub name: std::string::String,

    /// Required. Immutable. The project into which the backups will be restored.
    /// The format is `projects/{projectId}` or `projects/{projectNumber}`.
    pub destination_project: std::string::String,

    /// Output only. Server generated global unique identifier of
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) format.
    pub uid: std::string::String,

    /// Output only. The timestamp when this RestoreChannel was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when this RestoreChannel was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. A set of custom labels supplied by user.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. User specified descriptive string for this RestoreChannel.
    pub description: std::string::String,

    /// Output only. `etag` is used for optimistic concurrency control as a way to
    /// help prevent simultaneous updates of a RestoreChannel from overwriting each
    /// other. It is strongly suggested that systems make use of the 'etag' in the
    /// read-modify-write cycle to perform RestoreChannel updates in order to
    /// avoid race conditions: An `etag` is returned in the response to
    /// `GetRestoreChannel`, and systems are expected to put that etag in the
    /// request to `UpdateRestoreChannel` or `DeleteRestoreChannel` to
    /// ensure that their change will be applied to the same version of the
    /// resource.
    pub etag: std::string::String,

    /// Output only. The project_id where backups will be restored.
    /// Example Project ID: "my-project-id".
    /// This will be an OUTPUT_ONLY field to return the project_id of the
    /// destination project.
    pub destination_project_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreChannel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestoreChannel::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [destination_project][crate::model::RestoreChannel::destination_project].
    pub fn set_destination_project<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_project = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::RestoreChannel::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::RestoreChannel::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::RestoreChannel::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::RestoreChannel::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::RestoreChannel::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::RestoreChannel::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::RestoreChannel::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::RestoreChannel::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [destination_project_id][crate::model::RestoreChannel::destination_project_id].
    pub fn set_destination_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination_project_id = v.into();
        self
    }
}

impl wkt::message::Message for RestoreChannel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.RestoreChannel"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestoreChannel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __destination_project,
            __uid,
            __create_time,
            __update_time,
            __labels,
            __description,
            __etag,
            __destination_project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestoreChannel")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "destinationProject" => Ok(__FieldTag::__destination_project),
                            "destination_project" => Ok(__FieldTag::__destination_project),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "description" => Ok(__FieldTag::__description),
                            "etag" => Ok(__FieldTag::__etag),
                            "destinationProjectId" => Ok(__FieldTag::__destination_project_id),
                            "destination_project_id" => Ok(__FieldTag::__destination_project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestoreChannel;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestoreChannel")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_project => {
                            if !fields.insert(__FieldTag::__destination_project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_project",
                                ));
                            }
                            result.destination_project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__destination_project_id => {
                            if !fields.insert(__FieldTag::__destination_project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for destination_project_id",
                                ));
                            }
                            result.destination_project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestoreChannel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.destination_project.is_empty() {
            state.serialize_entry("destinationProject", &self.destination_project)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.destination_project_id.is_empty() {
            state.serialize_entry("destinationProjectId", &self.destination_project_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The configuration of a potential series of Restore operations to be performed
/// against Backups belong to a particular BackupPlan.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RestorePlan {
    /// Output only. The full name of the RestorePlan resource.
    /// Format: `projects/*/locations/*/restorePlans/*`.
    pub name: std::string::String,

    /// Output only. Server generated global unique identifier of
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) format.
    pub uid: std::string::String,

    /// Output only. The timestamp when this RestorePlan resource was
    /// created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when this RestorePlan resource was last
    /// updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. User specified descriptive string for this RestorePlan.
    pub description: std::string::String,

    /// Required. Immutable. A reference to the
    /// [BackupPlan][google.cloud.gkebackup.v1.BackupPlan] from which Backups may
    /// be used as the source for Restores created via this RestorePlan. Format:
    /// `projects/*/locations/*/backupPlans/*`.
    ///
    /// [google.cloud.gkebackup.v1.BackupPlan]: crate::model::BackupPlan
    pub backup_plan: std::string::String,

    /// Required. Immutable. The target cluster into which Restores created via
    /// this RestorePlan will restore data. NOTE: the cluster's region must be the
    /// same as the RestorePlan. Valid formats:
    ///
    /// - `projects/*/locations/*/clusters/*`
    /// - `projects/*/zones/*/clusters/*`
    pub cluster: std::string::String,

    /// Required. Configuration of Restores created via this RestorePlan.
    pub restore_config: std::option::Option<crate::model::RestoreConfig>,

    /// Optional. A set of custom labels supplied by user.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. `etag` is used for optimistic concurrency control as a way to
    /// help prevent simultaneous updates of a restore from overwriting each other.
    /// It is strongly suggested that systems make use of the `etag` in the
    /// read-modify-write cycle to perform restore updates in order to avoid
    /// race conditions: An `etag` is returned in the response to `GetRestorePlan`,
    /// and systems are expected to put that etag in the request to
    /// `UpdateRestorePlan` or `DeleteRestorePlan` to ensure that their change
    /// will be applied to the same version of the resource.
    pub etag: std::string::String,

    /// Output only. State of the RestorePlan. This State field reflects the
    /// various stages a RestorePlan can be in
    /// during the Create operation.
    pub state: crate::model::restore_plan::State,

    /// Output only. Human-readable description of why RestorePlan is in the
    /// current `state`. This field is only meant for human readability and should
    /// not be used programmatically as this field is not guaranteed to be
    /// consistent.
    pub state_reason: std::string::String,

    /// Output only. The fully qualified name of the RestoreChannel to be used to
    /// create a RestorePlan. This field is set only if the `backup_plan` is in a
    /// different project than the RestorePlan. Format:
    /// `projects/*/locations/*/restoreChannels/*`
    pub restore_channel: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestorePlan {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestorePlan::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::RestorePlan::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::RestorePlan::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::RestorePlan::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::RestorePlan::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::RestorePlan::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::RestorePlan::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [backup_plan][crate::model::RestorePlan::backup_plan].
    pub fn set_backup_plan<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_plan = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::RestorePlan::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [restore_config][crate::model::RestorePlan::restore_config].
    pub fn set_restore_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RestoreConfig>,
    {
        self.restore_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [restore_config][crate::model::RestorePlan::restore_config].
    pub fn set_or_clear_restore_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RestoreConfig>,
    {
        self.restore_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::RestorePlan::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::RestorePlan::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [state][crate::model::RestorePlan::state].
    pub fn set_state<T: std::convert::Into<crate::model::restore_plan::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_reason][crate::model::RestorePlan::state_reason].
    pub fn set_state_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_reason = v.into();
        self
    }

    /// Sets the value of [restore_channel][crate::model::RestorePlan::restore_channel].
    pub fn set_restore_channel<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.restore_channel = v.into();
        self
    }
}

impl wkt::message::Message for RestorePlan {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.RestorePlan"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestorePlan {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __create_time,
            __update_time,
            __description,
            __backup_plan,
            __cluster,
            __restore_config,
            __labels,
            __etag,
            __state,
            __state_reason,
            __restore_channel,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestorePlan")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "description" => Ok(__FieldTag::__description),
                            "backupPlan" => Ok(__FieldTag::__backup_plan),
                            "backup_plan" => Ok(__FieldTag::__backup_plan),
                            "cluster" => Ok(__FieldTag::__cluster),
                            "restoreConfig" => Ok(__FieldTag::__restore_config),
                            "restore_config" => Ok(__FieldTag::__restore_config),
                            "labels" => Ok(__FieldTag::__labels),
                            "etag" => Ok(__FieldTag::__etag),
                            "state" => Ok(__FieldTag::__state),
                            "stateReason" => Ok(__FieldTag::__state_reason),
                            "state_reason" => Ok(__FieldTag::__state_reason),
                            "restoreChannel" => Ok(__FieldTag::__restore_channel),
                            "restore_channel" => Ok(__FieldTag::__restore_channel),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestorePlan;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestorePlan")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_plan => {
                            if !fields.insert(__FieldTag::__backup_plan) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_plan",
                                ));
                            }
                            result.backup_plan = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__restore_config => {
                            if !fields.insert(__FieldTag::__restore_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_config",
                                ));
                            }
                            result.restore_config = map
                                .next_value::<std::option::Option<crate::model::RestoreConfig>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::restore_plan::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state_reason => {
                            if !fields.insert(__FieldTag::__state_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_reason",
                                ));
                            }
                            result.state_reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__restore_channel => {
                            if !fields.insert(__FieldTag::__restore_channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_channel",
                                ));
                            }
                            result.restore_channel = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestorePlan {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.backup_plan.is_empty() {
            state.serialize_entry("backupPlan", &self.backup_plan)?;
        }
        if !self.cluster.is_empty() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if self.restore_config.is_some() {
            state.serialize_entry("restoreConfig", &self.restore_config)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_reason.is_empty() {
            state.serialize_entry("stateReason", &self.state_reason)?;
        }
        if !self.restore_channel.is_empty() {
            state.serialize_entry("restoreChannel", &self.restore_channel)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RestorePlan].
pub mod restore_plan {
    #[allow(unused_imports)]
    use super::*;

    /// State
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default first value for Enums.
        Unspecified,
        /// Waiting for cluster state to be RUNNING.
        ClusterPending,
        /// The RestorePlan has successfully been created and is ready for Restores.
        Ready,
        /// RestorePlan creation has failed.
        Failed,
        /// The RestorePlan is in the process of being deleted.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ClusterPending => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::ClusterPending => std::option::Option::Some("CLUSTER_PENDING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ClusterPending,
                2 => Self::Ready,
                3 => Self::Failed,
                4 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CLUSTER_PENDING" => Self::ClusterPending,
                "READY" => Self::Ready,
                "FAILED" => Self::Failed,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ClusterPending => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.gkebackup.v1.RestorePlan.State",
            ))
        }
    }
}

/// A RestorePlanBinding binds a RestorePlan with a RestoreChannel.
/// This resource is created automatically when a RestorePlan is created using a
/// RestoreChannel. This also serves as a holder for cross-project fields
/// that need to be displayed in the current project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RestorePlanBinding {
    /// Identifier. The fully qualified name of the RestorePlanBinding.
    /// `projects/*/locations/*/restoreChannels/*/restorePlanBindings/*`
    pub name: std::string::String,

    /// Output only. Server generated global unique identifier of
    /// [UUID4](https://en.wikipedia.org/wiki/Universally_unique_identifier)
    pub uid: std::string::String,

    /// Output only. The timestamp when this binding was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when this binding was created.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The fully qualified name of the RestorePlan bound to this
    /// RestoreChannel. `projects/*/locations/*/restorePlans/{restore_plan}`
    pub restore_plan: std::string::String,

    /// Output only. `etag` is used for optimistic concurrency control as a way to
    /// help prevent simultaneous updates of a RestorePlanBinding from overwriting
    /// each other. It is strongly suggested that systems make use of the 'etag' in
    /// the read-modify-write cycle to perform RestorePlanBinding updates in
    /// order to avoid race conditions: An `etag` is returned in the response to
    /// `GetRestorePlanBinding`, and systems are expected to put that etag in
    /// the request to `UpdateRestorePlanBinding` or
    /// `DeleteRestorePlanBinding` to ensure that their change will be applied
    /// to the same version of the resource.
    pub etag: std::string::String,

    /// Output only. The fully qualified name of the BackupPlan bound to the
    /// specified RestorePlan. `projects/*/locations/*/backukpPlans/{backup_plan}`
    pub backup_plan: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestorePlanBinding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestorePlanBinding::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::RestorePlanBinding::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::RestorePlanBinding::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::RestorePlanBinding::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::RestorePlanBinding::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::RestorePlanBinding::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [restore_plan][crate::model::RestorePlanBinding::restore_plan].
    pub fn set_restore_plan<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.restore_plan = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::RestorePlanBinding::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [backup_plan][crate::model::RestorePlanBinding::backup_plan].
    pub fn set_backup_plan<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_plan = v.into();
        self
    }
}

impl wkt::message::Message for RestorePlanBinding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.RestorePlanBinding"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestorePlanBinding {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __create_time,
            __update_time,
            __restore_plan,
            __etag,
            __backup_plan,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestorePlanBinding")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "restorePlan" => Ok(__FieldTag::__restore_plan),
                            "restore_plan" => Ok(__FieldTag::__restore_plan),
                            "etag" => Ok(__FieldTag::__etag),
                            "backupPlan" => Ok(__FieldTag::__backup_plan),
                            "backup_plan" => Ok(__FieldTag::__backup_plan),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestorePlanBinding;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestorePlanBinding")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__restore_plan => {
                            if !fields.insert(__FieldTag::__restore_plan) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_plan",
                                ));
                            }
                            result.restore_plan = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_plan => {
                            if !fields.insert(__FieldTag::__backup_plan) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_plan",
                                ));
                            }
                            result.backup_plan = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestorePlanBinding {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.restore_plan.is_empty() {
            state.serialize_entry("restorePlan", &self.restore_plan)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.backup_plan.is_empty() {
            state.serialize_entry("backupPlan", &self.backup_plan)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the backup of a specific persistent volume as a component of a
/// Backup - both the record of the operation and a pointer to the underlying
/// storage-specific artifacts.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VolumeBackup {
    /// Output only. The full name of the VolumeBackup resource.
    /// Format: `projects/*/locations/*/backupPlans/*/backups/*/volumeBackups/*`.
    pub name: std::string::String,

    /// Output only. Server generated global unique identifier of
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) format.
    pub uid: std::string::String,

    /// Output only. The timestamp when this VolumeBackup resource was
    /// created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when this VolumeBackup resource was last
    /// updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. A reference to the source Kubernetes PVC from which this
    /// VolumeBackup was created.
    pub source_pvc: std::option::Option<crate::model::NamespacedName>,

    /// Output only. A storage system-specific opaque handle to the underlying
    /// volume backup.
    pub volume_backup_handle: std::string::String,

    /// Output only. The format used for the volume backup.
    pub format: crate::model::volume_backup::VolumeBackupFormat,

    /// Output only. The aggregate size of the underlying artifacts associated with
    /// this VolumeBackup in the backup storage. This may change over time when
    /// multiple backups of the same volume share the same backup storage
    /// location. In particular, this is likely to increase in size when
    /// the immediately preceding backup of the same volume is deleted.
    pub storage_bytes: i64,

    /// Output only. The minimum size of the disk to which this VolumeBackup can be
    /// restored.
    pub disk_size_bytes: i64,

    /// Output only. The timestamp when the associated underlying volume backup
    /// operation completed.
    pub complete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current state of this VolumeBackup.
    pub state: crate::model::volume_backup::State,

    /// Output only. A human readable message explaining why the VolumeBackup is in
    /// its current state. This field is only meant for human consumption and
    /// should not be used programmatically as this field is not guaranteed to be
    /// consistent.
    pub state_message: std::string::String,

    /// Output only. `etag` is used for optimistic concurrency control as a way to
    /// help prevent simultaneous updates of a volume backup from overwriting each
    /// other. It is strongly suggested that systems make use of the `etag` in the
    /// read-modify-write cycle to perform volume backup updates in order to avoid
    /// race conditions.
    pub etag: std::string::String,

    /// Output only. [Output Only] Reserved for future use.
    pub satisfies_pzs: bool,

    /// Output only. [Output Only] Reserved for future use.
    pub satisfies_pzi: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VolumeBackup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VolumeBackup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::VolumeBackup::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::VolumeBackup::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::VolumeBackup::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::VolumeBackup::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::VolumeBackup::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_pvc][crate::model::VolumeBackup::source_pvc].
    pub fn set_source_pvc<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NamespacedName>,
    {
        self.source_pvc = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_pvc][crate::model::VolumeBackup::source_pvc].
    pub fn set_or_clear_source_pvc<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NamespacedName>,
    {
        self.source_pvc = v.map(|x| x.into());
        self
    }

    /// Sets the value of [volume_backup_handle][crate::model::VolumeBackup::volume_backup_handle].
    pub fn set_volume_backup_handle<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.volume_backup_handle = v.into();
        self
    }

    /// Sets the value of [format][crate::model::VolumeBackup::format].
    pub fn set_format<T: std::convert::Into<crate::model::volume_backup::VolumeBackupFormat>>(
        mut self,
        v: T,
    ) -> Self {
        self.format = v.into();
        self
    }

    /// Sets the value of [storage_bytes][crate::model::VolumeBackup::storage_bytes].
    pub fn set_storage_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.storage_bytes = v.into();
        self
    }

    /// Sets the value of [disk_size_bytes][crate::model::VolumeBackup::disk_size_bytes].
    pub fn set_disk_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_size_bytes = v.into();
        self
    }

    /// Sets the value of [complete_time][crate::model::VolumeBackup::complete_time].
    pub fn set_complete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [complete_time][crate::model::VolumeBackup::complete_time].
    pub fn set_or_clear_complete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::VolumeBackup::state].
    pub fn set_state<T: std::convert::Into<crate::model::volume_backup::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_message][crate::model::VolumeBackup::state_message].
    pub fn set_state_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_message = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::VolumeBackup::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::VolumeBackup::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::VolumeBackup::satisfies_pzi].
    pub fn set_satisfies_pzi<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.satisfies_pzi = v.into();
        self
    }
}

impl wkt::message::Message for VolumeBackup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.VolumeBackup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VolumeBackup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __create_time,
            __update_time,
            __source_pvc,
            __volume_backup_handle,
            __format,
            __storage_bytes,
            __disk_size_bytes,
            __complete_time,
            __state,
            __state_message,
            __etag,
            __satisfies_pzs,
            __satisfies_pzi,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VolumeBackup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "sourcePvc" => Ok(__FieldTag::__source_pvc),
                            "source_pvc" => Ok(__FieldTag::__source_pvc),
                            "volumeBackupHandle" => Ok(__FieldTag::__volume_backup_handle),
                            "volume_backup_handle" => Ok(__FieldTag::__volume_backup_handle),
                            "format" => Ok(__FieldTag::__format),
                            "storageBytes" => Ok(__FieldTag::__storage_bytes),
                            "storage_bytes" => Ok(__FieldTag::__storage_bytes),
                            "diskSizeBytes" => Ok(__FieldTag::__disk_size_bytes),
                            "disk_size_bytes" => Ok(__FieldTag::__disk_size_bytes),
                            "completeTime" => Ok(__FieldTag::__complete_time),
                            "complete_time" => Ok(__FieldTag::__complete_time),
                            "state" => Ok(__FieldTag::__state),
                            "stateMessage" => Ok(__FieldTag::__state_message),
                            "state_message" => Ok(__FieldTag::__state_message),
                            "etag" => Ok(__FieldTag::__etag),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VolumeBackup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VolumeBackup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__source_pvc => {
                            if !fields.insert(__FieldTag::__source_pvc) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_pvc",
                                ));
                            }
                            result.source_pvc = map
                                .next_value::<std::option::Option<crate::model::NamespacedName>>(
                                )?;
                        }
                        __FieldTag::__volume_backup_handle => {
                            if !fields.insert(__FieldTag::__volume_backup_handle) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_backup_handle",
                                ));
                            }
                            result.volume_backup_handle = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__format => {
                            if !fields.insert(__FieldTag::__format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for format",
                                ));
                            }
                            result.format = map
                                .next_value::<std::option::Option<
                                    crate::model::volume_backup::VolumeBackupFormat,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage_bytes => {
                            if !fields.insert(__FieldTag::__storage_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.storage_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disk_size_bytes => {
                            if !fields.insert(__FieldTag::__disk_size_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_size_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_size_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__complete_time => {
                            if !fields.insert(__FieldTag::__complete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for complete_time",
                                ));
                            }
                            result.complete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::volume_backup::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state_message => {
                            if !fields.insert(__FieldTag::__state_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_message",
                                ));
                            }
                            result.state_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzi",
                                ));
                            }
                            result.satisfies_pzi = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VolumeBackup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.source_pvc.is_some() {
            state.serialize_entry("sourcePvc", &self.source_pvc)?;
        }
        if !self.volume_backup_handle.is_empty() {
            state.serialize_entry("volumeBackupHandle", &self.volume_backup_handle)?;
        }
        if !wkt::internal::is_default(&self.format) {
            state.serialize_entry("format", &self.format)?;
        }
        if !wkt::internal::is_default(&self.storage_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("storageBytes", &__With(&self.storage_bytes))?;
        }
        if !wkt::internal::is_default(&self.disk_size_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("diskSizeBytes", &__With(&self.disk_size_bytes))?;
        }
        if self.complete_time.is_some() {
            state.serialize_entry("completeTime", &self.complete_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_message.is_empty() {
            state.serialize_entry("stateMessage", &self.state_message)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzs) {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if !wkt::internal::is_default(&self.satisfies_pzi) {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VolumeBackup].
pub mod volume_backup {
    #[allow(unused_imports)]
    use super::*;

    /// Identifies the format used for the volume backup.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VolumeBackupFormat {
        /// Default value, not specified.
        Unspecified,
        /// Compute Engine Persistent Disk snapshot based volume backup.
        GcePersistentDisk,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VolumeBackupFormat::value] or
        /// [VolumeBackupFormat::name].
        UnknownValue(volume_backup_format::UnknownValue),
    }

    #[doc(hidden)]
    pub mod volume_backup_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VolumeBackupFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GcePersistentDisk => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VOLUME_BACKUP_FORMAT_UNSPECIFIED"),
                Self::GcePersistentDisk => std::option::Option::Some("GCE_PERSISTENT_DISK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VolumeBackupFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VolumeBackupFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VolumeBackupFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GcePersistentDisk,
                _ => Self::UnknownValue(volume_backup_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VolumeBackupFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VOLUME_BACKUP_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "GCE_PERSISTENT_DISK" => Self::GcePersistentDisk,
                _ => Self::UnknownValue(volume_backup_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VolumeBackupFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GcePersistentDisk => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VolumeBackupFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VolumeBackupFormat>::new(
                ".google.cloud.gkebackup.v1.VolumeBackup.VolumeBackupFormat",
            ))
        }
    }

    /// The current state of a VolumeBackup
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// This is an illegal state and should not be encountered.
        Unspecified,
        /// A volume for the backup was identified and backup process is about to
        /// start.
        Creating,
        /// The volume backup operation has begun and is in the initial "snapshot"
        /// phase of the process. Any defined ProtectedApplication "pre" hooks will
        /// be executed before entering this state and "post" hooks will be executed
        /// upon leaving this state.
        Snapshotting,
        /// The snapshot phase of the volume backup operation has completed and
        /// the snapshot is now being uploaded to backup storage.
        Uploading,
        /// The volume backup operation has completed successfully.
        Succeeded,
        /// The volume backup operation has failed.
        Failed,
        /// This VolumeBackup resource (and its associated artifacts) is in the
        /// process of being deleted.
        Deleting,
        /// The underlying artifacts of a volume backup (eg: persistent disk
        /// snapshots) are deleted.
        CleanedUp,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Snapshotting => std::option::Option::Some(2),
                Self::Uploading => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::Deleting => std::option::Option::Some(6),
                Self::CleanedUp => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Snapshotting => std::option::Option::Some("SNAPSHOTTING"),
                Self::Uploading => std::option::Option::Some("UPLOADING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::CleanedUp => std::option::Option::Some("CLEANED_UP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Snapshotting,
                3 => Self::Uploading,
                4 => Self::Succeeded,
                5 => Self::Failed,
                6 => Self::Deleting,
                7 => Self::CleanedUp,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "SNAPSHOTTING" => Self::Snapshotting,
                "UPLOADING" => Self::Uploading,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "DELETING" => Self::Deleting,
                "CLEANED_UP" => Self::CleanedUp,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Snapshotting => serializer.serialize_i32(2),
                Self::Uploading => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::Deleting => serializer.serialize_i32(6),
                Self::CleanedUp => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.gkebackup.v1.VolumeBackup.State",
            ))
        }
    }
}

/// Represents the operation of restoring a volume from a VolumeBackup.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VolumeRestore {
    /// Output only. Full name of the VolumeRestore resource.
    /// Format: `projects/*/locations/*/restorePlans/*/restores/*/volumeRestores/*`
    pub name: std::string::String,

    /// Output only. Server generated global unique identifier of
    /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) format.
    pub uid: std::string::String,

    /// Output only. The timestamp when this VolumeRestore resource was
    /// created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp when this VolumeRestore resource was last
    /// updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The full name of the VolumeBackup from which the volume will
    /// be restored. Format:
    /// `projects/*/locations/*/backupPlans/*/backups/*/volumeBackups/*`.
    pub volume_backup: std::string::String,

    /// Output only. The reference to the target Kubernetes PVC to be restored.
    pub target_pvc: std::option::Option<crate::model::NamespacedName>,

    /// Output only. A storage system-specific opaque handler to the underlying
    /// volume created for the target PVC from the volume backup.
    pub volume_handle: std::string::String,

    /// Output only. The type of volume provisioned
    pub volume_type: crate::model::volume_restore::VolumeType,

    /// Output only. The timestamp when the associated underlying volume
    /// restoration completed.
    pub complete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current state of this VolumeRestore.
    pub state: crate::model::volume_restore::State,

    /// Output only. A human readable message explaining why the VolumeRestore is
    /// in its current state.
    pub state_message: std::string::String,

    /// Output only. `etag` is used for optimistic concurrency control as a way to
    /// help prevent simultaneous updates of a volume restore from overwriting each
    /// other. It is strongly suggested that systems make use of the `etag` in the
    /// read-modify-write cycle to perform volume restore updates in order to avoid
    /// race conditions.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VolumeRestore {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VolumeRestore::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::VolumeRestore::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::VolumeRestore::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::VolumeRestore::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::VolumeRestore::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::VolumeRestore::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [volume_backup][crate::model::VolumeRestore::volume_backup].
    pub fn set_volume_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.volume_backup = v.into();
        self
    }

    /// Sets the value of [target_pvc][crate::model::VolumeRestore::target_pvc].
    pub fn set_target_pvc<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NamespacedName>,
    {
        self.target_pvc = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_pvc][crate::model::VolumeRestore::target_pvc].
    pub fn set_or_clear_target_pvc<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NamespacedName>,
    {
        self.target_pvc = v.map(|x| x.into());
        self
    }

    /// Sets the value of [volume_handle][crate::model::VolumeRestore::volume_handle].
    pub fn set_volume_handle<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.volume_handle = v.into();
        self
    }

    /// Sets the value of [volume_type][crate::model::VolumeRestore::volume_type].
    pub fn set_volume_type<T: std::convert::Into<crate::model::volume_restore::VolumeType>>(
        mut self,
        v: T,
    ) -> Self {
        self.volume_type = v.into();
        self
    }

    /// Sets the value of [complete_time][crate::model::VolumeRestore::complete_time].
    pub fn set_complete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [complete_time][crate::model::VolumeRestore::complete_time].
    pub fn set_or_clear_complete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.complete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::VolumeRestore::state].
    pub fn set_state<T: std::convert::Into<crate::model::volume_restore::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_message][crate::model::VolumeRestore::state_message].
    pub fn set_state_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_message = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::VolumeRestore::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for VolumeRestore {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.gkebackup.v1.VolumeRestore"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VolumeRestore {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __uid,
            __create_time,
            __update_time,
            __volume_backup,
            __target_pvc,
            __volume_handle,
            __volume_type,
            __complete_time,
            __state,
            __state_message,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VolumeRestore")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "uid" => Ok(__FieldTag::__uid),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "volumeBackup" => Ok(__FieldTag::__volume_backup),
                            "volume_backup" => Ok(__FieldTag::__volume_backup),
                            "targetPvc" => Ok(__FieldTag::__target_pvc),
                            "target_pvc" => Ok(__FieldTag::__target_pvc),
                            "volumeHandle" => Ok(__FieldTag::__volume_handle),
                            "volume_handle" => Ok(__FieldTag::__volume_handle),
                            "volumeType" => Ok(__FieldTag::__volume_type),
                            "volume_type" => Ok(__FieldTag::__volume_type),
                            "completeTime" => Ok(__FieldTag::__complete_time),
                            "complete_time" => Ok(__FieldTag::__complete_time),
                            "state" => Ok(__FieldTag::__state),
                            "stateMessage" => Ok(__FieldTag::__state_message),
                            "state_message" => Ok(__FieldTag::__state_message),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VolumeRestore;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VolumeRestore")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__volume_backup => {
                            if !fields.insert(__FieldTag::__volume_backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_backup",
                                ));
                            }
                            result.volume_backup = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_pvc => {
                            if !fields.insert(__FieldTag::__target_pvc) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_pvc",
                                ));
                            }
                            result.target_pvc = map
                                .next_value::<std::option::Option<crate::model::NamespacedName>>(
                                )?;
                        }
                        __FieldTag::__volume_handle => {
                            if !fields.insert(__FieldTag::__volume_handle) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_handle",
                                ));
                            }
                            result.volume_handle = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__volume_type => {
                            if !fields.insert(__FieldTag::__volume_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_type",
                                ));
                            }
                            result.volume_type = map.next_value::<std::option::Option<crate::model::volume_restore::VolumeType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__complete_time => {
                            if !fields.insert(__FieldTag::__complete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for complete_time",
                                ));
                            }
                            result.complete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::volume_restore::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state_message => {
                            if !fields.insert(__FieldTag::__state_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_message",
                                ));
                            }
                            result.state_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VolumeRestore {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.volume_backup.is_empty() {
            state.serialize_entry("volumeBackup", &self.volume_backup)?;
        }
        if self.target_pvc.is_some() {
            state.serialize_entry("targetPvc", &self.target_pvc)?;
        }
        if !self.volume_handle.is_empty() {
            state.serialize_entry("volumeHandle", &self.volume_handle)?;
        }
        if !wkt::internal::is_default(&self.volume_type) {
            state.serialize_entry("volumeType", &self.volume_type)?;
        }
        if self.complete_time.is_some() {
            state.serialize_entry("completeTime", &self.complete_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_message.is_empty() {
            state.serialize_entry("stateMessage", &self.state_message)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VolumeRestore].
pub mod volume_restore {
    #[allow(unused_imports)]
    use super::*;

    /// Supported volume types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VolumeType {
        /// Default
        Unspecified,
        /// Compute Engine Persistent Disk volume
        GcePersistentDisk,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VolumeType::value] or
        /// [VolumeType::name].
        UnknownValue(volume_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod volume_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VolumeType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GcePersistentDisk => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VOLUME_TYPE_UNSPECIFIED"),
                Self::GcePersistentDisk => std::option::Option::Some("GCE_PERSISTENT_DISK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VolumeType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VolumeType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VolumeType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GcePersistentDisk,
                _ => Self::UnknownValue(volume_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VolumeType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VOLUME_TYPE_UNSPECIFIED" => Self::Unspecified,
                "GCE_PERSISTENT_DISK" => Self::GcePersistentDisk,
                _ => Self::UnknownValue(volume_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VolumeType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GcePersistentDisk => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VolumeType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VolumeType>::new(
                ".google.cloud.gkebackup.v1.VolumeRestore.VolumeType",
            ))
        }
    }

    /// The current state of a VolumeRestore
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// This is an illegal state and should not be encountered.
        Unspecified,
        /// A volume for the restore was identified and restore process is about to
        /// start.
        Creating,
        /// The volume is currently being restored.
        Restoring,
        /// The volume has been successfully restored.
        Succeeded,
        /// The volume restoration process failed.
        Failed,
        /// This VolumeRestore resource is in the process of being deleted.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Restoring => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Deleting => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Restoring => std::option::Option::Some("RESTORING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Restoring,
                3 => Self::Succeeded,
                4 => Self::Failed,
                5 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "RESTORING" => Self::Restoring,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Restoring => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Deleting => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.gkebackup.v1.VolumeRestore.State",
            ))
        }
    }
}
